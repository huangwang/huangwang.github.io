<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jack Huang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huangwang.github.io/"/>
  <updated>2019-04-28T14:59:25.911Z</updated>
  <id>https://huangwang.github.io/</id>
  
  <author>
    <name>Jack Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenCV4.0相机标定教程</title>
    <link href="https://huangwang.github.io/2019/04/28/OpenCV4-0%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%E6%95%99%E7%A8%8B/"/>
    <id>https://huangwang.github.io/2019/04/28/OpenCV4-0相机标定教程/</id>
    <published>2019-04-28T14:55:38.000Z</published>
    <updated>2019-04-28T14:59:25.911Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 2.8)</span><br><span class="line">set (CMAKE_CXX_STANDARD 11)</span><br><span class="line">project( camera_calibration )</span><br><span class="line">find_package( OpenCV REQUIRED )</span><br><span class="line">include_directories( $&#123;OpenCV_INCLUDE_DIRS&#125; )</span><br><span class="line">add_executable( camera_calibration camera_calibration.cpp )</span><br><span class="line">target_link_libraries( camera_calibration $&#123;OpenCV_LIBS&#125; )</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://docs.opencv.org/4.1.0/db/df5/tutorial_linux_gcc_cmake.html" target="_blank" rel="noopener">Using OpenCV with gcc and CMake</a>,by opencv.</li><li><a href="https://docs.opencv.org/4.1.0/d4/d94/tutorial_camera_calibration.html" target="_blank" rel="noopener">Camera calibration With OpenCV</a>,by opencv.</li><li><a href="https://stackoverflow.com/questions/49012222/c11-activation-with-target-compile-feature-or-set-cmake-cxx-standard" target="_blank" rel="noopener">C++11 activation with <target_compile_feature> or <set (cmake_cxx_standard)=""></set></target_compile_feature></a>,by stackoverflow.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="计算机视觉" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="opencv" scheme="https://huangwang.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu_16.04安装OpenCV的方法</title>
    <link href="https://huangwang.github.io/2019/04/28/Ubuntu-16-04%E5%AE%89%E8%A3%85opencv%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://huangwang.github.io/2019/04/28/Ubuntu-16-04安装opencv的方法/</id>
    <published>2019-04-28T11:38:11.000Z</published>
    <updated>2019-04-28T15:03:15.057Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录在Ubuntu16.04 LTS操作系统中从源代码编译安装OpenCV的过程。</p><h1 id="安装必需的软件包"><a href="#安装必需的软件包" class="headerlink" title="安装必需的软件包"></a>安装必需的软件包</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[compiler] sudo apt-get install build-essential</span><br><span class="line">[required] sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br><span class="line">[optional] sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br></pre></td></tr></table></figure><h1 id="下载OpenCV源代码"><a href="#下载OpenCV源代码" class="headerlink" title="下载OpenCV源代码"></a>下载OpenCV源代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/&lt;my_working_directory&gt;</span><br><span class="line">git clone https://github.com/opencv/opencv.git</span><br><span class="line">git clone https://github.com/opencv/opencv_contrib.git</span><br></pre></td></tr></table></figure><h1 id="使用CMake构建OpenCV"><a href="#使用CMake构建OpenCV" class="headerlink" title="使用CMake构建OpenCV"></a>使用CMake构建OpenCV</h1><h2 id="创建临时的build目录"><a href="#创建临时的build目录" class="headerlink" title="创建临时的build目录"></a>创建临时的build目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~/opencv</span><br><span class="line"># 查看并检出OpenCV最新发布版</span><br><span class="line">git tag</span><br><span class="line">git checkout 4.1.0</span><br><span class="line"></span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br></pre></td></tr></table></figure><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_</span><br><span class="line">INSTALL_PREFIX=/usr/local ..</span><br></pre></td></tr></table></figure><h2 id="构建OpenCV"><a href="#构建OpenCV" class="headerlink" title="构建OpenCV"></a>构建OpenCV</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j3 # runs 3 jobs in parallel</span><br></pre></td></tr></table></figure><h2 id="安装OpenCV"><a href="#安装OpenCV" class="headerlink" title="安装OpenCV"></a>安装OpenCV</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://docs.opencv.org/4.1.0/d7/d9f/tutorial_linux_install.html" target="_blank" rel="noopener">Installation in Linux</a>, by opencv.</li><li><a href="https://github.com/opencv/opencv/issues/13154" target="_blank" rel="noopener">4.0.0 does not produce pkgconfig file</a>, by opencv.</li><li><a href="https://zh.wikipedia.org/zh-hans/Pkg-config" target="_blank" rel="noopener">Pkg-config</a>,by wikipedia.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文记录在Ubuntu16.04 LTS操作系统中从源代码编译安装OpenCV的过程。&lt;/p&gt;
&lt;h1 id=&quot;安装必需的软件包&quot;&gt;&lt;a href=&quot;#安装必需的软件包&quot; class=&quot;headerlink&quot; title=&quot;安装必需的软件包&quot;&gt;&lt;/a&gt;安装必需的软件包&lt;/h
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="计算机视觉" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="OpenCV" scheme="https://huangwang.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>PX4开发基本概念解读</title>
    <link href="https://huangwang.github.io/2019/04/27/PX4%E5%BC%80%E5%8F%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E8%A7%A3%E8%AF%BB/"/>
    <id>https://huangwang.github.io/2019/04/27/PX4开发基本概念解读/</id>
    <published>2019-04-27T14:02:29.000Z</published>
    <updated>2019-04-27T15:11:50.434Z</updated>
    
    <content type="html"><![CDATA[<p>进行PX4开发，必先了解PX4体系结构及相关概念。下面及简要介绍PX4开发的相关知识。</p><h1 id="PX4体系结构"><a href="#PX4体系结构" class="headerlink" title="PX4体系结构"></a>PX4体系结构</h1><p>PX4由两个层次组成：一是飞行控制栈(flight stack)，即自驾仪的软件解决方案，二是中间件，一种可以支持任意类型自主机器人的通用机器人中间件。</p><p>所有的无人机机型，事实上所有的包括船舶在内的机器人系统，都具有同一代码库。整个系统设计是反应式(reactive)的，这意味着：</p><ul><li>所有的功能被划分为可替换部件</li><li>通过异步消息传递进行通信</li><li>该系统可以应对不同的工作负载</li></ul><p>除了这些运行时考虑之外，其模块化最大限度地提高了系统的可重用性。</p><p></p><p align="center">    <img src="images/PX4_Architecture.svg" width="90%" alt="PX4体系结构"></p><p></p><center>图1  PX4体系结构</center><h2 id="飞行控制栈"><a href="#飞行控制栈" class="headerlink" title="飞行控制栈"></a>飞行控制栈</h2><p>飞行控制栈是自主无人机的引导、导航和控制算法的集合。它包括用于固定翼，多旋翼和垂直起降机身的控制器以及用于姿态和位置的估计器。</p><p>图2显示了飞行控制栈的构建块的预览。 它包含从传感器，RC输入和自主飞行控制（导航器）到电机或伺服控制（执行器）的完整管道。</p><p></p><p align="center">    <img src="images/PX4_High-Level_Flight-Stack.svg" width="90%" alt="PX4飞行控制栈结构图"></p><p></p><center>图2  PX4飞行控制栈结构图</center><p><strong>估计器</strong>采用一个或多个传感器输入，组合它们，并计算无人机状态（例如来自IMU传感器数据的姿态）。</p><p><strong>控制器</strong>是将设定值和测量或估计状态（过程变量）作为输入的组件。 其目标是调整过程变量的值，使其与设定值匹配。 输出是最终达到该设定点的校正。 例如，位置控制器将位置设定点作为输入，过程变量是当前估计的位置，输出是将车辆移向期望位置的姿态和推力设定点。</p><p><strong>混合器</strong>接受强制命令（例如向右转）并将它们转换为单独的电机命令，同时确保不超过某些限制。 该平移特定于无人机类型并且取决于各种因素，例如关于重心的马达布置或无人机的转动惯量。</p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件主要包括嵌入式传感器的设备驱动程序，与外部世界的通信（协同计算机，地面控制站等）和uORB发布 - 订阅消息总线。</p><p>此外，中间件包括一个模拟层，允许PX4飞行代码在桌面操作系统上运行，并在模拟的“世界”中控制计算机建模的无人机。</p><h2 id="更新速率"><a href="#更新速率" class="headerlink" title="更新速率"></a>更新速率</h2><p>由于模块等待消息更新，因此驱动程序通常会定义模块更新的速度。 大多数IMU驱动器以1kHz采样数据，将其集成并以250Hz发布。 系统的其他部分，例如导航器，不需要如此高的更新速率，因此运行速度相当慢。</p><p>可以通过运行uorb top在系统上实时检查消息更新率。</p><h2 id="运行时环境"><a href="#运行时环境" class="headerlink" title="运行时环境"></a>运行时环境</h2><p>PX4可在各种提供POSIX-API的操作系统上运行（例如Linux，macOS，NuttX或QuRT）。 它还应该具有某种形式的实时调度（例如FIFO）。</p><p>模块间通信（使用uORB）基于共享内存。 整个PX4中间件在单个地址空间中运行，即在所有模块之间共享存储器。</p><p>有两种不同的方式可以执行模块：</p><ul><li><strong>任务</strong>：模块在自己的任务中运行，具有自己的堆栈和进程优先级（这是更常见的方式）。</li><li><p><strong>工作队列</strong>：模块在共享任务上运行，这意味着它不拥有堆栈。 多个任务在同一堆栈上运行，每个工作队列具有一个优先级。</p><p>通过指定将来的固定时间来安排任务。 优点是它使用较少的RAM，但不允许任务在消息上休眠或轮询。</p><p>工作队列用于周期性任务，例如传感器驱动器或陆地探测器。</p></li></ul><h2 id="操作系统相关信息"><a href="#操作系统相关信息" class="headerlink" title="操作系统相关信息"></a>操作系统相关信息</h2><h3 id="NuttX"><a href="#NuttX" class="headerlink" title="NuttX"></a>NuttX</h3><p>NuttX是在飞行控制板上运行PX4的主要RTOS。 它是开源（BSD许可证），重量轻，高效且非常稳定。</p><p>模块作为任务执行：它们有自己的文件描述符列表，但它们共享一个地址空间。 任务仍然可以启动共享文件描述符列表的一个或多个线程。</p><p>每个任务/线程都有一个固定大小的堆栈，并且有一个周期性任务，它检查所有堆栈是否有足够的可用空间（基于堆栈着色）。</p><h3 id="Linux-MacOS"><a href="#Linux-MacOS" class="headerlink" title="Linux / MacOS"></a>Linux / MacOS</h3><p>在Linux或macOS上，PX4在单个进程中运行，并且模块在它们自己的线程中运行（NuttX上的任务和线程之间没有区别）。</p><h1 id="PX4飞行模式"><a href="#PX4飞行模式" class="headerlink" title="PX4飞行模式"></a>PX4飞行模式</h1><p>飞行模式定义了系统在任何给定时间的状态。用户可以使用远程遥控器或者QGroundControl地面站来进行飞行模式切换。</p><p></p><p align="center">    <img src="images/commander-flow-diagram.png" width="90%" alt="PX4飞行模式控制流程图"></p><p></p><center>图3  PX4飞行模式控制流程图</center><h1 id="Dronecode平台软硬件架构"><a href="#Dronecode平台软硬件架构" class="headerlink" title="Dronecode平台软硬件架构"></a>Dronecode平台软硬件架构</h1><p>Dronecode是开源的无人机平台，其软硬件体系结构如图4所示。图4左侧显示了一种可能的硬件配置，其中飞行控制器（浅蓝色）通过RTPS连接到感知计算机（深蓝色）。 感知计算机使用相机传感器阵列提供视觉控制和物体避免，并且具有单独的有效载荷相机。</p><p>图的右侧显示了端到端软件堆栈。 堆栈“近似”水平对齐图表的硬件部分，并进行颜色编码，以显示飞行控制器上运行的软件以及配套计算机上的软件。</p><p></p><p align="center">    <img src="images/dronecode_platform_architecture.jpg" width="90%" alt="Dronecode平台软硬件架构"></p><p></p><center>图4  Dronecode平台软硬件架构</center><h1 id="PX4位姿控制"><a href="#PX4位姿控制" class="headerlink" title="PX4位姿控制"></a>PX4位姿控制</h1><h2 id="多旋翼位置控制"><a href="#多旋翼位置控制" class="headerlink" title="多旋翼位置控制"></a>多旋翼位置控制</h2><p></p><p align="center">    <img src="images/px4_mc_position_controller_diagram.png" width="90%" alt="PX4多旋翼位置控制"></p><p></p><center>图5  PX4多旋翼位置控制</center><h1 id="混合和执行器"><a href="#混合和执行器" class="headerlink" title="混合和执行器"></a>混合和执行器</h1><p>PX4架构保证了核心控制器中不需要针对机身布局做特别处理。</p><p>混控指的是把输入指令（例如：遥控器打右转）分配到电机以及舵机的执行器（如电调或舵机PWM）指令。对于固定翼的副翼控制而言，每个副翼由一个舵机控制，那么混控的意义就是控制其中一个副翼抬起而另一个副翼落下。同样的，对多旋翼而言，俯仰操作需要改变所有电机的转速。</p><p>将混控逻辑从实际姿态控制器中分离出来可以大大提高复用性。</p><h2 id="控制管线"><a href="#控制管线" class="headerlink" title="控制管线"></a>控制管线</h2><p>一个特定的控制器（如姿态控制器）发送特定的归一化（-1..+1）的命令到给混合（mixing）,然后混合后输出独立的PWM到执行器（电调，舵机等）.在经过输出驱动如（串口，UAVCAN，PWM）等将归一化的值再转回特性的值（如输出1300的PWM等）。</p><p></p><p align="center">    <img src="images/control_pipeline.jpg" width="90%" alt="PX4控制管线"></p><p></p><center>图6  PX4控制管线</center><h2 id="控制组"><a href="#控制组" class="headerlink" title="控制组"></a>控制组</h2><p>PX4 有输入组和输出组的概念，顾名思义：控制输入组（如： attitude），就是用于核心的飞行姿态控制，（如： gimbal ）就是用于挂载控制. 一个输出组就是一个物理总线，如前8个PWM组成的总线用于舵机控制，组内带8个归一化（-1..+1）值,一个混合就是用于输入和输出连接方式（如:对于四轴来说,输入组有俯仰，翻滚，偏航等，对于于向前打俯仰操作，就需要改变输出组中的4个电调的PWM输出值，前俩个降低转速，后两个增加转速，飞机就向前）。</p><p>对于简单的固定翼来说，输入0（roll），就直接连接到输出的0（副翼）。对于多旋翼来说就不同了，输入0（roll）需要连接到所有的4个电机。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://dev.px4.io/en/" target="_blank" rel="noopener">PX4 Development Guide (STABLE - v1.8.2)</a>,by Dronecode.</li><li><a href="https://dev.px4.io/zh/" target="_blank" rel="noopener">PX4开发指南</a>, by Dronecode.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进行PX4开发，必先了解PX4体系结构及相关概念。下面及简要介绍PX4开发的相关知识。&lt;/p&gt;
&lt;h1 id=&quot;PX4体系结构&quot;&gt;&lt;a href=&quot;#PX4体系结构&quot; class=&quot;headerlink&quot; title=&quot;PX4体系结构&quot;&gt;&lt;/a&gt;PX4体系结构&lt;/h1&gt;&lt;p
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="无人机" scheme="https://huangwang.github.io/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="飞行仿真" scheme="https://huangwang.github.io/tags/%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>PX4编译开发环境配置</title>
    <link href="https://huangwang.github.io/2019/04/26/PX4%E7%BC%96%E8%AF%91%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://huangwang.github.io/2019/04/26/PX4编译开发环境配置/</id>
    <published>2019-04-26T12:50:05.000Z</published>
    <updated>2019-04-27T14:02:48.300Z</updated>
    
    <content type="html"><![CDATA[<p>拟在基于NuttX的硬件平台如Pixhawk系列开源硬件平台上运行自定义的Px4自驾仪软件，因此需要建立Px4的编译开发环境。以官方文档推荐，在Ubuntu 16.04 LTS操作系统上建立Px4编译开发环境为例，记录整个配置过程。</p><h1 id="安装Ubuntu-16-04-LTS"><a href="#安装Ubuntu-16-04-LTS" class="headerlink" title="安装Ubuntu 16.04 LTS"></a>安装Ubuntu 16.04 LTS</h1><p>官方推荐在Mac OS和Linux上进行开发，因此选择安装Ubuntu 16.04 LTS作为Px4开发的操作系统。主要步骤如下：</p><ol><li>安装VirtualBox系统虚拟机</li><li>在VirtualBox创建虚拟机</li><li>在虚拟机中安装Ubuntu 16.04 LTS操作系统</li></ol><h1 id="Ubuntu中安装工具链"><a href="#Ubuntu中安装工具链" class="headerlink" title="Ubuntu中安装工具链"></a>Ubuntu中安装工具链</h1><h2 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h2><p>为了使当前用户能够访问串口，将当前用户添加到dialout组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G dialout $USER</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="安装工具链"><a href="#安装工具链" class="headerlink" title="安装工具链"></a>安装工具链</h2><h3 id="Pixhawk-NuttX-and-jMAVSim"><a href="#Pixhawk-NuttX-and-jMAVSim" class="headerlink" title="Pixhawk/NuttX (and jMAVSim)"></a>Pixhawk/NuttX (and jMAVSim)</h3><p>针对基于NuttX的硬件平台如Pixhawk构建开发工具链，步骤如下：</p><ol><li>下载ubuntu_sim_nuttx.sh</li><li>运行脚本ubuntu_sim_nuttx.sh</li><li>完成后重启</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/PX4/Devguide/master/build_scripts/ubuntu_sim_nuttx.sh</span><br><span class="line">source ubuntu_sim_nuttx.sh</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="编译Px4软件"><a href="#编译Px4软件" class="headerlink" title="编译Px4软件"></a>编译Px4软件</h1><h2 id="下载Px4源代码"><a href="#下载Px4源代码" class="headerlink" title="下载Px4源代码"></a>下载Px4源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/src</span><br><span class="line">cd ~/src</span><br><span class="line">git clone https://github.com/PX4/Firmware.git</span><br><span class="line"></span><br><span class="line">cd Firmware</span><br><span class="line"></span><br><span class="line"># list the releases (tags)</span><br><span class="line">git tag -l</span><br><span class="line"></span><br><span class="line"># Checkout code for particular tag (e.g. for tag v1.8.2 stable version)</span><br><span class="line">git checkout v1.8.2</span><br><span class="line"></span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>现在可以通过编译源代码来构建二进制文件。在直接使用硬件前，推荐先<strong>进行仿真</strong>。</p><h2 id="jMAVSim仿真器"><a href="#jMAVSim仿真器" class="headerlink" title="jMAVSim仿真器"></a>jMAVSim仿真器</h2><p>在直接使用硬件之前，以jMAVSim仿真器为目标平台构建PX4，验证PX4的正确性。<strong>注意在virtualbox中启动3D图形加速，防止jMAVSim运行出错！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make posix jmavsim</span><br><span class="line"></span><br><span class="line"># 起飞四旋翼无人机</span><br><span class="line">pxh&gt; commander takeoff</span><br></pre></td></tr></table></figure><h2 id="基于NuttX-Pixhawk的硬件板"><a href="#基于NuttX-Pixhawk的硬件板" class="headerlink" title="基于NuttX / Pixhawk的硬件板"></a>基于NuttX / Pixhawk的硬件板</h2><p>以Pixhawk为目标平台，构建PX4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Firmware</span><br><span class="line">make px4fmu-v2_default</span><br></pre></td></tr></table></figure><p>注意到“make”是一个字符命令编译工具，“px4fmu-v2”是硬件/ardupilot版本，“default”是默认配置，所有的PX4编译目标遵循这个规则。</p><p>成功编译的最后输出是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[100%] Linking CXX executable firmware_nuttx</span><br><span class="line">[100%] Built target firmware_nuttx</span><br><span class="line">Scanning dependencies of target build/firmware_px4fmu-v2</span><br><span class="line">[100%] Generating nuttx-px4fmu-v2-default.px4</span><br><span class="line">[100%] Built target build/firmware_px4fmu-v2</span><br></pre></td></tr></table></figure><p>通过在命令后面添加‘upload’，编译的二进制程序就会通过USB上传到飞控硬件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make px4fmu-v2_default upload</span><br></pre></td></tr></table></figure><p>上传成功时输出情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Erase  : [====================] 100.0%</span><br><span class="line">Program: [====================] 100.0%</span><br><span class="line">Verify : [====================] 100.0%</span><br><span class="line">Rebooting.</span><br><span class="line"></span><br><span class="line">[100%] Built target upload</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://dev.px4.io/en/" target="_blank" rel="noopener">PX4 Development Guide (STABLE - v1.8.2)</a>,by Dronecode.</li><li><a href="https://dev.px4.io/zh/" target="_blank" rel="noopener">PX4开发指南</a>, by Dronecode.</li><li><a href="https://github.com/DrTon/jMAVSim/issues/42" target="_blank" rel="noopener">running JMAVSim in vmware fails</a>, by jMAVSim issues.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;拟在基于NuttX的硬件平台如Pixhawk系列开源硬件平台上运行自定义的Px4自驾仪软件，因此需要建立Px4的编译开发环境。以官方文档推荐，在Ubuntu 16.04 LTS操作系统上建立Px4编译开发环境为例，记录整个配置过程。&lt;/p&gt;
&lt;h1 id=&quot;安装Ubuntu
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="无人机" scheme="https://huangwang.github.io/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="飞行仿真" scheme="https://huangwang.github.io/tags/%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>硬件在环与软件在环概念辨析</title>
    <link href="https://huangwang.github.io/2019/04/25/%E7%A1%AC%E4%BB%B6%E5%9C%A8%E7%8E%AF%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%9C%A8%E7%8E%AF%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90/"/>
    <id>https://huangwang.github.io/2019/04/25/硬件在环与软件在环概念辨析/</id>
    <published>2019-04-25T13:51:19.000Z</published>
    <updated>2019-04-25T14:46:16.952Z</updated>
    
    <content type="html"><![CDATA[<p>在PX4自驾仪软件的二次开发过程中，涉及硬件在环与软件在环两个概念，不易理解。下面对这两个概念进行辨析。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="硬件在环"><a href="#硬件在环" class="headerlink" title="硬件在环"></a>硬件在环</h2><p>硬件在环（Hardware in the Loop，简称HIL）即硬件在控制环路，是一种半实物仿真。根据控制器和控制对象是否为真实硬件，分为以下两种硬件在环方式：</p><ul><li>虚拟控制器+实际对象=快速控制原型(RCP)仿真系统，是系统的一种半实物仿真；</li><li>实际控制器+虚拟对象=硬件在回路(HIL)仿真系统，是系统的另一种半实物仿真。</li></ul><p>硬件在环主要用于测试控制器系统。</p><h2 id="软件在环"><a href="#软件在环" class="headerlink" title="软件在环"></a>软件在环</h2><p>软件在环主要测试控制器模型与控制器模型代码实现之间的一致性。</p><h2 id="处理器在环"><a href="#处理器在环" class="headerlink" title="处理器在环"></a>处理器在环</h2><p>软件在环主要测试控制器模型与控制器模型代码实现在目标处理器上运行之间的一致性。</p><h2 id="模型在环"><a href="#模型在环" class="headerlink" title="模型在环"></a>模型在环</h2><p>模型在环（Model in the Loop，简称MIL）是用模型驱动进行嵌入式系统的开发时，在开发阶段初期及建模阶段中进行的仿真方式。嵌入式系统需和其运作的环境互动，一般会预期有合理的传感器信号为其输入，也会依输入及系统设计来驱动实体系统。为了使系统正常工作，需要将嵌入式系统的环境纳入仿真考量范围内。若嵌入式系统模型和环境模型连接，一起进行仿真，则即称为模型在环模拟。</p><p>模型在环主要用于测试控制算法，其控制器模型和控制器对象都是虚拟的。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://www.zhihu.com/question/32069347" target="_blank" rel="noopener">请明白人通俗的解释一下什么叫硬件在环？</a>, by zhihu.</li><li><a href="http://www.360doc.com/content/16/0908/10/22368478_589256146.shtml" target="_blank" rel="noopener">简单说说MIL、SIL、PIL和HIL</a>, by Wangxn665.</li><li><a href="https://zh.wikipedia.org/wiki/模型在环" target="_blank" rel="noopener">模型在环</a>, by wikipedia.</li><li><a href="https://baike.baidu.com/item/硬件在环" target="_blank" rel="noopener">硬件在环</a>, by 百度百科.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在PX4自驾仪软件的二次开发过程中，涉及硬件在环与软件在环两个概念，不易理解。下面对这两个概念进行辨析。&lt;/p&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="飞行仿真" scheme="https://huangwang.github.io/tags/%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>机器人路径规划、轨迹规划和运动规划概念辨析</title>
    <link href="https://huangwang.github.io/2019/04/17/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92-%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92%E5%92%8C%E8%BF%90%E5%8A%A8%E8%A7%84%E5%88%92%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90/"/>
    <id>https://huangwang.github.io/2019/04/17/机器人路径规划-轨迹规划和运动规划概念辨析/</id>
    <published>2019-04-17T13:15:42.000Z</published>
    <updated>2019-04-17T13:56:21.132Z</updated>
    
    <content type="html"><![CDATA[<p>在机器人自动控制研究中，路径规划、轨迹规划和运动规划三个概念总是混淆不清，难以捉摸。下面结合各种资料，给出我个人的一些理解，对这三个概念进行辨析。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="路径规划（path-planning）"><a href="#路径规划（path-planning）" class="headerlink" title="路径规划（path planning）"></a>路径规划（path planning）</h2><p>路径是机器人位姿的一定序列，<strong>不考虑机器人位姿参数随时间变化的因素</strong>。路径规划（一般指位置规划）是找到一系列要经过的路径点，路径点是空间中的位置或关节角度。</p><h2 id="轨迹规划（trajectory-planning）"><a href="#轨迹规划（trajectory-planning）" class="headerlink" title="轨迹规划（trajectory planning）"></a>轨迹规划（trajectory planning）</h2><p>路径是机器人位姿的一定序列，<strong>不考虑机器人位姿参数随时间变化的因素</strong>。路径规划（一般指位置规划）是找到一系列要经过的路径点，路径点是空间中的位置或关节角度，而轨迹规划是赋予路径时间信息。</p><h2 id="运动规划（motion-planning）"><a href="#运动规划（motion-planning）" class="headerlink" title="运动规划（motion planning）"></a>运动规划（motion planning）</h2><p>运动规划就是在给定的位置A与位置B之间为机器人找到一条符合约束条件的路径。运动规划包含路径规划和轨迹规划。</p><p>运动规划，又称运动插补，是在给定的路径端点之间插入用于控制的中间点序列从而实现沿给定的平稳运动。</p><p>运动控制则是主要解决如何控制目标系统准确跟踪指令轨迹的问题，即对于给定的指令轨迹，选择适合的控制算法和参数，产生输出，控制目标实时，准确地跟踪给定的指令轨迹。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://www.cnblogs.com/wdzeng/p/9159575.html" target="_blank" rel="noopener">运动（motion）规划、路径（path）规划和轨迹（trajectory）规划之区别</a>,by Roger_Ceng.</li><li><a href="https://blog.csdn.net/wx545644217/article/details/54175035" target="_blank" rel="noopener">运动规划/路径规划/轨迹规划</a>,by 小白鼠2号.</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA5MDE2MjQ0OQ==&amp;mid=2652786406&amp;idx=1&amp;sn=f937dd6aa91344fed689baf51dc821ab#rd" target="_blank" rel="noopener">运动规划 | 简介篇</a>,by qqfly.</li><li><a href="https://www.zhihu.com/question/67867008" target="_blank" rel="noopener">无人车运动规划，路径规划，轨迹规划的区别和联系？</a>, by zhihu.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在机器人自动控制研究中，路径规划、轨迹规划和运动规划三个概念总是混淆不清，难以捉摸。下面结合各种资料，给出我个人的一些理解，对这三个概念进行辨析。&lt;/p&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="机器学习" scheme="https://huangwang.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>FlightGear简易飞行教程</title>
    <link href="https://huangwang.github.io/2019/03/29/FlightGear%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%95%99%E7%A8%8B/"/>
    <id>https://huangwang.github.io/2019/03/29/FlightGear简易飞行教程/</id>
    <published>2019-03-29T02:29:07.000Z</published>
    <updated>2019-03-29T08:34:07.255Z</updated>
    
    <content type="html"><![CDATA[<p>FlightGear是一个始于1997年多平台飞行模拟器、自由软件项目。下面简要介绍如何在FlightGear中驾驶飞行。</p><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><h2 id="飞机操纵"><a href="#飞机操纵" class="headerlink" title="飞机操纵"></a>飞机操纵</h2><ul><li>9/3</li></ul><p>推力：9增加推力（油门），3减小推力（油门）</p><ul><li>4/6</li></ul><p>副翼：4向左滚转，6向右滚转</p><ul><li>8/2</li></ul><p>升降舵：8推杆低头，2拉杆抬头</p><ul><li>0/Enter</li></ul><p>方向舵：0向右偏航，Enter向右偏航</p><ul><li>5</li></ul><p>居中副翼/升降舵/方向舵</p><ul><li>]/[</li></ul><p>放/收襟翼</p><ul><li>g/G</li></ul><p>收/放起落架</p><ul><li>b/B</li></ul><p>刹车（全部轮胎）/或释放刹车</p><h2 id="视角变换"><a href="#视角变换" class="headerlink" title="视角变换"></a>视角变换</h2><ul><li>x/X</li></ul><p>放大/缩小</p><ul><li>v/V</li></ul><p>切换飞行员的观测模式</p><ul><li>Tab</li></ul><p>循环切换鼠标模式：正常模式(默认)、控制模式和查看模式。</p><h2 id="自动驾驶"><a href="#自动驾驶" class="headerlink" title="自动驾驶"></a>自动驾驶</h2><ul><li>Ctril + A</li></ul><p>高度保持开关</p><ul><li>Ctril + G</li></ul><p>下滑角跟随开关</p><ul><li>Ctril + H</li></ul><p>航向保持开关</p><ul><li>Ctril + N</li></ul><p>NAV 开关</p><ul><li>Ctril + T</li></ul><p>地形跟随开关</p><ul><li>Ctril + U</li></ul><p>高度增加 1000 英尺（紧急情况）</p><h1 id="起飞教程"><a href="#起飞教程" class="headerlink" title="起飞教程"></a>起飞教程</h1><p>起飞步骤如下：</p><p>1.启动引擎</p><p>在驾驶舱内通过按键启动飞机引擎的过程很麻烦，且各种类型飞机引擎启动过程不一样。幸运的是，FlightGear的飞机菜单中会有自动启动或快速启动的子菜单，点击它们自动启动飞机引擎和各种航电设备。</p><p>2.释放刹车</p><p>使用快捷键B释放刹车。</p><p>3.滑跑起飞</p><p>飞机尽量在跑道中央进行滑跑起飞，使用快捷键“0/Enter”控制飞机方向舵，使飞机在跑道中央滑跑; 当飞机达到起飞速度（一般200～300km/h）时，<strong>先使用快捷键“5”居中副翼/升降舵/方向舵，以降低飞机在空中操纵的难度，再使用快捷键“8/2”操纵飞机升降舵，注意应避免仰角过大</strong>。</p><h1 id="武器使用教程"><a href="#武器使用教程" class="headerlink" title="武器使用教程"></a>武器使用教程</h1><p>各种战斗机可通过飞机菜单选择不同武器加载方案。但各种战斗机的武器使用方法不一样，对应武器发射的快捷键也不一样，可通过菜单“Help-&gt;Aircraft Help”查看具体飞机的自定义快捷键。下面以官方飞机库中的F15和F16为例说明武器使用方法。</p><h2 id="F15"><a href="#F15" class="headerlink" title="F15"></a>F15</h2><p>F15武器使用步骤如下：</p><p>1.打开Master ARM开关</p><p>该军械总开关防止武器误发射，使用快捷键Ctrl+w控制。</p><p>2.选择武器</p><p>可选择航炮和导弹等武器，使用快捷键m控制</p><p>3.发射航炮或释放导弹</p><p>使用快捷键e控制，注意航炮按e就发射，而导弹按e得持续3秒钟才能释放导弹。</p><p>4.使用诱饵弹</p><p>使用快捷键Ctrl+q释放诱饵弹。</p><h2 id="F16"><a href="#F16" class="headerlink" title="F16"></a>F16</h2><p>F16武器使用步骤如下：</p><p>1.打开Master ARM开关</p><p>该开关防止武器误发射，使用快捷键m控制。</p><p>2.选择武器</p><p>可选择航炮和导弹等武器，使用快捷键w控制</p><p>3.发射航炮或释放导弹</p><p>使用快捷键e控制，注意航炮按e就发射，而导弹按e得持续3秒钟才能释放导弹。</p><p>4.使用诱饵弹</p><p>使用快捷键q释放诱饵弹。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zh.wikipedia.org/wiki/FlightGear" target="_blank" rel="noopener">FlightGear</a>,by wikipedia.</li><li><a href="http://www.flightgear.org.cn/thread-23-1-1.html" target="_blank" rel="noopener">FlightGear基本飞行操作快捷键</a>,by zxc.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FlightGear是一个始于1997年多平台飞行模拟器、自由软件项目。下面简要介绍如何在FlightGear中驾驶飞行。&lt;/p&gt;
&lt;h1 id=&quot;常用快捷键&quot;&gt;&lt;a href=&quot;#常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;常用快捷键&quot;&gt;&lt;/a&gt;常用
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="飞行仿真" scheme="https://huangwang.github.io/tags/%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>JSBSim编程实践之入门</title>
    <link href="https://huangwang.github.io/2019/03/27/JSBSim%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwang.github.io/2019/03/27/JSBSim编程实践之入门/</id>
    <published>2019-03-27T07:32:05.000Z</published>
    <updated>2019-03-27T08:12:15.251Z</updated>
    
    <content type="html"><![CDATA[<p>JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。JSBSim可以独立运行，通过命令行参数指定飞行器和初始状态，进行简单情境下的飞行动力学仿真，也可以将JSBSim作为代码库，编程实现飞行器模型加载，设置输入，获得输出。下面即介绍在Linux平台编程调用JSBSim库的方法和步骤。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="gcc与g"><a href="#gcc与g" class="headerlink" title="gcc与g++"></a>gcc与g++</h2><p>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。</p><p>通常gcc用于编译链接c代码文件，而g++用于编译链接c++代码文件，但它们的使用方法很类似。下面介绍gcc和g++的常用选项。</p><ul><li>添加头文件搜索路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc foo.c -I /home/xiaowp/include -o foo</span><br></pre></td></tr></table></figure><ul><li>添加动态库搜索路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc foo.c -L /home/xiaowp/lib -lfoo -o foo</span><br></pre></td></tr></table></figure><ul><li>添加静态库搜索路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc foo.c -L /home/xiaowp/lib -static -lfoo -o foo</span><br></pre></td></tr></table></figure><h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><h2 id="最简仿真"><a href="#最简仿真" class="headerlink" title="最简仿真"></a>最简仿真</h2><p>下面是JSBSim参考手册中的最简单实例，因JSBSim的不断开发，JSBSim参考手册中该编程实例有点过时，因此进行了少量修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;FGFDMExec.h&gt;</span><br><span class="line">#include &lt;sg_path.hxx&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  JSBSim::FGFDMExec FDMExec;</span><br><span class="line">  bool result = true;</span><br><span class="line"> </span><br><span class="line">  FDMExec.LoadScript(SGPath::fromUtf8(argv[1]));</span><br><span class="line"> </span><br><span class="line">  while (result) result = FDMExec.Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可知，调用JSBSim的主要方法是利用FGFDMExec类，通过实例化一个FGFDMExec类，就相当于获得了一个运行JSBSim仿真的工具箱，通过这个工具箱就可以调用JSBSim的大部分功能，实现我们要的仿真目标。</p><p>接下来对该实例进行编译链接，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># jsbsim_script.cpp是上述实例的代码文件</span><br><span class="line">g++ jsbsim_script.cpp -I ../jsbsim/src/ -I../jsbsim/src/simgear/misc  -L ../jsbsim/build/src/ -static -l JSBSim -o jsbsim_script</span><br></pre></td></tr></table></figure><p>测试该实例，使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># jsbsim是JSBSim项目文件夹</span><br><span class="line"># JSBSimTest是JSBSim测试实例所在文件夹</span><br><span class="line">cd jsbsim</span><br><span class="line">../JSBSimTest/jsbsim_script ./scripts/c1723.xml</span><br></pre></td></tr></table></figure></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://blog.csdn.net/yu_lei_/article/details/81916143" target="_blank" rel="noopener">JSBSim编程实践</a>,by 32768.</li><li><a href="https://huangwang.github.io/2019/03/20/Linux平台编译安装测试JSBSim/">Linux平台编译安装测试JSBSim</a>,by jack huang.</li><li><a href="http://jsbsim.sourceforge.net/documentation.html" target="_blank" rel="noopener">JSBSim Reference Manual </a>,by jsbsim.</li><li><a href="https://www.cnblogs.com/zxouxuewei/p/7263568.html" target="_blank" rel="noopener">gcc和g++头文件和库路径的寻找和添加</a>,by 周学伟.</li><li><a href="https://zh.wikipedia.org/wiki/GCC" target="_blank" rel="noopener">GCC</a>,by wikipedia.</li><li><a href="https://www.freelancinggig.com/blog/2017/11/10/difference-gcc-g/" target="_blank" rel="noopener">WHAT IS THE DIFFERENCE BETWEEN GCC AND G++</a>,by KITTY GUPTA.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。JSBSim可以独立运行，通过命令行参数指定飞行器和初始状态，进行简单情境下的飞行动力学仿真，也可以将
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="飞行仿真" scheme="https://huangwang.github.io/tags/%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>四旋翼无人机制作简易教程</title>
    <link href="https://huangwang.github.io/2019/03/25/%E5%9B%9B%E6%97%8B%E7%BF%BC%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%88%B6%E4%BD%9C%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
    <id>https://huangwang.github.io/2019/03/25/四旋翼无人机制作简易教程/</id>
    <published>2019-03-25T13:40:54.000Z</published>
    <updated>2019-04-08T12:24:22.360Z</updated>
    
    <content type="html"><![CDATA[<p>四轴飞行器又称四旋翼、四转子，是一种多轴飞行器，有四个旋翼来悬停、维持姿态及平飞。和固定翼飞机不同，它通过旋翼提供的推力使飞机升空。它的四个旋翼大小相同，分布位置接近对称。对于简单的设计来说，仅仅通过调整不同旋翼之间的相对速度来调节不同位置的推力，并克服每个旋翼之间的反扭力矩，就可以控制飞机维持姿态、或完成各种机动飞行。下面简单介绍四旋翼无人机的制作过程。</p><h1 id="无人机硬件装配"><a href="#无人机硬件装配" class="headerlink" title="无人机硬件装配"></a>无人机硬件装配</h1><p>组装一件无人机所需配件及其连接示意图如图1所示。</p><p></p><p align="center">    <img src="images/drone_connect.jpg" width="100%" alt="四旋翼无人机机硬件连接图"></p><p></p><center>图1  四旋翼无人机机硬件连接图</center><p>所需配件主要有：</p><ul><li>机身骨架</li><li>一对正浆和一对反浆。注意浆的固定方向与电机旋转方向要一致。</li><li>遥控器及接收机</li><li>无刷电机及电调</li><li>ppm sum receiver</li><li>pixhawk 1，内含安全开关和蜂鸣器</li><li>gps</li><li>锂电池</li><li>云台和摄像头（可选）</li><li>telemetry无线收发装置与图传（可选）</li></ul><h1 id="无人机软件调试"><a href="#无人机软件调试" class="headerlink" title="无人机软件调试"></a>无人机软件调试</h1><h2 id="遥控器与接收机之间对码"><a href="#遥控器与接收机之间对码" class="headerlink" title="遥控器与接收机之间对码"></a>遥控器与接收机之间对码</h2><p>遥控器和接收机之间是配对的，使用之前必须对码，可根据遥控器的使用说明书进行操作。其连接示意图如图2所示。</p><p></p><p align="center">    <img src="images/pair_code.png" width="80%" alt="航模遥控器与接收机对码示意图"></p><p></p><center>图2  航模遥控器与接收机对码示意图</center><h2 id="电子调速器的油门行程和进角设置"><a href="#电子调速器的油门行程和进角设置" class="headerlink" title="电子调速器的油门行程和进角设置"></a>电子调速器的油门行程和进角设置</h2><p>电子调速器主要控制马达的转速，其调试连接示意图如图3所示。</p><p></p><p align="center">    <img src="images/esc.jpg" width="80%" alt="电子调速器连接示意图"></p><p></p><center>图3 电子调速器连接示意图</center><p>如图3所示将电子调速器连接后，即开始设置油门行程和电子调速器进角。设置油门行程即让电子调速器知道遥控器的油门输入范围。而电子调速器进角有高中低之分，类似于汽车档位。低进角速度慢但扭力大，高进角速度快但扭力小，一般设置电子调速器中进角即可满足大多数要求。具体设置说明参照电子调速器使用说明书。</p><h2 id="pixhawk飞控平台的设置"><a href="#pixhawk飞控平台的设置" class="headerlink" title="pixhawk飞控平台的设置"></a>pixhawk飞控平台的设置</h2><p>Pixhawk是PX4飞行堆栈的标准微控制器平台。在pixhawk硬件平台上可运行PX4和ArduPilot两种不同的自动驾驶仪软件套件。如果在pixhawk平台上安装px4自驾仪软件，则使用QGroundControl地面站软件进行设置；如果在pixhawk平台上安装ArduPilot自驾仪软件，则使用MissionPlanner地面站软件进行设置。</p><p>Pixhawk和GPS按照方向捆绑好后，按照地面站软件的指示进行设置。设置好之后，长按Pixhawk的安全开关，再将遥控器油门拉动底并推向最右方，即可解锁Pixhawk。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zh.wikipedia.org/wiki/四轴飞行器" target="_blank" rel="noopener">四轴飞行器</a>,by wikipedia.</li><li><a href="http://dev.px4.io/" target="_blank" rel="noopener">PX4 autopilot</a>, by px4 homepage.</li><li><a href="http://www.crazepony.com/book/" target="_blank" rel="noopener">Crazepony开源四轴飞行器</a>,by crazepony.</li><li><a href="https://en.wikipedia.org/wiki/ArduPilot" target="_blank" rel="noopener">ArduPilot</a>,by wikipedia.</li><li><a href="https://en.wikipedia.org/wiki/PX4_autopilot" target="_blank" rel="noopener">PX4 autopilot</a>,by wikipedia.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;四轴飞行器又称四旋翼、四转子，是一种多轴飞行器，有四个旋翼来悬停、维持姿态及平飞。和固定翼飞机不同，它通过旋翼提供的推力使飞机升空。它的四个旋翼大小相同，分布位置接近对称。对于简单的设计来说，仅仅通过调整不同旋翼之间的相对速度来调节不同位置的推力，并克服每个旋翼之间的反扭力
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="无人机" scheme="https://huangwang.github.io/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>FlightGear多人服务器的本地安装配置</title>
    <link href="https://huangwang.github.io/2019/03/20/FlightGear%E5%A4%9A%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://huangwang.github.io/2019/03/20/FlightGear多人服务器的本地安装配置/</id>
    <published>2019-03-20T12:28:23.000Z</published>
    <updated>2019-03-20T13:53:22.827Z</updated>
    
    <content type="html"><![CDATA[<p>FGMS或FlightGear多人游戏服务器是FlightGear的独立网络服务器，并根据GPL许可。 它允许通过FGFS内的网络与其他飞行员一起飞行。</p><p>FGMS服务器列表类型主要有：</p><ul><li>中继服务器 - 网络中的其他服务器。 每个都必须有完整的列表（减去自己）以获得适当的网络功能。</li><li>交叉馈送服务器 - 服务器从本地用户和其他服务器接收的所有内容都将转发到交叉馈送服务器。 用于在同一主机上运行多个连接的fgms实例，例如用于提供跟踪和未跟踪服务，而不会产生额外的外部流量。</li><li>跟踪服务器 - 服务器每10秒向跟踪器发送一个每个本地用户的摘要更新。</li><li>HUB服务器  - 通常服务器不会将从服务器接收的数据包发送到其他中继。 HUB服务器将数据从服务器发送到它知道的所有中继。</li></ul><p>特别呼号：</p><ul><li>“obsXXXX”（用您喜欢的任何字符替换X）允许连接的FlightGear客户端查看全球所有其他MP飞行员（位置数据和聊天消息），但对他们和MPmap保持不可见。</li><li>“mpdummy”阻止在FGTracker上跟踪飞行员。 不推荐 - 如果多个用户使用此呼号，服务器将忽略一些用户。 改为连接到未跟踪的服务器。</li></ul><h1 id="安装配置FGMS服务器"><a href="#安装配置FGMS服务器" class="headerlink" title="安装配置FGMS服务器"></a>安装配置FGMS服务器</h1><h2 id="下载FGMS服务器源码"><a href="#下载FGMS服务器源码" class="headerlink" title="下载FGMS服务器源码"></a>下载FGMS服务器源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://git.code.sf.net/p/fgms/src fgms-src</span><br></pre></td></tr></table></figure><h2 id="安装配置FGMS服务器源码"><a href="#安装配置FGMS服务器源码" class="headerlink" title="安装配置FGMS服务器源码"></a>安装配置FGMS服务器源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd fgms-src</span><br><span class="line">mkdir build</span><br><span class="line">cd build </span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">cd ..</span><br><span class="line">cp contrib/etc/fgms_production.skel.conf build/fgms.cfg</span><br><span class="line">cd build</span><br><span class="line">./fgms</span><br></pre></td></tr></table></figure><h1 id="安装配置FGMS跟踪服务器源码"><a href="#安装配置FGMS跟踪服务器源码" class="headerlink" title="安装配置FGMS跟踪服务器源码"></a>安装配置FGMS跟踪服务器源码</h1><h2 id="下载FGMS跟踪服务器源码"><a href="#下载FGMS跟踪服务器源码" class="headerlink" title="下载FGMS跟踪服务器源码"></a>下载FGMS跟踪服务器源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://git.code.sf.net/p/fgms/fgtracker fgms-fgtracker</span><br></pre></td></tr></table></figure><h1 id="FlightGear联网飞行配置"><a href="#FlightGear联网飞行配置" class="headerlink" title="FlightGear联网飞行配置"></a>FlightGear联网飞行配置</h1><p>联机前，请选择合适的服务器名（通常是mpserver0?.flightgear.org）和端口号(通常是5000)，然后按照以下方式启动FlightGear。</p><h2 id="使用向导程序"><a href="#使用向导程序" class="headerlink" title="使用向导程序"></a>使用向导程序</h2><p>在向导程序上专门有一个联网飞行选项，只要选中选项，填入服务器名和端口号以及你的昵称就可以了，你的昵称最长可以使7个字符。同时必须确定AI models选项选中，否则无法看到别的联网飞机。</p><h2 id="使用命令行方式"><a href="#使用命令行方式" class="headerlink" title="使用命令行方式"></a>使用命令行方式</h2><p>基本命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--multiplay=out,10,&lt;server&gt;,&lt;portnumber&gt;</span><br><span class="line">--multiplay=in,10,&lt;client&gt;,&lt;portnumber&gt;</span><br><span class="line">--callsign=&lt;anything&gt;</span><br><span class="line">--enable-ai-models</span><br></pre></td></tr></table></figure></p><p>备注:</p><ol><li><portnumber> 为端口号，比如5000.</portnumber></li><li><server> 为服务器名，比如mpserver01.flightgear.org.</server></li><li><client> 是你的计算机名，或者是你的联网的IP地址，比如本地IP地址192.168.0.1</client></li><li><callsign> 是你自己的昵称, 最多7个字符比如NFGFS.<br>当程序开始运行后，你可以在服务器地图上看到自己，如果看不到，检查一下程序是否有报错信息，按照下面将要介绍的内容检查错误。</callsign></li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://wiki.flightgear.org/Howto:Multiplayer" target="_blank" rel="noopener">Howto:Multiplayer</a>,by flightgear home.</li><li><a href="http://wiki.flightgear.org/FlightGear_Multiplayer_Server" target="_blank" rel="noopener">FlightGear Multiplayer Server</a>,by flightgear home.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FGMS或FlightGear多人游戏服务器是FlightGear的独立网络服务器，并根据GPL许可。 它允许通过FGFS内的网络与其他飞行员一起飞行。&lt;/p&gt;
&lt;p&gt;FGMS服务器列表类型主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中继服务器 - 网络中的其他服务器。 每个都必须
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="3D" scheme="https://huangwang.github.io/tags/3D/"/>
    
      <category term="计算机仿真" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux平台编译安装测试JSBSim</title>
    <link href="https://huangwang.github.io/2019/03/20/Linux%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95JSBSim/"/>
    <id>https://huangwang.github.io/2019/03/20/Linux平台编译安装测试JSBSim/</id>
    <published>2019-03-20T02:42:19.000Z</published>
    <updated>2019-03-20T03:29:51.717Z</updated>
    
    <content type="html"><![CDATA[<p>JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。 它也可以从一个小型独立程序调用，以创建批处理模拟工具。 JSBSim是用C ++编写的，使用XML配置文件。下面介绍如何在Linux平台编译按照测试JSBSim。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><p>代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。</p><p>Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</p><p>Make工具有很多，例如 GNU Make ，QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。</p><p>CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等。</p><p>在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：</p><ol><li>编写 CMake 配置文件 CMakeLists.txt 。</li><li>执行命令 cmake PATH 或者 ccmake PATH 生成 Makefile。其中， PATH 是 CMakeLists.txt 所在的目录。</li><li>使用 make 命令进行编译。</li></ol><h1 id="编译JSBSim"><a href="#编译JSBSim" class="headerlink" title="编译JSBSim"></a>编译JSBSim</h1><h2 id="下载JSBSim源代码"><a href="#下载JSBSim源代码" class="headerlink" title="下载JSBSim源代码"></a>下载JSBSim源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/JSBSim-Team/jsbsim.git</span><br></pre></td></tr></table></figure><h2 id="编译JSBSim-1"><a href="#编译JSBSim-1" class="headerlink" title="编译JSBSim"></a>编译JSBSim</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 跳转到jsbsim源码目录</span><br><span class="line">cd jsbsim  </span><br><span class="line"># 创建build文件夹用于编译jsbsim</span><br><span class="line">mkdir build </span><br><span class="line">cd build</span><br><span class="line"># 生成Makefile文件</span><br><span class="line">cmake .. </span><br><span class="line"># 编译</span><br><span class="line">make </span><br><span class="line"># 编译完成后跳转到jsbsim所在目录测试</span><br><span class="line">cd src</span><br><span class="line">./jsbsim</span><br></pre></td></tr></table></figure><h1 id="测试jsbsim"><a href="#测试jsbsim" class="headerlink" title="测试jsbsim"></a>测试jsbsim</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 跳转到jsbsim源码目录</span><br><span class="line">cd jsbsim </span><br><span class="line"># 测试jsbsim</span><br><span class="line">./build/src/JSBSim scripts/c1723.xml</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://en.wikipedia.org/wiki/JSBSim" target="_blank" rel="noopener">JSBSim</a>, by wikipedia.</li><li><a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">Make 命令教程</a>,by 阮一峰</li><li><a href="https://www.hahack.com/codes/cmake/" target="_blank" rel="noopener">CMake 入门实战</a>,by hahack.</li><li><a href="https://blog.csdn.net/yu_lei_/article/details/81813203" target="_blank" rel="noopener">JSBSim使用教程</a>, by  32768.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。 它也可以从一个小型独立程序调用，以创建批处理模拟工具。 JSBSim是用C ++编写的，使用XML配
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="计算机仿真" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>FlightGear飞行模拟器中创建新飞机的方法</title>
    <link href="https://huangwang.github.io/2019/03/17/FlightGear%E9%A3%9E%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E9%A3%9E%E6%9C%BA%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://huangwang.github.io/2019/03/17/FlightGear飞行模拟器中创建新飞机的方法/</id>
    <published>2019-03-17T14:24:54.000Z</published>
    <updated>2019-03-18T14:34:48.788Z</updated>
    
    <content type="html"><![CDATA[<p>FlightGear中创建新飞机粗略地分成四步：创建飞机的3D模型，创建飞机的飞行动力学模型，创建飞机操作动画，实现飞机各子系统。具体而言，又可分成两个主要的开发领域：飞行动力学模型开发和飞机3D模型开发。</p><h1 id="飞机3D模型开发"><a href="#飞机3D模型开发" class="headerlink" title="飞机3D模型开发"></a>飞机3D模型开发</h1><p>主要包括飞机外形、驾驶舱的3D模型开发，为飞行动力学模型设计的动画，声音等。</p><h2 id="加载飞机模型"><a href="#加载飞机模型" class="headerlink" title="加载飞机模型"></a>加载飞机模型</h2><p>通过OpenSceneGraph，FlightGear支持许多不同的3D文件格式，包括VRML1，AC3D，DXF等等。 但是，.ac是大多数FG模型中使用的标准。</p><p>主FlightGear属性树中的属性/ sim / model / path控制将加载的模型; 它需要一个字符串值，从$ FG ROOT给出模型的相对路径。</p><p>加载新模型的最简单方法是使用—prop：命令行选项在启动时设置属性; 例如，要使用已安装在$ FG_ROOT / Models / my-cessna.ac中的3D飞机模型，您可以像这样调用FlightGear（在类Unix系统下）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgfs --prop:/sim/model/path=Models/my-cessna.ac</span><br></pre></td></tr></table></figure><p>（注意：通常模型使用的所有纹理必须出现在同一目录中。如果my-cessna.ac使用纹理cessna01.rgb和cessna02.rgb，你还应该在$ FG_ROOT / Models /中安装这些纹理。</p><p>如果要将3D模型永久设置为飞机的默认值而不是在命令行上指定，则需要编辑飞机设置文件。 在$ FG_ROOT / Aircraft /目录中有一系列以-set.xml结尾的文件，例如c172-set.xml，dc3-yasim-set.xml和beech99-uiuc-set.xml。 当您使用—aircraft选项启动FlightGear时，它会从其中一个文件中读取属性; 例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgfs --aircraft=dc3-yasim</span><br></pre></td></tr></table></figure><p>将$ FG_ROOT / Aircraft / dc3-yasim-set.xml中的属性加载到主FlightGear属性树中。 这些文件与$ FG_ROOT / preferences.xml和FlightGear保存文件具有相同的XML属性列表格式。 对于任何单机类型，可能有许多具有不同启动条件，声音，面板，3D模型等的XML文件，因此您最好复制现有的，重命名它，然后更改模型内部路径元素内的值SIM卡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;PropertyList&gt;</span><br><span class="line">&lt;sim&gt;</span><br><span class="line"> &lt;model&gt;</span><br><span class="line">  &lt;path&gt;Models/my-cessna.ac&lt;/path&gt;</span><br><span class="line">  &lt;texture-path&gt;./Textures&lt;/texture-path&gt;</span><br><span class="line"> &lt;/model&gt;</span><br><span class="line">&lt;/sim&gt;</span><br><span class="line">&lt;/PropertyList&gt;</span><br></pre></td></tr></table></figure><h1 id="飞机动力学模型开发"><a href="#飞机动力学模型开发" class="headerlink" title="飞机动力学模型开发"></a>飞机动力学模型开发</h1><p>FlightGear主要使用JSBSim 和 YASim两个开源的飞行动力学模型，也有极少数使用UIUC飞行动力学模型。</p><h2 id="YASim"><a href="#YASim" class="headerlink" title="YASim"></a>YASim</h2><p>FDM是控制模拟器内飞行物理的数学模型。 物理3D飞机模型与飞行动力学无关 - 实质上它只是一张要看的图片。 这是FDM决定模型如何飞行。</p><p>为何选择YASim？ YASim使用飞机的几何形状来生成基本飞行特征。 虽然这表明了一种“现实的”或开箱即用的方法，但在获得接近现实主义的结果之前，这只是一种粗略的近似，需要进行大量的调整。 如果您的飞机有稳定的飞行数据，例如风洞数据，或者您希望最终生成超逼真的模拟，那么JSBSim可能是更好的方法。 如果你缺乏这样的数据但是知道飞机的几何形状并且能够获得与真实飞行员相同的飞行特性和限制，那么YASim可以提供足以满足大多数模拟需求的解决方案。</p><h2 id="JSBSim"><a href="#JSBSim" class="headerlink" title="JSBSim"></a>JSBSim</h2><p>JSBSim是一个开源飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。 它也可以从一个小型独立程序调用，以创建批处理模拟工具。 JSBSim自1996年以来一直在开发和使用，并且已经构建在当今使用的所有最流行的平台上，包括运行Linux，Macintosh和Microsoft Windows操作系统的平台。 JSBSim是用C ++编写的，使用XML配置文件。</p><h1 id="飞机模型开发规范说明"><a href="#飞机模型开发规范说明" class="headerlink" title="飞机模型开发规范说明"></a>飞机模型开发规范说明</h1><h2 id="规则和指导"><a href="#规则和指导" class="headerlink" title="规则和指导"></a>规则和指导</h2><ul><li><p>FlightGear中的所有图像的大小应为2的幂（例如64 <em> 64,128 </em> 256或16 * 1024）。大多数计算机无法处理大于4096像素的纹理。从FlightGear 1.9开始，图像不再需要以.rgb格式保存。现在.png是FlightGear开发人员中最常用的.png。</p></li><li><p>请注意，我们在代码中使用空格，一些开发人员使用相应的选项卡，以使我们的代码易于（呃）阅读。每一行开始一个新标签，我们按空格键一次，这样你就可以得到一种楼梯。只要您在所有文件中始终如一地使用它，使用何种方法并不重要。但是JSBSim FDM使用的XML文件必须使用空格而不是制表符。</p></li><li><p>在大多数操作系统上，文件名和目录区分大小写。 Windows不区分大小写，因此当您在Windows计算机上进行开发时，您不会发现任何问题。在其他操作系统上，“波音”和“波音”之间存在差异。由于FlightGear用于多个平台，请确保您的代码正确使用大写字母！</p></li></ul><h2 id="目录结构说明"><a href="#目录结构说明" class="headerlink" title="目录结构说明"></a>目录结构说明</h2><p>创建一个新的飞机模型，应该在$FG_ROOT/Aircraft/路径下创建文件夹，以飞机名称命名。例如在$FG_ROOT/Aircraft/路径下创建一个Su30的文件夹，开始构建Su30飞机模型。在飞机根目录下，其目录结构如下：</p><ul><li>-set.xml file</li></ul><p>描述飞机依赖关系的最重要文件是aircraft-set.xml文件。</p><ul><li>.xml file (FDM)</li></ul><p>该文件包含飞机的整个（或部分）飞行动力学模型。有YASim、JSBSim、UIUC三种不同的飞行动力学模型，他们都有自己的优缺点。</p><p>由于数据有限，YASim通常被认为是最好的方式。 当您访问真实的风洞数据和/或需要更多灵活性时，JSBSim可能是更好的选择。</p><ul><li>Engines/ directory</li></ul><p>仅适用于JSBSim飞机。 在此目录中，存储引擎和推进器/螺旋桨文件。</p><ul><li>Models/ directory</li></ul><p>该目录包含所有与模型相关的文件; 例如纹理，模型和动画文件（.xml）。 在-set.xml文件中，我们将路径设置为一个.xml文件。 该文件应链接（间接）到飞机所需的每个其他模型文件（包括可能的3D驾驶舱）。 整个飞机可以建模为一个文件，但大多数开发人员更喜欢拆分。 例如，驾驶舱可以由几个文件构建，每个文件只存在一个仪器或面板。 这样很容易（重新）移动飞机的某些部件。 您可以像这样设置模型文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;PropertyList&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;path&gt;Aircraft.ac&lt;/path&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;model&gt;</span><br><span class="line">  &lt;name&gt;Cockpit&lt;/name&gt;</span><br><span class="line">  &lt;path&gt;Aircraft/.../Models/cockpit.xml&lt;/path&gt;</span><br><span class="line">  &lt;offsets&gt;</span><br><span class="line">   &lt;x-m&gt; -5.25&lt;/x-m&gt;</span><br><span class="line">   &lt;y-m&gt;  0.00&lt;/y-m&gt;</span><br><span class="line">   &lt;z-m&gt;  1.30&lt;/z-m&gt;</span><br><span class="line">  &lt;/offsets&gt;</span><br><span class="line"> &lt;/model&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;animation&gt;</span><br><span class="line">  &lt;type&gt;rotate&lt;/type&gt;</span><br><span class="line">  &lt;object-name&gt;AileronLeft&lt;/object-name&gt;</span><br><span class="line">  &lt;property&gt;/controls/flight/aileron&lt;/property&gt;</span><br><span class="line">  &lt;factor&gt;-65&lt;/factor&gt;</span><br><span class="line">  &lt;center&gt;</span><br><span class="line">   &lt;x-m&gt; 2.09&lt;/x-m&gt;</span><br><span class="line">   &lt;y-m&gt;-5.50&lt;/y-m&gt;</span><br><span class="line">   &lt;z-m&gt;-1.50&lt;/z-m&gt;</span><br><span class="line">  &lt;/center&gt;</span><br><span class="line">  &lt;axis&gt;</span><br><span class="line">   &lt;x&gt;1&lt;/x&gt;</span><br><span class="line">   &lt;y&gt;0&lt;/y&gt;</span><br><span class="line">   &lt;z&gt;0&lt;/z&gt;</span><br><span class="line">  &lt;/axis&gt;</span><br><span class="line"> &lt;/animation&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;/PropertyList&gt;</span><br></pre></td></tr></table></figure><p>cockpit.xml文件可以包含相似结构，所有工具都是单独的模型。 模型的数量不受限制，动画的数量也不限。</p><ul><li>Nasal/ directory</li></ul><p>所有针对飞机的Nasal脚本都放在此目录中，但某些系统或仪器特定的Nasal脚本除外。 如果某个Nasal脚本对所有飞机都有用（例如天气或多人相关），它可以放在$ FG_ROOT / Nasal目录中。 可以在$ FG_ROOT / Aircraft / Generic目录中找到可在多架飞机上使用的Nasal脚本（例如空中加油）。</p><ul><li>Sounds/ directory</li></ul><p>声音对于增加你实际进入模拟的感觉非常重要。 在此目录中，存储了特定于飞行器的所有声音文件。 可以在多个飞机上使用的声音（例如，点击开关或雷声）可在$ FG_ROOT / Sounds目录中找到。</p><ul><li>Tutorials/ directory</li></ul><p>FlightGears教程系统是学习如何启动飞机引擎等的有用功能。 它允许您创建一个分步教程，指导用户完成某个过程。 它甚至可以指示应按下哪些开关！</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://wiki.flightgear.org/Howto:Make_an_aircraft" target="_blank" rel="noopener">Howto:Make an aircraft</a>,by flightgear home.</li><li><a href="http://wiki.flightgear.org/Howto:3D_Aircraft_Models" target="_blank" rel="noopener">Howto:3D Aircraft Models</a>,by flightgear home.</li><li><a href="http://wiki.flightgear.org/Howto:Animate_models" target="_blank" rel="noopener">Howto:Animate models</a>,by flightgear home.</li><li><a href="http://wiki.flightgear.org/YASim" target="_blank" rel="noopener">YASim</a>,by flightgear home.</li><li><a href="http://wiki.flightgear.org/JSBSim" target="_blank" rel="noopener">JSBSim</a>,by flightgear home.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FlightGear中创建新飞机粗略地分成四步：创建飞机的3D模型，创建飞机的飞行动力学模型，创建飞机操作动画，实现飞机各子系统。具体而言，又可分成两个主要的开发领域：飞行动力学模型开发和飞机3D模型开发。&lt;/p&gt;
&lt;h1 id=&quot;飞机3D模型开发&quot;&gt;&lt;a href=&quot;#飞
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="3D" scheme="https://huangwang.github.io/tags/3D/"/>
    
      <category term="计算机仿真" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>FlightGear安装飞机和场景的方法</title>
    <link href="https://huangwang.github.io/2019/03/13/FlightGear%E5%AE%89%E8%A3%85%E9%A3%9E%E6%9C%BA%E5%92%8C%E5%9C%BA%E6%99%AF%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://huangwang.github.io/2019/03/13/FlightGear安装飞机和场景的方法/</id>
    <published>2019-03-13T00:21:13.000Z</published>
    <updated>2019-03-13T09:56:42.301Z</updated>
    
    <content type="html"><![CDATA[<p>FlightGear可安装额外的飞行器和地景。</p><h1 id="安装地景"><a href="#安装地景" class="headerlink" title="安装地景"></a>安装地景</h1><p>FlightGear的详细地景可以覆盖整个世界。默认的FlightGear安装包只包括旧金山周边一小块区域，因此想要飞到其他地方，得下载额外的地景。</p><p>每一块地景被打包成一个压缩包，每经纬度10度为一块。每一个压缩包以10×10经纬度命名，如w130n50.tgz。</p><p>下载FlightGear地景参考链接1。下载后的地景复制到$FG_ROOT/Scenery或者$FG_SCENERY下。</p><p>使用如下命令解压地景，将在$FG_ROOT/Scenery产生Objects和Terrain两个文件夹，分别为卫星地图和地形数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $FG_ROOT/Scenery</span><br><span class="line">tar -xvf e110n30.tgz</span><br><span class="line">rm e110n30.tgz</span><br></pre></td></tr></table></figure></p><h1 id="安装飞行器"><a href="#安装飞行器" class="headerlink" title="安装飞行器"></a>安装飞行器</h1><p>默认的FlightGear安装包只有少数几个飞行器，可以从参考链接2中获得大量的飞行器。</p><p>下载的飞行器复制到$FG_ROOT/Aircraft文件夹下。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://home.flightgear.org/download/scenery/" target="_blank" rel="noopener">下载FlightGear地景</a>， by flightgear.</li><li><a href="http://home.flightgear.org/download/download-aircraft/" target="_blank" rel="noopener">下载FlightGear飞行器</a>, by flightgear.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FlightGear可安装额外的飞行器和地景。&lt;/p&gt;
&lt;h1 id=&quot;安装地景&quot;&gt;&lt;a href=&quot;#安装地景&quot; class=&quot;headerlink&quot; title=&quot;安装地景&quot;&gt;&lt;/a&gt;安装地景&lt;/h1&gt;&lt;p&gt;FlightGear的详细地景可以覆盖整个世界。默认的Flig
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="3D" scheme="https://huangwang.github.io/tags/3D/"/>
    
      <category term="计算机仿真" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫获取网页链接</title>
    <link href="https://huangwang.github.io/2019/03/13/Python%E7%88%AC%E8%99%AB%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5/"/>
    <id>https://huangwang.github.io/2019/03/13/Python爬虫获取网页链接/</id>
    <published>2019-03-13T00:20:11.000Z</published>
    <updated>2019-03-13T10:18:02.888Z</updated>
    
    <content type="html"><![CDATA[<p>最近研究开源飞行模拟器，想将其世界地景全部下载下来。一个个手动下载太麻烦，于是想先用python的requests和Beautiful Soup组件获取地景链接，再以每行一个地景链接写入文本文档，最后使用axel多线程自动下载每一个地景包。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="requests组件"><a href="#requests组件" class="headerlink" title="requests组件"></a>requests组件</h2><p>Requests是一个Python HTTP库，在Apache 2许可证下发布。该项目的目标是使HTTP请求更简单，更人性化。</p><p>下面是示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import requests</span><br><span class="line">&gt;&gt;&gt; r = requests.get(&apos;https://api.github.com/user&apos;, auth=(&apos;user&apos;, &apos;pass&apos;))</span><br><span class="line">&gt;&gt;&gt; r.status_code</span><br><span class="line">200</span><br><span class="line">&gt;&gt;&gt; r.headers[&apos;content-type&apos;]</span><br><span class="line">&apos;application/json; charset=utf8&apos;</span><br><span class="line">&gt;&gt;&gt; r.encoding</span><br><span class="line">&apos;utf-8&apos;</span><br><span class="line">&gt;&gt;&gt; r.text # doctest: +ELLIPSIS</span><br><span class="line">u&apos;&#123;&quot;type&quot;:&quot;User&quot;...&apos;</span><br><span class="line">&gt;&gt;&gt; r.json() # doctest: +ELLIPSIS</span><br><span class="line">&#123;u&apos;private_gists&apos;: 419, u&apos;total_private_repos&apos;: 77, ...&#125;</span><br></pre></td></tr></table></figure><h2 id="Beautiful-Soup组件"><a href="#Beautiful-Soup组件" class="headerlink" title="Beautiful Soup组件"></a>Beautiful Soup组件</h2><p>Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库。它能够通过你喜欢的转换器实现惯用的文档导航，查找，修改文档的方式。Beautiful Soup会帮你节省数小时甚至数天的工作时间。</p><p>Beautiful Soup支持Python标准库中的HTML解析器，还支持一些第三方的解析器，其中一个是 lxml。</p><p>Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment。</p><ul><li>Tag 对象与XML或HTML原生文档中的tag相同，有最重要的属性: name和attributes。</li><li>BeautifulSoup 对象表示的是一个文档的全部内容，但并不是真正的HTML或XML的tag，所以它没有name和attribute属性。</li><li>Beautiful Soup用 NavigableString 类来包装tag中的字符串。</li><li>Comment 对象是一个特殊类型的 NavigableString 对象:</li></ul><p>下面是BeautifulSoup的一个简单示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html_doc)</span><br><span class="line"></span><br><span class="line">print(soup.prettify())</span><br><span class="line"># &lt;html&gt;</span><br><span class="line">#  &lt;head&gt;</span><br><span class="line">#   &lt;title&gt;</span><br><span class="line">#    The Dormouse&apos;s story</span><br><span class="line">#   &lt;/title&gt;</span><br><span class="line">#  &lt;/head&gt;</span><br><span class="line">#  &lt;body&gt;</span><br><span class="line">#   &lt;p class=&quot;title&quot;&gt;</span><br><span class="line">#    &lt;b&gt;</span><br><span class="line">#     The Dormouse&apos;s story</span><br><span class="line">#    &lt;/b&gt;</span><br><span class="line">#   &lt;/p&gt;</span><br><span class="line">#   &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">#    Once upon a time there were three little sisters; and their names were</span><br><span class="line">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">#     Elsie</span><br><span class="line">#    &lt;/a&gt;</span><br><span class="line">#    ,</span><br><span class="line">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span><br><span class="line">#     Lacie</span><br><span class="line">#    &lt;/a&gt;</span><br><span class="line">#    and</span><br><span class="line">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link2&quot;&gt;</span><br><span class="line">#     Tillie</span><br><span class="line">#    &lt;/a&gt;</span><br><span class="line">#    ; and they lived at the bottom of a well.</span><br><span class="line">#   &lt;/p&gt;</span><br><span class="line">#   &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">#    ...</span><br><span class="line">#   &lt;/p&gt;</span><br><span class="line">#  &lt;/body&gt;</span><br><span class="line"># &lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="axel工具"><a href="#axel工具" class="headerlink" title="axel工具"></a>axel工具</h2><p>axel是Linux下一个不错的HTTP/ftp高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。适合网速不给力时多线程下载提高下载速度。</p><p>axel语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axel [options] url1 [url2] [url...]</span><br></pre></td></tr></table></figure></p><p>axel选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--max-speed=x , -s x         最高速度x</span><br><span class="line">--num-connections=x , -n x   连接数x</span><br><span class="line">--output=f , -o f            下载为本地文件f</span><br><span class="line">--search[=x] , -S [x]        搜索镜像</span><br><span class="line">--header=x , -H x            添加头文件字符串x（指定 HTTP header）</span><br><span class="line">--user-agent=x , -U x        设置用户代理（指定 HTTP user agent）</span><br><span class="line">--no-proxy ， -N             不使用代理服务器</span><br><span class="line">--quiet ， -q                静默模式</span><br><span class="line">--verbose ，-v               更多状态信息</span><br><span class="line">--alternate ， -a            Alternate progress indicator</span><br><span class="line">--help ，-h                  帮助</span><br><span class="line">--version ，-V               版本信息</span><br></pre></td></tr></table></figure></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="获取地景链接"><a href="#获取地景链接" class="headerlink" title="获取地景链接"></a>获取地景链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"># 下载指定URI链接</span><br><span class="line">def getUriContent(uri):</span><br><span class="line">    try:</span><br><span class="line">        fgWorldScenery = requests.get(link, timeout=10)</span><br><span class="line">    except requests.exceptions.HTTPError as errh:</span><br><span class="line">        print (&quot;Http Error:&quot;,errh)</span><br><span class="line">    except requests.exceptions.ConnectionError as errc:</span><br><span class="line">        print (&quot;Error Connecting:&quot;,errc)</span><br><span class="line">    except requests.exceptions.Timeout as errt:</span><br><span class="line">        print (&quot;Timeout Error:&quot;,errt)  </span><br><span class="line">    except requests.exceptions.RequestException as err:</span><br><span class="line">        print (&quot;OOps: Something Else&quot;,err)</span><br><span class="line">    else:    </span><br><span class="line">        print(&quot;Http Request Success!&quot;)</span><br><span class="line">        return fgWorldScenery.text</span><br><span class="line"></span><br><span class="line"># 获取所有地景链接，存入列表</span><br><span class="line">def getTargetLinks(html):</span><br><span class="line">    soup = BeautifulSoup(html)</span><br><span class="line">    list=[]</span><br><span class="line">    #print(soup.prettify())</span><br><span class="line">    for child in soup.find_all(&apos;area&apos;):</span><br><span class="line">        list.append(child[&apos;href&apos;])</span><br><span class="line">    print(&quot;Get Target Links Success!&quot;)</span><br><span class="line">    return list</span><br><span class="line"></span><br><span class="line"># 将地景链接逐行写入文件</span><br><span class="line">def writeToFile(linkList):</span><br><span class="line">    file = open(&apos;./sceneLink.txt&apos;,&apos;w&apos;)</span><br><span class="line">    for link in linkList:</span><br><span class="line">        file.write(link)</span><br><span class="line">        file.write(&apos;\t\n&apos;)</span><br><span class="line">    print(&quot;Write Target Link To File Success!&quot;)</span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    link = &quot;http://www.flightgear.org/legacy-Downloads/scenery-v2.12.html&quot;</span><br><span class="line">    html=getUriContent(link)</span><br><span class="line">    linkList=getTargetLinks(html)</span><br><span class="line">    writeToFile(linkList)</span><br></pre></td></tr></table></figure><h2 id="下载世界地景"><a href="#下载世界地景" class="headerlink" title="下载世界地景"></a>下载世界地景</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for line in $(cat sceneLink.txt)</span><br><span class="line">do </span><br><span class="line">    axel -n 10 $line</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">requests快速上手</a>,by requests.</li><li><a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">Python 基础教程</a>, by runoob.</li><li><a href="http://codingpy.com/article/guido-shows-how-to-write-main-function/" target="_blank" rel="noopener">Python之父教你写main()函数</a>,by 编程派.</li><li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">Beautiful Soup 4.2.0 文档</a>,by BeautifulSoup.</li><li><a href="https://huangwang.github.io/2019/03/13/FlightGear安装飞机和场景的方法/">FlightGear安装飞机和场景的方法</a>,by jack huang.</li><li><a href="http://man.linuxde.net/axel" target="_blank" rel="noopener">axel命令</a>,by Linux命令大全.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近研究开源飞行模拟器，想将其世界地景全部下载下来。一个个手动下载太麻烦，于是想先用python的requests和Beautiful Soup组件获取地景链接，再以每行一个地景链接写入文本文档，最后使用axel多线程自动下载每一个地景包。&lt;/p&gt;
&lt;h1 id=&quot;基础知识
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="python" scheme="https://huangwang.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Git_Clone大项目超过1G失败解决方案</title>
    <link href="https://huangwang.github.io/2019/03/09/Git-Clone%E5%A4%A7%E9%A1%B9%E7%9B%AE%E8%B6%85%E8%BF%871G%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://huangwang.github.io/2019/03/09/Git-Clone大项目超过1G失败解决方案/</id>
    <published>2019-03-09T00:59:46.000Z</published>
    <updated>2019-03-09T12:19:21.799Z</updated>
    
    <content type="html"><![CDATA[<p>SourceForge.net，又称SF.net，是开源软件的开发者进行开发管理的集中式场所，也是全球最大开源软件开发平台和仓库。FlightGear的源代码就托管在该平台。最近在使用Git克隆FlightGear的子项目fgdata时，老是到1G时失败。具体情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># git clone fgdata大项目时超过1G就会出错</span><br><span class="line">$ git clone https://git.code.sf.net/p/flightgear/fgdata</span><br><span class="line">Cloning into &apos;fgdata&apos;...</span><br><span class="line">remote: Counting objects: 61455, done.</span><br><span class="line">remote: Compressing objects: 100% (27321/27321), done.</span><br><span class="line">error: RPC failed; curl 56 GnuTLS recv error (-110): The TLS connection was non-properly terminated.</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure><p>经多种方案尝试，使用如下方法可避免该问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git://git.code.sf.net/p/flightgear/fgdata</span><br></pre></td></tr></table></figure></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://forum.flightgear.org/viewtopic.php?f=20&amp;t=33620&amp;p=329768&amp;hilit=clone+fgdata+fail#p329768" target="_blank" rel="noopener">FGdata downloading error</a>,by flightgear forum.</li><li><a href="https://sourceforge.net/p/forge/documentation/Git/#anonymous-access-read-only" target="_blank" rel="noopener">SourceForge Support</a>,by sourceforge.</li><li><a href="https://www.aneasystone.com/archives/2015/08/git-clone-faster.html" target="_blank" rel="noopener">git clone 太慢怎么办？</a>, by aneasystone.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SourceForge.net，又称SF.net，是开源软件的开发者进行开发管理的集中式场所，也是全球最大开源软件开发平台和仓库。FlightGear的源代码就托管在该平台。最近在使用Git克隆FlightGear的子项目fgdata时，老是到1G时失败。具体情况如下：&lt;/
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="git" scheme="https://huangwang.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Flightgear在Linux/Debian中的下载编译安装教程</title>
    <link href="https://huangwang.github.io/2019/03/08/Flightgear%E5%9C%A8Linux-Debian%E4%B8%AD%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>https://huangwang.github.io/2019/03/08/Flightgear在Linux-Debian中的下载编译安装教程/</id>
    <published>2019-03-08T02:29:59.000Z</published>
    <updated>2019-03-13T07:50:03.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><p>使用如下脚本在Linux/Debian操作系统下从源代码构建开源飞行模拟器FlightGear.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd  &lt;your working directory for building FlightGear&gt;</span><br><span class="line">wget -O download_and_compile.sh  http://sourceforge.net/p/flightgear/fgmeta/ci/next/tree/download_and_compile.sh?format=raw</span><br><span class="line">chmod +x download_and_compile.sh</span><br><span class="line">mkdir -p stable</span><br><span class="line">mkdir -p next</span><br><span class="line">cd stable</span><br><span class="line">../download_and_compile.sh -s</span><br><span class="line">cd ../next</span><br><span class="line">../download_and_compile.sh -p n</span><br></pre></td></tr></table></figure></p><p>需要注意的是，该脚本git clone fgdata时超过1G时就会报错退出，解决方案见链接4。</p><p>此外，如果之前安装过FlightGear的旧版本，编译过程也有可能报错，清理之前旧版本之后即可解决问题。</p><h1 id="启动模拟器"><a href="#启动模拟器" class="headerlink" title="启动模拟器"></a>启动模拟器</h1><p>启动FlightGear命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;your working directory for building FlightGear&gt;</span><br><span class="line">cd stable</span><br><span class="line">./run_fgfs.sh</span><br></pre></td></tr></table></figure></p><h1 id="fgfs常用选项"><a href="#fgfs常用选项" class="headerlink" title="fgfs常用选项"></a>fgfs常用选项</h1><p>fgfs为flightgear的飞行模拟器主程序，在命令行中输入fgfs —launcher即可打开启动器，选择飞机、位置等配置，然后开始模拟飞行。下面介绍fgfs的一些常用选项。</p><ul><li><p>—launcher</p><p>  打开启动器。</p></li><li><p>—fg-root=path</p><p>  告诉flightgear到path下寻找数据文件，如飞机、地景等。</p></li><li><p>—fg-scenery=path</p><p>  告诉flightgear到path下寻找地景文件。</p></li><li><p>—fg-aircraft=path</p><p>  告诉flightgear到path下寻找飞机文件。</p></li><li><p>—language=code</p><p>  指定会话语音， 例如 pl, nl, it, fr, en, de。</p></li><li><p>—aircraft= 飞行器</p><p>  载入特定飞行器。</p></li><li><p>—show-aircraft</p><p>  打印可用的飞行器列表。</p></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://wiki.flightgear.org/Howto:Get_Local_Copies_of_Flightgear_Source_Code" target="_blank" rel="noopener">Howto:Get Local Copies of Flightgear Source Code</a>,by flightgear wiki.</li><li><a href="http://wiki.flightgear.org/Scripted_Compilation_on_Linux_Debian/Ubuntu" target="_blank" rel="noopener">Scripted Compilation on Linux Debian/Ubuntu</a>, by flightgear wiki.</li><li><a href="http://wiki.flightgear.org/Building_FlightGear" target="_blank" rel="noopener">Building FlightGear</a>,by flightgear wiki.</li><li><a href="https://huangwang.github.io/2019/03/09/Git-Clone大项目超过1G失败解决方案/">Git_Clone大项目超过1G失败解决方案</a>,by jack huang.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编译安装&quot;&gt;&lt;a href=&quot;#编译安装&quot; class=&quot;headerlink&quot; title=&quot;编译安装&quot;&gt;&lt;/a&gt;编译安装&lt;/h1&gt;&lt;p&gt;使用如下脚本在Linux/Debian操作系统下从源代码构建开源飞行模拟器FlightGear.&lt;br&gt;&lt;figure cl
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="3D" scheme="https://huangwang.github.io/tags/3D/"/>
    
      <category term="计算机仿真" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>博弈论简介</title>
    <link href="https://huangwang.github.io/2019/02/26/%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%AE%80%E4%BB%8B/"/>
    <id>https://huangwang.github.io/2019/02/26/博弈论简介/</id>
    <published>2019-02-26T02:37:31.000Z</published>
    <updated>2019-02-26T04:35:57.635Z</updated>
    
    <content type="html"><![CDATA[<p>博弈论（英语：game theory），又译为对策论，经济学的一个分支，1944年冯·诺伊曼与奥斯卡·摩根斯特恩合著《博弈论与经济行为》，标志着现代系统博弈理论的的初步形成，因此他被称为“博弈论之父”。博弈论被认为是20世纪经济学最伟大的成果之一。目前在生物学、经济学、国际关系、计算机科学、政治学、军事战略和其他很多学科都有广泛的应用。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。表面上不同的相互作用可能表现出相似的激励结构（incentive structure），所以它们是同一个游戏的特例。其中一个有名有趣的应用例子是囚徒困境。</p><p>具有竞争或对抗性质的行为称为博弈行为。在这类行为中，参加斗争或竞争的各方各自具有不同的目标或利益。为了达到各自的目标和利益，各方必须考虑对手的各种可能的行动方案，并力图选取对自己最为有利或最为合理的方案。比如日常生活中的下棋，打牌等。博弈论就是研究博弈行为中斗争各方是否存在着最合理的行为方案，以及如何找到这个合理的行为方案的数学理论和方法。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p></p><p align="center">    <img src="images/game_theory.png" width="100%" alt="博弈论知识结构"></p><p></p><center>图1 博弈论知识结构</center><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><ul><li><p>局中人（players）：在一场竞赛或博弈中，每一个有决策权的参与者成为一个局中人。只有两个局中人的博弈现象称为“两人博弈”，而多于两个局中人的博弈称为 “多人博弈”。</p></li><li><p>策略（strategies）：一局博弈中，每个局中人都有选择实际可行的完整的行动方案，即方案不是某阶段的行动方案，而是指导整个行动的一个方案，一个局中人的一个可行的自始至终全局筹划的一个行动方案，称为这个局中人的一个策略。如果在一个博弈中局中人都总共有有限个策略，则称为“有限博弈”，否则称为“无限博弈”。</p></li><li><p>得失（payoffs）：一局博弈结局时的结果称为得失。每个局中人在一局博弈结束时的得失，不仅与该局中人自身所选择的策略有关，而且与全局中人所取定的一组策略有关。所以，一局博弈结束时每个局中人的“得失”是全体局中人所取定的一组策略的函数，通常称为支付（payoff）函数。</p></li><li><p>次序（orders）：各博弈方的决策有先后之分，且一个博弈方要作不止一次的决策选择，就出现了次序问题；其他要素相同次序不同，博弈就不同。</p></li><li><p>博弈涉及到均衡：均衡是平衡的意思，在经济学中，均衡意即相关量处于稳定值。在供求关系中，某一商品市场如果在某一价格下，想以此价格买此商品的人均能买到，而想卖的人均能卖出，此时我们就说，该商品的供求达到了均衡。所谓纳什均衡，它是一稳定的博弈结果。</p></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zh.wikipedia.org/wiki/博弈论" target="_blank" rel="noopener">博弈论</a>,by wikipedia.</li><li><a href="https://wiki.mbalib.com/wiki/博弈论" target="_blank" rel="noopener">博弈论</a>, by 智库百科.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博弈论（英语：game theory），又译为对策论，经济学的一个分支，1944年冯·诺伊曼与奥斯卡·摩根斯特恩合著《博弈论与经济行为》，标志着现代系统博弈理论的的初步形成，因此他被称为“博弈论之父”。博弈论被认为是20世纪经济学最伟大的成果之一。目前在生物学、经济学、国际
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="博弈论" scheme="https://huangwang.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux代理工具简介</title>
    <link href="https://huangwang.github.io/2019/02/23/Linux%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%AE%80%E4%BB%8B/"/>
    <id>https://huangwang.github.io/2019/02/23/Linux代理工具简介/</id>
    <published>2019-02-23T08:32:06.000Z</published>
    <updated>2019-02-23T08:50:58.113Z</updated>
    
    <content type="html"><![CDATA[<p>下面介绍两个Linux代理工具shadowsock和proxychains。</p><h1 id="shadowsock"><a href="#shadowsock" class="headerlink" title="shadowsock"></a>shadowsock</h1><p>Shadowsocks可以指一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。当前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。<strong>Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装方法</span><br><span class="line">sudo apt-get install shadowsocks</span><br><span class="line"># 使用方法</span><br><span class="line">nohup /usr/bin/sslocal -c /etc/shadowsocks/server.json</span><br></pre></td></tr></table></figure><h1 id="proxychains"><a href="#proxychains" class="headerlink" title="proxychains"></a>proxychains</h1><p>ProxyChains是一个开源代理工具，能够强制使任何应用的TCP连接使用SOCKS4,SOCKS或者HTTP(S)代理进行连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装配置</span><br><span class="line">sudo apt install proxychains</span><br><span class="line">sudo gedit /etc/proxychains.conf</span><br><span class="line">socks5 127.0.0.1 1080</span><br><span class="line"># 使用方法</span><br><span class="line">proxychains firefoxt</span><br><span class="line">proxychains aria2c</span><br><span class="line">proxychains wget</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zh.wikipedia.org/wiki/Shadowsocks" target="_blank" rel="noopener">Shadowsocks</a>,by wikipedia.</li><li><a href="https://zh.wikipedia.org/wiki/SOCKS" target="_blank" rel="noopener">SOCKS</a>,by wikipedia.</li><li><a href="https://linux.cn/article-6836-1.html" target="_blank" rel="noopener">将 Tor socks 转换成 http 代理</a>,by linux 中国.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面介绍两个Linux代理工具shadowsock和proxychains。&lt;/p&gt;
&lt;h1 id=&quot;shadowsock&quot;&gt;&lt;a href=&quot;#shadowsock&quot; class=&quot;headerlink&quot; title=&quot;shadowsock&quot;&gt;&lt;/a&gt;shadowsock
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="linux" scheme="https://huangwang.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统的CAP理论简介</title>
    <link href="https://huangwang.github.io/2019/02/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84CAP%E7%90%86%E8%AE%BA%E7%AE%80%E4%BB%8B/"/>
    <id>https://huangwang.github.io/2019/02/17/分布式系统的CAP理论简介/</id>
    <published>2019-02-17T02:25:41.000Z</published>
    <updated>2019-02-17T13:01:50.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式系统定义"><a href="#分布式系统定义" class="headerlink" title="分布式系统定义"></a>分布式系统定义</h1><blockquote><p>分布式系统是其组件分布正在连网的计算机上，组件之间通过传递消息进行通信和动作协调的系统<sup>[1]</sup>。通过该定义可知，分布式系统具有以下重要特征：组件的并发性、缺乏全局时钟、组件故障的独立性。</p></blockquote><h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p><ul><li>一致性（Consistency）</li><li>可用性（Availability）</li><li>分区容错性（Partition Tolerance）</li></ul><h2 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h2><p>在分布式系统中,是指对于一组服务器,给定一组操作,我们需要一个协议使得最后它们的结果达成一致。更详细的解释就是,当其中某个服务器收到客户端的一组指令时,它必须与其它服务器交流以保证所有的服务器都是以同样的顺序收到同样的指令,这样的话所有的服务器会产生一致的结果,看起来就像是一台机器一样。</p><p>分布式系统的一致性算法分为：</p><ul><li>弱一致性（最终一致性），例如DNS域名解析。</li><li>强一致性，例如主从同步、多数派（读/写）、Paxos、Raft（multi Paxos）、ZAB（multi Paxos）。</li></ul><h2 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h2><p>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。</p><p>通常我们描述一个系统的可用性时，我们说淘宝的系统可用性可以达到5个9，意思就是说他的可用水平是99.999%，即全年停机时间不超过 $(1-0.99999)<em>365</em>24*60 = 5.256 min$ ，这是一个极高的要求。</p><h2 id="分区容错性（Partition-Tolerance）"><a href="#分区容错性（Partition-Tolerance）" class="headerlink" title="分区容错性（Partition Tolerance）"></a>分区容错性（Partition Tolerance）</h2><p>分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p><p>好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。</p><p>简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。</p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><ol><li>George Coulouris, Jean Dollimore， Tim Kindberg，Gordon Blair，金蓓弘，马应龙，等译. 分布式系统概念与设计[M].2013.</li><li><a href="https://zhuanlan.zhihu.com/p/49760579" target="_blank" rel="noopener">Zookeeper之分布式系统的一致性算法</a>, by 养兔子的大叔.</li><li><a href="https://zh.wikipedia.org/wiki/分布式计算" target="_blank" rel="noopener">分布式计算</a>,by wikipedia.</li><li><a href="https://www.hollischuang.com/archives/666" target="_blank" rel="noopener">分布式系统的CAP理论</a>,by HollisChuang.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式系统定义&quot;&gt;&lt;a href=&quot;#分布式系统定义&quot; class=&quot;headerlink&quot; title=&quot;分布式系统定义&quot;&gt;&lt;/a&gt;分布式系统定义&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;分布式系统是其组件分布正在连网的计算机上，组件之间通过传递消息进行通信和动
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="软件工程" scheme="https://huangwang.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>最优化算法之动态规划入门</title>
    <link href="https://huangwang.github.io/2019/02/10/%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwang.github.io/2019/02/10/最优化算法之动态规划入门/</id>
    <published>2019-02-10T15:15:14.000Z</published>
    <updated>2019-02-10T15:25:39.630Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划中包含三个重要子概念：</p><ul><li>最优子结构</li><li>边界</li><li>状态转移公式</li></ul><p>对有重叠子问题和最优子结构性质的问题，在建模之后，即获得其状态转移公式和边界之后，可采用下列算法求解：</p><ul><li>递归求解</li><li>备忘录算法</li><li>动态规划求解</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zh.wikipedia.org/wiki/动态规划" target="_blank" rel="noopener">动态规划</a>,by wikipedia.</li><li><a href="https://zhuanlan.zhihu.com/p/31628866" target="_blank" rel="noopener">漫画：什么是动态规划？</a>,by 程序员小灰.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。&lt;/p&gt;
&lt;p&gt;动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="机器学习" scheme="https://huangwang.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
