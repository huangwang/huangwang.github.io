<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TL-WR703N版本v1.7刷openwrt教程]]></title>
    <url>%2F2018%2F12%2F31%2FTL-WR703N%E7%89%88%E6%9C%ACv1-7%E5%88%B7openwrt%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[我的TL-WR703N路由器运行不稳定，就准备尝试刷最新的OpenWRT，看看能否好一点。 背景123curl -o - -b &quot;subType=pcSub; Authorization=Basic%20YWRtaW46cmVkaGF0MTIz; ChgPwdSubTag=true&quot; &quot;http://192.168.1.1/&quot;curl -o - -b &apos;subType=pcSub; Authorization=Basic%20YWRtaW46cmVkaGF0MTIz; ChgPwdSubTag=&apos; --referer &apos;http://192.168.1.1/userRpm/ParentCtrlRpm.htm&apos; &apos;http://192.168.1.1/userRpm/ParentCtrlRpm.htm?ctrl_enable=1&amp;parent_mac_addr=00-00-00-00-00-02&amp;Page=1&apos;curl -o - -b &apos;subType=pcSub; Authorization=Basic%20YWRtaW46cmVkaGF0MTIz; ChgPwdSubTag=&apos; --referer &apos;http://192.168.1.1/userRpm/ParentCtrlRpm.htm?Modify=0&amp;Page=1&apos; &apos;http://192.168.1.1/userRpm/ParentCtrlRpm.htm?child_mac=00-00-00-00-00-01&amp;lan_lists=888&amp;url_comment=test&amp;url_0=;cd%20/tmp;&amp;url_1=;tftp%20-gl%20aa%20192.168.1.101;&amp;url_2=;sh%20aa;&amp;url_3=&amp;url_4=&amp;url_5=&amp;url_6=&amp;url_7=&amp;scheds_lists=255&amp;enable=1&amp;Changed=1&amp;SelIndex=0&amp;Page=1&amp;rule_mode=0&amp;Save=%B1%A3+%B4%E6&apos; 参考链接 给 v1.7 版本的 TL-WR703N 刷 openwrt,by Cubic Zone. TL-WR703N v1.7刷openwrt,by 梦里茶.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian安装配置使用TFTP]]></title>
    <url>%2F2018%2F12%2F30%2FDebian%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8TFTP%2F</url>
    <content type="text"><![CDATA[简单文件传输协议也称小型文件传输协议（Trivial File Transfer Protocol, TFTP），是一种简化的文件传输协议（FTP），通过少量存储器就能轻松实现。 TFTP技术信息小型文件传输协议的一些详细资料： 使用UDP（端口69）作为其传输协议（不像FTP使用TCP端口21）。 不能列出目录内容。 无验证或加密机制。 被用于在远程服务器上读取或写入文件。 支持三种不同的传输模式：”netascii”,”octet”和”mail”，前两种匹配FTP协议中的”ASCII”和”image（binary）”模式；第三种从来很少使用，当前已经废弃。 TFTP安装安装TFTP的客户端和服务器端：1sudo apt-get install atftp atftpd TFTP配置 创建TFTP服务器目录 123sudo mkdir /tftpbootsudo chmod 777 /tftpbootsudo chmod 777 /tftpboot/* 编辑TFTP配置文件 12345sudo gedit /etc/default/atftpd# 修改内容如下，主要是修改目录USE_INETD=falseOPTIONS=&quot;--daemon --port 69 --retry-timeout 5 --mcast-port 1758 --mcast-addr 239.239.239.0-255 --mcast-ttl 1 --maxthread 100 --verbose=5 /tftpboot&quot; 重启TFTP守护程序 1sudo /etc/init.d/atftpd restart TFTP测试123456789~$ sudo tftp 192.168.43.116tftp&gt; statusConnected to 192.168.43.116.Mode: netascii Verbose: off Tracing: offRexmt-interval: 5 seconds, Max-timeout: 25 secondstftp&gt; get iproad.txtReceived 959 bytes in 0.0 secondstftp&gt; put upload.txtSent 13 bytes in 0.0 seconds 参考链接 TFTP,by wikipedia. Using TFTP to Install Malicious Software on the Target,by kail forum.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Linux</tag>
        <tag>计算机安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium中3D模型的驱动方法]]></title>
    <url>%2F2018%2F12%2F26%2FCesium%E4%B8%AD3D%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%A9%B1%E5%8A%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Cesium中3D模型的运动可以使用CZML直接驱动，但使用该方法前提是能事先计算出3D模型的运动轨迹，具有很大的局限性。那么如何实时驱动3D模型呢？ Cesium渲染过程分析Cesium渲染过程的分析可以参考链接1。Cesium的渲染始于虚拟地球组件CesiumWidget的startRenderLoop方法，在该方法中将调用requestAnimationFrame函数开始渲染。 虚拟地球组件CesiumWidget包含Scene组件，在其render方法随后调用Scene的render方法。在场景组件Scene的render方法中提供了preUpdate、postUpdate、preRender、postRender四个事件对象，这四个事件对象将是我们实时驱动3D模型的关键。 preUpdate事件在Cesium更新渲染周期开始之前以目标帧率触发preUpdate事件。 123456scene.postUpdate.addEventListener(function() &#123; // This code will run at 60 FPS if (changeToPromptRender) &#123; scene.requestRender(); &#125;&#125;); postUpdate事件在场景更新之后，新帧渲染之前以目标帧率触发postUpdate事件。 preRender事件在场景更新之后，新帧渲染之前触发preRender事件。 1234scene.preRender.addEventListener(function() &#123; // This code will run when a new frame is rendered // including when changeToPromptRender is true&#125;); postRender事件在新帧渲染之后触发postRender事件。 实时驱动3D模型从上一节对Cesium渲染过程分析可知，要实时驱动3D模型，应订阅场景Scene的preUpdate事件，在preUpdate事件的处理函数中改变3D模型的位置和姿态。 订阅preUpdate事件123456789101112131415//订阅场景的preUpdate事件viewer.scene.preUpdate.addEventListener(function(scene, time) &#123; speedVector = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.UNIT_X, speed / 10, speedVector); position = Cesium.Matrix4.multiplyByPoint(planePrimitive.modelMatrix, speedVector, position); pathPosition.addSample(Cesium.JulianDate.now(), position); Cesium.Transforms.headingPitchRollToFixedFrame(position, hpRoll, Cesium.Ellipsoid.WGS84, fixedFrameTransform, planePrimitive.modelMatrix); if (fromBehind.checked) &#123; // Zoom to model Cesium.Matrix4.multiplyByPoint(planePrimitive.modelMatrix, planePrimitive.boundingSphere.center, center); hpRange.heading = hpRoll.heading; hpRange.pitch = hpRoll.pitch; camera.lookAt(center, hpRange); &#125;&#125;); 获取czml实体的参数1234567891011121314151617viewer.scene.preUpdate.addEventListener(function(scene, time) &#123; //target是czml实体对象 //获取time时刻target的位置参数 target.position.getValue(time,position) console.log(position) target.orientation.getValue(time,orientation) console.log(orientation)&#125;);viewer.scene.preUpdate.addEventListener(function(scene, time) &#123; var pos=target.position.getValue(time) console.log(pos.toString()) //世界坐标转经纬高 var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(pos); console.log(cartographicPosition.toString())&#125;); 使用Entity API加载3D模型1234567891011121314151617var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;);var center=Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706,100);var hpr=Cesium.HeadingPitchRoll.fromDegrees(90,-90,0);//从headingPitchRoll转四元数var quatern=Cesium.Transforms.headingPitchRollQuaternion(center,hpr);var entity = viewer.entities.add(&#123; position :center , orientation:quatern , model : &#123; uri : &apos;../../../../Apps/SampleData/models/missile.glb&apos;, scale: 0.1, minimumPixelSize:50, maximumScale:5000 &#125;&#125;);viewer.trackedEntity = entity; 使用Primitive API加载3d模型123456789101112var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;);var center1=Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706,100);var hpr1=Cesium.HeadingPitchRoll.fromDegrees(90,-90,100);//计算模式矩阵，实现本地坐标系坐标到世界坐标系坐标的转换var modelMatrix=Cesium.Transforms.headingPitchRollToFixedFrame(center1, hpr1)var model = viewer.scene.primitives.add(Cesium.Model.fromGltf(&#123; url : &apos;../../../../Apps/SampleData/models/missile.glb&apos;, modelMatrix : modelMatrix, scale : 1.0&#125;)); 参考链接 Cesium摄像头跟踪飞机实体时晃动问题分析,by jack huang. Improving Performance with Explicit Rendering, by Gabby Getz.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络安全攻防技术探讨]]></title>
    <url>%2F2018%2F12%2F22%2FWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E6%8E%A2%E8%AE%A8%2F</url>
    <content type="text"><![CDATA[网络安全（英语：network security）包含网络设备安全、网络信息安全、网络软件安全。在此重点探讨网络软件安全中的Web安全。当前Web安全面临的压力越来越大，一方面是Web应用一统江湖，君临天下，另一方面针对Web应用的攻击越来越多，攻击方法越来越成熟。下面重点介绍常见的Web攻击方法。 XSSXSS (Cross Site Script，跨站脚本攻击)的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 非持久型 XSS持久型 XSSCSRFCSRF（Cross-Site Request Forgery,跨站请求伪造攻击）可以盗用你的登陆信息，以你的身份模拟发送各种请求。 SQL 注入SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。 命令行注入命令行注入漏洞，指的是攻击者能够通过 HTTP 请求直接侵入主机，执行攻击者预设的 shell 命令。 DDoS 攻击DDoS 又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量的请求造成资源过载，导致服务不可用。 网络层 DDoS应用层 DDoS流量劫持流量劫持是黑产行业的一大经济支柱。 DNS 劫持HTTP 劫持参考链接 Advanced web security topics,by George. 网络安全,by wikipedia. 常见 Web 安全攻防总结,by zoumiaojiang.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机安全</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学研究中阅读论文的方法]]></title>
    <url>%2F2018%2F12%2F20%2F%E7%A7%91%E5%AD%A6%E7%A0%94%E7%A9%B6%E4%B8%AD%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在科学研究的过程中，选题十分重要。因此在初步确定好选题方向后，应对该选题方向进行调研。调研的主要工作就是寻找该方向的论文，进行阅读、分析、总结，了解该方向的过去和现在，并预测未来可能的发展方向。对于刚上研究生的同学，该采用什么样的方法来整理选题方向上的论文，使之符合逻辑，并且条理清晰呢？偶尔拜读了Flood Sung写的文章”深度学习论文阅读路线图“，觉得深受启发，将其所提出的深度学习论文阅读路线图构建原则记录备忘一下。 路线图的构建原则有以下四个原则： 从整体到局部。即从Survey的文章，影响大局的文章到具体子问题子领域的文章。 从过去到最前沿。即每个topic的文章是按照时间顺序排列的，这样大家就可以清楚的看到这个方向的研究发展脉络。 从通用到应用。即有些深度学习的文章是面向深度学习通用理论，比如Resnet，可以用在任意的神经网络中，而有些文章则是具体应用，比如Image Caption。 面向最前沿。收集的文章会有很多是最新的，甚至就是几天前出来的，这样能保证路线图是最新的。 每一种topic只选择最有代表性的几篇文章，比如深度增强学习（Deep Reinforcement Learning），这个领域现在有几十篇文章，但只选择几篇，要深入了解甚至做为自己的研究方向，还需要进一步的阅读该领域的文章。 参考链接 深度学习论文阅读路线图 Deep Learning Papers Reading Roadmap,by Flood Sung. Deep Learning Papers Reading Roadmap,by Flood Sung.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统仿真中一些问题的思考]]></title>
    <url>%2F2018%2F12%2F18%2F%E7%B3%BB%E7%BB%9F%E4%BB%BF%E7%9C%9F%E4%B8%AD%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[系统仿真（system simulation）就是根据系统分析的目的，在分析系统各要素性质及其相互关系的基础上，建立能描述系统结构或行为过程的、且具有一定逻辑关系或数量关系的仿真模型，据此进行试验或定量分析，以获得正确决策所需的各种信息。 系统仿真与仿真游戏的区别系统仿真与仿真游戏本质上没有区别，都是计算机程序对现实的模拟，所不同的是各自对仿真保真度（Simulation Fidelity）的要求不同。 仿真保真度（Simulation Fidelity）用于描述仿真精度，模拟真实对应物有多近似： 低保真：对系统的最小模拟，接受输入产生输出 中等保真：对刺激能自动响应，有限精度 高保真：接近不可辨识或者尽可能地接近真实系统 通常系统仿真对仿真保真度的要求比仿真游戏要高。 计算步长与采样周期采用计算机进行数值模拟或系统仿真时，经常需要采用数值解法求解模型方程。系统模型一般采用微分方程描述（也有其它形式），采用数值方法求解，就是采用迭代法逐步逼近。 计算步长积分与微分是互逆。对一个曲线（包括直线）方程求积分，其实就是求曲线与横轴围成的面积。该面积可以用一系列间隔很小的面积块相加得到。这些小间隔的宽度就是计算步长。显然，纯粹从精度的角度考虑，步长越小越精确，因为近似面积更接近实际图形面积。 采样周期采样周期是对一个实际信号测量时，相邻两次测量之间的时间间隔。有时候，采样周期和计算步长相似，但采样周期要考虑实际限制，且是时间单位，而计算步长不一定是时间单位，且相对自由些。两者在数值上没必然联系。对于同一问题，且都是时间量纲的话，采样周期大于等于计算步长，前者是后者的整数倍。 系统仿真包含系统模型求解，也就是在每个采样周期内，要解出模型方程。控制系统仿真时在采样周期内要解出两个模型方程：控制器模型和系统模型。 一个采样周期内可对系统模型迭代求解一次或多次。 计算步长和采样周期大小的选择关于采样周期和计算步长的选择，一般考虑以下因素： 从求解精度考虑，越小越好。 从计算量考虑，越大越好。 采样周期与每秒帧数(Frames Per Second，FPS)采样周期以秒为单位，则 FPS=\frac{1}{采样周期}FPS是指每秒画面重绘的次数，用于衡量画面切换速度。FPS越大，则动画效果越平滑，当FPS小于20时，一般就能明显感受到画面的卡滞现象。 当FPS足够大(比如达到60)，再增加帧数人眼也不会感受到明显的变化，反而相应地就要消耗更多资源(比如电影的胶片就需要更长了，或是电脑刷新画面需要消耗计算资源等等)。因此，选择一个适中的FPS即可。 NTSC标准的电视FPS是30，PAL标准的电视FPS是25，电影的FPS标准为24。 WebGL动画WebGL是一种JavaScript API，用于在不使用插件的情况下在任何兼容的网页浏览器中呈现交互式2D和3D图形。但要产生WebGL动画，需要对运动的场景不停的采样，即不停地拍照。JavaScript的采样函数主要有setInterval方法和requestAnimationFrame方法。 setInterval方法 如果要设置特定的FPS(虽然严格来说，即使使用这种方法，JavaScript也不能保证帧数精确性)，可以使用JavaScript DOM定义的方法： 1setInterval(fn,mesc) 其中，fn是每过msec毫秒执行的函数，如果将fn定义为重绘画面的函数，就能实现动画效果。setInterval函数返回一个变量timer，如果需要停止重绘，需要使用clearInterval方法，并传入该变量timer。 requestAnimationFrame方法 大多数时候，我们并不在意多久重绘一次，这时候就适合用requestAnimationFrame方法了。它告诉浏览器在合适的时候调用指定函数，通常可能达到60FPS。 requestAnimationFrame同样有对应的cancelAnimationFrame取消动画 和setInterval不同的是，由于requestAnimationFrame只请求一帧画面，因此，除了在init函数中需要调用，在被其调用的函数中需要再次调用requestAnimationFrame 使用stat.js记录FPSstat.js是Three.js的作者Mr.Doob的另一个有用的JavaScript库。很多情况下，我们希望知道实时的FPS信息，从而更好地监测动画效果。这时候，stat.js就能提供一个很好的帮助，它占据屏幕中的一小块位置(如左上角)，显示实时的FPS信息。 在HTML中引用stat.js:1&lt;script type=&quot;text/javascript&quot; src=&quot;//mrdoob.github.io/stats.js/build/stats.min.js&quot;&gt;&lt;/script&gt; 再使用如下代码监视实时FPS：1234567891011121314151617var stats = new Stats();stats.showPanel( 1 ); // 0: fps, 1: ms, 2: mb, 3+: customdocument.body.appendChild( stats.dom );function animate() &#123; stats.begin(); // monitored code goes here stats.end(); requestAnimationFrame( animate );&#125;requestAnimationFrame( animate ); 参考链接 计算步长和采样周期,by 王永林. 离散和连续模拟之间的实际区别是什么？,by UF Game. 系统仿真,by 百度百科. 开源的物理引擎,by M. Jones. 数值分析,by wikipedia. three.js 入门详解(二),by Levi. WebGL,by wikipedia. stats.js, by mydoob. 详解JavaScript中的Event Loop（事件循环）机制,by 暮雨清秋.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
        <tag>WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[撰写学术论文的思考]]></title>
    <url>%2F2018%2F12%2F17%2F%E6%92%B0%E5%86%99%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[迫于学业和工作的压力，撰写了不少的学术论文。但是并没有对如何撰写学术论文进行思考。看到清华大学的肖寒博士在某个问题下的回答后，感觉茅塞顿开： 不过，一般注水的作者相对而言都是新手，因为比较有经验的研究者都知道：“论文的一切都在于贡献，不在于结果” 你的结果只是一个说明你贡献的例证，多那么点少那么点，大家看了毫无区别。你注水除了恶心我们这些后来实验的人，就没什么别的用处了。有那些疯狂调参和使劲弄技巧的时间，真不如拿来整理好你自己的思路，把论文的论述过程做到有理有据！因为 80.2 和 80.3 正常人都没法记住其间区别，但你循循善诱的精致论述会让所有人印象深刻。我希望新手不要本末倒置！ 论文重在贡献，迫于学业和工作的压力造的注水论文实在无趣！ 参考链接 看图说话的AI小朋友——图像标注趣谈（下）, by 杜客.]]></content>
      <tags>
        <tag>科研</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node-gyp使用帮助]]></title>
    <url>%2F2018%2F12%2F16%2Fnode-gyp%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[node-gyp是为了编译nodejs addon模块而构建的跨平台命令行工具。nodejs addon模块使用c++语言编写，在源代码级别进行分发，通过node-gyp实现跨平台的编译安装。 背景知识node-gyp源于gyp。gyp是一个用来生成项目文件的工具，刚开始设计给chromium项目使用的。它可以从平台无关的配置生成平台相关的Visual Studio、Xcode、Makefile的项目文件，然后调用 vsbuild、xcode、gcc等编译平台来编译。这就不需要花额外的时间处理每个平台不同的项目配置以及项目之间的依赖关系。 nodejs addon模块采用源代码分发，安装需要根据不同平台采用合适的编译器编译安装，这就是node-gyp项目诞生的原由。 安装过程安装node-gyp在上线情况下，使用如下命令安装node-gyp：1$ npm install -g node-gyp 安装C++编译器根据操作系统平台的不同，需安装对应的编译器，以方便node-gyp调用。以Windows平台为例，安装VC++编译器有两种方法： 直接安装 123# 以管理员身份打开cmd或powershellnpm install --global --production windows-build-tools 手动安装 安装Visual C++构建环境： 使用Visual Studio Build Tools的Visual C++ build tools工作负载或者Visual Studio 2017 Community的Desktop development with C++工作负载。 安装Python 2.7，不支持python3，然后运行npm config set python python2.7 在cmd中运行npm config set msvs_version 2017 手动安装Visual C++构建环境的命令如下：1234567# 使用Visual Studio Build Tools的Visual C++ build tools工作负载，确保安装win10sdk，编译nodejs源码时需要.\vs_buildtools__2041717674.1536666005.exe --layout d:\vc2017_offline --lang zh-CN --add Microsoft.VisualStudio.Workload.MSBuildTools --add Microsoft.VisualStudio.Workload.VCTools --includeRecommended# 使用Visual Studio 2017 Community的Desktop development with C++工作负载.\vs_community__208176120.1522073957.exe --layout e:\vs2017_offline --lang zh-CN --add Microsoft.VisualStudio.Workload.CoreEditor --add Microsoft.VisualStudio.Workload.NativeDesktop --includeRecommended node-gyp编译测试以在Win10平台编译nodejs addon模块为例，在离线情况使用如下命令测试node-gyp是否工作正常：123node-gyp configure --nodedir=d:\node-v8.11.3node-gyp build 参考链接 node-gyp的作用是什么?,by zhihu. node-gyp, by nodejs Windows-Build-Tools, by felixrieseberg.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派使用lirc进行红外遥控测试]]></title>
    <url>%2F2018%2F12%2F15%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8lirc%E8%BF%9B%E8%A1%8C%E7%BA%A2%E5%A4%96%E9%81%A5%E6%8E%A7%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[在树莓派上使用lirc进行红外遥控测试的步骤比较繁琐，记录一下以备忘。 背景知识lirc库LIRC (Linux Infrared remote control,Linux红外线遥控)是一个开放源代码的包。这个包可以让你的Linux系统能够接收及发送红外线信号。 Microsoft Windows上有个功能相同的软件叫WinLIRC。 利用LIRC和红外线接收器，你就几乎可以用所有的红外线遥控器（例如：电视遥控器）来控制你的计算机。举例来说，你可以用遥控器来控制DVD或音乐的播放。 lirc配置文件说明 /etc/lirc/lircd.conf为遥控器配置文件 /etc/lirc/lircmd.conf为lircmd配置文件，后者可以将遥控器用作鼠标。 /etc/lirc/lircrc为irexec配置文件，后者可以在收到遥控器信号号运行设定的程序。 制作遥控器配置文件使用irrecord命令制作遥控器配置文件lircd.conf。12345# 首先停止lirc服务sudo service lirc stop# 制作遥控器配置文件irrecord -d /dev/lirc0 &lt;model&gt;.conf 测试过程硬件 树莓派3B+ 红外接收器 红外遥控器 杜邦线 接线红外接收器都有三个引脚：VCC、GND、Data。其中：VCC：连接5V的引脚GND：连接接地的引脚Data：连接GPIO23 lirc配置 安装lirc: 1sudo apt-get install lirc -y 修改/etc/modules 123456789# /etc/modules: kernel modules to load at boot time.## This file contains the names of kernel modules that should be loaded# at boot time, one per line. Lines beginning with &quot;#&quot; are ignored.i2c-dev# 添加如下代码lirc_devlirc_rpi gpio_in_pin=23 gpio_out_pin=22 修改/etc/lirc/lirc_options.conf 123# 修改如下两项driver = default device = /dev/lirc0 修改/boot/config.txt在/boot/config.txt文件中找到#dtoverlay=lirc-rpi，将其修改如下： 1dtoverlay=lirc-rpi:gpio_in_pin=23,gpio_out_pin=22 重启测试 1234sudo init 6# 查看lirc是否加载成功lsmod | grep lircls /dev/lirc0 参考链接 LIRC,by wikipedia. 树莓派—-红外遥控设置,by 逍遥游. 配置树莓派上的lirc(Raspbian, 2016) ,by Cnly.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[飞行力学中坐标系定义]]></title>
    <url>%2F2018%2F12%2F10%2F%E9%A3%9E%E8%A1%8C%E5%8A%9B%E5%AD%A6%E4%B8%AD%E5%9D%90%E6%A0%87%E7%B3%BB%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[建立飞机的运动学模型的前提是建立合适的坐标系，在此基础上才能定义各种参数描述飞机的状态。下面介绍常用的坐标系及常用描述飞机状态的参数。 常用坐标系地面固定坐标轴系($AX_gY_gZ_g$)将地球视为椭球体，则地面固定坐标轴系定义为： 以椭球面上一点为坐标系原点$A$，$Z_g$轴与椭球法线重合，向下为正，$X_g$与$Y_g$轴位于过坐标原地的椭球切平面上,按右手法则建立，$X_g$轴与椭球短半轴重合（北向），$Y_g$轴与地球椭球的长半轴重合（东向）。 在研究坐标转换关系时，常使用飞机牵连铅垂地面固定坐标系$OX_gY_gZ_g$。其原点$O$位于飞机质心，三坐标轴平行于地面固定坐标轴系$AX_gY_gZ_g$的各个轴。飞机姿态——偏航、俯仰、滚转的定义即与飞机牵连铅垂地面固定坐标系有关。 机体坐标系(体轴系$OXYZ$)机体坐标系定义为： 原点$O$位于质心，$O_X$平行于机身轴线或对称面机翼弦线指向前方（机头方向）；$O_Y$垂直于对称面指向右翼；$O_Z$在飞机对称面内，垂直于$O_X$指向下方。符合右手系建立规定。 图1 飞机牵连铅垂地面固定坐标系（OXgYgZg）与体轴系（OXYZ） 航迹坐标系($OX_kY_kZ_k$)航迹坐标系定义： 原点$O$位于飞机质心，$OX_k$沿飞机速度方向；$OZ_k$在$OX_k$所在铅垂平面内，垂直于$OX_k$指向下方；$OY_k$垂直于$OX_k$、$OZ_k$ 所在平面指向右方；符合右手系建立规定。 图2 航迹坐标系（OXkYkZk） 气流坐标轴系(风轴系$OX_aY_aZ_a$)气流坐标轴系又称速度坐标轴系，定义为： 原点$O$位于飞机质心，$OX_a$沿飞机速度方向；$OZ_a$在飞机对称面内，垂直于$OX_a$指向下方；$OY_a$垂直于$OX_a$、$OZ_a$ 所在平面指向右方；符合右手系建立规定。 气动力三个分量（升力、阻力、侧力）是根据风轴系定义的，其中升力与阻力分别沿$OZ_a$、$OX_a$的负向。 半机体坐标系($OX_iY_iZ_i$)半机体坐标系定义为： 原点$O$位于质心，$OX_i$沿飞机速度向飞机对称面内投影方向；$OZ_i$在飞机对称面内，垂直于$OX_i$指向下方；$OY_i$垂直于$OX_i$、$OZ_i$ 所在平面指向右方；符合右手系建立规定。 图3 风轴系（OXaYaZa）与半机体坐标系（OXiYiZi） 稳定性坐标系($OX_sY_sZ_s$)稳定性坐标系定义为： 原点$O$位于质心，$OX_s$沿未受扰动的速度在对称面内的投影方向；$OY_s$在飞机对称面内，指向右；$OZ_s$对称平面内垂直于$OX_s$向下；符合右手系建立规定。 图4 稳定性坐标系（OXsYsZs） 常用飞参 机体坐标系相对于飞机牵连铅垂地面固定坐标系的夹角 偏航角：机体坐标系$x$轴在水平面内投影与$x_g$的夹角，以$\psi$表示 俯仰角：机体坐标系$x$轴与水平面的夹角，以$\theta$表示 滚转角：过机体坐标系$x$轴的铅垂面与机体坐标系$z$轴的夹角，以$\phi$表示 飞行速度矢量相对于体轴系的夹角 迎角：速度矢量在飞机纵向对称面内投影与机体坐标系$x$轴夹角，以$\alpha$表示 侧滑角：速度矢量与飞机纵向对称面的夹角，以$\beta$表示 飞行速度矢量相对于地面的夹角 爬升角：速度与地面水平面夹角，以$\gamma$表示 航迹方位角：速度在地面水平面的投影与$x_g$夹角，以$\chi$表示 参考链接 无人机飞控通俗演义之 纷繁复杂的飞行力学, by 量子黑洞. 一起写飞行仿真之 六自由度动力学方程, by 量子黑洞. 飞行器飞行动力学（二）坐标系与夹角们, by 萝卜. Cesium中飞行器姿态控制,by jack huang. MathJax 支持的 Latex 符号总结(希腊字母和希伯来字母),by liyuanbhu 空间中三维矢量,by tina_ttl.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>飞行力学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian系统安装NVIDIA驱动支持双显卡切换]]></title>
    <url>%2F2018%2F12%2F10%2FDebian%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85NVIDIA%E9%A9%B1%E5%8A%A8%E6%94%AF%E6%8C%81%E5%8F%8C%E6%98%BE%E5%8D%A1%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[购买笔记本拥有Intel集成显卡和NVIDIA显卡，如何在Debian Linux下启用NVIDIA显卡是一个难题。幸运的是，通过bumblebee软件可在Linux下支持NVIDIA Optimus技术，实现Intel集成显卡和NVIDIA显卡之间的切换使用。 背景知识NVIDIA OptimusOptimus是NVIDIA针对笔记本电脑的显示切换技术。它可以实现笔记本电脑中独立显卡与主板内置显卡之间无缝、自动、实时的切换（用户无需重启或手动调整），从而实现能源的节约。 利用Optimus技术后，计算机的显示输出永远都只会通过集成式芯片组的显示核心。独立显卡的显示输出将会被废掉，有关的输出亦会发送到前者。由于显示输出的设备是固定的，所以黑屏现象将会被解决。额外的切换线路亦变得不需要，因为在不需要独立显示核心的时候，系统会索性断绝其电源供应。当系统的显示负载轻的时候，就会完全利用内置的显示核心。当负载增加后，系统就会打开独立显示核心作计算之用。协议分工方面由驱动程序负责，NVIDIA声称可以兼容所有的API。 BumblebeeBumblebee 致力于使 NVIDIA Optimus 在 GNU/Linux 系统上可用，实现两块不同的供电配置的显卡同时插入使用，共享同一个 framebuffer。 安装配置过程禁止加载开源驱动nouveau12345678$ vi /etc/modprobe.d/nvidia-installer-disable-nouveau.conf#上述文件不存在则新建，在文件中添加下面两行文字blacklist nouveauoptions nouveau modeset = 0#系统重启后使用以下命令查看nouveau驱动是否被禁止lsmod |grep -i nouveau 安装内核头文件1$ sudo apt-get install -y linux-headers-$(uname -r) 安装NVIDIA驱动12# 关于是否生存xorg.conf文件，选no$ sudo apt-get install nvidia-driver nvidia-xconfig nvidia-kernel-dkms 安装双显卡切换解决方案包1$ apt-get install bumblebee-nvidia primus 添加当前用户到bumblebee用户组1$ adduser $USER bumblebee 修改bumblebee配置123456789101112$ vi /etc/bumeblebee/bumblebee.conf: Driver=nvidia#将/etc/bumeblebee/bumblebee.conf文件中的Driver=* 改成 =nvidia$ vi /etc/bumblebee/xorg.conf.nvidia:BusID &quot;PCI:01:00:0&quot; #在/etc/bumblebee/xorg.conf.nvidia文件中，将Section“Device”部分添加PCI ID# 可使用如下命令查看NVIDIA显卡的BUS IDnvidia-xconfig --query-gpu-info | grep &apos;BusID : &apos; | cut -d &apos; &apos; -f6 重启进入桌面如果无法进入桌面环境，则安装失败，进入高级修复使用如下命令进行清理。1$ sudo apt-get purge nvidia* bumblebee* prime* bumblebee服务开机不会启动，设置开机启动即可。1$ update-rc.d -f bumblebee defaults 使用独显运行程序bumblebee不能做到集显和独显之间自动切换，系统运行时默认使用集显，当你需要使用独显运行某个程序或者游戏的时候，终端执行如下命令即可：12$ optirum command #使用独显运行command程序$ optirum -b primus command #使用独显运行command程序，提升性能 参考链接 kali 在支持双显卡切换机器宏碁（Acer）V3下安装NVIDIA驱动, by 不梦君. Installing-Nvidia-drivers-on-Kali-Linux, by europa502. NVIDIA Optimus, by wikipedia. 在Ubuntu上安装和配置Nvidia Optimus驱动, by Linux中国. Bumblebee),by archlinux.]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux图形界面基础知识]]></title>
    <url>%2F2018%2F12%2F09%2FLinux%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Linux初学者经常分不清楚linux和X之间，X和Xfree86之间，X和KDE，GNOME等之间是什么关系。常常混淆概念，下面以易于理解的方式解释X，X11，XFREE，WM，KDE，GNOME等之间的关系。 Linux内核没有图形用户界面与Windows操作系统内核集成图形用户界面不同，Linux内核没有图形用户界面，是一个基于命令行的操作系统。 linux和Xfree的关系就相当于当年的DOS和 WINDOWS3.0一样，windows3.0不是独立的操作系统，它只是DOS的扩充，是DOS下的应用程序级别的系统，不是独立的操作系统，同样 XFree只是linux下的一个应用程序而已。不是系统的一部分，但是X的存在可以方便用户使用电脑。 WINDOWS95及以后的版本就不一样了，他们 的图形界面是操作系统的一部分，图形界面在系统内核中就实现了，没有了图形界面windows就不成为windows了，但linux却不一样，没有图形 界面linux还是linux，很多装linux的WEB服务器就根本不装X服务器.这也WINDOWS和linux的重要区别之一。 X是协议，不是具体的某个软件X 是协议，就像HTTP协议，IP协议一样。一个基于X的应用程序需要运行并显示内容时他就联 接到X服务器，开始用X协议和服务器交谈。 比如一个X应用程序要在屏幕上输出一个圆那么他就用X协议对X服务器说：喂!我需要在屏幕上画一个圆.X应用程 序只负责告诉X服务器在屏幕的什么地方用什么颜色画一个多大的圆，而具体的”画”的动作，比如这个圆如何生成，用什么显卡的驱动程序去指挥显卡完成等等工作是由X服务器来完成的。 X服务器还负责捕捉键盘和鼠标的动作，假设X服务器捕捉到鼠标的左键被按下了，他就告诉X应用程序：亲爱的应用程序先生，我发现 鼠标被按下了，您有什么指示吗?如果X应用程序被设计成当按下鼠标左健后再在屏幕上画一个正方形的话，X应用程序就对X服务器说：请再画一个正方形，当然 他会告诉服务器在什么地方用什么颜色画多大的正方形，但不关心具体怎么画—那是服务器的事情。 XFree86和Xorg是实现X协议的服务器程序Xfree86就是这样一个去根据法规实现协议的 “交警”。他按照X协议的规定来完成X应用程序提交的在屏幕上显示的任务。当然不仅仅是某个特定的交警才可以去维护和实现这个法规，比如还可以由交通协管 员来实现交通法规，必要的时候警察也可以介入，当然前提是他们都要懂得交通法规，也就是要懂得协议。 所以实现X协议的软件也并不只有 XFree86，XFree86只是实现X协议的一个免费X服务器软件.商业上常用MOTIF，现在还有XORG，还有很多很小的由爱好者写的小的X服务器软件。 X和X11R6的关系X11R6 实际上是 X Protocol version 11 Release 6(X协议第11版第六次发行)的意思，就是说目前用的X协议是第11版的，然后经过了6次小的修正。 不同版本的X协议是不能通信的。就象我们现在IPV4和IPV6不能通信一样，不过不用担心，现在的X服务器软件和X应用程序都遵循X11R6。 X服务器和WM(window manager 窗口管理器)的关系 窗口管理器是一种X应用程序，它负责窗口最大化，最小化，移动，关闭窗口等。这些不是X服务器负责完成的。 KDE和GNOMEKDE 和GNOME是LINUX里最常用的图形界面操作环境，他们不仅仅是一个窗口管理器那么简单， KDE是K Desktop Environment 的缩写。他不仅是一个窗口管理器，还有很多配套的应用软件和方便使用的桌面环境，比如任务栏，开始菜单，桌面图标等等。 GNOME是GNU Network Object Model Environment 的缩写。和KDE一样，也是一个功能强大的综合环境。 另外在其它UNIX系统中，常常使用CDE作为这样一个环境。 其它的小型窗口管理器有: window maker，after step，blackbox，fvwm，fvwm2，等等都是常用的优秀窗口管理器。 linux图形界面层次关系总结linux本身—&gt;X服务器&lt;-[通过X协议交谈]-&gt;窗口管理器(综合桌面环境)—&gt;X应用程序。 Xfree86服务器的实现包括两个部分，一部分是和显卡直接打交道的低层，一部分是和X应用程序打交道的上层。 上层负责接收应用程序的请求和鼠标 键盘的动作。而和显卡直接打交道的底层负责指挥显卡生成图形，其实就是显卡驱动。上层接收到应用程序的请求后，将请求内容做适当处理，然后交给显卡驱动来 指挥 显卡完成画图的动作。 另外，上层的捕捉键盘和鼠标动作的部分会向应用程序提供鼠标和键盘的状态信息，应用程序接收到这些信息后决定是否再有相应的动作。 参考链接 linux图形界面基本知识(X、X11、Xfree86、Xorg、GNOME、KDE), by huang_xw.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家用电器安全使用年限与折旧]]></title>
    <url>%2F2018%2F12%2F08%2F%E5%AE%B6%E7%94%A8%E7%94%B5%E5%99%A8%E5%AE%89%E5%85%A8%E4%BD%BF%E7%94%A8%E5%B9%B4%E9%99%90%E4%B8%8E%E6%8A%98%E6%97%A7%2F</url>
    <content type="text"><![CDATA[家用电器都有一定的安全使用年限，超过安全使用年限，家用电器因产品老化将产生如下问题，造成安全隐患： 绝缘体老化，产生漏电，导致电磁污染 元器件技术指标严重下降，导致有害物质泄漏，耗电量增加 那么家用电器的安全使用年限是多少呢？购买二手家用电器时如何折旧呢？ 家用电器安全使用年限有关家电安全使用年限的标准通则早已出台，但是针对不同产品的具体年限细则却迟迟未发布。原因主要在于不同产品的使用年限评估难度较大，不同地区的使用差异性也较大，因此就目前而言国内尚无明确的家电使用年限方面的规定，国际通行年限可作参考： 电吹风：4年 电热毯：6年 电脑：6年 吸尘器：8年 煤气灶：8年 电热水器：8年 洗衣机：8年 电视：8-10年 空调：8-10年 微波炉：10年 电饭煲：10年 电风扇：10年 冰箱：12-16年 家用电器安全使用年限只是最高限定，如果在使用过程中不注意保养维护，也有可能缩减家用电器的使用寿命，这就要求用户在日常生活中需要注重维护保养，使家电处于良好的工作环境，确保家电安全“服役”。 家用电器老化特征家用电器也有各自的老化特征，当出现以下老化特征时，建议及时保养或更换： 空调：如果使用多年的空调开始出现制冷或制热变慢，噪音过大，在开机时会出现霉味且出风伴有灰尘，流出黑水，那么用户就应该考虑更换一台新空调。老旧空调此时不仅耗费更多电量，出风还会带有细菌污垢，影响身体健康。 冰箱：平时运行良好的冰箱开始出现制冷效果差，噪音过大，甚至发生轻微颤动时，说明已经老化。若继续使用，耗电量将会加大，食物的储鲜功能也会退化，有时还会出现冰箱制冷剂泄露，污染食材环境的问题。 洗衣机：洗衣机使用超龄的现象在用户中最为常见，判断它已经超龄的方式也最为简单。通常来说，洗衣机出现渗水、漏水、漏电，噪音过大，衣物清洗不净等问题都是达到使用年限的表现，严重时甚至会发生爆炸事件。 电视机：虽然各种类型的平板、投影仪的市场占有率越来越高，但电视机仍然是每个家庭不可或缺的电器之一。日常使用电视时，屏幕色彩暗淡，画面模糊抖动，除了要考虑电视自身质量问题，还要查看电视使用时长是否已经超出使用年限。超龄服役的电视机除了耗电量增加外，自燃或爆炸事故也时有发生。 热水器：热水器超出使用年限后，在运行时会出现异常声音，安全装置也会发生功能异常问题，再加上内胆中日积月累的杂质污垢，不仅会污染水质，还可能因漏电对人体造成伤害。除此之外，超龄热水器还易出现漏水、保温性差以及因内部电器元件老化导致的短路、冒烟等故障。 一旦发现家中电器存在以上类似的老化特征时，最好提前更换产品，以免带来严重后果。据媒体公开报道，每年我国因家电触电伤亡人数超过1000人，因家电引起的火灾损失更加惊人，而这其中最典型的原因就是家电超龄“使用”。 家用电器折旧家用电器折旧可简单按固定资产折旧方法中的直线法，根据家用电器安全使用年限逐年折旧。 固定资产折旧方法固定资产折旧方法（Fixed-assets Depreciation Method），指将应提折旧总额在固定资产各使用期间进行分配时所采用的具体计算方法。折旧是指固定资产由于使用而逐渐磨损所减少的那部分价值。 固定资产的损耗有两种： 有形损耗，也称作物质磨损，是由于使用而发生的机械磨损，以及由于自然力的作用所引起的自然损耗。 无形损耗，也称精神磨损，是指科学进步以及劳动生产率提高等原因而引起的固定资产价值的损失。 一般情况下，当计算固定资产折旧时，要同时考虑这两种损耗。 固定资产折旧方法可分为三类： 直线法直线法（straight-line method）根据固定资产在整个使用寿命中的磨损状态而确定的成本分配结构。直线法依据是，固定资产的使用强度比较平均，而且各期所取得的收入差距不大。在直线法下，折旧金额是时间的线性函数。 直线法折旧公式如下： 年折旧率 = （1 － 预计净残值率）÷ 预计使用寿命（年）× 100% 月折旧额 = 固定资产原价× 年折旧率 ÷ 12 其中，净残值是指预计固定资产清理报废时可收回的残值扣除清理费用后的数额。企业应根据固定资产的性质和使用方式，合理估计固定资产的净残值。 加速折旧法加速折旧法也称为快速折旧法或递减折旧法。其特点是：在固定资产有效使用年限的前期多提折旧，后期则少提折旧。从而相对加快折旧的速度，以使固定资产成本在有效使用年限中加快得到补偿。在具体实务中，加速折旧方法又包括年数总和法和双倍余额递减法两种。 年数总和法计算公式如下： 年折旧率 = 尚可使用寿命/ 预计使用寿命的年数总和 × 100 % 月折旧额 = （固定资产原价 － 预计净残值 ）× 年折旧率 ÷ 12 某设备预计使用5年，则预计使用寿命的年数总和为15（5+4+3+2+1）。第2年时尚可使用寿命为4，此年的年折旧率为4/15。 双倍余额递减法计算公式如下： 年折旧率 =2÷ 预计使用寿命（年）× 100% 月折旧额 = 固定资产净值 × 年折旧率 ÷ 12 产量法产量法（production method）根据固定资产的产出量分配其成本的方法。产量法的依据是固定资产的使用寿命主要是受其使用量影响，其合理性取决于三个条件： （1）固定资产的每期用量波动较大； （2）固定资产使用期内的产出的每期用量波动较大； （3）固定资产服务潜力的下降与其使用程序密切相关。 如果符合这三个条件，产量法是最符合配比原则的。反对产量法的人认为，估计固定资产的产出量比估计固定资产的使用年限更加困难，而且很难考虑功能损耗因素。 产量法计算公式如下： 单位工作量折旧额 = 固定资产原价 × （ 1 － 预计净残值率 ）/ 预计总工作量 某项固定资产月折旧额 = 该项固定资产当月工作量 × 单位工作量折旧额 参考链接 家用电器的使用年限是多久？如何尽可能延长其寿命？,by 海尔智慧生活. 固定资产折旧方法,by 百度百科.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>生活常识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空战类游戏仿真的一些思考]]></title>
    <url>%2F2018%2F12%2F08%2F%E7%A9%BA%E6%88%98%E7%B1%BB%E6%B8%B8%E6%88%8F%E4%BB%BF%E7%9C%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[空战类游戏仿真涉及飞机、导弹、诱饵弹三种关键元素。为了使游戏仿真接近真实，一方面要使飞机、导弹、诱饵弹的模型及其特效（如尾焰）尽量逼真，另一方面要使飞机、导弹、诱饵弹的运动控制模型尽量接近真实。飞机、导弹、诱饵弹的模型可以用3d建模软件构建，尾焰也可以用粒子系统进行模拟，但飞机、导弹、诱饵弹的运动控制模型比较复杂，是实现空战类游戏仿真的关键。下面分别介绍飞机、导弹、诱饵弹的建模仿真。 飞机的建模仿真飞机的运动模型基于牛顿第二运动定律，即物体所受到的外力等于此物体的质量与加速度的乘积，而加速度与外力同方向。根据外部受力和力矩计算出各种惯性坐标系下的加速度和角加速度。将加速度和角加速度分别进行积分，则可以得出飞机在某个时间段内的速度变化量和角速度变化量，进一步积分便可得到位置变化量和角度的变化量，再通过积分过程中的坐标变换以及初始时刻的状态参数，便可获得任意时刻飞机的姿态、位置、速度等参数。 飞行员通过油门杆和操纵杆控制飞机的运动。油门杆决定飞机的推力，操纵杆则控制飞机的副翼、襟翼、尾翼，改变飞机所受合力矩，从而改变飞机姿态。飞行仿真采用同样原理，油门杆和操作杆的位移经过非线性函数变换改变飞机所受合力和合力矩，经飞机运动模型获得加速度和角加速度，再经积分获得任意时刻飞机的姿态、位置、速度等参数。 当使用键盘输入控制飞机时，应将键盘输入先虚拟成油门杆和操作杆。另外需要注意的是，油门杆不回中，操作杆则自动回中。 导弹的建模仿真根据导弹的工作原理，导弹的建模仿真应分成三个方面： 探测模型 目标识别算法 运动控制模型 诱饵弹的建模仿真诱饵弹的运动模型比较简单，可运用牛顿第二运动定律分析得出。比较有难度的是诱饵弹的视觉特效建模。诱饵弹是一个变质量、不规则的发光体，如何3D建模有难度，不能像太阳一样直接用图片代替。 参考链接 无人机飞控通俗演义之 纷繁复杂的飞行力学, by 量子黑洞. 一起写飞行仿真之 六自由度动力学方程, by 量子黑洞. 飞行仿真—1.三维建模篇, by WFYX. 无人机飞控通俗演义之 无人机导航制导与控制, by WFYX. FLIGHTGEAR FLIGHT SIMULATOR, by flightgear.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
        <tag>计算机仿真</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机视觉研究范畴简介]]></title>
    <url>%2F2018%2F12%2F07%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%A0%94%E7%A9%B6%E8%8C%83%E7%95%B4%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[计算机视觉是一个跨领域的交叉学科，包括计算机科学（图形、算法、理论、系统、体系结构），数学（信息检索、机器学习），工程学（机器人、语音、自然语言处理、图像处理），物理学（光学 ），生物学（神经科学）和心理学（认知科学）等等。那么什么是计算机视觉呢？这里给出了几个比较严谨的定义： “对图像中的客观对象构建明确而有意义的描述”（Ballard＆Brown，1982） “从一个或多个数字图像中计算三维世界的特性”（Trucco＆Verri，1998） “基于感知图像做出对客观对象和场景有用的决策”（Sockman＆Shapiro，2001） 研究范畴视觉识别是计算机视觉的关键组成部分，如图像分类、定位和检测。神经网络和深度学习的最新进展极大地推动了这些最先进的视觉识别系统的发展。下面介绍 5 种主要的计算机视觉技术： 图像分类 给定一组各自被标记为单一类别的图像，我们对一组新的测试图像的类别进行预测，并测量预测的准确性结果，这就是图像分类问题。图像分类问题需要面临以下几个挑战： 视点变化，尺度变化，类内变化，图像变形，图像遮挡，照明条件和背景杂斑 对象检测 识别图像中的对象这一任务，通常会涉及到为各个对象输出边界框和标签。这不同于分类/定位任务——对很多对象进行分类和定位，而不仅仅是对个主体对象进行分类和定位。在对象检测中，你只有 2 个对象分类类别，即对象边界框和非对象边界框。例如，在汽车检测中，你必须使用边界框检测所给定图像中的所有汽车。 目标跟踪 目标跟踪，是指在特定场景跟踪某一个或多个特定感兴趣对象的过程。传统的应用就是视频和真实世界的交互，在检测到初始对象之后进行观察。现在，目标跟踪在无人驾驶领域也很重要，例如 Uber 和特斯拉等公司的无人驾驶。 语义分割 计算机视觉的核心是分割，它将整个图像分成一个个像素组，然后对其进行标记和分类。特别地，语义分割试图在语义上理解图像中每个像素的角色（比如，识别它是汽车、摩托车还是其他的类别）。 实例分割 除了语义分割之外，实例分割将不同类型的实例进行分类，比如用 5 种不同颜色来标记 5 辆汽车。分类任务通常来说就是识别出包含单个对象的图像是什么，但在分割实例时，我们需要执行更复杂的任务。我们会看到多个重叠物体和不同背景的复杂景象，我们不仅需要将这些不同的对象进行分类，而且还要确定对象的边界、差异和彼此之间的关系！ 典型应用计算机视觉领域已经衍生出了一大批快速成长的、有实际作用的应用，例如： 人脸识别： Snapchat 和 Facebook 使用人脸检测算法来识别人脸。 图像检索：Google Images 使用基于内容的查询来搜索相关图片，算法分析查询图像中的内容并根据最佳匹配内容返回结果。 游戏和控制：使用立体视觉较为成功的游戏应用产品是：微软 Kinect。 监测：用于监测可疑行为的监视摄像头遍布于各大公共场所中。 生物识别技术：指纹、虹膜和人脸匹配仍然是生物识别领域的一些常用方法。 智能汽车：计算机视觉仍然是检测交通标志、灯光和其他视觉特征的主要信息来源。 前沿研究 超分辨率重建 (Image Super-Resolution) 图像着色 (Image Colorization) “看图说话” (Image Caption) 人像复原 (Sketch Inversion) 图像自动生成 参考文献 详解计算机视觉五大技术：图像分类、对象检测、目标跟踪、语义分割和实例分割…, by AI科技大本营 「无中生有」计算机视觉探奇, by 魏秀参]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三维建模方法简介]]></title>
    <url>%2F2018%2F12%2F05%2F%E4%B8%89%E7%BB%B4%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[三维建模是一种常用技术，奈何心向往之，却没有时间去系统学习，也没有做出过一个作品。下面将我看到的一些好的有关三维建模的资料记录一下，以做备忘。 三维建模方法选择软件当前三维软件层出不穷，既有商业级的3ds MAX、MAYA、Creator，也有免费使用的Blender、MilkShape。 下载蓝图飞行仿真的三维模型主要有飞行器、机场建筑等。和大多数虚拟现实中使用的模型一样，并不需要CAD级别的精度，一般是下载一些图片或飞机整体蓝图作为蓝本，采用多边形建模的方法分部建模。蓝图下载网址首推： the‑blueprints.com 这里免费提供各种汽车、国内外飞机、船舶的三视图图纸下载。 多边形建模采用下载的蓝图，作为贴图放置在相应的投影平面上，然后采用多边形建模的方法画出各部分细节。多边形建模的思想就是采用一个诸如一个最接近的多边形，进行点线面的操作就可以绘制出复杂的飞机外形。 多边形建模从最基本的外形开始变形，可以从点线面及整体四个级别的操作，在越需要突出外形细节处用越多的点，通过建立网格模型，然后使用网格平滑功能生成平滑的曲面模型。 建模时不能有重复的点线面等几何体，否则即使表面上已经贴好了材质，但载入程序后，往往会因为Z向深度冲突的原因产生闪烁效果。其细节取决于您的需求，需要花费大量的时间。 贴图真实世界的模型带有各种彩色并具有光泽度。完成了几何体的建模对于一个模型来说只完成了一小半工作，还需要给模型添加材质。 与一般的模型不同，飞行器出于气动设计的考虑，其表面模型一般成流线型的曲面，且部件组成复杂，界线较难区分，即使是UVW贴图也难以胜任。因此，对飞行器的贴图主要采用3ds MAX的UVW展开贴图技术贴图。 一个模型最好只有一个贴图，因为贴图数目过多零散会影响计算机载入三维模型时间和效率。因此，一般将整个模型各个部件组合为一个多边形，各部件为元素，待完成UVW贴图后再分离成单独的部件。UVW展开贴图有多重形式，如长方体展开（即按六个视图投影）、平面展开等，按需选择。 在一张贴图上展开整个模型的UV坐标显然是有限的，需要根据现实精度调整各个部分的贴图大小。保存这些展开的贴图坐标并渲染输出UV模板图像文件。UV模板图像其实就是整个模型的贴图的界线图像，通过Photoshop等图像处理软件处理，采用尽可能真实的图像放置在对应的区域。最后将材质赋给对象即完成贴图渲染。 数据导出直接采用3ds MAX绘制的三维模型当然是.max格式，它不能为外界程序读取。这时就需要根据自己的开发环境选择导出的数据格式，比如用开源的OSG做仿真开发，就需要OSGExp插件的支持，导成.ive、.osg、.osgb等格式即可。但无论导出何种格式，切记保证模型质心与建模的原点不能相差不远，还要注意光照、贴图格式以及单位问题。 参考链接 飞行仿真—1.三维建模篇,by WFYX.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度强化学习研究笔记]]></title>
    <url>%2F2018%2F11%2F26%2F%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[深度强化学习Deep Reinforcement Learning是将深度学习与强化学习结合起来，从而实现从Perception感知到Action动作的端对端学习End-to-End Learning的一种全新的算法。深度强化学习具备使机器人实现真正完全自主地学习一种甚至多种技能的潜力。 深度强化学习的起源深度强化学习是深度学习与强化学习相结合的产物。 深度学习深度学习（deep learning）是机器学习的分支，是一种试图使用包含复杂结构或由多重非线性变换构成的多个处理层对数据进行高层抽象的算法。 深度学习是机器学习中一种基于对数据进行表征学习的算法。观测值（例如一幅图像）可以使用多种方式来表示，如每个像素强度值的向量，或者更抽象地表示成一系列边、特定形状的区域等。而使用某些特定的表示方法更容易从实例中学习任务（例如，人脸识别或面部表情识别）。深度学习的好处是用非监督式或半监督式的特征学习和分层特征提取高效算法来替代手工获取特征。 表征学习的目标是寻求更好的表示方法并创建更好的模型来从大规模未标记数据中学习这些表示方法。表示方法来自神经科学，并松散地创建在类似神经系统中的信息处理和对通信模式的理解上，如神经编码，试图定义拉动神经元的反应之间的关系以及大脑中的神经元的电活动之间的关系。 至今已有数种深度学习框架，如深度神经网络、卷积神经网络和深度置信网络和递归神经网络已被应用在计算机视觉、语音识别、自然语言处理、音频识别与生物信息学等领域并获取了极好的效果。 另外，“深度学习”已成为类似术语，或者说是神经网络的品牌重塑。 深度神经网络深度神经网络是一种具备至少一个隐层的神经网络。与浅层神经网络类似，深度神经网络也能够为复杂非线性系统提供建模，但多出的层次为模型提供了更高的抽象层次，因而提高了模型的能力。 深度神经网络（Deep Neural Networks, DNN）是一种判别模型，可以使用反向传播算法进行训练。权重更新可以使用下式进行随机梯度下降法求解： \Delta w_{ij}(t+1)=\Delta w_{ij}(t) + \eta\frac{\partial C}{\partial w_{ij}}其中，$\eta$为学习率，$C$为代价函数。这一函数的选择与学习的类型（例如监督学习、无监督学习、增强学习）以及激活函数相关。例如，为了在一个多分类问题上进行监督学习，通常的选择是使用ReLU作为激活函数，而使用交叉熵作为代价函数。Softmax函数定义为${\displaystyle p{j}={\frac {\exp(x{j})}{\sum {k}\exp(x{k})}}}$，其中 ${\displaystyle p{j}}$代表类别 ${\displaystyle j}$的概率，而 ${\displaystyle x{j}}$和 ${\displaystyle x{k}}$分别代表对单元 ${\displaystyle j}$ 和 ${\displaystyle k}$的输入。交叉熵定义为 $C = -\sum_j d_j \log(p_j)$ ，其中 ${\displaystyle d{j}}$代表输出单元${\displaystyle j}$的目标概率， ${\displaystyle p_{j}}$代表应用了激活函数后对单元 ${\displaystyle j}$的概率输出。 强化学习在人工智能领域，一般用智能体Agent表示一个具备行为能力的物体，比如机器人，无人车等等。而强化学习则研究智能体Agent和环境Environment之间交互过程如何取得任务的成功。 强化学习与环境的交互过程如图1所示。在某个时间点，智能体Agent会获得观察值(Observation)和反馈值(Reward)，然后根据这些选择下一步的动作(Action)。 图1 强化学习示意图 在整个过程中，任务的目标是获取尽可能多的Reward，这是任务的目标。而在每个时间片，Agent都是根据当前的观察来确定下一步的动作。观察Observation的集合就作为Agent的所处的状态State，因此，状态State和动作Action存在映射关系，也就是一个state可以对应一个action，或者对应不同动作的概率（常常用概率来表示，概率最高的就是最值得执行的动作）。状态与动作的关系其实就是输入与输出的关系，而状态State到动作Action的过程就称之为一个策略Policy，一般用 $\pi$ 表示，也就是需要找到以下关系： a=\pi(s)或者 \pi(a|s)其中a是action，s是state。第一种是一一对应的表示，第二种是概率的表示。1强化学习的任务就是找到一个最优的策略Policy从而使Reward最多。 强化学习的训练一开始从采用随机策略进行试验开始，可获得一系列的状态,动作和反馈： \{s_1,a_1,r_1,s_2,a_2,r_2,...,s_t,a_t,r_t\}根据这一系列样本，强化学习从中改进策略，使得任务反馈Reward越来越多。 强化学习模型假设强化学习的研究建立在经典物理学基础上，基于以下两种假设： 时间是可以分割成一个一个时间片的，并且有完全的先后顺序。 上帝不掷筛子！如果输入是确定的，那么输出也一定是确定的。 强化学习与马尔科夫决策过程MDP基于这样一种假设：未来只取决于当前。 一个状态$S_t$是Markov当且仅当 P(s_{t+1}|s_t)=P(s_{t+1}|s_t,s_{t-1},...s_1,s_0)P为概率。简单的说就是下一个状态仅取决于当前的状态和当前的动作。注意这里的状态是完全可观察的全部的环境状态（也就是上帝视角）。 增强学习的问题都可以模型化为MDP的问题。 一个基本的MDP可以用（S,A,P）来表示，S表示状态，A表示动作，P表示状态转移概率，也就是根据当前的状态$st$和$a_t$转移到$s{t+1}$的概率。如果我们知道了转移概率P，也就是称为我们获得了模型Model，有了模型，未来就可以求解，那么获取最优的动作也就有可能，这种通过模型来获取最优动作的方法也就称为Model-based的方法。但是现实情况下，很多问题是很难得到准确的模型的，因此就有Model-free的方法来寻找最优的动作。 强化学习的回报Result既然一个状态对应一个动作，或者动作的概率，而有了动作，下一个状态也就确定了。这就意味着每个状态可以用一个确定的值来进行描述。可以由此判断一个状态是好的状态还是不好的状态。 状态的好坏其实等价于对未来回报的期望。因此，引入回报Return来表示某个时刻t的状态将具备的回报： G_t = R_{t+1} + \lambda R_{t+2} + ... = \sum_{k=0}^\infty\lambda^kR_{t+k+1}上面R是Reward反馈，λ是discount factor折扣因子，一般小于1，就是说一般当下的反馈是比较重要的，时间越久，影响越小。 那么实际上除非整个过程结束，否则显然我们无法获取所有的reward来计算出每个状态的Return，因此，再引入一个概念价值函数Value Function,用value function $v(s)$来表示一个状态未来的潜在价值。 从定义上看，value function就是回报的期望： v(s) = \mathbb E[G_t|S_t = s]引出价值函数，对于获取最优的策略Policy这个目标，我们就会有两种方法： 直接优化策略$\pi(a|s)$或者$a = \pi(s)$使得回报更高 通过估计value function来间接获得优化的策略。道理很简单，既然我知道每一种状态的优劣，那么我就知道我应该怎么选择了，而这种选择就是我们想要的策略。 把值函数展开： \begin{aligned} v(s) & = \mathbb E[G_t|S_t = s] \\\\ & = \mathbb E[R_{t+1}+\lambda R_{t+2} + \lambda ^2R_{t+3} + ...|S_t = s] \\\\ & = \mathbb E[R_{t+1}+\lambda (R_{t+2} + \lambda R_{t+3} + ...)|S_t = s] \\\\ & = \mathbb E[R_{t+1} + \lambda G_{t+1}|S_t = s] \\\\ & = \mathbb E[R_{t+1} + \lambda v(S_{t+1})|S_t = s] \end{aligned}因此： v(s) = \mathbb E[R_{t+1} + \lambda v(S_{t+1})|S_t = s]上面这个公式就是Bellman方程的基本形态。从公式上看，当前状态的价值和下一步的价值以及当前的反馈Reward有关。它表明Value Function是可以通过迭代来进行计算的!!! Action-Value function 动作价值函数前面我们引出了价值函数，考虑到每个状态之后都有多种动作可以选择，每个动作之下的状态又多不一样，我们更关心在某个状态下的不同动作的价值。显然。如果知道了每个动作的价值，那么就可以选择价值最大的一个动作去执行了。这就是Action-Value function $Q^\pi(s,a)$。那么同样的道理，也是使用reward来表示，只是这里的reward和之前的reward不一样，这里是执行完动作action之后得到的reward，之前state对应的reward则是多种动作对应的reward的期望值。显然，动作之后的reward更容易理解。 动作价值函数就为如下表示： \begin{aligned} Q^\pi(s,a) & = \mathbb E[r_{t+1} + \lambda r_{t+2} + \lambda^2r_{t+3} + ... |s,a] \\\\ & = \mathbb E_{s^\prime}[r+\lambda Q^\pi(s^\prime,a^\prime)|s,a] \end{aligned}这里要说明的是动作价值函数的定义，加了$\pi$,也就是说是在策略下的动作价值。因为对于每一个动作而已，都需要由策略根据当前的状态生成，因此必须有策略的支撑。而前面的价值函数则不一定依赖于策略。当然，如果定义$v^\pi(s)$则表示在策略$\pi$下的价值。 Optimal value function 最优价值函数能计算动作价值函数是不够的，因为我们需要的是最优策略，现在求解最优策略等价于求解最优的value function，找到了最优的value function，自然而然策略也就是找到。（当然，这只是求解最优策略的一种方法，也就是value-based approach，由于DQN就是value-based，因此这里只讲这部分，以后我们会看到还有policy-based和model-based方法。一个就是直接计算策略函数，一个是估计模型，也就是计算出状态转移函数，从而整个MDP过程得解） 这里以动作价值函数来分析。 首先是最优动作价值函数和一般的动作价值函数的关系： \begin{aligned} Q^*(s,a) &= \max_\pi Q^\pi(s,a)\\\\ & = \mathbb E_{s^\prime}[r+\lambda \max _{a^\prime}Q^*(s^\prime,a^\prime)|s,a] \end{aligned}也就是最优的动作价值函数就是所有策略下的动作价值函数的最大值。通过这样的定义就可以使最优的动作价值的唯一性，从而可以求解整个MDP。 下面介绍基于Bellman方程的两个最基本的算法，策略迭代和值迭代。 策略迭代Policy IterationPolicy Iteration的目的是通过迭代计算value function 价值函数的方式来使policy收敛到最优。 Policy Iteration本质上就是直接使用Bellman方程而得到的： \begin{aligned} v_{k+1}(s) &\overset{.}{=} \mathbb E_{\pi}[R_{t+1}+\gamma v _{k}(S_{t+1})|S_t=s]\\\\ &=\sum_{a}{\pi(a|s)}\sum_{s^\prime,r}{p(s^\prime,r|s,a)[r+\gamma v_k(s^\prime)]} \end{aligned}那么Policy Iteration一般分成两步： Policy Evaluation 策略评估。目的是更新Value Function，或者说更好的估计基于当前策略的价值 Policy Improvement 策略改进。 使用 greedy policy 产生新的样本用于第一步的策略评估。 图2 策略迭代算法示意图 本质上就是使用当前策略产生新的样本，然后使用新的样本更好的估计策略的价值，然后利用策略的价值更新策略，然后不断反复。理论可以证明最终策略将收敛到最优。 具体算法： 图3 策略迭代算法 那么这里要注意的是policy evaluation部分。这里的迭代很重要的一点是需要知道state状态转移概率p。也就是说依赖于model模型。而且按照算法要反复迭代直到收敛为止。所以一般需要做限制。比如到某一个比率或者次数就停止迭代。那么需要特别说明的是不管是策略迭代还是值迭代都是在理想化的情况下（上帝视角）推导出来的算法，本质上并不能直接应用，因为依赖Model。 Value Iteration 价值迭代Value Iteration则是使用Bellman 最优方程得到: \begin{aligned} v_{*}(s) & = \max_{a} \mathbb E_{\pi}[R_{t+1}+\gamma v _{*}(S_{t+1})|S_t=s,A_t=a]\\\\ & = \max_{a} \sum_{s^\prime,r}p(s^\prime,r|s,a)[r+\gamma v_*(s^\prime)] \end{aligned}然后改变成迭代形式: \begin{aligned} v_{k+1}(s) &\overset{.}{=} \max_{a} \mathbb E_{\pi}[R_{t+1}+\gamma v _{k}(S_{t+1})|S_t=s,A_t=a]\\\\ & = \max_{a} \sum_{s^\prime,r}p(s^\prime,r|s,a)[r+\gamma v_k(s^\prime)] \end{aligned}value iteration的算法如下： 图4 值迭代算法 Policy Iteration和Value Iteration有什么本质区别？ policy iteration使用bellman方程来更新value，最后收敛的value 即$v_\pi$是当前policy下的value值（所以叫做对policy进行评估），目的是为了后面的policy improvement得到新的policy。 而value iteration是使用bellman 最优方程来更新value，最后收敛得到的value即$v_*$就是当前state状态下的最优的value值。因此，只要最后收敛，那么最优的policy也就得到的。因此这个方法是基于更新value的，所以叫value iteration。 从上面的分析看，value iteration较之policy iteration更直接。不过问题也都是一样，需要知道状态转移函数p才能计算。本质上依赖于模型，而且理想条件下需要遍历所有的状态，这在稍微复杂一点的问题上就基本不可能了。 Q-LearningQ Learning的思想完全根据value iteration得到。但要明确一点是value iteration每次都对所有的Q值更新一遍，也就是所有的状态和动作。但事实上在实际情况下我们没办法遍历所有的状态，还有所有的动作，我们只能得到有限的系列样本。因此，只能使用有限的样本进行操作。那么，怎么处理？Q Learning提出了一种更新Q值的办法： Q(S_{t},A_{t}) \leftarrow Q(S_{t},A_{t})+\alpha({R_{t+1}+\lambda \max _aQ(S_{t+1},a)} - Q(S_t,A_t))虽然根据value iteration计算出target Q值，但是这里并没有直接将这个Q值（是估计值）直接赋予新的Q，而是采用渐进的方式类似梯度下降，朝target迈近一小步，取决于α,这就能够减少估计误差造成的影响。类似随机梯度下降，最后可以收敛到最优的Q值。 具体的算法如下： 图5 Q学习算法 Exploration and Exploitation 探索与利用回到policy的问题，那么要选择怎样的policy来生成action呢？有两种做法： 随机的生成一个动作 根据当前的Q值计算出一个最优的动作，这个policy\pi称之为greedy policy贪婪策略。也就是 \pi(S_{t+1}) = arg\max _aQ(S_{t+1},a)使用随机的动作就是exploration，也就是探索未知的动作会产生的效果，有利于更新Q值，获得更好的policy。而使用greedy policy也就是target policy则是exploitation，利用policy，这个相对来说就不好更新出更好的Q值，但可以得到更好的测试效果用于判断算法是否有效。 将两者结合起来就是所谓的$\epsilon-greedy$策略，$\epsilon$一般是一个很小的值，作为选取随机动作的概率值。可以更改$\epsilon$的值从而得到不同的exploration和exploitation的比例。 这里需要说明的一点是使用$\epsilon-greedy$策略是一种极其简单粗暴的方法，对于一些复杂的任务采用这种方法来探索未知空间是不可取的。因此，最近有越来越多的方法来改进这种探索机制。 深度强化学习深度强化学习始于DeepMind在NIPS 2013上发表的Playing Atari with Deep Reinforcement Learning一文，在该文中第一次提出Deep Reinforcement Learning 这个名称，并且提出DQN（Deep Q-Network）算法，实现从纯图像输入完全通过学习来玩Atari游戏的成果。 之后DeepMind在Nature上发表了改进版的DQN文章Human-level Control through Deep Reinforcement Learning，引起了广泛的关注，Deep Reinfocement Learning 从此成为深度学习领域的前沿研究方向。 维度灾难对简单问题可使用表格来表示Q(s,a)，但是这个在现实的很多问题上是几乎不可行的，因为状态实在是太多。使用表格的方式根本存不下。 以计算机玩Atari游戏为例，计算机玩Atari游戏的要求是输入原始图像数据，也就是210x160像素的图片，然后输出几个按键动作。总之就是和人类的要求一样，纯视觉输入，然后让计算机自己玩游戏。那么这种情况下，到底有多少种状态呢？有可能每一秒钟的状态都不一样。因为，从理论上看，如果每一个像素都有256种选择，那么就有： 256^{210\times 160}这简直是天文数字。所以，我们是不可能通过表格来存储状态的。我们有必要对状态的维度进行压缩，解决办法就是 价值函数近似Value Function Approximation 价值函数近似Value Function Approximation什么是价值函数近似呢？说起来很简单，就是用一个函数来表示Q(s,a)。即 Q(s,a) = f(s,a)$f$可以是任意类型的函数，比如线性函数： Q(s,a) = w_1s + w_2a + b其中$w_1$,$w_2$,$b$是函数$f$的参数。 通过函数表示，我们就可以无所谓s到底是多大的维度，反正最后都通过矩阵运算降维输出为单值的Q。 这就是价值函数近似的基本思路。 如果我们就用$w$来统一表示函数$f$的参数，那么就有 Q(s,a) = f(s,a,w)为什么叫近似，因为我们并不知道Q值的实际分布情况，本质上就是用一个函数来近似Q值的分布，所以，也可以说是 Q(s,a)\approx f(s,a,w)Q值神经网络化——DQN算法意思很清楚，就是我们用一个深度神经网络来表示这个函数$f$。 以DQN为例，输入是经过处理的4个连续的84x84图像，然后经过两个卷积层，两个全连接层，最后输出包含每一个动作Q值的向量。 神经网络的训练是一个最优化问题，最优化一个损失函数loss function，也就是标签和网络输出的偏差，目标是让损失函数最小化。为此，我们需要有样本，巨量的有标签数据，然后通过反向传播使用梯度下降的方法来更新神经网络的参数。 如何为Q网络提供有标签的样本？答案就是利用Q-Learning算法。目标Q值作为标签，使Q值趋近于目标Q值。于是Q网络训练的损失函数就是： 图6 DQN损失函数 上面公式是$s^\prime$, $a^\prime$即下一个状态和动作。这里用了David Silver的表示方式，看起来比较清晰。既然确定了损失函数，也就是cost，确定了获取样本的方式。那么DQN的整个算法也就成型了！ 这里分析第一个版本的DQN，也就是NIPS 2013提出的DQN。 图7 DQN算法 具体的算法主要涉及到Experience Replay，也就是经验池的技巧，就是如何存储样本及采样问题。 由于玩Atari采集的样本是一个时间序列，样本之间具有连续性，如果每次得到样本就更新Q值，受样本分布影响，效果会不好。因此，一个很直接的想法就是把样本先存起来，然后随机采样如何？这就是Experience Replay的意思。按照脑科学的观点，人的大脑也具有这样的机制，就是在回忆中学习。 那么上面的算法看起来那么长，其实就是反复试验，然后存储数据。接下来数据存到一定程度，就每次随机采用数据，进行梯度下降！ 策略梯度Policy Gradient的方法的基本思想是通过评价动作action的好坏，来调整该action的出现概率。最基本的Policy Gradient的损失函数Loss就是： loss = -log(\pi)*Q这里先以Q值来指代对动作的评价。 Robot Learning的发展路径Robot Learning从目前来看，经过了以下研究思路的发展： （1）利用传统的控制算法结合深度学习来实现机器人端到端的控制。这个方法主要是以Guided Policy Search（GPS）为首。这个方法是Sergey Levine提出的，通过与传统方法结合，确实可以让机器人学习出一些有意思的技能，但是有个根本问题摆在面前，就是传统方法通常需要知道整个系统的模型，而这在实际的机器人中非常难以适用。就比如四轴飞行器的控制，我们可以通过外部的Vicon设备来精确的定位四轴飞行器的位置，从而实现对其精确控制，但是在户外，我们根本就做不到这点，也就无法精确建模。因此，还依赖传统方法是没有出路的，我们使用深度学习就是要抛弃传统方法的弊端。 （2）深度增强学习DRL。由于DeepMind在DRL取得了巨大成功，而DRL就是面向决策与控制问题，特别适用于机器人，因此想在机器人上使用DRL是一种必然的想法。Google Brain团队（依然以Sergey Levine为首）做出了一些进展，在我们之前的专栏文章中也有分析最前沿 之 谷歌的协作机械臂 - 知乎专栏 。但是在使用DRL之后，DRL的弊端也就显现出来了，那就是需要大量的尝试来获取数据。对于这个问题，在机器人仿真环境还好，但是在真实的机器人上就根本没办法这么做了。为了解决这个问题，也就引出来下面两个研究思路。 （3）迁移学习Transfer Learning。既然在真实环境不行，而仿真环境可以，那么是不是可以先在仿真环境中训练好，再把知识迁移到真实机器人上。Google Deepmind在这一块做了一些不错的工作，提出了Progressive Neural Net和PathNet，验证了迁移的可能性。而且很显然的，仿真环境越真实，迁移效果会越好。那么，搞一个非常仿真的环境就非常有意义了。这不，Nvidia 刚刚推出Isaac机器人模拟系统，确实是对Robot Learning的研究注入了一剂强心剂。 （4）Imitation Learning 模仿学习/Few Shot Learning 少样本学习/ Meta Learning 学会学习。这是另一条思路，那就是尽量减少数据的使用量。我们如果能够教机器人几次机器人就能学会技能那么问题也能解决。而这一块也就是OpenAI (依然是Sergey Levine）那帮人在如火如荼的研究的方向。而且特别是Meta Learning，直指通用人工智能的核心。如果能够在Meta Learning上取得突破，那么本身会是革命性的。 因此，Robot Learning发展到这里，把研究的方向就聚焦到第三和第四点上了，并且也取得了一定的成果，但是显然还有非常多的工作可以去做。 参考链接 深度学习, by wikipedia. DQN 从入门到放弃1 DQN与增强学习, by Flood Sung. DQN 从入门到放弃2 增强学习与MDP, by Flood Sung. DQN 从入门到放弃3 价值函数与Bellman方程, by Flood Sung. DQN 从入门到放弃4 动态规划与Q-Learning,by Flood Sung. DQN从入门到放弃5 深度解读DQN算法, by Flood Sung. DQN从入门到放弃6 DQN的各种改进, by Flood Sung. DQN从入门到放弃7 连续控制DQN算法-NAF,by Flood Sung. 最前沿：机器人学习Robot Learning的发展,by Flood Sung.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wiringPi学习笔记]]></title>
    <url>%2F2018%2F11%2F24%2FwiringPi%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[wiringPi 库是由 Gordon Henderson 所编写并维护的一个用 C 语言写成的类库。起初,主要是作为 BCM2835 芯片的 GPIO 库。而现在,已经非常丰富,除了 GPIO 库,还包括了I2C 库、SPI 库、UART 库和软件 PWM 库等。 由于其与 Arduino 的“wiring”系统较为类似,故以此命名。它是采用 GNU LGPLv3许可证的,可以在 C 或 C++上使用,而且在其他编程语言上也有对应的扩展。 wiringPi 库包含了一个命令行工具 gpio,它可以用来设置 GPIO 管脚,可以用来读写GPIO 管脚,甚至可以在 Shell 脚本中使用来达到控制 GPIO 管脚的目的。 下载、编译和测试wiringPi 下载并编译wiringPi 123git clone git://git.drogon.net/wiringPicd wiringPi./build 测试wiringPi是否安装成功打开命令终端，可以通过 gpio 命令来检查 wiringPi 是否安装成功，运行下面的命令： 12gpio –vgpio readall 运行上述第二条命令将得到树莓派的 GPIO 接口之间的对应关系。 使用wiringPi在使用wiringPi之前，应首先对wiringPi进行设置。 wiringPi设置函数wiringPi设置函数如下：1234int wiringPiSetup (void) ;int wiringPiSetupGpio (void) ;int wiringPiSetupPhys (void) ;int wiringPiSetupSys (void) ; wiringPiSetup (void) 函数该函数初始化wiringPi，假定程序将使用wiringPi的管脚定义图。具体管脚映射，可以通过gpio readall命令来查看。该函数需要root权限。 wiringPiSetupGpio (void) 函数该函数与wiringPiSetup函数类似，区别在于假定程序使用的是Broadcom的GPIO管脚定义，而没有重新映射。该函数需要root权限，需要注意v1和v2版本的树莓派是不同的。 wiringPiSetupPhys (void) 函数该函数与wiringPiSetup函数类似，区别在于允许程序使用物理管脚定义，但仅支持P1接口。该函数需要root权限。 wiringPiSetupSys (void) 函数该函数初始化wiringPi，使用/sys/class/gpio接口，而不是直接通过操作硬件来实现。该函数可以使用非root权限用户，在此种模式下的管脚号是Broadcom的GPIO管脚号，不wiringPiSetupGpio函数类似，需要注意v1和v2板子的不同。 在此种模式下，在运行程序前，您需要通过/sys/class/gpio接口导出要使用的管脚。你可以在一个独立的shell脚本中来导出将要使用的管脚，或者使用系统的system()函数来调用GPIO命令。 软件 PWM 库wiringPi 中包含了一个软件驱动的 PWM (Pulse Width Modulation, 脉冲宽度调节)处理库，可以在任意的树莓派 GPIO 上输出 PWM 信号。 但是也有一些限制。为了维护较低的 CPU 使用率，最小的脉冲宽度是 100 微秒，结合默认的建议值为 100，那么最小的 PWM 频率是 100Hz。如果需要更高的频率，可以使用更低的数值。如果看脉冲宽度的驱动代码，你会发现低于 100 微秒，wiringPi 是在软件循环中实现的，这就意味着 CPU 使用率将会动态增加，从而使得控制其他管脚成为不可能。 需要注意的是，当其他程序运行在更高的实时的优先级，Linux 可能会影响产生信号的精度。尽管有这些限制，控制 LED 或电机还是可以的。 使用前,需要包含相应的文件:12#include &lt;wiringPi.h&gt;#include &lt;softPwm.h&gt; 当编译程序时,必须加上 pthread 库,如下:1gcc –o myprog myprog.c –lwiringPi –lpthread 必须使用 wiringPiSetup()、 wiringPiSetupGpio()或者 wiringPiSetupPhys()函数来初始化 wiringPi。 wiringPiSetupSys()是不够快的，因此，必须使用 sudo 命令来运行程序。 softPwmCreate 函数该函数的原型为：int softPwmCreate(int pin, int initialValue, int pwmRange); 该函数将会创建一个软件控制的 PWM 管脚。可以使用任何一个 GPIO 管脚 , pwmRange 参数可以为 0(关)~100(全开)。 返回值为 0，代表成功，其他值，代表失败。 softPwmWrite 函数该函数的原型为: void softPwmWrite(int pin, int value); 该函数将会更新指定管脚的 PWM 值。value 参数的范围将会被检查,如果指定的管脚之前没有通过 softPwmCreate 初始化,将会被忽略。 wiringPi核心函数pinMode函数该函数的原型为: void pinMode(int pin, int mode); 使用该函数可以将某个管脚讴置为 INPUT(输入)、 OUTPUT(输出)、 PWM_OUTPUT(脉冲输出)或者 GPIO_CLOCK(GPIO 时钟)。 需要注意的是仅有管脚 1(BCM_GPIO 18)支持 PWM_OUTPUT 模式,仅有管脚 7(BCM_GPIO 4)支持 CLOCK 输出模式。 在 Sys 模式下,返个函数没有影响。你可以通过调用 gpio 命令在 shell 脚本中来设置管脚的模式。 digitalWrite 函数该函数的原型为: void digitalWrite(int pin, int value); 使用该函数可以向指定的管脚写入 HIGH(高)或者 LOW(低),写入前,需要将管脚设置为输出模式。 wiringPi 将任何的非 0 值作为 HIGH (高)来对待,因此, 0 是唯一能够代表 LOW (低)的数值。 digitalRead 函数该函数原型： digitalRead(int pin); 使用该函数可以读取指定管脚的值，读取到的值为HIGH（1）或者LOW（0），该值取决于该管脚的逻辑电平的高低。 时间函数delay 函数该函数的原型为：void delay(unsigned int howLong); 该函数将会中断程序执行至少 howLong 毫秒。因为 Linux 是多任务的原因，中断时间可能会更长。需要注意的是，最长的延迟值是一个无符号 32 位整数，其大约为 49 天。 delayMicroseconds 函数该函数的原型为：void delayMicroseconds(unsigned int howLong); 该函数将会中断程序执行至少 howLong 微秒。因为 Linux 是一个多任务的系统，因此中断时间可能会更长。需要注意的是，最长的延迟值是一个无符号 32 位整数，其大约为 71分钟。 延迟低于100 微秒，将会使用硬件循环来实现；超过 100 微秒，将会使用系统的nanosleep()函数来实现。 优先级/时间/线程wiringPiISR 函数该函数的原型为：int wiringPiISR(int pin, int edgeType, void (*function)(void)); 该函数会在指定管脚注册一个中断事件的函数，当指定管脚发生中断事件时，会自动调用该函数。 edgeType 参数可以为 INT_EDGE_FALLING（下降沿）、INT_EDGE_RISING（上升沿）、INT_EDGE_BOTH（上升沿或者下降沿）或者 INT_EDGE_SETUP。如果是INT_EDGE_SETUP，将不会初始化该管脚，因为它假定已经在别处设置过该管脚（比如使用 gpio 命令），但是，如果指定另外的类型，指定管脚将会被导出并初始化。完成此操作使用的是 gpio 命令，所以，必须保证 gpio 命令是可用的。 注册函数在中断触发时，将会被调用。在调用注册函数前，中断事件将会从分配器中清除，所以，即使有后续的触发发生，在处理完成前，也不会错过此次触发。（当然，如果在正在处理触发时，有不止一个的中断发生，已经发生的中断将会被忽略）。 I2C库wiringPi 包含了一个 I2C 库，来让您能够更轻松的使用树莓派的板上 I2C 接口。在使用 I2C 接口之前，您可能需要使用 gpio 命令来加载 I2C 驱劢到内核中：1gpio load i2c 如果你需要的波特率是 100Kbps，那么您可以使用如下命令设置波特率为1000Kbps：1gpio load i2c 1000 使用 I2C 库，需要包含 wiringPiI2C.h 文件。并且编译时，同样需要使用-lwiringPi 来连接到 wiringPi 库。 您仍然可以使用标准的系统命令来检测 I2C 设备，如 i2cdetect 命令，需要注意的是，在 v1 版本的树莓派上是 0，v2 版本上是 1，如下： 123ls /dev/i2c-1# 注意i2c-1后面的编码1i2cdetect –y 1 当然，您也可以使用 gpio 命令来调用 i2cdetect 命令，从而检测 I2C 讴备，返样就不用在乎您的树莓派版本了，如下：1gpio i2cdetect wiringPiI2CSetup 函数该函数的原型为：int wiringPiI2CSetup(int devId); 该函数使用指定设备标示号来初始化 I2C 系统。参数 devId 是 I2C 设备的地址，可以通过 i2cdetect 命令可以查到该地址。该函数会获取树莓派的版本并依据此打开/dev 目录下对应的讴备。 返回值是标准的 Linux 文件句柄，如果有错误，则返回-1。 比如，流行的 MCP23017 GPIO 扩展器的设备 ID 是 0x20，所以，你需要将这个数值传递给 wiringPiI2CSetup()。 wiringPiI2CWrite 函数该函数的原型为：int wiringPiI2CWrite(int fd, int data)； 简单的设备写操作。一些设备可以接受数据，而不需要发送任何内部寄存器地址。 wiringPiI2CRead 函数该函数的原型为：int wiringPiI2CRead(int fd)； 简单的设备读操作。一些设备可以直接读取，而不需要发送任何寄存器地址。 wiringPiI2CWriteReg8 和 wiringPiI2CWriteReg16 函数该函数的原型为： int wiringPiI2CWriteReg8(int fd, int reg, int data); int wiringPiI2CWriteReg16(int fd, int reg, int data); 使用返两个函数，可以写一个 8 位或 16 位数值到指定的设备寄存器。 wiringPiI2CReadReg8 和 wiringPiI2CReadReg16 函数该函数的原型为： int wiringPiI2CReadReg8(int fd, int reg); int wiringPiI2CReadReg16(int fd, int reg); 使用返两个函数，可以从指定的设备寄存器读取一个 8 位或 16 位的数值。 参考链接 树莓派 wiringPi 用户手册 , by 科技爱好者博客 Wiring Pi Pthreads 入门教程,by hanbingyan.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能——人类科技再次飞跃的门槛]]></title>
    <url>%2F2018%2F11%2F21%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E2%80%94%E2%80%94%E4%BA%BA%E7%B1%BB%E7%A7%91%E6%8A%80%E5%86%8D%E6%AC%A1%E9%A3%9E%E8%B7%83%E7%9A%84%E9%97%A8%E6%A7%9B%2F</url>
    <content type="text"><![CDATA[问题的提出问题的分析解决方案总结参考文献]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之神经网络]]></title>
    <url>%2F2018%2F11%2F20%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[人工神经网络（英语：Artificial Neural Network，ANN），简称神经网络（Neural Network，NN）或类神经网络，在机器学习和认知科学领域，是一种模仿生物神经网络（动物的中枢神经系统，特别是大脑）的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。 神经网络由大量的人工神经元联结进行计算。大多数情况下人工神经网络能在外界信息的基础上改变内部结构，是一种自适应系统，通俗的讲就是具备学习功能。现代神经网络是一种非线性统计性数据建模工具。 神经元神经元示意图： 图1 神经元示意图 a1~an为输入向量的各个分量 w1~wn为神经元各个突触的权值 b为偏置 f为传递函数，通常为非线性函数。一般有Sigmoid(), ReLU(), Softmax()。 t为神经元输出 神经元的数学表示是：$t=f(\vec{W^{‘}}\vec{A}+b)$ $\vec{W}$为权向量，$\vec{W^{‘}}$为$\vec{W}$的转置 $\vec{A}$为输入向量 $b$为偏置 $f$为传递函数 可见，一个神经元的功能是求得输入向量与权向量的内积后，经一个非线性传递函数得到一个标量结果。 激活函数 Sigmoid函数 Sigmoid函数也称S型激活函数，其将加权和转换为介于 0 和 1 之间的值。 F(x)=\frac{1} {1+e^{-x}}曲线图如下： 图2 S 型激活函数 ReLU函数 相较于 S 型函数等平滑函数，以下修正线性单元激活函数（简称为 ReLU）的效果通常要好一点，同时还非常易于计算。 F(x)=max(0,x)ReLU 的优势在于它基于实证发现（可能由 ReLU 驱动），拥有更实用的响应范围。S 型函数的响应性在两端相对较快地减少。 图3 ReLU 激活函数 Softmax函数 Softmax函数用于多类别神经网络。在多类别问题中，Softmax 会为每个类别分配一个用小数表示的概率。这些用小数表示的概率相加之和必须是 1.0。 Softmax 方程式如下所示： p(y = j|\textbf{x}) = \frac{e^{(\textbf{w}_j^{T}\textbf{x} + b_j)}}{\sum_{k\in K} {e^{(\textbf{w}_k^{T}\textbf{x} + b_k)}} }请注意，此公式本质上是将逻辑回归公式延伸到了多类别。 Softmax 层是紧挨着输出层之前的神经网络层。Softmax 层必须和输出层拥有一样的节点数。 图4 神经网络中的 Softmax 层 神经元网络神经元网络可分为单层神经元网络和多层神经元网络。而常用的是多层神经元网络。 多层神经元网络一种常见的多层结构的前馈网络（Multilayer Feedforward Network）由三部分组成，如图2所示： 图5 包含激活函数的三层模型的图表 输入层（Input layer），众多神经元（Neuron）接受大量非线形输入消息。输入的消息称为输入向量。 输出层（Output layer），消息在神经元链接中传输、分析、权衡，形成输出结果。输出的消息称为输出向量。 隐藏层（Hidden layer），简称“隐层”，是输入层和输出层之间众多神经元和链接组成的各个层面。隐层可以有一层或多层。隐层的节点（神经元）数目不定，但数目越多神经网络的非线性越显著，从而神经网络的强健性（robustness）（控制系统在一定结构、大小等的参数摄动下，维持某些性能的特性）更显著。习惯上会选输入节点1.2至1.5倍的节点。 这种网络一般称为感知器（对单隐藏层）或多层感知器（对多隐藏层），神经网络的类型已经演变出很多种，这种分层的结构也并不是对所有的神经网络都适用。 训练神经网络通常使用方向传播算法训练神经网络[3]，但一些常见情况都会导致反向传播算法出错。 梯度消失 较低层（更接近输入）的梯度可能会变得非常小。在深度网络中，计算这些梯度时，可能涉及许多小项的乘积。 当较低层的梯度逐渐消失到 0 时，这些层的训练速度会非常缓慢，甚至不再训练。 ReLU 激活函数有助于防止梯度消失。 梯度爆炸 如果网络中的权重过大，则较低层的梯度会涉及许多大项的乘积。在这种情况下，梯度就会爆炸：梯度过大导致难以收敛。 批标准化可以降低学习速率，因而有助于防止梯度爆炸。 ReLU 单元消失 一旦 ReLU 单元的加权和低于 0，ReLU 单元就可能会停滞。它会输出对网络输出没有任何贡献的 0 激活，而梯度在反向传播算法期间将无法再从中流过。由于梯度的来源被切断，ReLU 的输入可能无法作出足够的改变来使加权和恢复到 0 以上。 降低学习速率有助于防止 ReLU 单元消失。 丢弃正则化 这是称为丢弃的另一种形式的正则化，可用于神经网络。其工作原理是，在梯度下降法的每一步中随机丢弃一些网络单元。丢弃得越多，正则化效果就越强。 参考链接 人工神经网络,by wikipedia. 神经网络简介,by google. 一文详解神经网络 BP 算法原理及 Python 实现,by AI研习社. 反向传播算法动态演示, by google.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
        <tag>人工智能</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之相关概念]]></title>
    <url>%2F2018%2F11%2F19%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[机器学习是人工智能的一个分支。人工智能的研究历史有着一条从以“推理”为重点，到以“知识”为重点，再到以“学习”为重点的自然、清晰的脉络。显然，机器学习是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。 定义机器学习有下面几种定义： 机器学习是一门人工智能的科学，该领域的主要研究对象是人工智能，特别是如何在经验学习中改善具体算法的性能。 机器学习是对能通过经验自动改进的计算机算法的研究。 机器学习是用数据或以往的经验，以此优化计算机程序的性能标准。 一种经常引用的英文定义是：A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E. 分类机器学习可以分成下面几种类别： 监督学习：从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求是包括输入和输出，也可以说是特征和目标。训练集中的目标是由人标注的。常见的监督学习算法包括回归分析和统计分类。 监督学习和非监督学习的差别就是训练集目标是否人标注。他们都有训练集且都有输入和输出。 无监督学习：与监督学习相比，训练集没有人为标注的结果。常见的无监督学习算法有生成对抗网络（GAN）、聚类。 半监督学习：介于监督学习与无监督学习之间。 强化学习：通过观察来学习做成如何的动作。每个动作都会对环境有所影响，学习对象根据观察到的周围环境的反馈来做出判断。 算法具体的机器学习算法有： 构造间隔理论分布：聚类分析和模式识别 人工神经网络 决策树 感知器 支持向量机 集成学习AdaBoost 降维与度量学习 聚类 贝叶斯分类器 构造条件概率：回归分析和统计分类 高斯过程回归 线性判别分析 最近邻居法 径向基函数核 通过再生模型构造概率密度函数： 最大期望算法 概率图模型：包括贝叶斯网和Markov随机场 Generative Topographic Mapping 近似推断技术： 马尔可夫链 蒙特卡罗方法 变分法 最优化：大多数以上方法，直接或者间接使用最优化算法。 机器学习基础标签标签是我们要预测的事物，即简单线性回归中的 y 变量。标签可以是小麦未来的价格、图片中显示的动物品种、音频剪辑的含义或任何事物。 特征特征是输入变量，即简单线性回归中的 x 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征，按如下方式指定： \{ x_1,x_2,...x_N \}在垃圾邮件检测器示例中，特征可能包括： 电子邮件文本中的字词 发件人的地址 发送电子邮件的时段 电子邮件中包含“一种奇怪的把戏”这样的短语。 样本样本是指数据的特定实例：x。（我们采用粗体 x 表示它是一个矢量。）我们将样本分为以下两类： 有标签样本 无标签样本 有标签样本同时包含特征和标签，常用于训练模型。。即：1labeled examples: &#123;features, label&#125;: (x, y) 无标签样本包含特征，但不包含标签，常用于模型预测。即：1unlabeled examples: &#123;features, ?&#125;: (x, ?) 模型模型定义了特征与标签之间的关系。例如，垃圾邮件检测模型可能会将某些特征与“垃圾邮件”紧密联系起来。我们来重点介绍一下模型生命周期的两个阶段： 训练表示创建或学习模型。向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。 推断表示将训练后的模型应用于无标签样本。使用训练后的模型来做出有用的预测 (y’)。 回归与分类回归模型可预测连续值。例如，回归模型做出的预测可回答如下问题： 加利福尼亚州一栋房产的价值是多少？ 用户点击此广告的概率是多少？ 分类模型可预测离散值。例如，分类模型做出的预测可回答如下问题： 某个指定电子邮件是垃圾邮件还是非垃圾邮件？ 这是一张狗、猫还是仓鼠图片？ 损失训练模型表示通过有标签样本来学习（确定）所有权重和偏差的理想值。在监督式学习中，机器学习算法通过以下方式构建模型：检查多个样本并尝试找出可最大限度地减少损失的模型；这一过程称为经验风险最小化。 损失是对糟糕预测的惩罚。也就是说，损失是一个数值，表示对于单个样本而言模型预测的准确程度。如果模型的预测完全准确，则损失为零，否则损失会较大。训练模型的目标是从所有样本中找到一组平均损失“较小”的权重和偏差。 平方损失：又称为 $L_2$ 损失,一种常见的损失函数。例如单个样本的平方损失如下：123= the square of the difference between the label and the prediction= (observation - prediction(x))^2= (y - y&apos;)^2 均方误差 (MSE) 指的是每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量： MSE = \frac{1}{N} \sum_{(x,y)\in D} (y - prediction(x))^2其中： (x,y)指的是样本，其中 x指的是模型进行预测时使用的特征集（例如，温度、年龄和交配成功率）。 y指的是样本的标签（例如，每分钟的鸣叫次数）。 prediction(x)指的是权重和偏差与特征集 x 结合的函数。 D指的是包含多个有标签样本（即 (x,y)）的数据集。 N指的是D中的样本数量。 迭代方法下图显示了机器学习算法用于训练模型的迭代试错过程： 图1 用于训练模型的迭代方法 梯度下降法计算参数更新的目标是在模型的迭代试错过程中，使损失越来越小。而常用的方法就是梯度下降法。 图2 回归问题产生的损失与权重图为凸形 对于图2所示的凸形问题，刚好存在一个斜率正好为 0 的位置，即是损失函数的收敛之处。梯度下降法的第一个阶段是为$w_1$ 选择一个起始值（起点）。 然后，梯度下降法算法会计算损失曲线在起点处的梯度。简而言之，梯度是偏导数的矢量；它可以让您了解哪个方向距离目标“更近”或“更远”。 请注意，梯度是一个矢量，因此具有以下两个特征： 方向 大小 梯度始终指向损失函数中增长最为迅猛的方向。梯度下降法算法会沿着负梯度的方向走一步，以便尽快降低损失。 为了确定损失函数曲线上的下一个点，梯度下降法算法会将梯度大小的一部分与起点相加，如图3所示： 图3 一个梯度步长将我们移动到损失曲线上的下一个点 然后，梯度下降法会重复此过程，逐渐接近最低点。 学习速率梯度下降法算法用梯度乘以一个称为学习速率（有时也称为步长）的标量，以确定下一个点的位置。例如，如果梯度大小为 2.5，学习速率为 0.01，则梯度下降法算法会选择距离前一个点 0.025 的位置作为下一个点。 超参数是编程人员在机器学习算法中用于调整的旋钮。大多数机器学习编程人员会花费相当多的时间来调整学习速率。如果您选择的学习速率过小，就会花费太长的学习时间。如果您指定的学习速率过大，下一个点将永远在 U 形曲线的底部随意弹跳。 随机梯度下降法在梯度下降法中，批量指的是用于在单次迭代中计算梯度的样本总数。到目前为止，我们一直假定批量是指整个数据集。就 Google 的规模而言，数据集通常包含数十亿甚至数千亿个样本。此外，Google 数据集通常包含海量特征。因此，一个批量可能相当巨大。如果是超大批量，则单次迭代就可能要花费很长时间进行计算。 通过从我们的数据集中随机选择样本，我们可以通过小得多的数据集估算（尽管过程非常杂乱）出较大的平均值。 随机梯度下降法 (SGD) 将这种想法运用到极致，它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱。“随机”这一术语表示构成各个批量的一个样本都是随机选择的。 小批量随机梯度下降法（小批量 SGD）是介于全批量迭代与 SGD 之间的折衷方案。小批量通常包含 10-1000 个随机选择的样本。小批量 SGD 可以减少 SGD 中的杂乱样本数量，但仍然比全批量更高效。 泛化(Generalization)泛化是指机器学习对从真实概率分布（已隐藏）中抽取的新数据做出良好预测的能力。要取得良好的泛化能力，机器学习必须满足以下基本假设，同时防止过拟合。 机器学习的基本假设： 从分布中随机抽取独立同分布 (i.i.d) 的样本。换言之，样本之间不会互相影响。（另一种解释：i.i.d. 是表示变量随机性的一种方式）。 分布是平稳的；即分布在数据集内不会发生变化。 从同一分布的数据划分中抽取样本。 过拟合模型在训练过程中产生的损失很低，但在预测新数据方面的表现却非常糟糕。 训练集与测试集机器学习模型旨在根据以前未见过的新数据做出良好预测。但是，如果您要根据数据集构建模型，如何获得以前未见过的数据呢？一种方法是将您的数据集分成两个子集： 训练集 - 用于训练模型的子集。 测试集 - 用于测试模型的子集。 测试集应满足以下两个条件： 规模足够大，可产生具有统计意义的结果。 能代表整个数据集。换言之，挑选的测试集的特征应该与训练集的特征相同。 验证集将数据集划分为训练集和测试集两个子集是个不错的想法，但不是万能良方。通过将数据集划分为训练集、验证集、测试集三个子集，可以大幅降低过拟合的发生几率。 使用验证集评估训练集的效果。然后，在模型“通过”验证集之后，使用测试集再次检查评估结果。图4展示了这一新工作流程： 图4 使用验证集的工作流程 特征表示特征工程指的是将原始数据转换为特征矢量。进行特征工程预计需要大量时间。 映射数值: 机器学习模型根据浮点值进行训练，因此整数和浮点原始数据不需要特殊编码。 映射字符串值: 首先为要表示的所有特征的字符串值定义一个词汇表。然后使用该词汇表创建一个独热编码，用于将指定字符串值表示为二元矢量。 映射分类（枚举）值 图5 通过独热编码映射字符串值 良好特征的特点 避免很少使用的离散特征值。 良好的特征值应该在数据集中出现大约 5 次以上。这样一来，模型就可以学习该特征值与标签是如何关联的。 最好具有清晰明确的含义。 每个特征对于项目中的任何人来说都应该具有清晰明确的含义。例如，下面的房龄适合作为特征，可立即识别为年龄：1house_age: 27 不要将“神奇”的值与实际数据混为一谈 良好的浮点特征不包含超出范围的异常断点或“神奇”的值。例如，假设一个特征具有 0 到 1 之间的浮点值。那么，如下值是可以接受的：12quality_rating: 0.82quality_rating: 0.37 不过，如果用户没有输入 quality_rating，则数据集可能使用如下神奇值来表示不存在该值：1quality_rating: -1 为解决神奇值的问题，需将该特征转换为两个特征：123一个特征只存储质量评分，不含神奇值。一个特征存储布尔值，表示是否提供了 quality_rating。为该布尔值特征指定一个名称，例如 is_quality_rating_defined。 考虑上游不稳定性 特征的定义不应随时间发生变化。例如，下列值是有用的，因为城市名称一般不会改变。（注意，我们仍然需要将“br/sao_paulo”这样的字符串转换为独热矢量。）1city_id: &quot;br/sao_paulo&quot; 但收集由其他模型推理的值会产生额外成本。可能值“219”目前代表圣保罗，但这种表示在未来运行其他模型时可能轻易发生变化：1inferred_city_cluster: &quot;219&quot; 清理数据即使是非常少量的坏样本会破坏掉一个大规模数据集，因此需花费大量的时间挑出坏样本并加工可以挽救的样本。 缩放特征值: 缩放是指将浮点特征值从自然范围（例如 100 到 900）转换为标准范围（例如 0 到 1 或 -1 到 +1）。如果特征集包含多个特征，则缩放特征可以带来以下优势： 帮助梯度下降法更快速地收敛。 帮助避免“NaN 陷阱”。 帮助模型为每个特征确定合适的权重。 处理极端离群值 对每个值取对数 将最大值“限制”为某个任意值 分箱 清查 数据集中的很多样本是不可靠的，原因有以下一种或多种： 遗漏值。 例如，有人忘记为某个房屋的年龄输入值。 重复样本。 例如，服务器错误地将同一条记录上传了两次。 不良标签。 例如，有人错误地将一颗橡树的图片标记为枫树。 不良特征值。 例如，有人输入了多余的位数，或者温度计被遗落在太阳底下。 正则化图6泛化曲线显示的是训练集和验证集相对于训练迭代次数的损失。 图6 训练集和验证集损失 图6显示的是某个模型的训练损失逐渐减少，但验证损失最终增加。换言之，该泛化曲线显示该模型与训练集中的数据过拟合。根据奥卡姆剃刀定律，或许我们可以通过降低复杂模型的复杂度来防止过拟合，这种原则称为正则化。 正则化以最小化损失和复杂度为目标，这称为结构风险最小化： \text{minimize(Loss(Data|Model) + complexity(Model))}现在，训练优化算法是一个由两项内容组成的函数：一个是损失项，用于衡量模型与数据的拟合度，另一个是正则化项，用于衡量模型复杂度。 有两种常用衡量模型复杂度的方法： 将模型复杂度作为模型中所有特征的权重的函数。 将模型复杂度作为具有非零权重的特征总数的函数。 如果模型复杂度是权重的函数，则特征权重的绝对值越高，对模型复杂度的贡献就越大。 L2正则化可以使用 L2 正则化公式来量化复杂度，该公式将正则化项定义为所有特征权重的平方和： L_2\text{ regularization term} = ||\boldsymbol w||_2^2 = {w_1^2 + w_2^2 + ... + w_n^2}在这个公式中，接近于 0 的权重对模型复杂度几乎没有影响，而离群值权重则可能会产生巨大的影响。 模型开发者通过以下方式来调整正则化项的整体影响：用正则化项的值乘以名为 lambda（又称为正则化率）的标量。也就是说，模型开发者会执行以下运算： \text{minimize(Loss(Data|Model)} + \lambda \text{ complexity(Model))}执行 L2 正则化对模型具有以下影响: 使权重值接近于 0（但并非正好为 0） 使权重的平均值接近于 0，且呈正态（钟形曲线或高斯曲线）分布。 在选择 lambda 值时，目标是在简单化和训练数据拟合之间达到适当的平衡： 如果您的 lambda 值过高，则模型会非常简单，但是您将面临数据欠拟合的风险。您的模型将无法从训练数据中获得足够的信息来做出有用的预测。 如果您的 lambda 值过低，则模型会比较复杂，并且您将面临数据过拟合的风险。您的模型将因获得过多训练数据特点方面的信息而无法泛化到新数据。 L1正则化稀疏矢量通常包含许多维度。创建特征组合会导致包含更多维度。由于使用此类高维度特征矢量，因此模型可能会非常庞大，并且需要大量的 RAM。 在高维度稀疏矢量中，最好尽可能使权重正好降至 0。正好为 0 的权重基本上会使相应特征从模型中移除。 将特征设为 0 可节省 RAM 空间，且可以减少模型中的噪点。 L1 正则化使模型中很多信息缺乏的系数正好为 0，从而在推理时节省 RAM，同时具有凸优化的优势，可有效进行计算。 L2 和 L1 采用不同的方式降低权重： L2 会降低权重2。 L1 会降低 |权重|。 因此，L2 和 L1 具有不同的导数： L2 的导数为 2 * 权重。 L1 的导数为 k（一个常数，其值与权重无关）。 逻辑回归许多问题需要将概率估算值作为输出。逻辑回归是一种极其高效的概率计算机制。实际上，您可以通过下两种方式之一使用返回的概率： “按原样” 转换成二元类别。 在很多情况下，您会将逻辑回归输出映射到二元分类问题的解决方案，该二元分类问题的目标是正确预测两个可能的标签（例如，“垃圾邮件”或“非垃圾邮件”）中的一个。 您可能想知道逻辑回归模型如何确保输出值始终落在 0 和 1 之间。巧合的是，S 型函数生成的输出值正好具有这些特性，其定义如下： y = \frac{1}{1 + e^{-z}}S 型函数会产生以下曲线图： 图7 S 型函数 如果 z 表示使用逻辑回归训练的模型的线性层的输出，则 S 型(z) 函数会生成一个介于 0 和 1 之间的值（概率）。用数学方法表示为： y' = \frac{1}{1 + e^{-(z)}}其中： y’ 是逻辑回归模型针对特定样本的输出。 z 是 b + w1x1 + w2x2 + … wNxN “w”值是该模型学习的权重和偏差。 “x”值是特定样本的特征值。 请注意，z 也称为对数几率，因为 S 型函数的反函数表明，z 可定义为标签“1”（例如“狗叫”）的概率除以标签“0”（例如“狗不叫”）的概率得出的值的对数： z = log(\frac{y}{1-y})逻辑回归模型训练线性回归的损失函数是平方损失。逻辑回归的损失函数是对数损失函数，定义如下： Log Loss = \sum_{(x,y)\in D} -ylog(y') - (1 - y)log(1 - y')其中： (xy)ϵD 是包含很多有标签样本 (x,y) 的数据集。 “y”是有标签样本中的标签。由于这是逻辑回归，因此“y”的每个值必须是 0 或 1。 “y’”是对于特征集“x”的预测值（介于 0 和 1 之间）。 对数损失函数的方程式与 Shannon 信息论中的熵测量密切相关。它也是似然函数的负对数（假设“y”属于伯努利分布）。实际上，最大限度地降低损失函数的值会生成最大的似然估计值。 正则化在逻辑回归建模中极其重要。如果没有正则化，逻辑回归的渐近性会不断促使损失在高维度空间内达到 0。因此，大多数逻辑回归模型会使用以下两个策略之一来降低模型复杂性： L2 正则化。 早停法，即，限制训练步数或学习速率。 分类指定阈值为了将逻辑回归值映射到二元类别，您必须指定分类阈值（也称为判定阈值）。如果值高于该阈值，则表示“垃圾邮件”；如果值低于该阈值，则表示“非垃圾邮件”。人们往往会认为分类阈值应始终为 0.5，但阈值取决于具体问题，因此您必须对其进行调整。 真与假以及正类别与负类别 真正例是指模型将正类别样本正确地预测为正类别。 真负例是指模型将负类别样本正确地预测为负类别。 假正例是指模型将负类别样本错误地预测为正类别 假负例是指模型将正类别样本错误地预测为负类别。 准确率准确率是一个用于评估分类模型的指标。通俗来说，准确率是指我们的模型预测正确的结果所占的比例。正式点说，准确率的定义如下： \text{Accuracy} = \frac{\text{Number of correct predictions}}{\text{Total number of predictions}}对于二元分类，也可以根据正类别和负类别按如下方式计算准确率： \text{Accuracy} = \frac{TP+TN}{TP+TN+FP+FN}其中，TP = 真正例，TN = 真负例，FP = 假正例，FN = 假负例。 精确率和召回率当使用分类不平衡的数据集（比如正类别标签和负类别标签的数量之间存在明显差异）时，单单准确率一项并不能反映全面情况。这时需要能够更好地评估分类不平衡问题的指标：精确率和召回率。 精确率的定义如下： \text{Precision} = \frac{TP}{TP+FP}从数学上讲，召回率的定义如下： \text{Recall} = \frac{TP}{TP+FN}要全面评估模型的有效性，必须同时检查精确率和召回率。遗憾的是，精确率和召回率往往是此消彼长的情况。 ROC 和曲线下面积ROC 曲线（接收者操作特征曲线）是一种显示分类模型在所有分类阈值下的效果的图表。该曲线绘制了以下两个参数： 真正例率 假正例率 真正例率 (TPR) 是召回率的同义词，因此定义如下： TPR = \frac{TP} {TP + FN}假正例率 (FPR) 的定义如下： FPR = \frac{FP} {FP + TN}ROC 曲线用于绘制采用不同分类阈值时的 TPR 与 FPR。降低分类阈值会导致将更多样本归为正类别，从而增加假正例和真正例的个数。下图显示了一个典型的 ROC 曲线。 图8 不同分类阈值下的 TP 率与 FP 率 曲线下面积表示“ROC 曲线下面积”。也就是说，曲线下面积测量的是从 (0,0) 到 (1,1) 之间整个 ROC 曲线以下的整个二维面积（参考积分学）。 图9 曲线下面积（ROC 曲线下面积） 曲线下面积对所有可能的分类阈值的效果进行综合衡量。曲线下面积的一种解读方式是看作模型将某个随机正类别样本排列在某个随机负类别样本之上的概率。 曲线下面积的取值范围为 0-1。预测结果 100% 错误的模型的曲线下面积为 0.0；而预测结果 100% 正确的模型的曲线下面积为 1.0。 曲线下面积因以下两个原因而比较实用： 曲线下面积的尺度不变。它测量预测的排名情况，而不是测量其绝对值。 曲线下面积的分类阈值不变。它测量模型预测的质量，而不考虑所选的分类阈值。 不过，这两个原因都有各自的局限性，这可能会导致曲线下面积在某些用例中不太实用： 并非总是希望尺度不变。 例如，有时我们非常需要被良好校准的概率输出，而曲线下面积无法告诉我们这一结果。 并非总是希望分类阈值不变。 在假负例与假正例的代价存在较大差异的情况下，尽量减少一种类型的分类错误可能至关重要。例如，在进行垃圾邮件检测时，您可能希望优先考虑尽量减少假正例（即使这会导致假负例大幅增加）。对于此类优化，曲线下面积并非一个实用的指标。 预测偏差逻辑回归预测应当无偏差。即: \text{预测平均值}\approx\text{观察平均值}预测偏差指的是这两个平均值之间的差值。即： \text{预测偏差} = \text{预测平均值} - \text{数据集中相应标签的平均值}造成预测偏差的可能原因包括： 特征集不完整 数据集混乱 模型实现流水线中有错误？ 训练样本有偏差 正则化过强 参考链接 机器学习，by wikipedia. 机器学习速成课程，by google. MathJax使用LaTeX语法编写数学公式教程]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机视觉之相机成像原理与坐标系转换]]></title>
    <url>%2F2018%2F11%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E4%B9%8B%E7%9B%B8%E6%9C%BA%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[计算机视觉是一门研究用摄影机和计算机代替人眼对目标进行识别、跟踪和测量的学科。为了解该门学科，首先应掌握投影原理和世界坐标系、相机坐标系、图像坐标系、像素坐标系之间的转换关系。 三维投影计算机3D图形学中，三维投影是将三维空间中的点映射到二维平面上的方法。常用三维投影有正交投影和透视投影。正交投影通常用于对现实物品的三维建模，而透视投影与人的视觉系统类似，常用于在二维平面呈现三维世界。 正交投影原理正交投影是一系列用于显示三维物体的轮廓、细节或精确测量结果的变换方法。通常又称作截面图、鸟瞰图或立面图。 当视平面的法向（即摄像机的朝向）平行于笛卡尔坐标系三根坐标轴中的一根，数学变换定义如下： 若使用一个平行于y轴（侧视图）的正交投影将三维点 $a{x}$, $a{y}$,$a{z}$投影到二维平面上得到二维点 $b{x}$,$b_{y}$，可以使用如下公式 b_x=s_xa_x+c_xb_y=s_za_z+c_z其中向量s是一个任意的缩放因子，而c是一个任意的偏移量。这些常量可自由选择，通常用于将视口调整到一个合适的位置。该投影变换同样可以使用矩阵表示（为清晰起见引入临时向量d） \begin{bmatrix} d_x \\ d_y \\ \end{bmatrix} = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & 1 \\ \end{bmatrix} \begin{bmatrix} a_x \\ a_y \\ a_z \\ \end{bmatrix} \begin{bmatrix} b_x\\ b_y\\ \end{bmatrix} = \begin{bmatrix} s_x & 0 \\ 0 & s_z \\ \end{bmatrix} \begin{bmatrix} d_x\\ d_y\\ \end{bmatrix} + \begin{bmatrix} c_x\\ c_z\\ \end{bmatrix}虽然正交投影产生的图像在一定程度上反映了物体的三维特性，但此类投影图像和实际观测到的并不相同。特别是对于相同长度的平行线段，无论离虚拟观察者（摄像机）远近与否，它们都会在正交投影中显示为相同长度。这会导致较近的线段看起来被缩短了。 透视投影原理透视投影是为了获得接近真实三维物体的视觉效果而在二维的纸或者画布平面上绘图或者渲染的一种方法，它也称为透视图。透视投影的绘制必须根据已有的几何规则进行。 常用的透视投影视椎体模型如图1所示。设视点E位于原点，视平面P垂直于Z轴，且四边分别平行于x轴和y轴，视椎体的近截面离视点的距离为n，远截面离视点的距离为f，且一般取近截面为视平面。 图1 透视投影的标准视椎体模型 坐标系之间的转换计算机视觉通常涉及到四个坐标系：像素平面坐标系（u,v）、像平面坐标系（图像物理坐标第（x,y）、相机坐标系（Xc,Yc,Zc）和世界坐标系（Xw,Yw,Zw），如图2所示。 图2 四个坐标系 1 : 世界坐标系：根据情况而定，可以表示任何物体。单位m。 2：相机坐标系：以摄像机光心为原点（在针孔模型中也就是针孔为光心），z轴与光轴重合也就是z轴指向相机的前方（也就是与成像平面垂直），x轴与y轴的正方向与物体坐标系平行，其中上图中的f为摄像机的焦距。单位m 3：图像物理坐标系（也叫平面坐标系）：用物理单位表示像素的位置，坐标原点为摄像机光轴与图像物理坐标系的交点位置。坐标系为图上o-xy。单位是mm。单位毫米的原因是此时由于相机内部的CCD传感器是很小的，比如8mm x 6mm。但是最后图像照片是也像素为单位比如640x480.这就涉及到了图像物理坐标系与像素坐标系的变换了。下面的像素坐标系将会讲到。 4：像素坐标系：以像素为单位，坐标原点在左上角。这也是一些opencv，OpenGL等库的坐标原点选在左上角的原因。当然明显看出CCD传感器以mm单位到像素中间有转换的。举个例子，CCD传感上上面的8mm x 6mm，转换到像素大小是640x480. 假如dx表示像素坐标系中每个像素的物理大小就是1/80. 也就是说毫米与像素点的之间关系是piexl/mm. 世界坐标系到相机坐标系的转换物体之间的坐标系变换都可以表示坐标系的旋转变换加上平移变换，则世界坐标系到相机坐标系的转换关系也是如此，他们之间的变换如图3所示。 图3 世界坐标系到相机坐标系的转换 可以得到P点在相机坐标系下的坐标: \begin{bmatrix} X_c\\ Y_c\\ Z_c\\ \end{bmatrix} = R \begin{bmatrix} X_w\\ Y_w\\ Z_w\\ \end{bmatrix} +T \Rightarrow \begin{bmatrix} X_c\\ Y_c\\ Z_c\\ 1\\ \end{bmatrix} = \begin{bmatrix} R & T\\ \vec{0} & 1\\ \end{bmatrix} \begin{bmatrix} X_w\\ Y_w\\ Z_w\\ 1\\ \end{bmatrix} , R:3*3,T:3*1相机坐标系到图像物理坐标系的转换从相机坐标系到图像坐标系，属于透视投影关系，从3D转换到2D。 也可以看成是针孔模型的变种。该转换满足三角形的相似定理，如图4所示。 图4 相机坐标系到图像物理坐标系的转换 图像物理坐标系到像素坐标系的转换图像物理坐标系到像素坐标系的转换不涉及旋转变换，但是坐标原点位置不一致，大小不一致，涉及伸缩变换及平移变换，如图5所示。 图5 图像物理坐标系到像素坐标系的转换 小结四个坐标系之间存在着下述关系 ( 矩阵依次左乘 )，如图6所示: 图6 世界坐标系到像素坐标系的转换 其中相机的内参和外参可以通过张正友标定获取。通过最终的转换关系来看，一个三维中的坐标点，的确可以在图像中找到一个对应的像素点，但是反过来，通过图像中的一个点找到它在三维中对应的点就很成了一个问题，因为我们并不知道等式左边的Zc的值。 参考链接 三维投影,by wikipedia. 透视投影的原理和实现,by Goncely. 计算机视觉：相机成像原理：世界坐标系、相机坐标系、图像坐标系、像素坐标系之间的转换,by 生活没有if-else 【相机标定】四个坐标系之间的变换关系]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>计算机视觉</tag>
        <tag>透视投影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活中的统计学之购买车展黄牛票]]></title>
    <url>%2F2018%2F11%2F17%2F%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%8B%E8%B4%AD%E4%B9%B0%E8%BD%A6%E5%B1%95%E9%BB%84%E7%89%9B%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[前段时间去看车展，一出地铁口，就有黄牛兜售车展门票，只需30元一张，而从车展正规窗口购买需要50元一张，那么买黄牛票还是买正规车展门票呢？ 黄牛票有可能是真的，这样我就只需30元就可以参观车展，也有可能是假的，这样我就得花80元才能参观车展。假设黄牛票为真的概率是p1，根据概率论的知识，我参观车展花费的期望是： E = 30*p_1+80*(1-p_1)在没有任何先验知识的前提下，假设黄牛票为真的概率是0.5，于是每次买黄牛票参观车展的花费期望是55，而每次买正规门票参观车展的花费期望是50，因此不建议买黄牛票，而应该去买正规车展门票。 参考链接 Cmd Markdown 公式指导手册 Markdown中写数学公式]]></content>
      <tags>
        <tag>概率论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国电信光猫华为HG8245C开启IPV6的方法]]></title>
    <url>%2F2018%2F11%2F11%2F%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1%E5%85%89%E7%8C%AB%E5%8D%8E%E4%B8%BAHG8245C%E5%BC%80%E5%90%AFIPV6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[据报道，目前中国电信已成功创建了IP骨干网全面支持IPv6，并且在4G网络开启了IPv6服务，在100多个城域网提供了IPv6服务[1]。那么如何使家里宽带用上IPv6服务呢？这个问题最关键是设置入户光猫使其支持IPv6。以如何光猫华为HG8245C为例，说明设置过程。 基础知识IPv6简介网际协议第6版（英文：Internet Protocol version 6，缩写：IPv6）是网际协议（IP）的最新版本，用作互联网的网上层协议，用它来取代IPv4主要是为了解决IPv4地址枯竭问题，不过它也在其他很多方面对IPv4有所改进。 IPv6格式IPv6二进位制下为128位长度，以16位为一组，每组以冒号“:”隔开，可以分为8组，每组以4位十六进制方式表示。例如：2001:0db8:85a3:08d3:1319:8a2e:0370:7344 是一个合法的IPv6地址。 同时IPv6在某些条件下可以省略： 每项数字前导的0可以省略，省略后前导数字仍是0则继续，例如下组IPv6是等价的。 123452001:0DB8:02de:0000:0000:0000:0000:0e132001:DB8:2de:0000:0000:0000:0000:e132001:DB8:2de:000:000:000:000:e132001:DB8:2de:00:00:00:00:e132001:DB8:2de:0:0:0:0:e13 可以用双冒号“::”表示一组0或多组连续的0，但只能出现一次。 1234567* 2001:DB8:2de:0:0:0:0:e13 2001:DB8:2de::e13* 2001:0DB8:0000:0000:0000:0000:1428:57ab 2001:0DB8:0000:0000:0000::1428:57ab 2001:0DB8:0:0:0:0:1428:57ab 2001:0DB8:0::0:1428:57ab 2001:0DB8::1428:57ab 如果这个地址实际上是IPv4的地址，后32位可以用10进制数表示；因此::ffff:192.168.89.9 相等于::ffff:c0a8:5909。 IPv6地址分类常用地址IPv6地址可分为三种: 单播（unicast）地址：单播地址标示一个网上接口。协议会把送往地址的数据包送往给其接口。 任播（anycast）地址: Anycast是IPv6特有的数据发送方式，它像是IPv4的Unicast（单点传播）与Broadcast（多点广播）的综合。 多播（multicast）地址: 多播地址也称组播地址。多播地址也被指定到一群不同的接口，送到多播地址的数据包会被发送到所有的地址。 特殊地址未指定地址 ::/128－所有比特皆为零的地址称作未指定地址。 链路本地地址 ::1/128－是一种单播绕回地址。如果一个应用程序将数据包送到此地址，IPv6堆栈会转送这些数据包绕回到同样的虚拟接口（相当于IPv4中的127.0.0.1/8）。 fe80::/10－这些链路本地地址指明，这些地址只在区域连线中是合法的，这有点类似于IPv4中的169.254.0.0/16。 唯一区域位域 fc00::/7－唯一区域地址（ULA，unique local address）只可在一群网站中绕送。 多播地址 ff00::/8－这个前置表明定义在”IP Version 6 Addressing Architecture”（RFC 4291）中的多播地址[ IPv4转译地址 ::ffff:x.x.x.x/96－用于IPv4映射地址。 2001::/32－用于Teredo隧道。 2002::/16－用于6to4。 IPv6优势 巨大的地址空间 新的协议头格式，加快路由速度 有效地、分级的寻址和路由结构 有状态和无状态的地址配置 内置的安全性 更好的支持Qos 用新协议处理邻节点的交互 可扩展性 设置华为光猫HG8245C开启IPv6步骤在设置华为光猫HG8245C开启IPv6之前，一是要确保所在电信已支持IPv6服务。二是获取华为HG8245C隐藏管理员帐号telecomadmin的密码。 以隐藏管理员帐号telecomadmin登录华为HG8245C的Web管理控制台后，选择“网络-&gt;宽带设置”，选择连接”2INTERNET_R_VID“,设置协议类型为“IPv4/IPv6”，设置前缀获取方式为“DHCPv6-PD”,再点应用即可。 在Debian Linux中打开终端，输入如下命令或者浏览网站http://test-ipv6.com/验证IPv6。123456789101112131415$ ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether e4:70:b8:30:f1:5b brd ff:ff:ff:ff:ff:ff inet 192.168.1.100/24 brd 192.168.1.255 scope global dynamic noprefixroute wlan0 valid_lft 251566sec preferred_lft 251566sec inet6 240e:bc:e60:3d00:ea5b:f704:6b65:fab1/64 scope global dynamic noprefixroute valid_lft 258984sec preferred_lft 172584sec inet6 fe80::4e2c:4397:f016:3eb4/64 scope link noprefixroute valid_lft forever preferred_lft forever 参考链接 中国电信：IPv6在线用户已超千万 年底将完成端到端服务能力.2018-07-16 维基百科.IPv6 掌握IPv6网络协议的优势,2010-06-10]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习之SFTP管理文件]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8BSFTP%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[当需要向树莓派发送文件时，可使用SFTP上传下载文件。下面介绍如何使用SFTP向树莓派发送下载文件。 基础知识SFTP是Secure File Transfer Protocol的缩写，安全文件传送协议。可以为传输文件提供一种安全的网络的加密方法。sftp 与 ftp 有着几乎一样的语法和功能。 SFTP 为 SSH的其中一部分，是一种传输文件至服务器的安全方式。在SSH软件包中，已经包含了一个叫作SFTP(Secure File Transfer Protocol)的安全文件信息传输子系统，SFTP本身没有单独的守护进程，它必须使用sshd守护进程（端口号默认是22）来完成相应的连接和答复操作。 SFTP传输使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SFTP代替FTP。 SFTP客户端程序在Windows平台，常用的SFTP客户端程序有： FileZilla WinSCP Xftp Core FTP 在Linux平台，可直接使用sftp命令进行连接服务器。 基本操作下面介绍在Debian平台使用sftp命令连接树莓派，在此之前应配置树莓派开启ssh服务。 建立连接 使用如下命令连接树莓派：1sftp pi@192.168.0.103 查看帮助 通过help查看在sftp连接下能使用的命令。从帮助中可知，在命令前加前缀“l”或者“！”即可在本地操作系统shell执行命令。12345678910111213141516171819202122232425262728293031323334sftp&gt; helpAvailable commands:bye Quit sftpcd path Change remote directory to &apos;path&apos;chgrp grp path Change group of file &apos;path&apos; to &apos;grp&apos;chmod mode path Change permissions of file &apos;path&apos; to &apos;mode&apos;chown own path Change owner of file &apos;path&apos; to &apos;own&apos;df [-hi] [path] Display statistics for current directory or filesystem containing &apos;path&apos;exit Quit sftpget [-afPpRr] remote [local] Download filereget [-fPpRr] remote [local] Resume download filereput [-fPpRr] [local] remote Resume upload filehelp Display this help textlcd path Change local directory to &apos;path&apos;lls [ls-options [path]] Display local directory listinglmkdir path Create local directoryln [-s] oldpath newpath Link remote file (-s for symlink)lpwd Print local working directoryls [-1afhlnrSt] [path] Display remote directory listinglumask umask Set local umask to &apos;umask&apos;mkdir path Create remote directoryprogress Toggle display of progress meterput [-afPpRr] local [remote] Upload filepwd Display remote working directoryquit Quit sftprename oldpath newpath Rename remote filerm path Delete remote filermdir path Remove remote directorysymlink oldpath newpath Symlink remote fileversion Show SFTP version!command Execute &apos;command&apos; in local shell! Escape to local shell? Synonym for help 下载远程文件到本地主机使用get命令下载远程文件到本地主机：123sftp&gt; get README.TXT Fetching /home/pi/wiringPi/README.TXT to README.TXT/home/pi/wiringPi/README.TXT 100% 606 39.1KB/s 00:00 get命令还有一些有用参数，如递归选项“ -r ”来递归的复制一个文件夹里面的内容，“ -P ”或者“ -p ”参数来告诉 SFTP 保持文件的权限访问位的设置和访问时间。 上传本地文件到远程主机使用“ put ”命令将文件上传到远程主机：123sftp&gt; put README.TXT Uploading README.TXT to /home/pi/README.TXTREADME.TXT 100% 606 33.6KB/s 00:00 ” put “具有类似“ get ”的参数。例如，递归选项“ -r ”可以上传整个文件夹。 参考文献 华华. 手把手教你使用 SFTP 安全地传输文件.2015-12-5.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium摄像头跟踪飞机实体时晃动问题分析]]></title>
    <url>%2F2018%2F11%2F08%2FCesium%E6%91%84%E5%83%8F%E5%A4%B4%E8%B7%9F%E8%B8%AA%E9%A3%9E%E6%9C%BA%E5%AE%9E%E4%BD%93%E6%97%B6%E6%99%83%E5%8A%A8%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在3D场景下使用Cesium跟踪飞机时会出现摄像头晃动问题，导致地图背景不断晃动，影响观看。下面以最新的Cesium1.51源码为例，解析Cesium 渲染过程原理，分析跟踪实体时摄像头晃动的原因，找出可能的解决方法。 Cesium渲染过程分析使用Cesium最简单示例代码如下：1var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;); Viewer是Cesium构建应用的最基础的组件。它又是其他组件的容器，包括： animation:控制时间前进、倒退、暂停以及前进和倒退速度的组件 baseLayerPicker：图层选择组件 fullscreenButton：控制是否全屏的组件 vrButton：控制是否VR显示的组件 geocoder：地理位置搜索组件 homeButton：返回摄像头默认位置按钮组建 infoBox：信息框组件 sceneModePicker：场景模式选择组件 selectionIndicator：选择指示组件 timeline：时间线组件 navigationHelpButton：导航帮助按钮，告诉使用者如何使用鼠标和触摸屏操纵虚拟地球 CesiumWidget：虚拟地球组件 其中，虚拟地球组件CesiumWidget是Viewer包含核心组件，在Viewer中创建CesiumWidget对象时，将设置其useDefaultRenderLoop属性。设置该属性将启动渲染函数startRenderLoop。1234567891011121314//from Source/Widgets/CesiumWidget/CesiumWidget.jsuseDefaultRenderLoop : &#123; get : function() &#123; return this._useDefaultRenderLoop; &#125;, set : function(value) &#123; if (this._useDefaultRenderLoop !== value) &#123; this._useDefaultRenderLoop = value; if (value &amp;&amp; !this._renderLoopRunning) &#123; startRenderLoop(this); &#125; &#125; &#125;&#125;, 函数startRenderLoop是Cesium渲染的开始，其代码如下：12345678910111213141516171819202122232425262728293031323334353637function startRenderLoop(widget) &#123; widget._renderLoopRunning = true; var lastFrameTime = 0; function render(frameTime) &#123; if (widget.isDestroyed()) &#123; return; &#125; if (widget._useDefaultRenderLoop) &#123; try &#123; var targetFrameRate = widget._targetFrameRate; if (!defined(targetFrameRate)) &#123; widget.resize(); widget.render(); requestAnimationFrame(render); &#125; else &#123; var interval = 1000.0 / targetFrameRate; var delta = frameTime - lastFrameTime; if (delta &gt; interval) &#123; widget.resize(); widget.render(); lastFrameTime = frameTime - (delta % interval); &#125; requestAnimationFrame(render); &#125; &#125; catch (error) &#123; ... &#125; &#125; else &#123; widget._renderLoopRunning = false; &#125; &#125; requestAnimationFrame(render);&#125; CesiumWidget组件的render方法随后调用Scene的render方法。12345678910111213141516171819202122232425262728293031323334353637383940414243Scene.prototype.render = function(time) &#123; if (!defined(time)) &#123; time = JulianDate.now(); &#125; var frameState = this._frameState; this._jobScheduler.resetBudgets(); var cameraChanged = this._view.checkForCameraUpdates(this); var shouldRender = !this.requestRenderMode || this._renderRequested || cameraChanged || this._logDepthBufferDirty || (this.mode === SceneMode.MORPHING); if (!shouldRender &amp;&amp; defined(this.maximumRenderTimeChange) &amp;&amp; defined(this._lastRenderTime)) &#123; var difference = Math.abs(JulianDate.secondsDifference(this._lastRenderTime, time)); shouldRender = shouldRender || difference &gt; this.maximumRenderTimeChange; &#125; if (shouldRender) &#123; this._lastRenderTime = JulianDate.clone(time, this._lastRenderTime); this._renderRequested = false; this._logDepthBufferDirty = false; var frameNumber = CesiumMath.incrementWrap(frameState.frameNumber, 15000000.0, 1.0); updateFrameNumber(this, frameNumber, time); &#125; // Update this._preUpdate.raiseEvent(this, time); tryAndCatchError(this, update); this._postUpdate.raiseEvent(this, time); if (shouldRender) &#123; // Render this._preRender.raiseEvent(this, time); tryAndCatchError(this, render); RequestScheduler.update(); &#125; updateDebugShowFramesPerSecond(this, shouldRender); callAfterRenderFunctions(this); if (shouldRender) &#123; this._postRender.raiseEvent(this, time); &#125; &#125;; Scene的render方法中tryAndCatchError函数将调用render函数。在该render函数中，地球的主要要素（地形&amp;影像）的渲染，将在Globe的beginFrame和endFrame之间完成的。123456789101112131415161718192021222324function render(scene) &#123; ... if (defined(scene.globe)) &#123; scene.globe.beginFrame(frameState); &#125; updateEnvironment(scene); updateAndExecuteCommands(scene, passState, backgroundColor); resolveFramebuffers(scene, passState); passState.framebuffer = undefined; executeOverlayCommands(scene, passState); if (defined(scene.globe)) &#123; scene.globe.endFrame(frameState); if (!scene.globe.tilesLoaded) &#123; scene._renderRequested = true; &#125; &#125; ...&#125; 其中updateAndExecuteCommands负责数据的调度，比如哪些Tile需要创建，这些Tile相关的地形数据，以及涉及到的影像数据之间的调度，都是在该函数中维护。而scene.globe.endFrame中，会对该帧所涉及的GlobeTile的下载，解析等进行处理。 Cesium跟踪实体在Viewer组件构造函数内，Viewer订阅了场景组件Scene的渲染后事件postRender，以执行Viewer自己的_postRender函数。1eventHelper.add(scene.postRender, Viewer.prototype._postRender, this); Viewer的_postRender函数代码如下，其中updateTrackedEntity函数将更新被跟踪实体的摄像头位置：1234Viewer.prototype._postRender = function() &#123; updateZoomTarget(this); updateTrackedEntity(this);&#125;; updateTrackedEntity函数代码如下：1234567891011121314151617181920212223242526272829303132333435363738function updateTrackedEntity(viewer) &#123; if (!viewer._needTrackedEntityUpdate) &#123; return; &#125; var trackedEntity = viewer._trackedEntity; var currentTime = viewer.clock.currentTime; //Verify we have a current position at this time. This is only triggered if a position //has become undefined after trackedEntity is set but before the boundingSphere has been //computed. In this case, we will track the entity once it comes back into existence. var currentPosition = Property.getValueOrUndefined(trackedEntity.position, currentTime); if (!defined(currentPosition)) &#123; return; &#125; var scene = viewer.scene; var state = viewer._dataSourceDisplay.getBoundingSphere(trackedEntity, false, boundingSphereScratch); if (state === BoundingSphereState.PENDING) &#123; return; &#125; var sceneMode = scene.mode; if (sceneMode === SceneMode.COLUMBUS_VIEW || sceneMode === SceneMode.SCENE2D) &#123; scene.screenSpaceCameraController.enableTranslate = false; &#125; if (sceneMode === SceneMode.COLUMBUS_VIEW || sceneMode === SceneMode.SCENE3D) &#123; scene.screenSpaceCameraController.enableTilt = false; &#125; var bs = state !== BoundingSphereState.FAILED ? boundingSphereScratch : undefined; viewer._entityView = new EntityView(trackedEntity, scene, scene.mapProjection.ellipsoid); viewer._entityView.update(currentTime, bs); viewer._needTrackedEntityUpdate = false;&#125; 除此之外，Viewer组件订阅了Clock组建的onTick事件，以执行其自身的_onTick事件处理函数：1eventHelper.add(clock.onTick, Viewer.prototype._onTick, this); 在Viewer组件的_onTick事件处理函数中，同样会更新被跟踪实体的摄像头位置。而Cesium摄像头跟踪飞机实体时产生晃动的根源即在此处。12345678910111213141516171819Viewer.prototype._onTick = function(clock) &#123; var time = clock.currentTime; var isUpdated = this._dataSourceDisplay.update(time); if (this._allowDataSourcesToSuspendAnimation) &#123; this._clockViewModel.canAnimate = isUpdated; &#125; var entityView = this._entityView; if (defined(entityView)) &#123; var trackedEntity = this._trackedEntity; var trackedState = this._dataSourceDisplay.getBoundingSphere(trackedEntity, false, boundingSphereScratch); if (trackedState === BoundingSphereState.DONE) &#123; entityView.update(time, boundingSphereScratch); &#125; &#125; ... &#125;; 可行的解决方案在Viewer组件的_onTick函数做如下修改：1234567891011121314151617181920212223Viewer.prototype._onTick = function(clock) &#123; var time = clock.currentTime; var isUpdated = this._dataSourceDisplay.update(time); if (this._allowDataSourcesToSuspendAnimation) &#123; this._clockViewModel.canAnimate = isUpdated; &#125; var entityView = this._entityView; if (defined(entityView)) &#123; var trackedEntity = this._trackedEntity; var trackedState = this._dataSourceDisplay.getBoundingSphere(trackedEntity, false, boundingSphereScratch); if (trackedState === BoundingSphereState.DONE) &#123; //entityView.update(time, boundingSphereScratch); var range=this.camera.distanceToBoundingSphere(boundingSphereScratch); var targetRange=range&gt;boundingSphereScratch.radius*10?range:boundingSphereScratch.radius*10; var offset=new HeadingPitchRange(0.0,-Math.toRadians(45.0),targetRange); this.camera.viewBoundingSphere(boundingSphereScratch,offset) &#125; &#125; ... &#125;; 参考文献 http://www.cnblogs.com/fuckgiser/p/5744509.html, by 法克鸡丝]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习之远程登录]]></title>
    <url>%2F2018%2F11%2F07%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[每次通过USB转串口登录树莓派比较麻烦，可以设置树莓派开启ssh和vnc服务，以便通过ssh或vnc远程登录树莓派。下面介绍在Debian中通过ssh或vnc远程登录树莓派的过程。 基础知识SSHSecure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。 SSH基本用法1234# 以用户名user，登录远程主机host$ ssh user@host# SSH的默认端口是22。使用p参数，可以修改这个端口。$ ssh -p 2222 user@host SSH通信过程及风险SSH采用了公钥加密保证安全。 整个过程是这样的：（1）远程主机收到用户的登录请求，把自己的公钥发给用户。（2）用户使用这个公钥，将登录密码加密后，发送回来。（3）远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 这个过程本身是安全的，但是实施的时候存在”中间人攻击”风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。 VNCVNC（Virtual Network Computing），为一种使用RFB协议的显示屏画面分享及远程操作软件。此软件借由网上，可发送键盘与鼠标的动作及即时的显示屏画面。 VNC与操作系统无关，因此可跨平台使用，例如可用Windows连线到某Linux的计算机，反之亦同。甚至在没有安装客户端程序的计算机中，只要有支持JAVA的浏览器，也可使用。 原理VNC系统由客户端，服务端和一个协议组成 VNC的服务端目的是分享其所运行机器的屏幕，服务端被动的允许客户端控制它。VNC客户端（或Viewer）观察控制服务端，与服务端交互。VNC协议Protocol（RFB）是一个简单的协议，传送服务端的原始图像到客户端（一个X,Y位置上的正方形的点阵数据），客户端传送事件消息到服务端。 服务器发送小方块的帧缓存给客户端，在最简单的情况，VNC协议使用大量的带宽，因此各种各样的方法被发明出来减少通讯的开支，举例来说，有各种各样的编码方法来决定最有效率的方法来传送这些点阵方块。 VNC默认使用TCP端口5900至5906，而JAVA的VNC客户端使用5800至5806。一个服务端可以在5900端口用“监听模式”连接一个客户端，使用监听模式的一个好处是服务端不需要设置防火墙。 安全性VNC并非是安全的协议，虽然VNC伺服程序需设置密码才可接受外来连线，且VNC客户端与VNC伺服程序之间的密码传输经过加密，但仍可被轻易的拦截到并使用暴力破解法破解。不过VNC可设计以SSH或VPN传输，以增加安全性。 VNC软件由于VNC以GPL授权，派生出了几个VNC软件： RealVNC：由VNC团队部分成员开发，分为全功能商业版及免费版。 TightVNC：强调节省带宽使用。 UltraVNC：加入了TightVNC的部分程序及加强性能的图型映射驱动程序，并结合Active Directory及NTLM的账号密码认证，但仅有Windows版本。 Vine Viewer：MacOSX的VNC客户端。 配置树莓派支持SSH和VNC通过USB转串口登录树莓派后，按如下步骤开启SSH和VNC： 运行命令raspi-config 1sudo raspi-config 选择第五项Interfacing Options 选择enable SSH 启用SSH，重复步骤一和二，再选择enable VNC。 通过SSH或VNC连接树莓派debian主机与树莓派在同一个局域网内，则按如下步骤通过SSH或VNC连接树莓派。 通过nmap命令获取树莓派ip地址1234567891011$ nmap 192.168.0.1/24Starting Nmap 7.70 ( https://nmap.org ) at 2018-11-08 13:08 CSTNmap scan report for 192.168.0.103Host is up (0.041s latency).Not shown: 998 closed portsPORT STATE SERVICE22/tcp open ssh5900/tcp open vncNmap done: 256 IP addresses (6 hosts up) scanned in 35.77 seconds 开启22和5900端口的主机即是树莓派。 通过ssh远程登录树莓派 12# 首次登录会给出主机认证不能建立的提示，输入yes可继续，再输入用户密码即可远程登录树莓派$ ssh pi@192.168.0.103 通过vnc远程登录树莓派 通过ssh登录树莓派后查看其使用的vnc程序 123$ apt list --installed | grep vncrealvnc-vnc-server/now 6.3.1.36657 armhf [已安装，可升级至：6.3.2.39069]# 可知，树莓派上使用realvnc程序 在Debian上安装realvnc客户端程序realvnc-vnc-viewer 在终端输入vncviewer，输入树莓派ip、用户名、密码即可登录树莓派 参考文献 http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html， by 阮一峰 https://zh.wikipedia.org/zh-hans/Secure_Shell， by wikipedia https://zh.wikipedia.org/zh-hans/VNC， by wikipedia]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习之USB转串口]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E4%B9%8BUSB%E8%BD%AC%E4%B8%B2%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[最近研究树莓派，需要通过usb转串口去连接树莓派，然后设置其wifi连接。于是将用到计算机硬件知识整理一下，并记录通过usb转串口设置树莓派wifi连接的过程。 硬件知识计算机硬件常用接口有并口和串口，对应串行通信和并行通信。串行通信（英语：Serial communication）是指在计算机总线或其他数据信道上，每次传输一个比特数据，并连续进行以上单次过程的通信方式。与之对应的是并行通信，它在串行端口上通过一次同时传输若干比特数据的方式进行通信。 串行通信被用于长距离通信以及大多数计算机网络，在这些应用场合里，电缆和同步化使并行通信实际应用面临困难。凭借着其改善的信号完整性和传播速度，串行通信总线正在变得越来越普遍，甚至在短程距离的应用中，其优越性已经开始超越并行总线不需要串行化组件(serializer)，并解决了诸如时钟偏移（Clock skew）、互联密度（interconnect density）等缺点。PCI到PCI Express的升级就一个例子。 并口并行接口，简称并口。并口采用的是25针D形接头。所谓“并行”，是指8位数据同时通过并行线进行传送，这样数据传送速度大大提高，但并行传送的线路长度受到限制，因为长度增加，干扰就会增加，数据也就容易出错，目前，并行接口主要作为打印机端口等。 串口串口叫做串行接口，也称串行通信接口，即COM口。按电气标准及协议来分包括RS-232-C、RS-422、RS485、USB等。 RS-232-C、RS-422与RS-485标准只对接口的电气特性做出规定，不涉及接插件、电缆或协议。 串行端口可以用于连接外置调制解调器、绘图仪或串行打印机。它也可以控制台连接的方式连接网络设备，例如路由器和交换机，主要用来配置它们。 RS-232-C 也称标准接口，是目前最常用的一种串行通讯接口。它是在1970年由美国电子工业协会（EIA）联合贝尔系统、 调制解调器厂家及计算机终端生产厂家共同制定的用于串行通讯的标准。 传统的RS-232-C接口标准有22根线，采用标准25芯D型插头座。自IBM PC/AT开始使用简化了的9芯D型插座。计算机一般有两个串行口：COM1和COM2，9针D形接口通常在计算机后面能看到。现在有很多手机数据线或者物流接收器都采用COM口与计算机相连。 RS-422 为改进RS-232通信距离短、速率低的缺点，RS-422定义了一种平衡通信接口，将传输速率提高到10Mb/s，传输距离延长到4000英尺（速率低于100kb/s时），并允许在一条平衡总线上连接最多10个接收器。 RS-485 为扩展应用范围，EIA又于1983年在RS-422基础上制定了RS-485 标准，增加了多点、双向通信能力，即允许多个发送器连接到同一条总线上，同时增加了发送器的驱动能力和冲突保护特性，扩展了总线共模范围，后命名为 TIA/EIA-485-A标准。 Universal Serial Bus（通用串行总线） 简称USB，是目前计算机上应用较广泛的接口规范，由Intel、Microsoft、Compaq、IBM、NEC、Northern Telcom等几家大厂商发起的新型外设接口标准。USB接口是计算机主板上的一种四针接口，其中中间两个针传输数据，两边两个针给外设供电。USB接口速度快、连接简单、不需要外接电源，传输速度12Mbps，新的USB 2.0可达480Mbps；电缆最大长度5米，USB电缆有4条线：2条信号线，2条电源线，可提供5伏特电源，USB电缆还分屏蔽和非屏蔽两种，屏蔽电缆传输速度可达12Mbps，价格较贵，非屏蔽电缆速度为1.5Mbps，但价格便宜；USB通过串联方式最多可串接127个设备；支持热插拔。最新的规格是USB 3.1。 RJ-45接口 是以太网最为常用的接口，RJ45是一个常用名称，指的是由IEC(60)603-7标准化，使用由国际性的接插件标准定义的8个位置（8针）的模块化插孔或者插头。 USB转串口原理硬件接口电气特性 TTL电平：一般用作数字芯片的电平，例如芯片的供电电压是5V，那么高电平就是5V，低电平就是0V，这里所说的电平，就是TTL电平。 232电平：232电平特制电脑串口的电平，-12V左右为正电平，+12V左右为低电平。我们刚才所见到的“USB转串口线”和电脑原生的串口，就是232电平。 USB转串口方法PC的串口电气特性是232电平，单片机的串口电气特性是TTL电平，这两个就不一样，肯定需要某个芯片或者电路来进行转换匹配才可以通信。这个时候我们就需要TTL转232芯片了，常见的是MAX232,MAX3232等。连接方式如下: 但是随着USB接口的普及，当前计算机已经取消了串口。为实现232到TTL的转换，又需要USB转232。连接方式如下： 为简化，可将USB转232和232转TTL集成到一个芯片上。这样的芯片常见的有CH340、PL2303。连接方式如下： 常见的CH340芯片如下图所示： 通过USB转串口连接树莓派下面介绍在Debian Linux主机通过USB转串口连接树莓派的过程。 配置树莓派开启串口通信将树莓派操作系统镜像烧录到SD卡后，打开boot分区，编辑其config.txt，在其末尾添加如下代码，以开启串口通信权限。1enable_uart=1 通过USB转串口物理连接树莓派通过将USB转串口将Debian主机和树莓派物理连接好之后，给树莓派加电启动。 查看Debian系统能否识别ch340芯片在官方Linux内核版本中自Kernel2.6以后就默认包含了对CH340/CH341芯片的驱动支持。在系统的默认驱动目录/lib/modules/$(uname -r)/kernel/drivers内可找到ch340芯片的驱动文件ch341.ko。 使用命令lsusb或dmesg查看linux系统是否识别USB转串口硬件。12345678~$ lsusbBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 001 Device 005: ID 0bda:0129 Realtek Semiconductor Corp. RTS5129 Card Reader ControllerBus 001 Device 004: ID 8087:0a2a Intel Corp. Bus 001 Device 003: ID 1bcf:2b8a Sunplus Innovation Technology Inc. Bus 001 Device 006: ID 1a86:7523 QinHeng Electronics HL-340 USB-Serial adapterBus 001 Device 002: ID 046d:c062 Logitech, Inc. M-UAS144 [LS1 Laser Mouse]Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub Bus 001 Device 006: ID 1a86:7523 QinHeng Electronics HL-340 USB-Serial adapter表明Linux系统识别了usb转串口线缆，芯片类型为HL-340。 ‘dmesg’命令显示linux内核的环形缓冲区信息，我们可以从中获得诸如系统架构、cpu、挂载的硬件，RAM等多个运行级别的大量的系统信息。当计算机启动时，系统内核（操作系统的核心部分）将会被加载到内存中。在加载的过程中会显示很多的信息，在这些信息中我们可以看到内核检测硬件设备。运行dmesg，输出如下：1234567891011~$ sudo dmesg | tail[ 4248.441104] usbcore: registered new interface driver usbserial_generic[ 4248.441112] usbserial: USB Serial support registered for generic[ 4248.456079] usbcore: registered new interface driver ch341[ 4248.456088] usbserial: USB Serial support registered for ch341-uart[ 4248.456097] ch341 1-3:1.0: ch341-uart converter detected[ 4248.456464] usb 1-3: ch341-uart converter now attached to ttyUSB0[ 4284.405593] i2c_hid i2c-ELAN1010:00: i2c_hid_get_input: incomplete report (14/65535)[ 4284.407844] i2c_hid i2c-ELAN1010:00: i2c_hid_get_input: incomplete report (14/65535)[ 4657.772761] i2c_hid i2c-ELAN1010:00: i2c_hid_get_input: incomplete report (14/65535)[ 4657.774969] i2c_hid i2c-ELAN1010:00: i2c_hid_get_input: incomplete report (14/65535) [ 4248.456097] ch341 1-3:1.0: ch341-uart converter detected;[ 4248.456464] usb 1-3: ch341-uart converter now attached to ttyUSB0说明linux系统识别了usb转串口适配器，并附加到ttyUSB0文件上。 使用minicom连接树莓派minicom是linux平台的串行通信程序，类似于windows的超级终端程序。1234567891011121314151617181920212223242526272829$ usermod -a -G dialout $USER#首次运行minicom使用-s选项，用于设置串行通信参数$ minicom -s+-----[configuration]------+| Filenames and paths || File transfer protocols || Serial port setup || Modem and dialing || Screen and keyboard || Save setup as dfl || Save setup as.. || Exit || Exit from Minicom |+--------------------------+#通过上下键选择Serial port setup+----------------------------------- +| A - Serial Device : /dev/ttyUSB0 || B - Lockfile Location : /var/lock || C - Callin Program : || D - Callout Program : || E - Bps/Par/Bits : 115200 8N1 || F - Hardware Flow Control : Yes || G - Software Flow Control : No || || Change which setting? |+----------------------------------+# 设置Serial Device为/dev/ttyUSB0，然后推出到上一界面，使用enter键Save setup as dfl，保存配置。下次即可直接运行minicom使用之前保存的配置进行串口通信 # 这时候要选择单独Exit（退出），不要选择Exit from Minicom（退出Minicom），不然你就把minicom关了。# 这时即可连接树莓派。 连接上树莓派后，输入用户名pi和密码raspberry，即可进入系统。1234567891011121314151617Raspbian GNU/Linux 9 raspberrypi ttyS0 raspberrypi login: pi Password: Last login: Tue Oct 9 13:12:40 UTC 2018 on tty1 Linux raspberrypi 4.14.71-v7+ #1145 SMP Fri Sep 21 15:38:35 BST 2018 armv7l The programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Wi-Fi is disabled because the country is not set. Use raspi-config to set the country before use. pi@raspberrypi:~$ 退出minicom，按Ctrl＋A，再按下X键，会提示你是否退出，yes就可以了。 配置树莓派wifi连接查看周围wifi热点信息1pi@raspberrypi:~$ iwlist scan 配置连接到wifi热点123456789101112# 编辑wifi文件pi@raspberrypi:~$ sudo vi /etc/wpa_supplicant/wpa_supplicant.conf# 在该文件最后添加下面的话network=&#123; ssid=&quot;WIFINAME&quot; psk=&quot;password&quot;&#125;# 引号部分分别为wifi的名字和密码# 重启系统pi@raspberrypi:~$ sudo init 6# 登录后查看是否连接成功pi@raspberrypi:~$ ip addr 参考文献 https://www.cnblogs.com/zcshan/archive/2010/12/03/com.html ,by 水寒 https://zh.wikipedia.org/wiki串行端口 , by wikipedia https://blog.csdn.net/he_wen_jie/article/details/50983076. by hwj666 https://linux.cn/article-3587-1.html , by linux中国 https://blog.csdn.net/JAZZSOLDIER/article/details/70170466 ， by SoldierJazz2018 http://blog.51cto.com/irinilu/289622, by feng9422 Pipci. Linux 串口终端调试工具minicom[EB/OL].https://blog.csdn.net/Pipcie/article/details/79379451, 2018-02-26. https://blog.csdn.net/huayucong/article/details/51376279， by huayucong USB转串口CH340接线方法,2015-11-03.]]></content>
      <tags>
        <tag>树莓派</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派操作系统镜像烧录方法指南]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E7%83%A7%E5%BD%95%E6%96%B9%E6%B3%95%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[树莓派是一个微型计算机硬件平台，为使其正常工作还需要安装操作系统。通常将树莓派操作系统烧录到SD卡上，再将SD卡插到树莓派上。加电启动后，树莓派就会从SD卡引导启动操作系统，开始工作。这里SD卡就相当于普通计算机的硬盘。下面记录在Debian Linux下烧录树莓派操作系统到SD卡的方法。 镜像烧录工具EtcherEtcher是树莓派官方推荐的镜像烧录工具。它采用图形界面，支持Windows、Linux、Mac，使用简单方便，推荐普通用户使用。 ddLinux的dd命令用于复制文件并对原文件的内容进行转换和格式化处理。dd命令功能很强大的，对于一些比较底层的问题，使用dd命令往往可以得到出人意料的效果。用的比较多的还是用dd来备份裸设备。同样也可用dd命令烧录系统镜像。 使用dd命令必须非常小心，如果输出指定了错误分区，将摧毁该分区的所有数据。 Linux下镜像烧录过程使用Etcher烧录镜像比较简单，重点介绍使用dd命令烧录镜像的方法。 查找sd卡设备可使用lsblk或者fdisk命令查找sd卡存储设备。需要注意的是： 块设备以/dev/sdX命名，其中X是小写字母，例如/dev/sda。 测试时发现当计算机只有usb3.0接口时，将不识别usb2.0的sd读卡器。 烧录镜像到sd卡将镜像烧录到sd卡使用如下dd命令将树莓派镜像少量到sd卡：1dd bs=4M if=2018-10-09-raspbian-stretch.img of=/dev/sdX conv=fsync 其中： if=文件名：输入文件名，缺省为标准输入。即指定源文件。 of=文件名：输出文件名，缺省为标准输出。即指定目的文件。 bs=bytes：同时设置读入/输出的块大小为bytes个字节。 conv=conversion：用指定的参数转换文件。 将压缩镜像烧录到sd卡当文件系统不支持大于4GB的文件时，可使用利用管道技术烧录镜像，命令如下：1unzip -p 2018-10-09-raspbian-stretch.zip | sudo dd of=/dev/sdX bs=4M conv=fsync 检查烧录进度默认情况下dd命令不给出烧录进度信息，最新的dd提供status=progress选项给出进度信息，命令如下：1dd bs=4M if=2018-10-09-raspbian-stretch.img of=/dev/sdX status=progress conv=fsync 或者可使用dcfldd命令替换dd进行烧录操作。 检查镜像是否正确的烧录到sd卡先使用dd命令将sd卡中内容复制到硬盘，在使用diff或者md5sum检查镜像文件与sd卡内容镜像之间的一致性。 之前dd命令烧录镜像到sd卡完成后会在shell中输出如下结果：123xxx+0 records inyyy+0 records outyyyyyyyyyy bytes (yyy kB, yyy KiB) copied, 0.00144744 s, 283 MB/s xxx是我们需要的，表示读取xxx块记录烧录到sd卡，xxx乘以bs=4M应该等于原始镜像的大小。 使用如下命令复制sd卡内容到硬盘上：12# 经测试count命令没有其作用，该命令将整个sd内容复制到了硬盘，但我们期望只复制之前烧录到sd卡内容dd bs=4M if=/dev/sdX of=from-sd-card.img count=xxx 如果from-sd-card.img文件大于原始镜像文件，那么先使用truncate命令将from-sd-card.img缩小到原始镜像文件的大小，命令如下：1truncate --reference 2018-10-09-raspbian-stretch.img from-sd-card.img 使用diff命令比较两者直接的一致性，如果不一致，可能烧录过程中有错误。1diff -s from-sd-card.img 2018-10-09-raspbian-stretch.img 使用sync命令强制将缓存写入硬盘，然后umount sd卡文件系统，最后移除sd卡。 参考文献 https://www.raspberrypi.org/documentation/installation/installing-images/linux.md, by raspberrypi. https://blog.csdn.net/liumang_D/article/details/3899462, by liumang_d. https://linux.cn/article-8024-1.html, by linux中国 https://www.jianshu.com/p/ff09ceffa816, by 二石兄.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派学习笔记]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[WiringPi简介WiringPi是应用于树莓派平台的GPIO控制库函数，WiringPi遵守GUN Lv3。wiringPi使用C或者C++开发并且可以被其他语言包转，例如python、ruby或者PHP等。WiringPi中的函数类似于Arduino的wiring系统，这使得熟悉arduino的用户使用wringPi更为方便。 树莓派具有26个普通输入和输出引脚。在这26个引脚中具有8个普通输入和输出管脚，这8个引脚既可以作为输入管脚也可以作为输出管脚。除此之外，树莓派还有一个2线形式的I2C、一个4线形式的SPI和一个UART接口。树莓派上的I2C和SPI接口也可以作为普通端口使用。如果串口控制台被关闭便可以使用树莓派上的UART功能。如果不使用I2C，SPI和UART等复用接口，那么树莓派总共具有8+2+5+2 =17个普通IO。 wiringPi包括一套gpio控制命令，使用gpio命令可以控制树莓派GPIO管脚。用户可以利用gpio命令通过shell脚本控制或查询GPIO管脚。wiringPi是可以扩展的，可以利用wiringPi的内部模块扩展模拟量输入芯片，可以使用MCP23x17/MCP23x08（I2C 或者SPI）扩展GPIO接口。另外可通过树莓派上的串口和Atmega（例如arduino等）扩展更多的GPIO功能。另外，用户可以自己编写扩展模块并把自定义的扩展模块集成到wiringPi中。WiringPi支持模拟量的读取和设置功能，不过在树莓派上并没有模拟量设备。但是使用WiringPi中的软件模块却可以轻松地应用AD或DA芯片。 I2CI²C（Inter-Integrated Circuit）字面上的意思是集成电路之间，它其实是I²C Bus简称，所以中文应该叫集成电路总线，它是一种串行通信总线，使用多主从架构，由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。I²C的正确读法为“I平方C”（”I-squared-C”），而“I二C”（”I-two-C”）则是另一种错误但被广泛使用的读法。自2006年10月1日起，使用I²C协议已经不需要支付专利费，但制造商仍然需要付费以获取I²C从属设备地址。 设计说明I²C只使用两条双向漏极开路（Open Drain）（串行数据（SDA）及串行时钟频率（SCL））并利用电阻将电位上拉。I²C允许相当大的工作电压范围，但典型的电压准位为+3.3V或+5v。 I²C的参考设计使用一个7比特长度的地址空间但保留了16个地址，所以在一组总线最多可和112个节点通信[a]。常见的I²C总线依传输速率的不同而有不同的模式：标准模式（100 Kbit/s）、低速模式（10 Kbit/s），但时钟频率可被允许下降至零，这代表可以暂停通信。而新一代的I²C总线可以和更多的节点（支持10比特长度的地址空间）以更快的速率通信：快速模式（400 Kbit/s）、高速模式（3.4 Mbit/s）。 虽然最大的节点数目是被地址空间所限制住，但实际上也会被总线上的总电容所限制住，一般而言为400 pF。 如上所述，参考设计为使用串行数据线（SDA）和串行时钟线（SCL）、拥有7bit寻址空间的总线。 总线上有两种类型角色的节点： 主节点 - 产生时钟并发起与从节点的通信 从节点 - 接收时钟并响应主节点的寻址 该总线是一种多主控总线，即可以在总线上放置任意多主节点。此外，在停止位（STOP）发出后，一个主节点也可以成为从节点，反之亦然。 总线上有四种不同的操作模式，虽然大部分设备只作为一种角色和使用其中两种操作模式： 主节点发送 - 主节点发送数据给从节点 主节点接收 - 主节点接收从节点数据 从节点发送 - 从节点发送数据给主节点 从节点接收 - 从节点接收主节点数据 一开始，主节点处于主节点发送模式，发送起始位（START），跟着发送希望与之通信的从节点的7bit位地址，最后再发送一个bit读写位，该数据位表示主节点想要与从节点进行读（1）还是写（0）操作。 如果从节点在总线上，它将以ACK字符比特位应答（低有效）该地址。主节点收到应答后，根据它发送的读写位，处于发送模式或者接收模式，从节点则处于对应的相反模式（接收或发送）。 地址和数据首先发送最高有效位。 起始位在SCL位高时，由SDA上电平从高变低表示；停止位在SCL为高时，由SDA上电平从低变高表示。其他SDA上的电平变化在SCL为低时发生。 如果主节点想要向从节点写数据，它将发送一个字节，然后从节点以ACK位应答，如此重复。此时，主节点处于主节点发送模式，从节点处于从节点接收模式。 如果主节点想要读取从节点数据，它将不断接收从节点发送的一个个字节，在收到每个字节后发送ACK进行应答，除了接收到的最后一个字节。此时，主节点处于主节点接收模式，从节点处于从节点发送模式。 此后，主节点要么发送停止位终止传输，要么发送另一个START比特以发起另一次传输（即“组合消息”）。 应用I²C被应用在简单且其制造成本较传输速度更为重要的外设上。一些常见的应用如下： 为了保存用户的设置而访问NVRAM芯片。 访问低速的数字模拟转换器（DAC）。 访问低速的模拟数字转换器（ADC）。 改变监视器的对比度、色调及色彩平衡设置（视频数据通道）。 改变音量大小。 获取硬件监视及诊断数据，例如中央处理器的温度及风扇转速。 读取实时时钟（Real-time clock）。 在系统设备中用来打开或关闭电源供应。 I²C的另一个强大用途在于微控制器的应用，利用两根通用的输入输出接脚及软件的规划，可以让微控制器控制一个小型网络。 外设可以在系统仍然在运作的同时加入或移出总线，这代表对于有热插拔需求的设备而言是个理想的总线。 像I²C这样的总线之所以流行起来，是因为计算机工程师发现到对于集成电路设计而言，许多的制造成本源自于封装尺寸及接脚数量。更小的包装通常能够减少重量及电源的消耗，这对于移动电话及手持式计算机而言格外重要。 UART在通信和计算机科学中，Serial communication是一个通用概念，泛指所有的串行的通信协议，如RS232、USB、I2C、SPI、1-Wire、Ethernet等。这里的串行（serial），是相对并行通信（parallel communication）来说的，如下图： 理解串行通信的概念之后，大家可能会有疑问：接收方接收到一长串的、表示0/1电平跳变的信号之后，怎么还原出有效的信息呢？有两种方法： 发送端在发送串行数据的同时，提供一个时钟信号，并按照一定的约定（例如在时钟信号的上升沿的时候，将数据发送出去）发送数据，接收端根据发送端提供的时钟信号，以及大家的约定，接收数据。这就是常说的同步串行通信（Synchronous serial communication），I2C、SPI等有时钟信号的协议，都属于这种通信方式。本文不再详述。 发送端在数据发送之前和之后，通过特定形式的信号（例如START信号和STOP信号），告诉接收端，可以开始（或者停止）接收数据了。与此同时，收发两方会约定一个数据发送的速度（就是大名鼎鼎的波特率），发送端在发送START信号之后，就按照固定的节奏发送串行数据，与此同时，接收端在收到START信号之后，也按照固定的节奏接收串行数据。这就是常说的异步串行通信（Asynchronous serial communication），我们本节的主角——串口通信，就是这种通信方式。 UART(Universal Asynchronous Receiver/Transmitter) 即是规定编码格式、bit rate，产生通信所需的bit流的标准。 SPI串行外设接口（Serial Peripheral Interface Bus，SPI），是一种用于短程通信的同步串行通信接口规范，主要应用于单片机系统中。类似I²C。 这种接口首先被Motorola（摩托罗拉）公司开发，然后发展成了一种行业规范。典型应用包含SD卡和液晶显示器。 SPI设备之间使用全双工模式通信，包含一个主机和一个或多个从机。主机产生待读或待写的帧数据，多个从机通过一个片选线路 决定哪个来响应主机的请求。 有时SPI接口被称作四线程接口，SPI准确来讲称为同步串行接口，但是与同步串行接口协议（SSI）不同，SSI是一个四线程 同步通信协议，但是使用差分信号输入同时仅提供一个单工通信信道。 接口SPI总线规定了4个保留逻辑信号接口： SCLK（Serial Clock）：串列时脉，由主机发出 MOSI（Master Output,Slave Input）：主机输出从机输入信号，由主机发出 MISO（Master Input,Slave Output）：主机输入从机输出信号，由从机发出 SS（Slave Selected）：选择信号，由主机发出，一般是低电位有效 尽管上面的引脚名称是最常用的，但在过去，有时会使用其他引脚命名约定，因此旧IC产品的SPI端口引脚名称可能有所不同。 1-Wire1-Wire是Maxim子公司达拉斯半导体的专利技术，仅用单一信号线就可像I²C、SPI一样，传输时钟（clock）又传输数据（data），并且数据传输是双向的。1-Wire使用较低的数据传输速率，通常是用来沟通小型设备，如数字温度计。1-Wire有两种速率：标准模式16kbps，驱动模式142kbps。 单总线只有一根数据线。设备主机或从机通过一个漏极开路或三态端口连接至该数据线，这样允许设备在不发送数据时释放数据总线，以便总线被其它设备所使用。单总线端口为漏极开路其内部等效电路如下图所示。 参考文献 树莓派学习笔记——wiringPi简介、安装和管脚说明 , by xukai871105. I²C, by wikipedia. UART、RS232、TTL关系浅析, by 老狼. 串行外设接口,by wikipedia. 1-Wire,by wikipedia. 1-Wire单总线的基本原理,by ce123. 解析单总线协议（1-wire）,by zhengqijun_.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>树莓派</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian下编译QGroundControl源码]]></title>
    <url>%2F2018%2F11%2F01%2FDebian%E4%B8%8B%E7%BC%96%E8%AF%91QGroundControl%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[MAVLink（Micro Air Vehicle Link，微型空中飞行器链路通讯协议）是无人飞行器与地面站之间通讯，以及无人飞行器之间通讯最常用的协议。它已经在PX4、APM、PIXHAWK和Parrot AR.Drone飞控平台上进行了大量测试。 QGroundControl则是一种操纵基于MAVLink通信协议的无人机的跨平台地面站开源软件。下面记录在Debian Linux下从源码编译QGroundControl的过程。 下载源码1234# 下载QGroundControl源码git clone --recursive https://github.com/mavlink/qgroundcontrol.git# 更新子模块git submodule update 安装编译环境 下载Qt社区版在线安装器，安装5.11.0版本的Qt，安装路径可在/opt下。 安装必要的包 1sudo apt-get install speech-dispatcher libudev-dev libsdl2-dev 解决编译时libQt5PositioningQuick.so.5不存在的bug 123sudo apt-get install libqt5positioningquick5sudo find /usr/ -name libQt5PositioningQuick.so.5cp /usr/lib/x86_64-linux-gnu/libQt5PositioningQuick.so.5 /opt/Qt/5.10.0/gcc_64/lib/libQt5PositioningQuick.so.5 将当前用户添加到dialout组，获取串口访问权限 12# 运行QGroundControl需要当前用户拥有串口访问权限sudo usermod -a -G dialout $USER 编译运行打开Qt Creater，打开qgroundcontrol.pro工程，构建后运行，即可打开QGroundControl地面站软件。 参考链接 https://blog.csdn.net/hebbely/article/details/79022799, by hebbely https://dev.qgroundcontrol.com/en/getting_started/, by Dronecode]]></content>
      <tags>
        <tag>linux</tag>
        <tag>无人机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令用法总结]]></title>
    <url>%2F2018%2F11%2F01%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[记录一些常用的linux命令用法，以备查询。 查找文件 12345# find基本语法：find [PATH] [option] [action]find /usr/lib -name libQt5Xml.so# 使用通配符find /usr/lib -name &quot;*ssl*&quot; 批量转换文件格式 1234567# 将png格式图像转换为jpg# -1 – 告诉 ls 每行列出一个图像名称的选项标识# -n – 指定最多参数个数，例子中为 1# -c – 指示 bash 运行给定的命令# $&#123;0%.png&#125;.jpg – 设置新转换的图像文件的名字，% 符号用来删除源文件的扩展名ls -1 *.png | xargs -n 1 bash -c &apos;convert &quot;$0&quot; &quot;$&#123;0%.png&#125;.jpg&quot;&apos; 修改用户 12# 将用户$USER添加到dialout用户组，以获取串口访问权限sudo usermod -a -G dialout $USER 校验文件 下载的文件最好校验完整性，防止被人篡改。以sha256sum为例： 1234#以下命令将生成树莓派映像的sha256哈希码，从树莓派官网复制该映像sha256哈希码，以便校验。当然通常应该会提供映像的哈希码校验文件。sha256sum 2018-10-09-raspbian-stretch.zip &gt;2018-10-09-raspbian-stretch.zip.sha256sum#使用下面校验文件的完整性，如果成功则映像与官方一致，未被篡改。注意被校验文件与校验文件应放在同一个目录。sha256sum -c 2018-10-09-raspbian-stretch.zip.sha256sum 特殊符号用法 123456789#| 管道 (pipeline)，是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。who | wc -l#! 惊叹号(negate or reverse)，通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表&quot;不等于&quot;#下例代表显示除了a0, a1 .... a9 这几个文件的其他文件。ls a[!0-9]#&amp; 后台工作，单一个&amp; 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。tar cvfz data.tar.gz data &gt; /dev/null &amp; 转换和复制文件命令 Linux的dd命令用于复制文件并对原文件的内容进行转换和格式化处理。12345678读指定物理扇区：dd if=&lt;源设备&gt; of=&lt;输出设备或文件&gt; skip=&lt;指定扇区值&gt; bs=512 count=1写指定物理扇区：dd if=&lt;输入设备或文件&gt; of=&lt;输出设备&gt; seek=&lt;指定扇区值&gt; bs=512 count=1读取sd启动扇区示例：dd if=/dev/mmcblk0 of=mbrsd.data bs=512 count=1]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用tensorflow_object_detection_api训练自定义模型]]></title>
    <url>%2F2018%2F10%2F20%2F%E4%BD%BF%E7%94%A8tensorflow-object-detection-api%E8%AE%AD%E7%BB%83%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[近期研究目标对象检测和识别，发现谷歌开源的基于tensorflow的object detection api模型效果不错，于是git clone下来测试一下。下面记录我在debian linux上安装配置object detection api模型，构建自定义数据集，训练和测试object detection api模型的过程，以及整个过程中遇到的一下问题，需要注意的事项。 准备工作docker安装TensorFlow 程序在 GPU 上的运行速度通常要比在 CPU 上快得多，在系统满足NVIDIA 软件要求的前提下，推荐使用支持 GPU 的 TensorFlow。 官方推荐使用Docker简化TensorFlow的GPU支持配置，这样只需要linux主机安装好Nvidia GPU驱动即可。 安装docker安装docker的方法可参考链接1。 安装nvidia-docker 123456789# Add the package repositoriescurl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -curl -s -L https://nvidia.github.io/nvidia-docker/debian9/nvidia-docker.list | \ sudo tee /etc/apt/sources.list.d/nvidia-docker.listsudo apt-get update# Install nvidia-docker2 and reload the Docker daemon configurationsudo apt-get install -y nvidia-docker2sudo service docker restart 下载最新支持GPU和Python3的tensorflow映像[2] 1docker pull tensorflow/tensorflow:latest-gpu-py3 测试tensorflow映像 12docker run --runtime=nvidia -it --rm tensorflow/tensorflow:latest-gpu-py3 \ python -c &quot;import tensorflow as tf; print(tf.contrib.eager.num_gpus())&quot; 下载TFModel库及其相关库1234# 基于tensorflow的模型和例子git clone https://github.com/tensorflow/models.git# raccoon数据集，可参考其中生成TFRecord格式数据的方法git clone https://github.com/datitran/raccoon_dataset.git 安装Python虚拟环境管理工具1234# 具体安装配置过程参见链接3sudo pip3 install virtualenvsudo pip3 install virtualenvwrappermkvirtualenv object-detection --python=/usr/bin/python3# 创建python3虚拟环境 数据标注以分类几何形状为例，收集相关图片后，需要对它们进行标注。推荐使用 LabelImg 进行标注，生成的文件是 PASCAL VOC 的 xml 格式。这个工具还可以加载标注文件，检查标注结果[3]。123456789git clone https://github.com/tzutalin/labelImg.gitworkon object-detection# 启动python3虚拟环境workon object-detection# 安装配置labelImgsudo apt-get install pyqt5-dev-toolssudo pip3 install -r requirements/requirements-linux-python3.txtmake qt5py3python3 labelImg.py 除了标注图片，还需创建一个 .pbtxt 文件用来说明标注的分类。例如：123456789101112item &#123; id: 1 name: &apos;circle&apos;&#125;item &#123; id: 2 name: &apos;square&apos;&#125;item &#123; id: 3 name: &apos;triangle&apos;&#125; 需要特别注意以下两点： name 不支持直接写中文，需要 UTF-8 编码 id 从 1 开始编号，不能从 0 开始编号。 数据准备标注好的数据是图片文件（.jpg）和标注文件（.xml），而 TensorFlow 不能直接用这些数据作为输入，还需要转成 TFRecord 格式。可采用两种方法生成TFRecord格式数据： tensorflow/models中方法 项目中使用create_pascal_tf_record.py, create_pet_tf_record.py生成TFrecord 格式数据 raccoon_dataset中方法 项目中使用xml_to_csv.py把xml合并成一个CSV文件，使用split labels.ipynb 随机划分训练集和测试集，以及使用generate_tfrecord.py 生成相对应的 TFRecord 训练集和测试集。123456789workon object-detection# 将生成geometry_labels.csvpython xml_to_csv.py# 打开split labels.ipynb生产训练集train_labels.csv和测试集test_labels.csvjupyter notebook# 创建训练用TFRecord文件:python generate_tfrecord.py --csv_input=data/train_labels.csv --output_path=training/geometry_train.record# 创建测试用TFRecord文件:python generate_tfrecord.py --csv_input=data/test_labels.csv --output_path=training/geometry_test.record 第二种方法比较直观，因此我采用第二种方法生产TFRecord数据。 安装配置安装TFModel依赖123456789101112workon object-detection# For CPUpip install tensorflow# For GPUpip install tensorflow-gpupip install --user Cythonpip install --user contextlib2pip install --user pillowpip install --user lxmlpip install --user jupyterpip install --user matplotlib 安装COCO API1234git clone https://github.com/cocodataset/cocoapi.gitcd cocoapi/PythonAPImakecp -r pycocotools &lt;path_to_tensorflow&gt;/models/research/ 编译Protobuf123456# From tensorflow/models/research/wget -O protobuf.zip https://github.com/google/protobuf/releases/download/v3.0.0/protoc-3.0.0-linux-x86_64.zipunzip protobuf.zip# From tensorflow/models/research/./bin/protoc object_detection/protos/*.proto --python_out=. 添加库到PYTHONPATH123# From tensorflow/models/research/# 每次调用TFModel的Object Detection API之前都要设置export PYTHONPATH=$PYTHONPATH:`pwd`:`pwd`/slim 安装测试12# if all tests is ok, the installation is no problem.python object_detection/builders/model_builder_test.py 模型训练数据准备 将label_map文件、训练用TFRecord文件、测试用TFRecord文件复制到tensorflow/models/research/object_detection/data文件夹下。 12345# 推荐的数据目录结构+ data - geometry.pbtxt - geometry_test.record - geometry_train.record 下载COCO预训练模型用于迁移学习 123# From tensorflow/models/research/object-detectionwget http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_2018_01_28.tar.gztar -xvf ssd_mobilenet_v1_coco_2018_01_28.tar.gz 修改解压后模型文件夹中pipeline.config 解压ssd_mobilenet_v1_coco_2018_01_28模型后会看到一个 .config 文件，里面包含有模型的参数，训练的参数，评估的参数等。这里需要修改到的有， 模型参数中的 num_classes，改成你的类别数， 训练参数中的 fine_tune_checkpoint，采用迁移学习，这里路径的指向刚才下载的Pre-train模型，比如 ssd_mobilenet_v1_coco_11_06_2017/model.ckpt train_input_reader 下面的 input_path，改成你的训练数据，例如 data/train.record。label_map_path，改成你的 pbtxt 文件路径，例如 data/object.pbtxt eval_input_reader 下面的 input_path，也需要改成你的测试集，例如 data/test.record。同样，label_map_path，也改成你的 pbtxt 文件路径，例如 data/object.pbtxt1234567891011121314151617181920212223242526272829//pipeline.config修改示例model &#123; ssd &#123; num_classes: 3 ... &#125;&#125;train_config &#123; ... fine_tune_checkpoint: &quot;object_detection/ssd_mobilenet_v1_coco_2018_01_28/model.ckpt&quot; from_detection_checkpoint: true num_steps: 50000&#125;train_input_reader &#123; label_map_path: &quot;object_detection/data/geometry.pbtxt&quot; tf_record_input_reader &#123; input_path: &quot;object_detection/data/geometry_train.record&quot; &#125;&#125;eval_input_reader &#123; label_map_path: &quot;object_detection/data/geometry.pbtxt&quot; shuffle: false num_epochs: 1 num_readers: 1 tf_record_input_reader &#123; input_path: &quot;object_detection/data/geometry_test.record&quot; &#125; sample_1_of_n_examples: 1&#125; 训练数据在GPU上训练TFModel，与在CPU上训练TFModel相比，要快五倍左右，因此推荐在GPU上训练TFModel。 启动docker 12# 启动docker，并使用-v参数将目录/home/$USER挂载到容器上docker run --runtime=nvidia -v /home/$USER:/home/$USER -it tensorflow/tensorflow:latest-gpu-py3 bash 执行训练 1234# From tensorflow/models/research/export PYTHONPATH=$PYTHONPATH:`pwd`:`pwd`/slim# 开始训练python object_detection/model_main.py --pipeline_config_path=object_detection/ssd_mobilenet_v1_coco_2018_01_28/pipeline.config --model_dir=object_detection/ssd_mobilenet_v1_coco_2018_01_28/saved_model/ --num_train_steps=50000 --alsologtostderr 使用tensorboard查看训练进度 12# From tensorflow/models/research/tensorboard --logdir=object_detection/ssd_mobilenet_v1_coco_2018_01_28/saved_model/ 在CPU上训练只需执行第二步和第三步。 导出模型12# From tensorflow/models/research/python object_detection/export_inference_graph.py --input_type=image_tensor --pipeline_config_path=object_detection/ssd_mobilenet_v1_coco_2018_01_28/pipeline.config --trained_checkpoint_prefix=object_detection/ssd_mobilenet_v1_coco_2018_01_28/saved_model/model.ckpt-50000 --output_directory=../../../../ssd_mobilenet_v1_coco_2018_01_28 运行完命令后模型就导出到 ssd_mobilenet_v1_coco_2018_01_28 文件夹中，其中的frozen_inference_graph.pb即是所需模型。 需要注意的是，参数中的 –trained_checkpoint_prefix 是需要指定到单个模型的，例如 model.ckpt-50000，这个50000就是训练了 50000 步后自动保存模型。 参考文献 https://huangwang.github.io/2018/10/18/Debian-Linux下安装Docker的方法/， by jack huang https://www.tensorflow.org/install/docker?hl=zh-cn , by tensorflow. https://huangwang.github.io/2018/10/09/Virtualenv简易教程/ , by jack huang https://laddiexu.github.io/tech/2017/11/04/TF-ODYourData.html , by 菁菁者莪 https://blog.csdn.net/xunan003/article/details/78720189?utm_source=blogxgwz2, by xunan003]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker使用帮助]]></title>
    <url>%2F2018%2F10%2F19%2FDocker%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%2F</url>
    <content type="text"><![CDATA[Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。 Docker与传统虚拟机如virtualbox、vmware相比，占用资源少，更加轻便，启动快，更适用于解决软件环境配置难题。 基本概念 镜像 Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 仓库 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。 一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 使用方法操作镜像获取镜像Docker Hub 上有大量的高质量的镜像可以用，使用docker pull命令拉取镜像。1234// 拉取镜像$ docker pull ubuntu:16.04// 以该镜像启动容器$ docker run -it --rm ubuntu:16.04 bash docker run 就是运行容器的命令,其参数含义如下： -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 —rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。 ubuntu:16.04：这是指用 ubuntu:16.04 镜像为基础来启动容器。 bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。 列出镜像1docker image ls 删除镜像删除本地镜像格式如下：1docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...] 以删除hello-world镜像为例：1docker image rm hello-world 操作容器启动容器1234// 新建并启动容器docker run ubuntu:14.04 /bin/echo &apos;Hello world&apos;// 启动已终止容器docker container start 后台运行1234567// 后台运行容器$ docker run -d ubuntu:17.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;// 通过 docker container ls 命令来查看容器信息$ docker container ls// 通过 docker container logs 命令获取容器的输出信息$ docker container logs [container ID or NAMES] 终止容器1docker container stop 进入容器在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令。1234$ docker run -dit ubuntu$ docker container ls$ docker exec -i 69d1 bash$ docker exec -it 69d1 bash 如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。 删除容器12345// 删除一个处于终止状态的容器$ docker container rm trusting_newton// 清理所有处于终止状态的容器docker container prune 参考文献 https://yeasy.gitbooks.io/docker_practice/introduction/what.html http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html ，by 阮一峰 https://zh.wikipedia.org/wiki/Docker ,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian_Linux下安装Docker的方法]]></title>
    <url>%2F2018%2F10%2F18%2FDebian-Linux%E4%B8%8B%E5%AE%89%E8%A3%85Docker%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。 Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心名字空间（name space），来创建独立的软件容器（containers）。这可以在单一Linux实体下运作，避免启动一个虚拟机造成的额外负担。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括进程树、网上、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括CPU、存储器、block I/O与网上。 下面即记录在Debian Linux下按照Docker社区版的方法。 前期准备添加Docker的pgp key。1curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - 配置Docker的Apt仓库。1echo &apos;deb https://download.docker.com/linux/debian stretch stable&apos; | sudo tee /etc/apt/sources.list.d/docker.list 更新Apt仓库1sudo apt-get update 安装Docker123456// 清除之前安装的Docker版本apt-get remove docker docker-engine docker.io// 在安装最新的Docker社区版apt-get install docker-ce// 测试dockerdocker run hello-world 以非root用户管理docker12sudo groupadd dockersudo usermod -aG docker $USER 参考文献 https://zh.wikipedia.org/wiki/Docker ,by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow学习笔记]]></title>
    <url>%2F2018%2F10%2F14%2Ftensorflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[TensorFlow™ 是一个开放源代码软件库，用于进行高性能数值计算。借助其灵活的架构，用户可以轻松地将计算工作部署到多种平台（CPU、GPU、TPU）和设备（桌面设备、服务器集群、移动设备、边缘设备等）。TensorFlow™ 最初是由 Google Brain 团队（隶属于 Google 的 AI 部门）中的研究人员和工程师开发的，可为机器学习和深度学习提供强力支持，并且其灵活的数值计算核心广泛应用于许多其他科学领域。 tensorflow入门tensorflow实现机器学习的基本步骤如下： 定义模型，建立数据流图 定义loss，并指定优化器 传入数据并进行训练 使用测试集进行评测 通用代码框架1234567891011121314151617181920212223242526272829303132333435363738394041424344import tensorflow as tf# 初始化变量和模型参数，定义训练闭环中的运算def inference(X): # 计算推断模型在数据X上的输出，并将结果返回def loss(X,Y): # 依据训练数据X及其期望输出Y计算损失def inputs(): # 读取或生成训练数据X及其期望输出Ydef train(total_loss): # 依据计算的总损失训练或调整模型参数def evaluate(sess,X,Y): # 对训练得到的模型进行评估# 在一个会话对象中启动数据流图，搭建流程with tf.Session() as sess: tf.initialize_all_variables().run() X,Y=inputs() total_loss=loss(X,Y) train_op=train(total_loss) coord=tf.train.Coordinator() threads=tf.train.start_queue_runners(sess=sess,coord=coord) # 实际的训练迭代次数 training_steps=1000 for step in range(training_steps): sess.run([train_op]) # 出于调试和学习的目的，查看损失在训练过程中递减的情况 if step % 10 =0: print &quot;loss: &quot;,sess,run([total_loss]) evalute(sess,X,Y) coord.request_stop() coord.join(threads) sess.close() 保存训练检查点借助tf.train.Saver类可创建检查点文件，将数据流图中变量保存至其中。修改后框架如下：1234567891011121314151617181920# 模型定义代码# 创建一个Saver对象saver=tf.train.Saver()# 在会话对象中启动数据流图，搭建流程with tf.Session() as sess: # 模型设置 # 实际的训练闭环 for step in range(training_steps): sess.run([train_op]) if step % 1000 ==0 # 将创建遵循命名模板为my-model-&#123;step&#125;的检查点文件，默认保存最近的5个文件 saver.save(sess,&apos;my-model&apos;,global_step=step) # 模型评估 saver.save(sess,&apos;my-model&apos;,global_step=training_steps) sess.close() 如果希望从检查点恢复，则使用tf.train.get_checkpoint_state方法验证检查点文件的存在，并使用tf.train.Saver.restore方法恢复变量值。123456789101112131415with tf.Session() as sess: # 模型设置 initial_step=0 # 验证之前是否已经保存了检查点文件 ckpt=tf.train.get_checkpoint_state(os.path.dirname(__file__)) if ckpt and ckpt.model_checkpoint_path: # 从检查点恢复模型参数 saver.restore(sess,ckpt.model_checkpoint_path) initial_step=int(ckpt.model_checkpoint_path.rsplite(&apos;_&apos;,1)[1]) # 实际的训练闭环 for step in range(initial_step, training_steps): ... 参考文献 https://www.tensorflow.org/?hl=zh-cn . 面向机器智能的TensorFlow实践, by Sam Abrahams, Danijar Hafner,etc.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python常用库简介]]></title>
    <url>%2F2018%2F10%2F14%2FPython%E5%B8%B8%E7%94%A8%E5%BA%93%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Python的高效开发建立在大量常用库基础上，因此掌握常用的Python库十分必要。下面简单介绍Python的各类常用库。 常用标准库 os： 访问操作系统功能模块 sys： 访问一些环境变量和与 Python 解释器交互 datetime： 日期时间处理 collections： 高级数据结构，有序字典，队列等等 uuid： 生成 UUID 模块 random： 随机数生成模块 re： 正则表达式模块 json： JSON 处理模块 pdb： 单步调试模块 科学计算 scipy：基于Python的matlab实现，旨在实现matlab的所有功能。包含Numpy、Ipython、Pandas、Matplotlib、Sympy等常用库 numpy： 基于Python的科学计算第三方库，提供了矩阵，线性代数，傅立叶变换等等的解决方案 pandas： 支持表格等多维数据 matplotlib： 用Python实现的类matlab的第三方库，用以绘制一些高质量的数学二维图形 命令交互 ipython： 交互命令行，适合科学计算 jupyter： ipython notebook 的延伸，可以直接放在github上 argparse：(Python 标准库)用于命令项选项与参数解析的模块 爬虫相关 urllib: (Python 标准库)，接受URL请求的相关模块 http: (Python 标准库)，处理所有客户端—服务器http请求的具体细节 requests: 第三方库，人性化的HTTP请求库，比urllib更好用 pillow: 处理验证码 rsa: 处理加密问题 BeautifulSoup：解析html文档为用户提供需要抓取的数据 lxml: 是基于 libxml2 这一 XML 解析库的 Python 封装,解析速度比 Beautiful Soup 更快 环境管理 virtualenv：创建独立 Python 环境的工具 virtualenvwrapper：virtualenv 的一组扩展 包管理 pip：Python 包和依赖关系管理工具 conda：跨平台，Python 二进制包管理工具 并发和并行 threading：(Python 标准库)更高层的线程接口 multiprocessing：(Python 标准库) 基于进程的“线程”接口 日志 logging：(Python 标准库) 为 Python 提供日志功能。 兼容性 six：Python 2 和 3 的兼容性工具 计算机视觉 opencv 机器学习 tensorflow 参考文献 Python 笔记四：Python的常用库收集, by brandonxiang]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Virtualenv简易教程]]></title>
    <url>%2F2018%2F10%2F09%2FVirtualenv%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[virtualenv是一个创建隔离python环境的工具，主要用于解决包冲突问题。 安装方法1sudo pip3 install virtualenv 使用方法创建项目的虚拟环境12$ cd my_project_folder$ virtualenv venv #venv是虚拟环境名称 执行上述命令后，将生成一个与虚拟环境同名的文件夹，包含 Python 可执行文件和 pip 库的拷贝，可用于安装其他包。 但是默认情况下，虚拟环境中不会包含也无法使用系统环境的global site-packages。比如系统环境里安装了 requests 模块，在虚拟环境里import requests会提示ImportError。如果想使用系统环境的第三方软件包，可以在创建虚拟环境时使用参数–system-site-packages。如下所示：1virtualenv --system-site-packages venv 此外可以指定虚拟环境所使用的 Python 版本，但前提是系统中已经安装了该版本：1virtualenv -p /usr/bin/python2.7 venv 使用虚拟环境启动虚拟环境：123cd venvsource bin/activate python -V 退出虚拟环境：1deactivate virtualenvwrappervirtualenvwrapper是virtualenv 的扩展工具，提供了一系列命令行命令，可以方便地创建、删除、复制、切换不同的虚拟环境。同时，使用该扩展后，所有虚拟环境都会被放置在同一个目录下。 安装方法1pip3 install virtualenvwrapper 环境配置在$home/.bashrc文件中添加如下几行代码：12345# bash -f file检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 trueif [ -f /usr/local/bin/virtualenvwrapper.sh ]; then export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.shfi 使用方法mkvirtualenv 也可以使用 virtualenv 的参数，比如 –python 来指定 Python 版本。123456789101112131415mkvirtualenv venv # 创建虚拟环境，虚拟环境目录都在 WORKON_HOME 里lsvirtualenv -b # 列出虚拟环境workon [虚拟环境名称] # 切换虚拟环境lssitepackages # 查看环境里安装了哪些包cdvirtualenv [子目录名] # 进入当前环境的目录cpvirtualenv [source] [dest] # 复制虚拟环境deactivate # 退出虚拟环境rmvirtualenv [虚拟环境名称] # 删除虚拟环境 conda vs. pip vs. virtualenvConda是一个开源包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 它适用于Linux，OS X和Windows，是为Python程序创建的，但可以打包和分发任何软件。 Pip是一个以Python计算机程序语言写成的软件包管理系统，用于安装和管理软件包。 它们直接的区别如下： pip使用方法1234# 导出python安装包环境pip freeze &gt; requirements.txt# 导入requirements文件pip install -r requirements.txt 参考文献 http://codingpy.com/article/virtualenv-must-have-tool-for-python-development/. https://conda.io/docs/commands.html#conda-vs-pip-vs-virtualenv-commands.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blender简易教程]]></title>
    <url>%2F2018%2F09%2F19%2FBlender%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近需要用Blender建3D模型，试用了半天，将经验简单总结一下。 3D建模流程 建立3D模型：通常在Blender的3D视图窗口对物体进行建模。 拆分制作纹理：设置缝合边，再展开。打开U/V图像编辑器窗口即可看到拆分效果。导出图片后制作纹理。 使用材质贴图：设置材质着色，添加纹理。 Blender快捷键Blender快捷键很多，熟练使用可加速3D模型的建立。 3D视图窗口字母键 A：全选、取消选择 Shift+A：增加物件，新建的物件会出现在准星的位置 B：框选，进行多选 C：刷选，加Shift取消选择，按Esc退出选择 E：挤出选中对象 G：移动选中对象 H：隐藏对象（Hide） Alt+H：显示对象 N：打开物体属性 Ctrl+Alt+Q：切换四视图 R: 旋转 Ctrl+R: 环切并滑动 S: 缩放 Alt+S：法向缩放 T：打开左侧工具栏 Tab：编辑模式和物体模式切换 Ctrl+U:存储为启动文件 X：删除 Z：线框模式与实体模式之间切换 Ctrl+Space：调出三维坐标系操纵物体 Ctrl+Tab：进行点、线、面的编辑模式 Shift+空格键：放大视图 功能键 F12：计算结果（算图模式），如果是黑色的，需要把摄像机和光源放在同一个图层中，或者选择摄像机和光源的图层。 数字键数字键主要用于视角切换 1：前视图 3：侧视图 5：正交与透视之间切换 7：俯视图 鼠标键 右键：选择物体 shift+中键：平移 滚轴/（Ctrl+中键拖拽）：缩放 参考文献 Blender常用快捷键,by JinunMeng. 如何系统的学习blender？,by zhihu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下将cmd命令添加到右键菜单]]></title>
    <url>%2F2018%2F09%2F11%2FWindows%E4%B8%8B%E5%B0%86cmd%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95%2F</url>
    <content type="text"><![CDATA[经常需要使用cmd命令，如果打开cmd窗口后在cd到目标路径，则非常麻烦。可使用如下方法将cmd添加到右键菜单，这样一打开cmd窗口就到了目标路径。设置方法如下： 打开注册表 添加注册项123a) 找到[HKEY_CLASSESS_ROOT\Folder\shell]子键，在其下新建“cmdPrompt”子项，在窗口右侧名称列上点击右键修改，将数值数据改为“CMD快速通道”。b) 再在这个项下，新建名为“command”子项，同样修改数值数据修改为c:\windows\system32\cmd.exe /k cd &quot;%1&quot; 设置完成后即可在目标路径文件夹上右键单击，选择“CMD快速通道”命令，打开cmd窗口的同时，已跳转到目标路径下。]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows平台Python安装与配置教程]]></title>
    <url>%2F2018%2F09%2F07%2FWindows%E5%B9%B3%E5%8F%B0Python%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[下面记录在Windows平台安装配置Python的过程。 去Python官网下载最新的Python3，当前最新版本为3.7。 双击Python3.7的安装包进行安装，设置安装路径为C:\Python\Python37，同时将Python路径加入系统Path变量中。 使用如下命令安装ipython。加参数—trusted-host，否则会报错误：SSLError(SSLCertVerificationError(1, ‘[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed。加参数-i，制定国内pip源，显著提高下载速度。1pip install ipython -i https://pypi.tuna.tsinghua.edu.cn/simple --trusted-host pypi.tuna.tsinghua.edu.cn]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows与Linux双系统Grub引导修复]]></title>
    <url>%2F2018%2F09%2F06%2FWindows%E4%B8%8ELinux%E5%8F%8C%E7%B3%BB%E7%BB%9FGrub%E5%BC%95%E5%AF%BC%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[因为个人爱好，我再笔记本中安装了Windows和Linux的双系统。最近因为Windows系统故障原因，重装Windows系统，导致无法引导Linux启动。 故障原因是之前安装双系统时，先安装Windows，再安装Linux，这样将由Grub2来引导Linux和Windows的启动。而重装Windows的过程中，将覆盖Grub2引导程序，导致无法Linux的启动。 故障解决方法是重新在硬盘中写入Grub2引导程序。具体步骤如下： 使用Linux安装盘，使用Live CD方式进行Linux系统。 使用fdisk -l命令查看硬盘信息。 使用grub-install —root-directory=/media/boot /dev/sda将grub2引导程序写入硬盘。/media/boot为引导分区所在位置，grub-install写入grub2引导程序时需要使用引导分区所在linux映像。 使用update-grub2更新引导配置。]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文文献免费下载方法]]></title>
    <url>%2F2018%2F08%2F26%2F%E4%B8%AD%E6%96%87%E6%96%87%E7%8C%AE%E5%85%8D%E8%B4%B9%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[下面记录经过验证可用的中文文献下载方法: idata中国知网 1234idata中国知网网址：https://www.cn-ki.net/进入系统，注册账号，登陆就可以每天免费下载五篇知网论文。额度用完之后，第二天可以继续下载。每天五篇的额度基本能满足需要，这样还不够的话，可以多注册几个账号。 全国图书馆参考咨询联盟 123全国图书馆参考咨询联盟网址：http://www.ucdrs.superlib.net/很全，可以查图书，查期刊，报纸等。还有硕士，博士的毕业论文。不仅有中文，还有外文。网站无需注册，通过文献传递服务，即通过邮箱接收全文。最快一两分钟，最慢三四个小时即可接收到全文。 上海研发公共服务平台 123上海研发公共服务平台网址：http://www.sgst.cn/。注册后可直接下载，论文、文献数量直接匹配知网和万方数据。下载速度较快，但有数量限制，可注册多个用户名。 库问搜索 12库问搜索网址：http://www.koovin.com/。库问搜索提供千万级文献免费下载。]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++跨平台移植开发思考]]></title>
    <url>%2F2018%2F07%2F16%2FCPP%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%A7%BB%E6%A4%8D%E5%BC%80%E5%8F%91%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近需要将一份C++代码通过Emscripten编译成asm.js，结果失败，因为这份C++代码使用MFC GUI库，导致Emscripten编译失败。这引起了我对C++跨平台移植的思考。 C++代码理论上能实现源代码级别的跨平台移植，即同一份代码可以不加修改的在不同的平台上编译运行且表现一致。这要求编写的C++代码符合跨平台移植的规范，如链接[1]所指出的那样，它给出了很多实现C++代码跨平台移植的编码细节，在编写跨平台的底层库方面十分有用。但在编写跨平台的C++应用方面，应使用经过长期实践证明能用的跨平台库来帮助编码，建立在巨人的肩膀上，使跨平台C++代码编写工作变得简单容易。下面给出一些常用的跨平台C++库供参考： 语言及基础库 标准 C++：标准 c++ 是98年制定的，现在主流的 c++ 编译器都能够比较好的支持了。这里建议使用VC7.1和GCC4.0及以上版本。在Linux中，glibc是标准C的实现，libstdc++则是标准C++的实现。在Windows中，VS2015之前MSVCRT.DLL是标准C/C++的实现，之后UCRTBASE.DLLz则是标准C/C++的实现。 boost：boost 则是 C++ 标准委员会的一群人弄起来的一个 C++ 库集合，其中不少库以经进入 C++ TR1，可以说是准标准。使用这里的库我们有着充分的理由。象字符串的操作可以用 boost 的 String algorithms 库，格式化操作可以用 boost::format，正则式可用 boost::regex 等等。 网络 ACE（Adaptive Communication Environment）：ACE是一个以C++的Template技术所做成的开放源代码的可跨平台的网络应用程序的程式库套件。ACE自适配通信环境（ADAPTIVE Communication Environment）是可以自由使用、开放源码的面向对象（OO）框架（Framework），在其中实现了许多用于并发通信软件的核心模式。ACE提供了一组丰富的可复用C++ Wrapper Facade（包装外观）和框架组件，可跨越多种平台完成通用的通信软件任务，其中包括：事件多路分离和事件处理器分派、信号处理、服务初始化、进程间通信、共享内存管理、消息路由、分布式服务动态（重）配置、并发执行和同步，等等。 Boost.Asio：用于网络和底层I/O编程的跨平台的C++库 数据库 OTL (Oracle, Odbc and DB2-CLI Template Library)：不但支持跨平台，还跨数据库。OTL支持以下面的数据库 : OTL Oracle ,SQL Server, Access, MySQL。还有其它的库如DTL，这个库不但支持ODBC，它还支持数据库的原生接口，可以有更佳的性能。 GUI QT：QT是双认证的，当你的程序免费时它就免费，你的程序打算卖钱时，它也要，而且要价很高。所以，如果有版权，成本上的考虑的话，则可以考虑wxWidgets。 wxWidgets：wxWidgets（/wɪksˈwɪdʒɪts/，原名wxWindows）是一个开放源代码且跨平台的对象工具集（widget toolkit），其库可用来创建基本的图形用户界面（GUI）。wxWidgets由Julian Smart于1992年首先开发。 科学计算 GSL：GNU科学库。 游戏开发 Cocos2d-x：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。 视频 FFmpeg：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流 参考文献 http://hongbomin.com/2017/03/08/cpp-cross-platform-guide/. by 洪柏敏. http://developer.51cto.com/art/201002/181960.htm. by 博客园. https://zh.wikipedia.org/wiki/ACE自适配通信环境. by wikipedia. https://blog.csdn.net/weiwangchao_/article/details/51130863. by 工程师WWW. https://zhuanlan.zhihu.com/p/25443704, by zhihu.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emscripten教程]]></title>
    <url>%2F2018%2F07%2F15%2FEmscripten%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Emscripten是一种基于LLVM的编译器，理论上能够将任何能够生成LLVM位码的代码编译成javascript的严格子集asm.js，实际上主要用于将C/C++代码编译成asm.js。本文主要介绍Emscripten的安装过程。 下载和安装从源码编译安装十分麻烦，推荐安装核心的Emscripten SDK。以Windows为例，先使用如下命令下载emsdk。12345# Get the emsdk repogit clone https://github.com/juj/emsdk.git# Enter that directorycd emsdk 再使用如下命令安装配置Emscripten。1234567891011# Fetch the latest registry of available tools..\emsdk.bat update# Download and install the latest SDK tools. Need install Python first. .\emsdk.bat install latest# Make the &quot;latest&quot; SDK &quot;active&quot; for the current user. (writes ~/.emscripten file).\emsdk.bat activate latest# Activate PATH and other environment variables in the current terminal.\emsdk_env.bat 验证使用如下命令验证Emscripten是否安装配置正确。12345678# Enter that directorycd emsdk# Activate PATH and other environment variables in the current terminal.\emsdk_env.bat# Verifying Emscriptenemcc.bat -v 运行如果验证通过，即可使用Emscripten编译C/C++代码到asm.js。 创建名为helloWorld.cpp的文件，其内容如下：123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;hello, world!\n&quot;); return 0;&#125; 使用如下命令编译：1emcc.bat helloWorld.cpp 编译后将生成a.out.js和a.out.wasm两个文件。后者是包含编译后代码的WebAssembly文件，前者是用于加载和执行后者的Javascipt文件。使用如下命令测试编译后生成的代码，将输出“hello,world!”。1node a.out.js 参考链接 http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html. by kripken.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器中运行3D游戏的思考]]></title>
    <url>%2F2018%2F07%2F10%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BF%90%E8%A1%8C3D%E6%B8%B8%E6%88%8F%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[Web技术突飞猛进，几乎无所不能，无所不在。然而在3D游戏领域，web技术乏善可陈，性能瓶颈问题制约其发展。但是开发者们没有放弃这个梦想，不断努力，孜孜不倦地改进和增强浏览器中运行3D游戏性能的方法和技术，目前已能看到一丝曙光。 对C/S架构的3D游戏而言，渲染和计算通常都在客户端，服务器端负责用户状态的管理和分发。同样对B/S架构的运行在浏览器中的3D游戏，所有的渲染和计算也应该在浏览器端。如果渲染和计算放在服务器端，将导致可怕的延迟，并严重损害3D游戏的可伸缩性。 当前很多3D游戏使用C/C++语言编写，如果能够将C/C++语言编译成JavaScript语言，可大大促进Web 3D游戏的开发。而编译器项目Emscripten正是一个这样的工具。它能将C/C++代码编译成一种叫做asm.js的Javascript变体。需要指出的是，Emscripten的输入，即C/C++代码最好是开放源代码的，因为Emscripten不支持闭源代码的编译。例如Emscripten不支持mfc程序的转换，因为mfc是闭源的[4]。 asm.js是一个JavaScript的严格子集，它只提供32位带符号整数和64位带符号浮点数两种数据类型，其他Javascript类型如字符串、布尔值等以数值形式存在，保存在内存中，通过TypedArray调用。另外asm.js没有垃圾回收机制，所有内存操作都由程序员自己控制。asm.js是优化后的JavaScript，它在浏览器中的运行速度大约是原生代码的一倍左右[1]。 asm.js虽然比原生javascript运行速度快了一倍左右，但是相比C/C++代码，运行速度还是有差距。幸运的是出现了名为WebAssembly的技术。WebAssembly或称wasm是一个实验性的低级编程语言，应用于浏览器内的客户端[5]。WebAssembly是便携式的抽象语法树，被设计来提供比JavaScript更快速的编译及运行。WebAssembly将让开发者能运用自己熟悉的编程语言（最初以C/C++作为实现目标）编译，再藉虚拟机引擎在浏览器内运行。WebAssembly的开发团队分别来自Mozilla、Google、Microsoft、Apple，代表着四大网络浏览器Firefox、Chrome、Microsoft Edge、Safari。2017年11月，所有以上四个浏览器都开始实验性的支持WebAssembly。目前，最新版本的Emscripten已支持将C/C++代码编译成wasm。 参考文献 http://www.ruanyifeng.com/blog/2017/09/asmjs_emscripten.html. by 阮一峰. https://www.cnblogs.com/slly/p/6639173.html. by 李某龙. http://kripken.github.io/emscripten-site/. by emscripten. https://github.com/kripken/emscripten/issues/941. by emscripten. https://zh.wikipedia.org/wiki/WebAssembly. by wikipedia.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie,Session和Token会话知识整理]]></title>
    <url>%2F2018%2F07%2F08%2FCookie-Session%E5%92%8CToken%E4%BC%9A%E8%AF%9D%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[HTTP是一种无状态的协议，然而当服务器端需要判断用户能否访问某些资源，记录用户的购物车内容等场景时，就需要一种机制维护会话状态，这时候Cookie、Session和Token就派上了用场。 CookieCookie技术最早用于解决HTTP的会话问题， 它是 http 协议的一部分，它的处理分为如下几步： 服务器向客户端发送 cookie。 通常使用 HTTP 协议规定的 set-cookie 头操作。 规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。 浏览器将 cookie 保存。 每次请求浏览器都会将 cookie 发向服务器。 可选的Cookie参数其他可选的 cookie 参数会影响将 cookie 发送给服务器端的过程，主要有以下几种： path：表示 cookie 影响到的路径，匹配该路径才发送这个 cookie。 expires 和 maxAge：告诉浏览器这个 cookie 什么时候过期，expires 是 UTC 格式时间，maxAge 是 cookie 多久后过期的相对时间。当不设置这两个选项时，会产生 session cookie，session cookie 是 transient 的，当用户关闭浏览器时，就被清除。一般用来保存 session 的 session_id。 secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。 httpOnly：浏览器不允许脚本操作 document.cookie 去更改 cookie。一般情况下都应该设置这个为 true，这样可以避免被 xss 攻击拿到 cookie。 常用场景当给Cookie设置expires和maxAge后，在未到期前，浏览器端的Cookie不会因为浏览器的关闭而消失。该特性常用于自动登录，记录用户浏览信息。例如很多购物网站常用该特性记录用户的喜好和购买的物品。 Cookie安全隐患Cookie提供了一种手段使得HTTP请求可以附加当前状态， 大多数网站就是靠Cookie来标识用户的登录状态的，例如： 用户提交用户名和密码的表单，这通常是一个POST HTTP请求。 服务器验证用户名与密码，如果合法则返回200（OK）并设置Set-Cookie为authed=true。 浏览器存储该Cookie。 浏览器发送请求时，设置Cookie字段为authed=true。 服务器收到第二次请求，从Cookie字段得知该用户已经登录。 按照已登录用户的权限来处理此次请求。 上述认证流程存在安全隐患，因为Cookie是可以被篡改的。如果使用一些HTTP客户端软件，设置Cookie字段为authed=true并发送该HTTP请求，服务器就会被欺骗。 Cookie防篡改机制服务器为每个Cookie项生成签名，可有效地防止Cookie被篡改。因为用户篡改Cookie后无法生成对应的签名， 服务器便可得知用户对Cookie进行了篡改。一个简单的校验过程可能是这样的： 在服务器中配置一个不为人知的字符串（我们叫它Secret），比如：x$sfz32。 当服务器需要设置Cookie时（比如authed=false），不仅设置authed的值为false， 在值的后面进一步设置一个签名，最终设置的Cookie是authed=false|6hTiBl7lVpd1P。 签名6hTiBl7lVpd1P是这样生成的：Hash(‘x$sfz32’+’false’)。 要设置的值与Secret相加再取哈希。 用户收到HTTP响应并发现头字段Set-Cookie: authed=false|6hTiBl7lVpd1P。 用户在发送HTTP请求时，篡改了authed值，设置头字段Cookie: authed=true|???。 因为用户不知道Secret，无法生成签名，只能随便填一个。 服务器收到HTTP请求，发现Cookie: authed=true|???。服务器开始进行校验： Hash(‘true’+’x$sfz32’)，便会发现用户提供的签名不正确。 通过给Cookie添加签名，使得服务器得以知道Cookie被篡改。然而故事并未结束。 因为Cookie是明文传输的， 只要服务器设置过一次authed=true|xxxx我不就知道true的签名是xxxx了么， 以后就可以用这个签名来欺骗服务器了。因此Cookie中最好不要放敏感数据。 一般来讲Cookie中只会放一个Session Id，而Session存储在服务器端。 Session为了解决Cookie的安全隐患，Session机制应运而生。session机制是一种服务器端的机制，它存储在服务器端的，避免了在客户端Cookie中存储敏感数据。Session可以存储在HTTP服务器的内存中，也可以存在内存数据库（如redis）中， 对于重量级的应用甚至可以存储在数据库中。 客户端对服务端请求时,服务端会检查请求中是否包含一个session标识( 称为session id ). 如果没有,那么服务端就生成一个随机的session以及和它匹配的session id,并将session id返回给客户端. 如果有,那么服务器就在存储中根据session id 查找到对应的session. 基于Session的登录流程一个简单的使用Session机制的登录流程可能是这样的： 用户提交包含用户名和密码的表单，发送HTTP请求。 服务器验证用户发来的用户名密码。 如果正确则把当前用户名（通常是用户对象）存储到redis中，并生成它在redis中的ID。这个ID称为Session ID，通过Session ID可以从Redis中取出对应的用户对象， 敏感数据（比如authed=true）都存储在这个用户对象中。 设置Cookie为sessionId=xxxxxx|checksum并发送HTTP响应， 仍然为每一项Cookie都设置签名。 用户收到HTTP响应后，便看不到任何敏感数据了。在此后的请求中发送该Cookie给服务器。 服务器收到此后的HTTP请求后，发现Cookie中有SessionID，进行放篡改验证。 如果通过了验证，根据该ID从Redis中取出对应的用户对象， 查看该对象的状态并继续执行业务逻辑。 Session安全隐患Session ID作为Cookie存储在浏览器端，因此存在被劫持的风险，尤其是开发者没有正确的关闭会话。用户关闭会话时，应删除传递 Session ID 的 Cookie，同时撤销服务器端的Session内容。例如：123456789101112/* 普通用户登出 */router.post(&apos;/signout&apos;, function(req, res, next) &#123; if (_.isEmpty(req.body) === false) &#123; req.session.account = null; // 删除session res.json(&#123; message: &apos;登出成功！&apos; &#125;); &#125; else &#123; res.send(406, &#123; message: &apos;The params is not correct!&apos; &#125;); &#125;&#125;); TokenToken是用户的验证方式,最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。 基于Token的身份验证流程使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 基于Token方法的优势 JWT 方法允许我们进行AJAX调用任何服务器或域。由于HTTP头是用来传输用户信息的。 没必要在服务器存储一个单独的session。JWT本身传达全部的信息。 服务器端减少到只是一个API和可以通过CDN服务的静态资源（HTML，CSS，JS)。 认证系统是手机兼容的，任何设备上可以生成令牌。 由于已经消除了cookie的需要，也不再需要保护跨站请求。 API密钥提供非此即彼的解决方案，然而JWT提供更颗粒度的控制，它可以用于任何调试目的的检查。 API密钥依赖于中央存储和服务。JWT可以自发行或者外部服务在允许的范围和期限发布它。 JWT结构Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。 Cookie、Session和Token对比cookie与session的区别 cookie数据存放在客户端上，session数据放在服务器上。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE。 session与token的区别作为身份认证token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击。 Session 是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。Session 认证只是简单的把User 信息存储到Session 里，因为SID 的不可预测性，暂且认为是安全的。这是一种认证手段。 但是如果有了某个User的SID,就相当于拥有该User的全部权利.SID不应该共享给其他网站或第三方。 Token, 如果指的是OAuth Token 或类似的机制的话，提供的是 认证 和 授权，认证是针对用户，授权是针对App。其目的是让某App有权利访问某用户的信息。这里的Token是唯一的。不可以转移到其它App上，也不可以转到其它用户上。 参考链接 http://wiki.jikexueyuan.com/project/node-lessons/cookie-session.html, by 极客学院. https://harttle.land/2015/08/10/cookie-session.html. by Harttle Land. https://python.freelycode.com/contribution/detail/84. by Python部落. https://www.jianshu.com/p/576dbf44b2ae, by Dearmadman]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兼容前后端多种JS模块规范的代码]]></title>
    <url>%2F2018%2F07%2F02%2F%E5%85%BC%E5%AE%B9%E5%89%8D%E5%90%8E%E7%AB%AF%E5%A4%9A%E7%A7%8DJS%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近研究如何在前后端调用同一份js代码。该问题本质是如何兼容前后端各类JS模块规范。上网一搜，已经有很多详细的解决方案和JS模块规范介绍，在这里简单记录一下。 JS模块规范JS模块规范前端主要有AMD、CMD，后端主要有CommonJS。此外还有最新的ES2015模块规范。 AMDAMD（异步模块定义，Asynchronous Module Definition）格式总体的目标是为现在的开发者提供一个可用的模块化 JavaScript 的解决方案。它诞生于 Dojo 在使用 XHR+eval 时的实践经验，其支持者希望未来的解决方案都可以免受由于过去方案的缺陷所带来的麻烦。 AMD风格模块定义通常包括：一个用来进行模块定义的 define 方法以及一个用来处理依赖项加载的 require 方法。define 根据如下的方法签名来定义具名或匿名的模块：12345define( module_id /*可选*/, [dependencies] /*可选*/, definition function /*用来初始化模块或对象的函数*/); CMDCMD(Common Module Definition)表示通用模块定义，该规范是国内发展出来的，由阿里的玉伯提出。就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS和requireJS一样，都是javascript的前端模块化解决方案。CMD规范简单到只有一个API，即define函数：12345define(function(require, exports, module) &#123; // The module code goes here&#125;); CMD 与 AMD 挺相近，二者区别如下： 对于依赖的模块 CMD 是延迟执行，而 AMD 是提前执行（不过 RequireJS 从 2.0 开始，也改成可以延迟执行。 ） CMD 推崇依赖就近，AMD 推崇依赖前置。 AMD 的 api 默认是一个当多个用，CMD 严格的区分推崇职责单一，其每个 API 都简单纯粹。例如：AMD 里 require 分全局的和局部的。CMD 里面没有全局的 require，提供 seajs.use() 来实现模块系统的加载启动。 CommonJSCommonJS是一个志愿性质的工作组，它致力于设计、规划并标准化 JavaScript API。至今为止他们已经尝试着认可了模块标准以及程序包标准。CommonJS 的模块提案为在服务器端声明模块指定了一个简单的 API。不像 AMD，它试图覆盖更宽泛的方面比如 IO、文件系统、promise 模式等等。CommonJS风格模块在nodejs中得到广泛的应用。 CommonJS风格模块是一段可重用的 JavaScript，它导出一系列特定的对象给依赖它的代码调用——通常来说这样的模块外围没有函数包裹（所以你在这里的例子中不会看到 define）。例如：12345678910// package/lib 是我们须要的一个依赖项var lib = require(&apos;package/lib&apos;); // 我们的模块的一些行为function foo()&#123; lib.log(&apos;hello world!&apos;);&#125; // 把 foo 导出（暴露）给其它模块exports.foo = foo; ES2015模块规范2015 年 6 月， ES2015（即 ECMAScript 6、ES6） 正式发布。ES2015 是该语言的一个显著更新，也是自 2009 年 ES5 标准确定后的第一个重大更新。 ES2015的模块规范如下： 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。 export 命令用于规定模块的对外接口。 import 命令用于输入其他模块提供的功能。 ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。 ES2015模块示例如下：123456789//circle.js//圆面积计算export function area(radius) &#123; return Math.PI * radius * radius;&#125;//main.jsimport &#123;area&#125; from &apos;./hangge&apos;;console.log(&apos;圆面积：&apos; + area(10)); 兼容多种模块规范需要指出的是下面兼容多种JS模块规范的代码并不支持最新的ES2015模块规范。 1234567891011121314151617181920;(function (name, definition) &#123; // 检测上下文环境是否为AMD或CMD var hasDefine = typeof define === &apos;function&apos;, // 检查上下文环境是否为Node hasExports = typeof module !== &apos;undefined&apos; &amp;&amp; module.exports; if (hasDefine) &#123; // AMD环境或CMD环境 define(definition); &#125; else if (hasExports) &#123; // 定义为普通Node模块 module.exports = definition(); &#125; else &#123; // 将模块的执行结果挂在window变量中，在浏览器中this指向window对象 this[name] = definition(); &#125;&#125;)(&apos;hello&apos;, function () &#123; var hello = function () &#123;&#125;; return hello;&#125;); 参考链接 https://i.jakeyu.top/2017/09/14/兼容前后端共用模块代码/. by Jake. https://segmentfault.com/a/1190000011633813. by CodeMan. http://justineo.github.io/singles/writing-modular-js/. by ADDY OSMANI. http://www.hangge.com/blog/cache/detail_1686.html. by hangge.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sequelize-cli使用经验总结]]></title>
    <url>%2F2018%2F06%2F22%2Fsequelize-cli%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Sequelize 是一个基于 promise 的 Node.js ORM, 目前支持 Postgres, MySQL, SQLite 和 Microsoft SQL Server. 它具有强大的事务支持, 关联关系, 读取和复制等功能[2]. 下面主要介绍如何使用sequelize-cli工具快速构建nodejs的数据访问层。 基于express创建nodejs web应用基于express建立nodejs的web应用，在此基础上再使用sequlize建立数据访问层和数据库。1234mkdir myappcd myappexpressnpm install 基于sequelize创建数据访问层和数据库安装sequlize12npm install --save sequelizenpm install --save mysql2 安装sequelize-cli首先应安装sequelize-cli工具，可以选择全局安装，也可以选择本地安装。12npm install --save sequelize-clinpm install -g sequelize-cli 建立初始的ORM引导框架使用如下命令在Nodejs Web应用中建立初始的数据访问层。123mkdir dbcd db../node_modules/.bin/sequelize init 这将创建以下文件夹: config, 包含配置文件，它告诉CLI如何连接数据库 models,包含您的项目的所有模型 migrations, 包含所有迁移文件 seeders, 包含所有种子文件 修改配置文件以连接到数据库管理系统，并创建数据库在建立模型之前，应先修改config/config.json，以告诉 CLI 如何连接到数据库。config/config.json内容如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; &quot;development&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;root&quot;, &quot;database&quot;: &quot;database_development&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot;, &quot;pool&quot;:&#123; &quot;max&quot;: 5, &quot;min&quot;: 0, &quot;idle&quot;: 10000 &#125;, &quot;timezone&quot;: &quot;+08:00&quot;, &quot;define&quot;:&#123; &quot;charset&quot;: &quot;utf8&quot;, &quot;dialectOptions&quot;:&#123; &quot;collate&quot;: &quot;utf8_general_ci&quot; &#125; &#125; &#125;, &quot;test&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;root&quot;, &quot;database&quot;: &quot;database_test&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot; &#125;, &quot;production&quot;: &#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: &quot;root&quot;, &quot;database&quot;: &quot;database_test&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot;, &quot;pool&quot;:&#123; &quot;max&quot;: 5, &quot;min&quot;: 0, &quot;idle&quot;: 10000 &#125;, &quot;timezone&quot;: &quot;+08:00&quot;, &quot;define&quot;:&#123; &quot;charset&quot;: &quot;utf8&quot;, &quot;dialectOptions&quot;:&#123; &quot;collate&quot;: &quot;utf8_general_ci&quot; &#125; &#125; &#125;&#125; 上述配置修改了数据库的字符集，使之能支持中文。当然在创建数据库之前，应配置mysql数据库管理系，使其支持utf8字符集。可执行如下命令查看其支持的字符集，如果其不支持uft字符集，请按照参考链接[3]进行修改。1234567891011121314mysql&gt; show variables like &apos;%char%&apos;;+--------------------------+---------------------------------------------------------+| Variable_name | Value |+--------------------------+---------------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | C:\Program Files\MySQL\MySQL Server 5.5\share\charsets\ |+--------------------------+---------------------------------------------------------+8 rows in set (0.00 sec) 使用如下命令创建数据库：1../node_modules/.bin/sequelize db:create 创建模型我们将使用 model:generate 命令。 此命令需要两个选项： name, 模型的名称 attributes, 模型的属性列表 创建一个名叫 User 的模型：1../node_modules/.bin/sequelize model:generate --name User --attributes firstName:string,lastName:string,email:string 这将发生以下事情: 在 models 文件夹中创建了一个 user 模型文件 在 migrations 文件夹中创建了一个名字像 XXXXXXXXXXXXXX-create-user.js 的迁移文件 注意: _Sequelize 将只使用模型文件，它是表描述。另一边，迁移文件是该模型的更改，或更具体的是说 CLI 所使用的表。 处理迁移，如提交或日志，以进行数据库的某些更改。 再创建一个名为Role的模型，它跟User是一对多的关系：1../node_modules/.bin/sequelize model:generate --name Role --attributes roleName:string 定义关系Role和User是一对多的关系，因此需要修改它们的模型定义。修改migrations/20180622153726-create-role.js如下：1234567891011&apos;use strict&apos;;module.exports = (sequelize, DataTypes) =&gt; &#123; var Role = sequelize.define(&apos;Role&apos;, &#123; roleName: DataTypes.STRING &#125;, &#123;&#125;); Role.associate = function(models) &#123; // associations can be defined here Role.hasMany(models.User) &#125;; return Role;&#125;; 修改migrations/20180622153152-create-user.js如下：123456789101112131415161718&apos;use strict&apos;;module.exports = (sequelize, DataTypes) =&gt; &#123; var User = sequelize.define(&apos;User&apos;, &#123; firstName: DataTypes.STRING, lastName: DataTypes.STRING, email: DataTypes.STRING &#125;, &#123;&#125;); User.associate = function(models) &#123; // associations can be defined here User.belongsTo(models.Role, &#123; onDelete: &quot;NULL&quot;, foreignKey: &#123; allowNull: false &#125; &#125;) &#125;; return User;&#125;; 修改和运行迁移Role和User是一对多的关系，因此需要修改User迁移文件的定义。修改models/user.js如下：12345678910111213141516171819202122232425262728293031323334353637383940414243&apos;use strict&apos;;module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.createTable(&apos;Users&apos;, &#123; id: &#123; allowNull: false, autoIncrement: true, primaryKey: true, type: Sequelize.INTEGER &#125;, roleId: &#123; // name of the key we&apos;re adding type: Sequelize.INTEGER, allowNull: false, references: &#123; model: &apos;Roles&apos;, // name of Target model key: &apos;id&apos;, // key in Target model that we&apos;re referencing &#125;, onUpdate: &apos;CASCADE&apos;, onDelete: &apos;CASCADE&apos;, &#125;, firstName: &#123; type: Sequelize.STRING &#125;, lastName: &#123; type: Sequelize.STRING &#125;, email: &#123; type: Sequelize.STRING &#125;, createdAt: &#123; allowNull: false, type: Sequelize.DATE &#125;, updatedAt: &#123; allowNull: false, type: Sequelize.DATE &#125; &#125;); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.dropTable(&apos;Users&apos;); &#125;&#125;; 注意：这里主要给User添加了外键字段，外键字段命名有规则：通常为小写的模型名加Id，即驼峰风格。例如这里加了roleId的外键字段。 直到目前为止，CLI没有将任何东西插入数据库。 刚刚为模型 User和Role创建了必需的模型和迁移文件。 现在要在数据库中实际创建该表，需要运行 db:migrate 命令。1../node_modules/.bin/sequelize db:migrate 此命令将执行这些步骤： 将在数据库中确保一个名为 SequelizeMeta 的表。 此表用于记录在当前数据库上运行的迁移 开始寻找尚未运行的任何迁移文件。 这可以通过检查 SequelizeMeta 表。 在这个例子中，它将运行创建的 XXXXXXXXXXXXXX-create-role.js和XXXXXXXXXXXXXX-create-user.js 迁移。 创建一个名为 Roles 的表，其中包含其迁移文件中指定的所有列。 创建一个名为 Users 的表，其中包含其迁移文件中指定的所有列。 创建种子，生成测试数据假设我们希望在默认情况下将一些数据插入到几个表中。 例如创建几个用户和角色：12../node_modules/.bin/sequelize seed:generate --name demo-role../node_modules/.bin/sequelize seed:generate --name demo-user 这个命令将会在 seeders 文件夹中创建两个种子文件。文件名看起来像是 XXXXXXXXXXXXXX-demo-role.js和XXXXXXXXXXXXXX-demo-user.js，它遵循相同的 up/down 语义，如迁移文件。 现在我们应该编辑这两个文件，将演示角色插入Role表,将演示用户插入User表。修改XXXXXXXXXXXXXX-demo-role.js如下：123456789101112131415161718192021&apos;use strict&apos;;module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.bulkInsert(&apos;Roles&apos;, [&#123; roleName: &apos;管理员&apos;, createdAt:new Date(), updatedAt:new Date() &#125;,&#123; roleName: &apos;普通用户&apos;, createdAt:new Date(), updatedAt:new Date() &#125;], &#123;&#125;); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.bulkDelete(&apos;Roles&apos;, null, &#123;&#125;); &#125;&#125;; 修改XXXXXXXXXXXXXX-demo-user.js如下：1234567891011121314151617181920212223242526&apos;use strict&apos;;module.exports = &#123; up: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.bulkInsert(&apos;Users&apos;, [&#123; roleId:1, firstName: &apos;John&apos;, lastName: &apos;Doe&apos;, email: &apos;demo@demo.com&apos;, createdAt:new Date(), updatedAt:new Date() &#125;,&#123; roleId:1, firstName: &apos;Jack&apos;, lastName: &apos;Smith&apos;, email: &apos;jack@demo.com&apos;, createdAt:new Date(), updatedAt:new Date() &#125;], &#123;&#125;); &#125;, down: (queryInterface, Sequelize) =&gt; &#123; return queryInterface.bulkDelete(&apos;Users&apos;, null, &#123;&#125;); &#125;&#125;; 种子文件修改后，即可使用如下命令将演示数据插入数据库中：1../node_modules/.bin/sequelize db:seed:all 参考链接 http://docs.sequelizejs.com/，by sequelizejs https://github.com/demopark/sequelize-docs-Zh-CN，by demopark https://www.jianshu.com/p/b85cc8a05e53, by 最怕认真]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual_Studio_Community_2017离线安装]]></title>
    <url>%2F2018%2F06%2F21%2FVisual-Studio-Community-2017%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Visual Studio 2017版本采用模块化安装方式，根据用户选择模块按需安装。这种方式在用户能够上网的情况下十分方便，但在离线情况下就无法使用。下面介绍在离线情况下如何打包安装Visual Studio community 2017的方法。 下载VS2017社区版安装包获取程序到官网下载最新版本的vs_community_xxxxxx.exe的下载器。 运行命令下载所需安装包运行如下命令获取VS2017的工作负载：1.\vs_community__208176120.1522073957.exe --layout e:\vs2017_offline --lang zh-CN --add Microsoft.VisualStudio.Workload.CoreEditor --add Microsoft.VisualStudio.Workload.NativeDesktop --includeRecommended --includeOptional 可从参考链接[2]中获取工作负载ID。如需更多语言包或者更多安装指令，请参考官方离线安装命令指南，即参考链接[3]。 参考链接 https://docs.microsoft.com/en-us/visualstudio/install/create-an-offline-installation-of-visual-studio, by microsoft https://docs.microsoft.com/zh-cn/visualstudio/install/workload-component-id-vs-community, by microsoft https://docs.microsoft.com/en-us/visualstudio/install/use-command-line-parameters-to-install-visual-studio, by microsoft]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node_C++_Addon插件编写方法]]></title>
    <url>%2F2018%2F06%2F20%2FNode-Addon%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近研究在Nodejs中调用DLL，上网搜索发现主要有两种方法： 使用Nodeffi调用C风格接口的DLL，但是无法调用C++风格导出类的DLL。 使用Nodejs C++ Addon 插件，该方法可直接与C++代码交互，理论上可以调用C++风格导出类的DLL。 下面研究Nodejs Addon C++插件的编写方法。 什么是Nodejs C++ AddonNode.js插件（Addons）是C/C++编写的动态链接对象，这些对象可以被Node.js的require()函数引用，并可以像普通的Node.js模块一样使用。Addons主要用于提供一个Node.js中运行的JavaScript和C/C++库之间的接口。 插件（Addons）是动态链接的共享对象，它提供了C/C++类库的调用能力。实现插件的方法比较复杂，涉及到以下元组件及API: V8：C++库，Node.js用于提供JavaScript执行环境。V8提供了对象创建、函数调用等执行机制，V8相关API包含在了v8.h头文件中（位于Node.js源码树的deps/v8/include/v8.h），也可以查看在线文档。 libuv：C库，实现了Node.js中的事件循环、工作线程及在不同平台中异步行为的相关功能。也可以做为是一个跨平台的抽象库，提供了简单的、类POSIX的对主要操作系统的常见系统任务功能，如：与文件系统、套接字、计时器、系统事件的交互等。libuv还提供了一个类pthreads的线程池抽象对象，可用于更复杂的、超越标准事件循环的异步插件的控制功能。 内部Node.js库：Node.js自身提供了一定义数量的C/C++API的插件可以使用 - 其中最重要的可能是node::ObjectWrap类 Node.js静态链接库：Node.js自身还包含了一部分静态链接库，如OpenSSL。这些位于Node.js源码树的deps/目录下，只有V8和OpenSSL提供了符号出口，可以供Node.js和基它插件所使用。详见Node.js依赖链接 Node Addon插件编写方法Node Addon插件的编写需要解决两个关键问题： 当数据流向 javaScript -&gt; C++时，如何将javascript类型数据包装成C++类型数据，供C++代码使用。 当数据流向 C++ -&gt; JavaScript时，如何将C++类型数据包装成JavaScript类型数据，供JavaScript代码使用。 这两个关键问题的分析请参见淘宝前端团队成员发表的文章“Node.js 和 C++ 之间的类型转换[3]”。解决这两个关键问题后，Node Addon插件编写难度就不大了。 Node Addon插件调用C++导出类DLL方法测试现有一个采用成熟方法导出类接口的DLL[4]，如何在Node Addon插件中调用该DLL呢?下面nodejs官网Node Addon插件例子Factory of wrapped objects为例进行讲解。 Factory of wrapped objects例子在Addon插件中包装了一个MyObject类，现在就在MyObject类调用DLL导出类的接口方法。修改MyObject.h代码，增加DLL导出类接口方法，增加类接口成员变量IExport和DLL句柄变量hDll，如下所示：123456789101112131415161718192021222324252627282930313233343536// myobject.h#ifndef MYOBJECT_H#define MYOBJECT_H#include &lt;node.h&gt;#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;node_object_wrap.h&gt;#include &quot;MatureApproach.h&quot;namespace demo &#123;typedef IExport*(*TYPE_fnCreateExportObj) (void);//定义函数指针 typedef void(*TYPE_fnDestroyExportObj) (IExport*);//定义函数指针 class MyObject : public node::ObjectWrap &#123; public: static void Init(v8::Isolate* isolate); static void NewInstance(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); private: explicit MyObject(double value = 0); ~MyObject(); static void New(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); static void PlusOne(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); static void Hi(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); static void Test(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args); static v8::Persistent&lt;v8::Function&gt; constructor; HMODULE hDll; IExport* pExport; double value_;&#125;;&#125; // namespace demo#endif 接下来将在MyObject类的构造函数中动态加载DLL，创建DLL导出类对象，在析构函数中析构DLL导出类对象，动态卸载DLL,在MyObject成员方法中调用DLL导出类方法，代码如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// myobject.cc#include &lt;node.h&gt;#include &quot;myobject.h&quot;namespace demo &#123;using v8::Context;using v8::Function;using v8::FunctionCallbackInfo;using v8::FunctionTemplate;using v8::Isolate;using v8::Local;using v8::Number;using v8::Object;using v8::Persistent;using v8::String;using v8::Value;Persistent&lt;Function&gt; MyObject::constructor;MyObject::MyObject(double value) : value_(value)&#123; MyObject::hDll = LoadLibrary(&quot;MatureApproach.dll&quot;); //加载动态链接库DllDemo.dll文件； TYPE_fnCreateExportObj fnCreateExportObj = (TYPE_fnCreateExportObj)GetProcAddress(MyObject::hDll, &quot;CreateExportObj&quot;); MyObject::pExport = fnCreateExportObj();&#125;MyObject::~MyObject() &#123; TYPE_fnDestroyExportObj fnDestroyExportObj = (TYPE_fnDestroyExportObj)GetProcAddress(MyObject::hDll, &quot;DestroyExportObj&quot;); fnDestroyExportObj(MyObject::pExport); FreeLibrary(MyObject::hDll);&#125;void MyObject::Init(Isolate* isolate) &#123; // Prepare constructor template Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(isolate, New); tpl-&gt;SetClassName(String::NewFromUtf8(isolate, &quot;MyObject&quot;)); tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(3); // Prototype NODE_SET_PROTOTYPE_METHOD(tpl, &quot;plusOne&quot;, PlusOne); NODE_SET_PROTOTYPE_METHOD(tpl, &quot;hi&quot;, Hi); NODE_SET_PROTOTYPE_METHOD(tpl, &quot;test&quot;, Test); constructor.Reset(isolate, tpl-&gt;GetFunction());&#125;void MyObject::New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); if (args.IsConstructCall()) &#123; // Invoked as constructor: `new MyObject(...)` double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue(); MyObject* obj = new MyObject(value); obj-&gt;Wrap(args.This()); args.GetReturnValue().Set(args.This()); &#125; else &#123; // Invoked as plain function `MyObject(...)`, turn into construct call. const int argc = 1; Local&lt;Value&gt; argv[argc] = &#123; args[0] &#125;; Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor); Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext(); Local&lt;Object&gt; instance = cons-&gt;NewInstance(context, argc, argv).ToLocalChecked(); args.GetReturnValue().Set(instance); &#125;&#125;void MyObject::NewInstance(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); const unsigned argc = 1; Local&lt;Value&gt; argv[argc] = &#123; args[0] &#125;; Local&lt;Function&gt; cons = Local&lt;Function&gt;::New(isolate, constructor); Local&lt;Context&gt; context = isolate-&gt;GetCurrentContext(); Local&lt;Object&gt; instance = cons-&gt;NewInstance(context, argc, argv).ToLocalChecked(); args.GetReturnValue().Set(instance);&#125;void MyObject::PlusOne(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder()); obj-&gt;value_ += 1; args.GetReturnValue().Set(Number::New(isolate, obj-&gt;value_));&#125;void MyObject::Hi(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder()); Local&lt;String&gt; str=v8::String::NewFromUtf8(isolate, obj-&gt;pExport-&gt;Hi().data()); args.GetReturnValue().Set(str);&#125;void MyObject::Test(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.Holder()); Local&lt;String&gt; str=v8::String::NewFromUtf8(isolate, obj-&gt;pExport-&gt;Test().data()); args.GetReturnValue().Set(str);&#125;&#125; // namespace demo 参考链接 https://itbilu.com/nodejs/core/4y4-Nrd5G.html，by IT笔录 https://nodejs.org/dist/latest-v8.x/docs/api/addons.html，by nodejs http://taobaofed.org/blog/2016/09/20/type-casts-between-node-and-cpp/，by 淘宝前端团队 https://huangwang.github.io/2018/06/15/DLL导出类和函数/,by jackhuang]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Vistual_Studio中调试Node_Addon_C++插件]]></title>
    <url>%2F2018%2F06%2F18%2F%E5%A6%82%E4%BD%95%E5%9C%A8Vistual-Studio%E4%B8%AD%E8%B0%83%E8%AF%95Node-Addon-C-%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近研究如何在Vistual Studio 2017社区版中调试Node addon C++插件，遇到很多问题，花费了不少时间，为防止遗忘，将方法记录下来。 准备工作 安装VS2017社区版 安装python 2.7 安装Nodejs 8.11.3 LTS 下载Nodejs 8.11.3 LTS源码 安装配置环境 安装node-gyp和nannode-gyp和nan用于编译生成node addon 插件。 12npm install -g node-gypnpm install -g nan 编译nodejs源码在nodejs源码解压后文件夹中执行如下命令： 1.\vcbuild.bat debug x64 创建nodejs addon c++插件示例工程使用如下命名生成调试用的vs工程： 1node-gyp configure rebuild --nodedir=&quot;D:\project\cpp_project\node-v8.11.3&quot; --debug 修改测试用的index.js,使其调用上一步骤生成的调试用的插件 //该js调用生成的插件 var addon = require(&#39;./build/Debug/max&#39;); var y=addon.max(2,3); console.log(y); 使用VS2017打开插件示例工程的build文件夹下node-gyp生成的解决方案。右键单击工程，在上下文菜单中点击属性，配置其调试命令和命令参数，如下图所示。 设置断点进行调试 参考链接 https://blog.csdn.net/zcyzsy/article/details/72821755, by Zmyths. https://computer-vision-talks.com/how-to-debug-nodejs-addons-in-visual-studio/.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DLL导出类和函数]]></title>
    <url>%2F2018%2F06%2F15%2FDLL%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%92%8C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[最近研究在DLL中导出类，探寻最佳的DLL导出类的方法和技术。把整个过程记录一下，防止遗忘。 基础知识动态链接库动态链接库（英语：Dynamic-link library，缩写为DLL）是微软公司在微软视窗操作系统中实现共享函数库概念的一种实现方式。这些库函数的扩展名是.DLL、.OCX（包含ActiveX控制的库）或者.DRV（旧式的系统驱动程序)。 所谓动态链接，就是把一些经常会共用的代码（静态链接的OBJ程序库）制作成DLL档，当可执行文件调用到DLL档内的函数时，Windows操作系统才会把DLL档加载存储器内，DLL档本身的结构就是可执行档，当程序有需求时函数才进行链接。通过动态链接方式，存储器浪费的情形将可大幅降低。静态链接库则是直接链接到可执行文件。 编写方法使用DLL导出C函数或全局变量很简单，具体代码如下：12345678910111213141516171819// 下列 ifdef 块是创建使从 DLL 导出更简单的// 宏的标准方法。此 DLL 中的所有文件都是用命令行上定义的 DLLDEMO_EXPORTS// 符号编译的。在使用此 DLL 的// 任何其他项目上不应定义此符号。这样，源文件中包含此文件的任何其他项目都会将// DLLDEMO_API 函数视为是从 DLL 导入的，而此 DLL 则将用此宏定义的// 符号视为是被导出的。#ifdef DLLDEMO_EXPORTS#define DLLDEMO_API __declspec(dllexport)#else#define DLLDEMO_API __declspec(dllimport)#endifextern &quot;C&quot; extern DLLDEMO_API int nDllDemo;//不使用extern &quot;C&quot;将导致函数名字改编DLLDEMO_API int fnDllDemo(int);extern &quot;C&quot; DLLDEMO_API int fnExternCDllDemo(int); 运行时通知DLL进程/线程加载进程/线程加载时，可以通过DllMain函数通知DLL相关信息，提供对应处理的机会。12345678910111213141516171819BOOL WINAPI DLLMain(HINSTANCE hinstDLL,DWORD fdwReason,LPVOID fImpLoad)&#123; switch(fdwReason) &#123; case DLL_PROCESS_ATTACH: //当这个DLL第一次被映射到了这个进程的地址空间时。DLLMain函数的返回值为FALSE，说明DLL的初始化没有成功，系统就会终结整个进程，去掉所有文件映象，之后显示一个对话框告诉用户进程不能启动。 break; case DLL_THREAD_ATTACH: //一个线程被创建，新创建的线程负责执行这次的DllMain函数。系统不会让进程已经存在的线程以DLL_THREAD_ATTACH的值来调用DllMain函数。主线程永远不会以DLL_THREAD_ATTACH的值来调用DllMain函数。系统是顺序调用DllMain函数的，一个线程执行完DllMain函数才会让另外一个线程执行DllMain函数。 break; case DLL_THREAD_DETACH: //如果线程调用了ExitThread来结束线程（线程函数返回时，系统也会自动调用ExitThread）。线程调用了TerminateThread，系统就不会用值DLL_THREAD_DETACH来调用所有DLL的DllMain函数。 break; case DLL_PROCESS_DETACH: //这个DLL从进程的地址空间中解除映射。如果进程的终结是因为调用了TerminateProcess，系统就不会用DLL_PROCESS_DETACH来调用DLL的DllMain函数。这就意味着DLL在进程结束前没有机会执行任何清理工作。 break; &#125; return(TRUE);&#125; DLL的静态调用方法采用静态调用方法，DLL最终将打包到生成的EXE中。静态调用方法步骤如下[2]： 把你的youApp.DLL拷到你目标工程(需调用youApp.DLL的工程)的Debug目录下; 把你的youApp.lib拷到你目标工程(需调用youApp.DLL的工程)目录下; 把你的youApp.h(包含输出函数的定义)拷到你目标工程(需调用youApp.DLL的工程)目录下; 打开你的目标工程选中工程,选择Visual C++的Project主菜单的Settings菜单; 执行第4步后，VC将会弹出一个对话框，在对话框的多页显示控件中选择Link页。然后在Object/library modules输入框中输入:youApp.lib 选择你的目标工程Head Files加入：youApp.h文件; 最后在你目标工程(*.cpp,需要调用DLL中的函数)中包含你的:#include “youApp.h” DLL的动态调用方法动态调用DLL的步骤： 创建一个函数指针，其指针数据类型要与调用的DLL引出函数相吻合。 通过Win32 API函数LoadLibrary()显式的调用DLL，此函数返回DLL的实例句柄。 通过Win32 API函数GetProcAddress()获取要调用的DLL的函数地址, 把结果赋给自定义函数的指针类型。 使用函数指针来调用DLL函数。 最后调用完成后，通过Win32 API函数FreeLibrary()释放DLL函数。 123456789101112131415161718192021222324int main()&#123; HMODULE hModule = LoadLibrary(_T(&quot;DllDemo.dll&quot;)); typedef int(*TYPE_fnDllDemo) (int);//定义函数指针 typedef int(*TYPE_fnExternCDllDemo) (int);//定义函数指针 //创建类对象 CDllDemo* pCDllDemo = (CDllDemo*)malloc(sizeof(CDllDemo)); TYPE_fnDllDemo fnDllDemo = (TYPE_fnDllDemo)GetProcAddress(hModule, &quot;?fnDllDemo@@YAHH@Z&quot;); int *nDllDemo = (int *)GetProcAddress(hModule, &quot;nDllDemo&quot;); TYPE_fnExternCDllDemo fnExternCDllDemo = (TYPE_fnExternCDllDemo)GetProcAddress(hModule, &quot;fnExternCDllDemo&quot;); if (pCDllDemo != NULL) // printf(&quot;pCDllDemo-&gt;Max(32,42) = %d\n&quot;, pCDllDemo-&gt;Max(32, 42));//Dll导出类的调用太麻烦，因为DLL本来就是为C函数服务设计的。 if (fnDllDemo != NULL) printf(&quot;fnDllDemo(32) = %d\n&quot;, fnDllDemo(32)); if (nDllDemo != NULL) printf(&quot;*nDllDemo = %d\n&quot;, *nDllDemo); if (fnExternCDllDemo != NULL) printf(&quot;fnExternCDllDemo(22) = %d\n&quot;, fnExternCDllDemo(22)); _tsystem(_T(&quot;pause&quot;)); FreeLibrary(hModule); return 0;&#125; COM技术COM主要是一套给C/C++用的接口，当然为了微软的野心，它也被推广到了VB、Delphi以及其他一大堆奇奇怪怪的平台上。它主要为了使用dll发布基于interface的接口。我们知道dll的接口是为了C设计的，它导出的基本都是C的函数，从原理上来说，将dll加载到内存之后，会告诉你一组函数的地址，你自己call进去就可以调用相应的函数[3]。 但是对于C++来说这个事情就头疼了，现在假设你有一个类，我们知道使用一个类的第一步是创建这个类：new MyClass()。这里直接就出问题了，new方法通过编译器计算MyClass的大小来分配相应的内存空间，但是如果库升级了，相应的类可能会增加新的成员，大小就变了，那么使用旧的定义分配出来的空间就不能在新的库当中使用。 要解决这问题，我们必须在dll当中导出一个CreateObject的方法，用来代替构造函数，然后返回一个接口。然而，接口的定义在不同版本当中也是有可能会变化的，为了兼容以前的版本同时也提供新功能，还需要让这个对象可以返回不同版本的接口。接口其实是一个只有纯虚函数的C++类，不过对它进行了一些改造来兼容C和其他一些编程语言。 在这样改造之后，出问题的还有析构过程~MyClass()或者说delete myClass，因为同一个对象可能返回了很多个接口，有些接口还在被使用，如果其中一个被人delete了，其他接口都会出错，所以又引入了引用计数，来让许多人可以共享同一个对象。 其实到此为止也并不算是很奇怪的技术，我们用C++有的时候也会使用Factory方法来代替构造函数实现某些特殊的多态，也会用引用计数等等。COM技术的奇怪地方在于微软实在是脑洞太大了，它们构造了一个操作系统级别的Factory，规定所有人的Interface都统一用UUID来标识，以后想要哪个Interface只要报出UUID来就行了。这样甚至连链接到特定的dll都省了。 这就好比一个COM程序员，只要他在Windows平台上，调用别的库就只要首先翻一下魔导书，查到了一个用奇怪文字写的“Excel = {xxx-xxx-xxxx…}”的记号，然后它只要对着空中喊一声：“召唤，Excel！CoCreateInstance, {xxx-xxx-xxxx…}”然后呼的从魔法阵里面窜出来了一个怪物，它长什么样我们完全看不清，因为这时候它的类型是IUnknow，这是脑洞奇大无比的微软为所有接口设计的一个基类。 我们需要进一步要求它变成我们能控制的接口形态，于是我们再喊下一条指令：“变身，Excel 2003形态！QueryInterface, {xxx-xxx-xxxx…}”QueryInterface使用的是另一个UUID，用来表示不同版本的接口。于是怪物就变成了我们需要的Excel 2003接口，虽然我们不知道它实际上是2003还是2007还是更高版本。等我们使唤完这只召唤兽，我们就会对它说“回去吧，召唤兽！Release！”但是它不一定听话，因为之前给它的命令也许还没有执行完，它会忠诚地等到执行完再回去，当然我们并不关心这些细节。 微软大概会觉得自己设计出了软件史上最完美的二进制接口，从今以后所有的第三方库都可以涵盖在这套接口之下。然而历史的车轮是无情的，它碾过那些自以为是的人的速度总是会比想象的更快。Java的直接基于类的接口被广泛应用，开发使用起来远远来的简单，即便偶尔出点问题大家也都想办法解决了，事实证明程序员并不愿意花10倍的编写代码的时间来解决二进制库的版本兼容问题，他们更愿意假装没看见。很快微软也抄了一个.NET托管dll的方案出来，于是纯的二进制接口COM就慢慢被抛弃了。 COM，OLE，ActiveX，OCX，VBScript，历史不会忘记你们的，如果历史忘了，我替历史记住你们。安息吧。 DLL导出类借鉴COM技术，这里直接给出DLL到处类的成熟方法，可有效避免DLL地狱问题。具体结构为： 导出类是一个派生类，派生自一个抽象类——都是纯虚函数。使用者需要知道这个抽象类的结构。DLL最少只需要提供一个用于获取类对象指针的接口。使用者跟DLL提供者共用一个抽象类的头文件，使用者依赖于DLL的东西很少，只需要知道抽象类的接口，以及获取对象指针的导出函数，对象内存空间的申请是在DLL模块中做的，释放也在DLL模块中完成,最后记得要调用释放对象的函数。 这种方式比较好，通用，产生的DLL没有特定环境限制。借助了C++类的虚函数。一般都是采用这种方式。除了对DLL导出类有好处外，采用接口跟实现分离，可以使得工程的结构更清晰，使用者只需要知道接口，而不需要知道实现。 具体代码如下： DLL导出类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//DLL导出类头文件MatureApproach.h，与DLL使用者共享#ifdef MATUREAPPROACH_EXPORTS#define MATUREAPPROACH_API __declspec(dllexport)#else#define MATUREAPPROACH_API __declspec(dllimport)#endifclass IExport &#123;public: virtual void Hi() = 0; virtual void Test() = 0; virtual void Release() = 0;&#125;;extern &quot;C&quot; MATUREAPPROACH_API IExport* _stdcall CreateExportObj();extern &quot;C&quot; MATUREAPPROACH_API void _stdcall DestroyExportObj(IExport* pExport);//DLL导出接口函数的实现MatureApproach.cpp#include &quot;stdafx.h&quot;#include &quot;MatureApproach.h&quot;#include &quot;ExportClassImpl.h&quot;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;MATUREAPPROACH_API IExport* APIENTRY CreateExportObj()&#123; return new ExportImpl;&#125;//这里不能直接delete pExport，因为没有把IExport的析构函数定义为虚函数MATUREAPPROACH_API void APIENTRY DestroyExportObj(IExport* pExport)&#123; pExport-&gt;Release();&#125; DLL导出类的具体实现 123456789101112131415161718192021222324252627282930313233343536//DLL导出类头文件ExportClassImpl.h#include &quot;MatureApproach.h&quot;class ExportImpl : public IExport&#123;public: virtual void Hi(); virtual void Test(); virtual void Release(); ~ExportImpl();private:&#125;;//DLL导出类的实现ExportClassImpl.cpp#include &quot;stdafx.h&quot;#include &quot;ExportClassImpl.h&quot;void ExportImpl::Hi()&#123; wcout &lt;&lt; L&quot;Hello World&quot; &lt;&lt; endl;&#125;void ExportImpl::Test()&#123; wcout &lt;&lt; L&quot;Hi cswuyg&quot; &lt;&lt; endl;&#125;void ExportImpl::Release()&#123; delete this;&#125;ExportImpl::~ExportImpl()&#123; cout &lt;&lt; &quot;Release OK&quot; &lt;&lt; endl;&#125; 参考链接 https://zh.wikipedia.org/wiki/动态链接库, by wikipedia http://www.cnblogs.com/micro-chen/p/5937428.html，by 特洛伊-Micro https://www.zhihu.com/question/49433640/answer/115952604, by 灵剑. http://www.cnblogs.com/cswuyg/archive/2011/10/06/DLL2.html，by 烛秋.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium卫星地图和高程数据切片经验总结]]></title>
    <url>%2F2018%2F06%2F13%2FCesium%E5%8D%AB%E6%98%9F%E5%9C%B0%E5%9B%BE%E5%92%8C%E9%AB%98%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%88%87%E7%89%87%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近研究在Cesium中调用自定义的图像和地形，不借助任何GIS系统（如Arcgis、天地图等），方便在网络不好或离线的情况下使用。下面对整个过程进行总结。 基础知识地图服务提供方法目前互联网地图服务商提供的地图服务分成两种[3]： 图像瓦片地图服务这种方法目前最常见，其提供的是图片格式的瓦片，在客户端将拼接成真正的地图。 矢量瓦片地图服务这种方法正在发展，其提供矢量的瓦片数据，然后在客户端进行渲染，是今后的发展方向。 地图服务在使用过程中需要获取特定经纬度所在区域的瓦片和获取瓦片上像素点对应的经纬度，因此需要进行经纬度坐标与瓦片坐标、像素坐标的相互转换。 经纬度与瓦片编号互换互联网地图的经纬度坐标与瓦片坐标相互转换只与该地图商的墨卡托投影和瓦片编号的定义有关，跟地图商采用的大地坐标系标准无关。 经纬度与瓦片像素互换转换方式与地图商采用的大地坐标系有关。国际标准的经纬度坐标是WGS84。Open Street Map、外国版的Google Map都是采用WGS84；高德地图使用的坐标系是GCJ-02；百度地图使用的坐标系是BD-09。 地图投影地图投影，是指按照一定的数学法则将地球椭球面上的经纬网转换到平面上，使地面的地理坐标与平面直角坐标建立起函数关系。这是绘制地图的数学基础之一。由于地球是一个不可展的球体，使用物理方法将其展平会引起褶皱、拉伸和断裂，因此要使用地图投影实现由曲面向平面的转化。 麦卡托投影法麦卡托投影法 (Mercator projection)，又称麦卡托投影法、正轴等角圆柱投影，是一种等角的圆柱形地图投影法。本投影法得名于法兰德斯出身的地理学家杰拉杜斯·麦卡托，他于1569年发表长202公分、宽124公分以此方式绘制的世界地图。在以此投影法绘制的地图上，经纬线于任何位置皆垂直相交，使世界地图可以绘制在一个长方形上。由于可显示任两点间的正确方位，航海用途的海图、航路图大都以此方式绘制。在该投影中线型比例尺在图中任意一点周围都保持不变，从而可以保持大陆轮廓投影后的角度和形状不变（即等角）；但麦卡托投影会使面积产生变形，极点的比例甚至达到了无穷大。 各大地图服务商大都采用了Web Mercator进行投影，瓦片坐标系的不同主要是投影截取的地球范围不同、瓦片坐标起点不同[3]。 ## 瓦片切割和瓦片坐标 对于经过墨卡托投影为平面的世界地图，在不同的地图分辨率(整个世界地图的像素大小)下，通过切割的方式将世界地图划分为像素为256px/256px的地图单元，划分成的每一块地图单元称为地图瓦片。其特定如下： * 具有唯一的瓦片等级（Level）和瓦片坐标编号（tileX, tileY）。 * 瓦片分辨率为256*256。 * 最小的地图等级是0，此时世界地图只由一张瓦片组成。 * 瓦片等级越高，组成世界地图的瓦片数越多，可以展示的地图越详细。 * 某一瓦片等级地图的瓦片是由低一级的各瓦片切割成的4个瓦片组成，形成了瓦片金字塔。 过程总结将自定义图像和地形以Web形式发布后，在cesium中调用自定义图像和地形很简单，代码如下，关键是图像和地形的获取和处理。123456789101112131415var tmsImageryProvider=Cesium.createTileMapServiceImageryProvider(&#123; url:&apos;http://localhost:8080/test_tms_tiles&apos;&#125;);var terrainProvider=new Cesium.CesiumTerrainProvider(&#123; url:&apos;http://localhost:8080/terrain_tiles&apos;&#125;);var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;, &#123; imageryProvider : tmsImageryProvider, terrainProvider: terrainProvider, baseLayerPicker: false, geocoder: false, shadows: false, shouldAnimate: true&#125;) 卫星图像的获取和处理卫星图像获取可以使用一些相关软件，如水经注等。其原理通常是从一些地图服务商下载地图瓦片后重新拼接，再分割成对应格式的瓦片。拼接的图像最好输出为tif格式，因为tif格式可以在头部包含一些信息，例如地理坐标等信息，以方便后续的瓦片切割，以及被GIS系统直接识别导入。为使切割后的瓦片能够被Cesium直接调用，应采用标准TMS方式。通常卫星图像下载软件提供多种瓦片分割方式，如果能直接进行标准TMS瓦片分割最好不过，如果不可以进行标准TMS分割，则可使用GDAL。GDAL是地理空间数据抽象库的简称，是一个地理空间数据的格式转换及处理工具。文章最后将详细介绍其安装使用方法。使用GDAL进行卫星图像瓦片分割主要使用gdal2tiles.py工具。具体步骤如下： 选取之前下载拼接的最大分辨率的tif卫星图像 使用如下命令切割卫星图片,将自动生成瓦片金字塔。1gdal2tiles.py &lt;image&gt; &lt;tilesdir&gt; 地形的获取和处理Cesium支持多种地形provider来接收地形数据瓦片[8]： Cesium Terrain Server——高分辨率的全球地形数据，支持地形光照和水流效果。地形瓦片提交给客户端的数据的格式用的是quantized-mesh v1.0。 Esri ArcGIS Image Server——从Esri影像服务里的高度图中产生地形数据集。详情见Cesium里的ArcGisImageServerTerrainProvider. VR-TheWorld Server——从一个VR-TheWorld服务里的高度图中产生地形数据。它们的托管服务器有全球90米的数据，包括深度测量。 Ellipsoid——是Cesium默认的地形provider，是一个光滑的椭球面，没有现实的地形，地形高度为0。 常用的CesiumTerrainProvider支持两种格式的地形：一种是quantized-mesh格式的地形数据，另一种是基于高度图技术的DEM。前一种技术是Cesium独有不开放，因此将使用DEM数据在Cesium中渲染地形。 DEM数据是数字高程模型，是描述每个点位的高程数据，没有其他附加信息[9]。DEM数据在ArcGIS中打开只能看到是灰度图。通过相关软件可直接下载各大地图服务商的高程数据，但没有在Cesium中加载成功。下面介绍一种经过验证可在Cesium中成功加载地形的方法： 下载地形数据。可以从地理空间数据云下载地形数据，网址为http://www.gscloud.cn/。注册登录后，在首页选择“DEM 数字高程数据”，在选择“GDEMV2 30M 分辨率数字高程数据”。 合并地形数据。使用GDAL下的gdal_merge.py工具将下载的地形数据合并成一个Tif文件。 1gdal_merge.py -o out.tif input1.tif input2.tif 切割地形数据。使用牛人制作的gdal2srtmtiles.py脚本分割地形数据。编辑gdal2srtmtiles.py，在最后设置高程文件和输出目录。 发布地形服务。把terrain_tiles直接放到与 Cesium同端口的Tomcat或IIS站点下（不能跨域），即可发布服务。 需要在Web Server中增加配置 .terrain文件的 Content-Type设为 application/octet-stream，同时拷贝“覆盖至生成tiles结果”目录中的 layer.json文件和0文件夹至生成结果目录下，比如我当前是 terrain_tiles目录下。 GDAL的安装使用GDAL不推荐从源码编译安装，建议从gisinternals下载gdal-203-1911-x64-core.msi、GDAL-2.3.0.win-amd64-py2.7.msi直接二进制安装。安装步骤如下： 安装python2.7。安装完成后配置环境变量，在path中添加 C:\Python27; 安装gdal-203-1911-x64-core.msi。安装完成后，设置环境变量GDAL_DATA，值为C:\Program Files\GDAL\gdal-data\，修改环境变量PATH，增加C:\Program Files\GDAL; pip install numpy。这是为了使用地形切割的脚本gdal2srtmtiles.py。 安装GDAL-2.3.0.win-amd64-py2.7.msi。 参考链接 https://cesiumjs.org/tutorials/Imagery-Layers-Tutorial/, by cesiumjs https://cesiumjs.org/tutorials/Terrain-Tutorial/, by cesiumjs http://cntchen.github.io/2016/05/09/国内主要地图瓦片坐标系定义及计算原理/, by CntChen https://zh.wikipedia.org/wiki/地图投影, by wikipedia https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/, by Yan Yinhong https://blog.csdn.net/wbz810/article/details/79294511，by wbz810. http://www.gdal.org/，by gdal https://blog.csdn.net/u013929284/article/details/71616600, by Super洛伽 https://www.jianshu.com/p/62d6f03f44e3，by CrazyGIS]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium中飞行器姿态控制]]></title>
    <url>%2F2018%2F06%2F10%2FCesium%E4%B8%AD%E9%A3%9E%E8%A1%8C%E5%99%A8%E5%A7%BF%E6%80%81%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[问题提出最近研究开源虚拟地球Cesium，遇到一个问题：在获取飞行器经度纬度高度偏航俯仰滚转六个参数的前提下，如何在Cesium中用CZML文件表示，从而完美实现飞行器姿态轨迹的复现。在CZML的position属性中使用cartographicDegrees表示飞行器的经度纬度高度，可以很好复现飞行器的轨迹。然而在CZML的orientation属性中使用unitQuaternion表示飞机自身姿态时，飞机姿态总是不对。 问题分析基本知识在Cesium中存在两种常用坐标系： 世界坐标系世界坐标系统是以椭球中心为原点的笛卡尔空间直角坐标系。 地理坐标系地理坐标系即人们常用的使用经度、纬度、高度表示位置的坐标系。 站心坐标系又称为Earth-fixed coordinate system（站点坐标系、东-北-天坐标系ENU）。可分为站心直角坐标系和站心极坐标系。常用的站心直角坐标系定义为：以站心（如GPS接收天线中心）为坐标系原点O，Z轴与椭球法线重合，向上为正（天向），y与椭球短半轴重合（北向），x轴与地球椭球的长半轴重合（东向）所构成的直角坐标系，称为当地东北天坐标系（ENU）。飞行器的偏航、俯仰、滚转即是以站心直角坐标系为参考。 模型坐标系模型坐标系以物体的中心为坐标原点，物体旋转、平移等操作都是围绕局部坐标系进行的。这时当物体模型进行旋转、平移等操作时，局部坐标系也执行相应的旋转、平移等操作。局部坐标系是一个假想的坐标系，该坐标系与物体的相对位置至始至终是不变的，假想出这个坐标系的目的主要是为了正向理解对三维场景中物体执行的平移和旋转操作。使用局部坐标系理解模型变换时，所有的变换操作直接作用与局部坐标系，由于局部坐标系与物体的相对位置不变，因此对局部坐标系进行平移、旋转和缩放时，物体在场景中位置和形状也会发生相应的变化。 在Cesium中存在两种世界坐标系和地理坐标系之间坐标转换的方法：123456789# 经纬度转换为世界坐标Cesium.Cartesian3.fromDegrees(longitude, latitude, height, ellipsoid, result) # 世界坐标转换为经纬度var ellipsoid=viewer.scene.globe.ellipsoid;var cartesian3=new Cesium.cartesian3(x,y,z);var cartographic=ellipsoid.cartesianToCartographic(cartesian3);var lat=Cesium.Math.toDegrees(cartograhphic.latitude);var lng=Cesium.Math.toDegrees(cartograhpinc.longitude);var alt=cartographic.height; CZML分析CZML是一种用来描述动态场景的JSON架构的语言，主要用于Cesium在浏览器中的展示。它可以用来描述点、线、布告板、模型以及其他的图元，同时定义他们是怎样随时间变化的[3]。CZML可使用model属性直接加载3D模型，由position属性决定模型在世界坐标系内的位置，由orientation决定模型在世界坐标系内的姿态，并最终由orientation的unitQuaternion表示。unitQuaternion即单位四元数，可与偏航俯仰滚转相互转换，并避免偏航俯仰滚转的万向节锁定问题，但其本质上都是一个旋转矩阵，可决定模型在世界坐标系内的姿态。 获取正确的飞行器姿态首先计算飞行器模型坐标系对站点直角坐标系的旋转矩阵（在制作飞行器3D模型时，应使其中心在本地坐标系原点，机头机翼与轴平行，方便计算在站点直角坐标系内的旋转角度），再乘以由飞行器偏航俯仰滚转得到的旋转矩阵，再乘以站点直角坐标系对世界坐标系的旋转矩阵。将最终得到旋转矩阵转换为单位四元数，即得到正确的飞行器姿态。 解决方法参考代码如下：123456var lon=113,lat=34;//模型的站心经纬度var h1=0,p1=0,r1=0;//模型坐标系对站点坐标系的旋转角度var h2=0,p2=0,r2=0;//模型在站点坐标系的姿态var center = Cesium.Cartesian3.fromDegrees(lon, lat)var hpr = new Cesium.HeadingPitchRoll(h1+h2, p1+p2, r1+r2)var q1 = Cesium.Transforms.headingPitchRollQuaternion(center, hpr) 参考链接 https://stackoverflow.com/questions/43389069/cesium-how-to-animate-an-aircraft-from-pitch-roll-heading, by stackoverflow. https://blog.csdn.net/qq_34149805/article/details/78393540. by finalLi. http://www.cnblogs.com/laixiangran/p/4997971.html. by laixiangran. https://github.com/AnalyticalGraphicsInc/cesium/wiki/CZML-Structure. by AnalyticalGraphicsInc. 3D坐标系.https://www.jianshu.com/p/8d483fa1acbd. by S_H_C. 3D空间的坐标系. https://blog.csdn.net/trojanpizza/article/details/6652533. by trojanpizza.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春江花月夜]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%98%A5%E6%B1%9F%E8%8A%B1%E6%9C%88%E5%A4%9C%2F</url>
    <content type="text"><![CDATA[作者：张若虚 春江潮水连海平，海上明月共潮生。 滟滟随波千万里，何处春江无月明？ 江流宛转绕芳甸，月照花林皆似霰。 空里流霜不觉飞，汀上白沙看不见。 江天一色无纤尘，皎皎空中孤月轮。 江畔何人初见月，江月何年初照人？ 人生代代无穷已，江月年年祇相似。 不知江月待何人？但见长江送流水。 白云一片去悠悠，青枫浦上不胜愁。 谁家今夜扁舟子，何处相思明月楼？ 可怜楼上月徘徊，应照离人妆镜台。 玉户帘中卷不去，捣衣砧上拂还来。 此时相望不相闻，愿逐月华流照君。 鸿雁长飞光不度，鱼龙潜跃水成文。 昨夜闲潭梦落花，可怜春半不还家。 江水流春去欲尽，江潭落月复西斜。 斜月沉沉藏海雾，碣石潇湘无限路。 不知乘月几人归，落月摇情满江树。]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>唐诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cesium小部件animation和timeline的系统时间显示]]></title>
    <url>%2F2018%2F06%2F09%2FCesium%E5%B0%8F%E9%83%A8%E4%BB%B6animation%E5%92%8Ctimeline%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[Cesium的小部件animation和timeline显示UTC系统时间，需要将其改为本地系统时间。修改方法如下：12345678910111213141516171819202122232425this.viewer.animation.viewModel.dateFormatter = localeDateTimeFormatterthis.viewer.animation.viewModel.timeFormatter = localeTimeFormatterthis.viewer.timeline.makeLabel = function (time) &#123; return localeDateTimeFormatter(time) &#125;// Date formatting to a global formfunction localeDateTimeFormatter(datetime, viewModel, ignoredate) &#123; var julianDT = new Cesium.JulianDate(); Cesium.JulianDate.addHours(datetime,8,julianDT) var gregorianDT= Cesium.JulianDate.toGregorianDate(julianDT) var objDT; if (ignoredate) objDT = &apos;&apos;; else &#123; objDT = new Date(gregorianDT.year, gregorianDT.month - 1, gregorianDT.day); objDT = gregorianDT.year + &apos;年&apos; +objDT.toLocaleString(&quot;zh-cn&quot;, &#123; month: &quot;short&quot; &#125;)+ gregorianDT.day + &apos;日&apos; ; if (viewModel || gregorianDT.hour + gregorianDT.minute === 0) return objDT; objDT += &apos; &apos;; &#125; return objDT + Cesium.sprintf(&quot;%02d:%02d:%02d&quot;, gregorianDT.hour, gregorianDT.minute, gregorianDT.second);&#125;function localeTimeFormatter(time, viewModel) &#123; return localeDateTimeFormatter(time, viewModel, true);&#125; 上述代码还存在一个问题，当timeline小部件不活动时，其仍然显示UTC标准系统时间。 参考链接 https://blog.csdn.net/chienchia/article/details/29185479, by chienchia. https://stackoverflow.com/questions/45875490/change-utc-timezone-to-sgt-timezone-in-cesiumjs, by stackoverflow.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>Cesium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib蜡烛图绘制教程]]></title>
    <url>%2F2018%2F06%2F03%2FMatplotlib%E8%9C%A1%E7%83%9B%E5%9B%BE%E7%BB%98%E5%88%B6%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[股票分析离不开各种图表的绘制，尤其是最常用的蜡烛图。下面介绍python中使用matplotlib绘制蜡烛图的过程。 环境及配置使用的环境如下：123456789101112$ python3 --versionPython 3.6.5rc1$ ipython3In [1]: import matplotlibIn [2]: matplotlib.__version__Out[2]: &apos;2.2.2&apos;In [3]: import tushare as tsIn [4]: ts.__version__Out[4]: &apos;1.1.9&apos;In [5]: import talibIn [6]: talib.__version__Out[6]: &apos;0.4.17&apos; 绘制蜡烛图通常使用matplotlib.finance库，但这个库在matplotlib 2.0后已经被废弃，并被移到一个名叫mpl_finance的库中。可使用如下命令安装mpl_finance。1pip3 install https://github.com/matplotlib/mpl_finance/archive/master.zip mpl_finance使用雅虎接口获取股票数据，但是不稳定，因此推荐使用tushare库获取股票数据。另外使用talib计算股票各种技术分析指标，例如常用的均线数据。需要注意的是通过pip3按照的talib库是对C/C++版talib的包装，因此需先安装C/C++版talib。 蜡烛图绘制蜡烛图绘制函数简介mpl_finance库中蜡烛图的绘制主要有以下四个函数：1234candlestick2_ochl(ax, opens, closes, highs, lows, width=4, colorup=&apos;k&apos;, colordown=&apos;r&apos;, alpha=0.75)candlestick2_ohlc(ax, opens, highs, lows, closes, width=4, colorup=&apos;k&apos;, colordown=&apos;r&apos;, alpha=0.75)candlestick_ochl(ax, quotes, width=0.2, colorup=&apos;k&apos;, colordown=&apos;r&apos;, alpha=1.0)candlestick_ohlc(ax, quotes, width=0.2, colorup=&apos;k&apos;, colordown=&apos;r&apos;, alpha=1.0) 在这四个函数的使用过程中需要注意的是： candlestick2_ohlc函数假定opens, highs, lows, closes中任意一个值不存在，则其他值也不存在。 candlestick_ochl和candlestick_ohlc的输入参数quotes是(time, open, close, high, low, …)元组序列，其中time必须是浮点日期格式，具体参见date2num。 蜡烛图绘制函数存在日线图的时间间隔问题（非交易日无法跳过，导致图像断裂）。常用解决方法是建议重新调整横坐标，被动地过滤掉非交易时间段[2]。例如：12ax.set_xticks(range(0, len(data[&apos;date&apos;]), 10))ax.set_xticklabels(data[&apos;date&apos;][::10]) 蜡烛图的简单绘制蜡烛图的简单例子如下：12345678910111213141516171819import numpy as npimport talibimport tushare as tsimport matplotlib.pyplot as pltimport mpl_finance as mpf data = ts.get_k_data(&apos;002320&apos;)sma_10 = talib.SMA(np.array(data[&apos;close&apos;]), 10)sma_30 = talib.SMA(np.array(data[&apos;close&apos;]), 30)fig = plt.figure(figsize=(24, 8))ax = fig.add_subplot(1, 1, 1)ax.set_xticks(range(0, len(data[&apos;date&apos;]), 50))ax.set_xticklabels(data[&apos;date&apos;][::50])ax.plot(sma_10, label=&apos;10 日均线&apos;)ax.plot(sma_30, label=&apos;30 日均线&apos;)ax.legend(loc=&apos;upper left&apos;)mpf.candlestick2_ochl(ax, data[&apos;open&apos;], data[&apos;close&apos;], data[&apos;high&apos;], data[&apos;low&apos;],width=0.5, colorup=&apos;r&apos;, colordown=&apos;green&apos;,alpha=0.6)plt.grid()plt.show() 参考链接 https://matplotlib.org/api/finance_api.html, by matplotlib https://ipreacher.github.io/2017/candlestick/, by The North]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib用法笔记]]></title>
    <url>%2F2018%2F05%2F26%2Fmatplotlib%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[matplotlib 是Python编程语言及其数值数学扩展包 NumPy的可视化操作界面。它为利用通用的图形用户界面工具包，如Tkinter, wxPython, Qt或GTK+向应用程序嵌入式绘图提供了应用程序接口（API）。此外，matplotlib还有一个基于图像处理库（如开放图形库OpenGL）的pylab接口，其设计与MATLAB非常类似—尽管并不怎么好用。SciPy就是用matplotlib进行图形绘制。 基本用法使用plt.figure定义一个图像窗口。1234567import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-1, 1, 50)y = 2*x + 1plt.figure() plt.plot(x, y)plt.show() 设置坐标轴使用plt.xlim设置x坐标轴范围：(-1, 2)； 使用plt.ylim设置y坐标轴范围：(-2, 3)；使用plt.xlabel设置x坐标轴名称：’I am x’； 使用plt.ylabel设置y坐标轴名称：’I am y’；1234plt.xlim((-1, 2))plt.ylim((-2, 3))plt.xlabel(&apos;I am x&apos;)plt.ylabel(&apos;I am y&apos;) 使用np.linspace定义范围以及个数：范围是(-1,2);个数是5. 使用print打印出新定义的范围. 使用plt.xticks设置x轴刻度：范围是(-1,2);个数是5.123new_ticks = np.linspace(-1, 2, 5)print(new_ticks)plt.xticks(new_ticks) 使用plt.yticks设置y轴刻度以及名称：刻度为[-2, -1.8, -1, 1.22, 3]；对应刻度的名称为[‘really bad’,’bad’,’normal’,’good’, ‘really good’]. 使用plt.show显示图像.12plt.yticks([-2, -1.8, -1, 1.22, 3],[r&apos;$really\ bad$&apos;, r&apos;$bad$&apos;, r&apos;$normal$&apos;, r&apos;$good$&apos;, r&apos;$really\ good$&apos;])plt.show() 使用plt.gca获取当前坐标轴信息. 使用.spines设置边框：右侧边框；使用.set_color设置边框颜色：默认白色； 使用.spines设置边框：上边框；使用.set_color设置边框颜色：默认白色；1234ax = plt.gca()ax.spines[&apos;right&apos;].set_color(&apos;none&apos;)ax.spines[&apos;top&apos;].set_color(&apos;none&apos;)plt.show() 调整坐标轴使用.xaxis.set_ticks_position设置x坐标刻度数字或名称的位置：bottom.（所有位置：top，bottom，both，default，none）1ax.xaxis.set_ticks_position(&apos;bottom&apos;) 使用.spines设置边框：x轴；使用.set_position设置边框位置：y=0的位置；（位置所有属性：outward，axes，data）使用.yaxis.set_ticks_position设置y坐标刻度数字或名称的位置：left.（所有位置：left，right，both，default，none）使用.spines设置边框：y轴；使用.set_position设置边框位置：x=0的位置；（位置所有属性：outward，axes，data） 使用plt.show显示图像.1234ax.spines[&apos;bottom&apos;].set_position((&apos;data&apos;, 0))ax.yaxis.set_ticks_position(&apos;left&apos;)ax.spines[&apos;left&apos;].set_position((&apos;data&apos;,0))plt.show() legend图例基本用法123456789101112131415161718192021222324import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3, 3, 50)y1 = 2*x + 1y2 = x**2plt.figure()#set x limitsplt.xlim((-1, 2))plt.ylim((-2, 3))# set new sticksnew_sticks = np.linspace(-1, 2, 5)plt.xticks(new_sticks)# set tick labelsplt.yticks([-2, -1.8, -1, 1.22, 3], [r&apos;$really\ bad$&apos;, r&apos;$bad$&apos;, r&apos;$normal$&apos;, r&apos;$good$&apos;, r&apos;$really\ good$&apos;])# set line sylesl1, = plt.plot(x, y1, label=&apos;linear line&apos;)l2, = plt.plot(x, y2, color=&apos;red&apos;, linewidth=1.0, linestyle=&apos;--&apos;, label=&apos;square line&apos;)plt.legend(loc=&apos;upper right&apos;) 调整位置和名称1plt.legend(handles=[l1, l2], labels=[&apos;up&apos;, &apos;down&apos;], loc=&apos;best&apos;) 其中’loc’参数有多种，’best’表示自动分配最佳位置。1234567891011&apos;best&apos; : 0, &apos;upper right&apos; : 1,&apos;upper left&apos; : 2,&apos;lower left&apos; : 3,&apos;lower right&apos; : 4,&apos;right&apos; : 5,&apos;center left&apos; : 6,&apos;center right&apos; : 7,&apos;lower center&apos; : 8,&apos;upper center&apos; : 9,&apos;center&apos; : 10, 参考链接 https://zh.wikipedia.org/wiki/Matplotlib, by wikipedia https://morvanzhou.github.io, by morvanzhou]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3与python2的区别与兼容]]></title>
    <url>%2F2018%2F05%2F26%2Fpython3%E4%B8%8Epython2%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%85%BC%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[Python是一种广泛使用的高级编程语言，属于通用型编程语言，由吉多·范罗苏姆创造，第一版发布于1991年。可以视之为一种改良（加入一些其他编程语言的优点，如面向对象）的LISP。作为一种解释型语言，Python的设计哲学强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词）。相比于C++或Java，Python让开发者能够用更少的代码表达想法。不管是小型还是大型程序，该语言都试图让程序的结构清晰明了。 与Scheme、Ruby、Perl、Tcl等动态类型编程语言一样，Python拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库。 Python 解释器本身几乎可以在所有的操作系统中运行。Python的正式解释器CPython是用C语言编写的、是一个由社区驱动的自由软件，目前由Python软件基金会管理。 python3与python2区别print函数Python 2 的 print 声明在Python 3中已经被 print() 函数取代12345#!/usr/bin/python2print &apos;Hello, World!&apos;#!/usr/bin/python3print(&apos;Hello, World!&apos;) 整除/是精确除法，//是向下取整除法，%是求模。 //和%运算符在2和3版本中一样，但是运算符/不一样。12345678910111213141516171819#!/usr/bin/python2&gt;&gt;&gt; 3 / 21&gt;&gt;&gt; 3 // 21&gt;&gt;&gt; 3 / 2.01.5&gt;&gt;&gt; 3 // 2.01.0#!/usr/bin/python3&gt;&gt;&gt; 3 / 21.5&gt;&gt;&gt; 3 // 21&gt;&gt;&gt; 3 / 2.01.5&gt;&gt;&gt; 3 // 2.01.0 Unicode由于历史遗留问题，Python 2.x版本虽然支持Unicode，但在语法上需要’xxx’和u’xxx’两种字符串表示方式。 在Python 3.x版本中，把’xxx’和u’xxx’统一成Unicode编码，即写不写前缀u都是一样的，而以字节形式表示的字符串则必须加上b前缀：b’xxx’。123456#!/usr/bin/python2#!/usr/bin/python3&gt;&gt;&gt; 中国 = &apos;china&apos; &gt;&gt;&gt; print(中国)china xrange模块在 Python 2 中 xrange() 创建迭代对象的用法是非常流行的。比如： for 循环或者是列表/集合/字典推导式。 在 Python 3 中，range() 是像 xrange() 那样实现以至于一个专门的 xrange() 函数都不再存在（在 Python 3 中 xrange() 会抛出命名异常）。 不等运算符Python 2.x中不等于有两种写法 != 和 &lt;&gt; Python 3.x中去掉了&lt;&gt;, 只有!=一种写法 数据类型 Py3.X去除了long类型，现在只有一种整型——int，但它的行为就像2.X版本的long 新增了bytes类型，对应于2.X版本的八位串 dict的.keys()、.items 和.values()方法返回迭代器，而之前的iterkeys()等函数都被废弃。同时去掉的还有 dict.has_key()，用 in替代它吧 。 异常 在 Python 3 中处理异常也轻微的改变了，在 Python 3 中我们现在使用 as 作为关键词。 捕获异常的语法由 except exc, var 改为 except exc as var。使用语法except (exc1, exc2) as var可以同时捕获多种类别的异常。 Python 2.6已经支持这两种语法。 解析用户的输入 在python2.x中raw_input()和input()，两个函数都存在，其中区别为 raw_input()—-将所有输入作为字符串看待，返回字符串类型 input()——-只能接收“数字”的输入，在对待纯数字输入时具有自己的特性，它返回所输入的数字的类型（int, float） 在python3.x中raw_input()和input()进行了整合，去除了raw_input()，仅保留了input()函数，其接收任意任性输入，将所有输入默认为字符串处理，并返回字符串类型。 返回可迭代对象，而不是列表如果在 xrange 章节看到的，现在在 Python 3 中一些方法和函数返回迭代对象 — 代替 Python 2 中的列表。 因为我们通常那些遍历只有一次，我认为这个改变对节约内存很有意义。尽管如此，它也是可能的，相对于生成器 —- 如需要遍历多次。它是不那么高效的。 而对于那些情况下，我们真正需要的是列表对象，我们可以通过 list() 函数简单的把迭代对象转换成一个列表。12345678910111213#!/usr/bin/python2&gt;&gt;&gt; print range(3) [0, 1, 2]&gt;&gt;&gt; print type(range(3))&lt;type &apos;list&apos;&gt;#!/usr/bin/python3&gt;&gt;&gt; print(range(3))range(0, 3)&gt;&gt;&gt; print(type(range(3)))&lt;class &apos;range&apos;&gt;&gt;&gt;&gt; print(list(range(3)))[0, 1, 2] For循环变量和全局命名空间泄漏在 Python 3.x 中 for 循环变量不会再导致命名空间泄漏。 在 Python 3.x 中做了一个改变，在 What’s New In Python 3.0 中有如下描述：“列表推导不再支持 [… for var in item1, item2, …] 这样的语法。使用 [… for var in (item1, item2, …)] 代替。1234567891011121314151617#!/usr/bin/python2&gt;&gt;&gt; i = 1&gt;&gt;&gt; print &apos;before: i =&apos;, ibefore: i = 1&gt;&gt;&gt; print &apos;comprehension: &apos;, [i for i in range(5)]comprehension: [0, 1, 2, 3, 4]&gt;&gt;&gt; print &apos;after: i =&apos;, iafter: i = 4#!/usr/bin/python3&gt;&gt;&gt; i = 1&gt;&gt;&gt; print(&apos;before: i =&apos;, i)before: i = 1&gt;&gt;&gt; print(&apos;comprehension:&apos;, [i for i in range(5)])comprehension: [0, 1, 2, 3, 4]&gt;&gt;&gt; print(&apos;after: i =&apos;, i)after: i = 1 兼容python3与python2当前python3的普及还不尽人意，因此编写的python程序能同时兼容python2与python3是十分必要的。下面介绍同时支持python2与python3的方法。 放弃python 2.6之前的python版本 使用 2to3 工具对代码检查 使用python -3执行python程序 from future import “from future import”后即可使使用python的未来特性了。python的完整future特性可见 future 。python3中所有字符都变成了unicode。在python2中unicode字符在定义时需要在字符前面加 u，但在3中则不需要家u，而且在加u后程序会无法编译通过。为了解决该问题可以 “from future import unicode_literals” ，这样python2中字符的行为将和python3中保持一致，python2中定义普通字符将自动识别为unicode。 import问题 python3中“少”了很多python2的包，在大多情况下这些包之是改了个名字而已。我们可以在import的时候对这些问题进行处理。 1234567try:#python2 from UserDict import UserDict #建议按照python3的名字进行import from UserDict import DictMixin as MutableMappingexcept ImportError:#python3 from collections import UserDict from collections import MutableMapping 使用python3的方式写程序 检查当前运行的python版本 12345import sysif sys.version &gt; &apos;3&apos;: PY3 = Trueelse: PY3 = False six不推荐使用six。 参考链接 https://zh.wikipedia.org/wiki/Python, by wikipedia https://www.jianshu.com/p/85583e032eb8, by EarthChen http://python.jobbole.com/83987/, by 天地一沙鸥]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git用法总结]]></title>
    <url>%2F2018%2F05%2F24%2Fgit%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[git是一个分布式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计[1]。 查看代码仓库中标签 1git tag 检出指定标签代码 1git checkout tag_name 打包导出仓库代码 1git archive --format zip --output ..\emsdk\zips\1.38.8.zip HEAD 参考链接 https://zh.wikipedia.org/zh-hans/Git, by wikipedia http://yijiebuyi.com/blog/eacf4d053fad77affffae397d9af7172.html, by 一介布衣]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成three.js]]></title>
    <url>%2F2018%2F05%2F13%2FVue-js%E9%9B%86%E6%88%90three-js%2F</url>
    <content type="text"><![CDATA[Three.js是一个跨浏览器的脚本，使用JavaScript函数库或API来在网页浏览器中创建和展示动画的三维计算机图形。Three.js使用WebGL。源代码托管在GitHub。 下面介绍在Vue.js中集成three.js的步骤。 安装vue-cli脚手架 安装three.js 1npm install --save three 编写使用three.js创建3D场景的Vuejs组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as Three from &apos;three&apos;export default &#123; name: &apos;Home&apos;, data () &#123; return &#123; camera: null, scene: null, renderer: null, mesh: null &#125; &#125;, methods: &#123; init: function () &#123; var container = document.getElementById(&apos;container&apos;) this.camera = new Three.PerspectiveCamera(70, container.clientWidth / container.clientHeight, 0.01, 10) this.camera.position.z = 1 this.scene = new Three.Scene() var geometry = new Three.BoxGeometry(0.2, 0.2, 0.2) var material = new Three.MeshNormalMaterial() this.mesh = new Three.Mesh(geometry, material) this.scene.add(this.mesh) this.renderer = new Three.WebGLRenderer(&#123; antialias: true &#125;) this.renderer.setSize(container.clientWidth, container.clientHeight) container.appendChild(this.renderer.domElement) &#125;, animate: function () &#123; requestAnimationFrame(this.animate) this.mesh.rotation.x += 0.01 this.mesh.rotation.y += 0.02 this.renderer.render(this.scene, this.camera) &#125; &#125;, mounted () &#123; this.init() this.animate() &#125;&#125;&lt;/script&gt;&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot; scoped&gt;#container &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125;&lt;/style&gt; 参考链接 https://zh.wikipedia.org/wiki/Three.js, by Wikipedia https://stackoverflow.com/questions/47849626/import-and-use-three-js-library-in-vue-component, by Stackoverlflow]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows批处理编程语法解析]]></title>
    <url>%2F2018%2F05%2F13%2FWindows%E6%89%B9%E5%A4%84%E7%90%86%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[批处理文件(BAT文件)是DOS，OS/2和Microsoft Windows中的一种脚本文件[1]。 它由命令行解释器执行的一系列命令组成，存储在纯文本文件中，通常以BAT为扩展名。批处理文件可以包含解释器交互接受的任何命令，并使用在批处理文件中启用条件分支和循环的构造，如IF，FOR和GOTO标签。在Windows平台自动化部署或处理日常重复性工作时，常使用Windows批处理文件。 下面简单介绍Windows BAT文件的语法。 @ 让执行窗口中不显示它后面这一行的命令本身。12// 使用@将不显示后面的echo off命令@ echo off echo echo即回显或反馈的意思。它由两种状态：打开和关闭。1234// 将不显示后续的命令@ echo off// 将显示后续的命令@ echo on :: 注释命令。在批处理文件中与rem命令等效 call call命令用来从一个批处理文件调用另一个批处理文件。只有当被调用的批处理文件执行完成时，才返回。1call pm2-startup install pause 暂停命令。方便用户查看信息，查看完毕后可继续执行。 参考链接 https://en.wikipedia.org/wiki/Batch_file,by Wikipedia. https://www.cnblogs.com/s1ihome/archive/2009/01/15/batTutorial.html, by s1ihome.]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Cesium]]></title>
    <url>%2F2018%2F05%2F11%2FVue-js%E9%9B%86%E6%88%90Cesium%2F</url>
    <content type="text"><![CDATA[近期在研究集成封装Cesium为Vue.js组件，记录一下过程，防止忘了。 安装环境 node.js: v8.9.4 npm: 5.6.0 vue: 2.5.2 cesium: 1.45.0 vue-cli: 2.9.3 webpack: 3.6.0 安装配置 安装nodejs 安装vue-cli脚手架 12345npm install -g vue-clivue init webpack my-projectcd my-projectnpm installnpm run dev 安装cesium 1npm install --save cesium webpack配置 在build/webpack.base.conf.js文件中做如下修改 123456789101112131415161718192021222324252627282930313233343536//定义cesium源代码位置const cesiumSource = &apos;../node_modules/cesium/Source&apos;...module.exports = &#123;...output: &#123; path: config.build.assetsRoot, filename: &apos;[name].js&apos;, publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath, // Needed to compile multiline strings in Cesium sourcePrefix: &apos;&apos; &#125;,amd:&#123; // Enable webpack-friendly use of require in Cesium toUrlUndefined: true &#125;,resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), //设置cesium的别名 &apos;cesium&apos;: path.resolve(__dirname, cesiumSource) &#125; &#125;,module: &#123; rules: [ ... ], //不让Webpack打印载入特定库时候的警告 unknownContextCritical: false &#125;,...&#125; 在build/webpack.dev.conf.js文件中做如下修改 12345678910111213141516//定义 Cesium 源代码路径，前面没有../const cesiumSource = &apos;node_modules/cesium/Source&apos;//定义 Cesium Workers 路径const cesiumWorkers = &apos;../Build/Cesium/Workers&apos;...plugins: [ ... new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, cesiumWorkers), to: &apos;Workers&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Assets&apos;), to: &apos;Assets&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Widgets&apos;), to: &apos;Widgets&apos; &#125; ]), new webpack.DefinePlugin(&#123; // Define relative base path in cesium for loading assets CESIUM_BASE_URL: JSON.stringify(&apos;&apos;) &#125;) ... ] 在build/webpack.prod.conf.js文件中做如下修改 12345678910111213141516//定义 Cesium 源代码路径，前面没有../const cesiumSource = &apos;node_modules/cesium/Source&apos;//定义 Cesium Workers 路径const cesiumWorkers = &apos;../Build/Cesium/Workers&apos;...plugins: [ ... new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, cesiumWorkers), to: &apos;Workers&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Assets&apos;), to: &apos;Assets&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Widgets&apos;), to: &apos;Widgets&apos; &#125; ]), new webpack.DefinePlugin(&#123; //定义 Cesium 从哪里加载资源，如果使用默认的&apos;&apos;，却变成了绝对路径了，所以这里使用&apos;./&apos;,使用相对路径 CESIUM_BASE_URL: JSON.stringify(&apos;./&apos;) &#125;) ... ] Vue.js组件编写 在src/components下新建 CesiumViewer.vue vue组件 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;cesiumContainer&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt;import Cesium from &apos;cesium/Cesium&apos;import widgets from &apos;cesium/Widgets/widgets.css&apos;export default &#123; name: &apos;CesiumViewer&apos;, mounted () &#123; var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;) &#125;&#125;&lt;/script&gt;&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot; scoped&gt;#cesiumContainer &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125;&lt;/style&gt; 创建全局样式文件src/styles/index.scss，做如下修改 12345678html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125; 在src/main.js中做如下修改 1import &apos;@/styles/index.scss&apos; // global css 参考链接 https://www.jianshu.com/p/fb237c7eb48c, by QingMings https://cesiumjs.org/tutorials/cesium-and-webpack/, by cesiumjs.org]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离线环境下Node.js应用部署方法]]></title>
    <url>%2F2018%2F05%2F10%2F%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8BNode-js%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[离线环境下Node.js应用部署时需要解决以下三个基本问题： Node.js应用的进程管理，如性能监控、自动重启、负载均衡等 Node.js应用开机如何自启动 离线环境下如何部署Node.js应用 下面以在Windows Server 2012上离线部署Node.js应用为例，记录上述问题的解决方案： Node.js应用的进程管理在生产环境中运行 Express 应用程序时，使用进程管理器对于完成以下任务很有帮助[1]： 在应用程序崩溃后将其重新启动。 获得对运行时性能和资源消耗的洞察。 动态修改设置以改善性能。 控制集群。 进程管理器有点类似于应用程序服务器：它是应用程序的“容器”，可促进部署，提供高可用性并使您可以在运行时管理应用程序。 用于 Express 和其他 Node.js 应用程序的最流行的进程管理器包括： StrongLoop Process Manager PM2 Forever 上述三种工具的比较请参阅http://strong-pm.io/compare/。其中，StrongLoop Process Manager无法在Windows平台工作，再综合比较PM2和Forever，由于Forever没有操作系统自启动的脚本，故选择PM2作为Windows平台Node.js应用的进程管理器。 Node.js应用开机如何自启动选择PM2作为Node.js应用的进程管理器后，Node.js应用开机自启动的问题就变为如何开机自启动PM2。Windows平台存在两个自启动PM2的脚本： pm2-windows-service pm2-windows-startup pm2-windows-service基于 node-windows将PM2注册为Windows服务，从而实现自启动。pm2-windows-startup则基于start-on-windows-boot在注册表中将PM2设为自启动程序，从而实现自启动。两种方案经测试，只有pm2-windows-startup在Windows Server 2012上可行，故选择pm2-windows-startup作为解决Node.js应用开机自启动的方案。 离线环境下如何部署Node.js应用PM2和pm2-windows-startup必须全局安装，如何简单方便地在离线环境下全局安装这两个模块是一个问题。网上搜到的方法有： npm link npm-bundle npm link[2]是npm的一个命令，可将本地包链接成全局包，但实际测试过程中，无法解决PM2包的依赖问题，故放弃。而npm-bundle[3]则能很好的解决PM2的依赖问题。具体过程为：12345\\在线环境下npm install -g npm-bundlenpm-bundle pm2\\离线环境下call npm install .\pm2-2.10.3.tgz -g 参考链接 http://expressjs.com/zh-cn/advanced/pm.html, by Express https://blog.csdn.net/fay462298322/article/details/53432691, by 爱死费崇政 https://stackoverflow.com/questions/41156556/what-exact-command-is-to-install-pm2-on-offline-rhel, by stackoverflow]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Highcharts]]></title>
    <url>%2F2018%2F05%2F10%2FVue-js%E9%9B%86%E6%88%90Highcharts%2F</url>
    <content type="text"><![CDATA[Vue.js集成Highcharts方法 安装highcharts 1npm install --save highcharts 封装hightcharts成Vue.js组件 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;highcharts-container&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Highcharts from &apos;highcharts/highstock&apos;import HighchartsMore from &apos;highcharts/highcharts-more&apos;import HighchartsDrilldown from &apos;highcharts/modules/drilldown&apos;import Highcharts3D from &apos;highcharts/highcharts-3d&apos;HighchartsMore(Highcharts)HighchartsDrilldown(Highcharts)Highcharts3D(Highcharts)export default &#123; props: [&apos;options&apos;], name: &apos;HighCharts&apos;, data () &#123; return &#123; chart: null &#125; &#125;, watch: &#123; options: function (newVal, oldVal) &#123; // watch it this.chart.update(newVal, true) &#125; &#125;, mounted () &#123; this.initChart() &#125;, methods: &#123; initChart () &#123; this.chart = new Highcharts.Chart(this.$el, this.options) &#125; &#125;&#125;&lt;/script&gt; 在src/main.js引入组件 12import HighCharts from &apos;./components/HighCharts.vue&apos;Vue.component(&apos;HighCharts&apos;, HighCharts) 使用组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;template&gt; &lt;div class=&quot;radarGraph&quot;&gt; &lt;HighCharts :options=&quot;options&quot; class=&quot;radar&quot; &gt;&lt;/HighCharts&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;RadarGraph&apos;, computed: &#123; gameInfo () &#123; return this.$store.state.gameInfo &#125;, options () &#123; return &#123; chart: &#123; polar: true, type: &apos;line&apos;, marginTop: 0, marginBottom: 0, marginLeft: 0, marginRight: 0 &#125;, credits: &#123; enabled: false &#125;, pane: &#123; size: &apos;75%&apos; &#125;, title: null, legend: &#123; enabled: false &#125;, xAxis: &#123; categories: [&apos;分类1&apos;, &apos;分类2&apos;, &apos;分类3&apos;, &apos;分类4&apos;, &apos;分类5&apos;, &apos;分类6&apos; ], labels: &#123; style: &#123; fontSize: &apos;14px&apos; &#125; &#125;, tickmarkPlacement: &apos;on&apos;, lineWidth: 0 &#125;, yAxis: &#123; gridLineInterpolation: &apos;polygon&apos;, lineWidth: 0, min: 0 &#125;, series: [&#123; type: &apos;area&apos;, name: &apos;得分&apos;, data: [this.gameInfo.radar1, this.gameInfo.radar2, this.gameInfo.radar3, this.gameInfo.radar4, this.gameInfo.radar5, this.gameInfo.radar6], pointPlacement: &apos;on&apos; &#125;] &#125; &#125;, ...mapGetters([ &apos;userId&apos; ]) &#125;, created () &#123; this.fetchData() &#125;, methods: &#123; fetchData () &#123; this.$store.dispatch(&apos;GetGameInfo&apos;, this.userId) &#125; &#125;&#125;&lt;/script&gt; 参考链接 https://blog.jianshukeji.com/2017/09/use-highcharts-with-vue/]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Socket.io]]></title>
    <url>%2F2018%2F05%2F09%2FVue-js%E9%9B%86%E6%88%90Socket-io%2F</url>
    <content type="text"><![CDATA[Socket.IO简介 Socket.IO 是一个面向实时 web 应用的 JavaScript 库。它使得服务器和客户端之间实时双向的通信成为可能。他有两个部分：在浏览器中运行的客户端库，和一个面向Node.js的服务端库。两者有着几乎一样的API。像Node.js一样，它也是事件驱动的. Socket.IO 主要使用WebSocket协议。但是如果需要的话，Socket.io可以回退到几种其它方法，例如Adobe Flash Sockets，JSONP拉取，或是传统的AJAX拉取，[2]并且在同时提供完全相同的接口。尽管它可以被用作WebSocket的包装库，它还是提供了许多其它功能，比如广播至多个套接字，存储与不同客户有关的数据，和异步IO操作。 Vue.js集成Socket.IO 安装socket.io-client 1npm install --save socket.io-client 在src/main.js中载入socket.io-client 123import io from &apos;socket.io-client&apos;const socket = io(process.env.BASE_API)Object.defineProperty(Vue.prototype, &apos;$socket&apos;, &#123; value: socket &#125;) 在Vuejs组件中使用socket.io-client 1this.$socket.on(&apos;event&apos;,function(e)&#123;&#125;) 参考链接 https://zh.wikipedia.org/wiki/Socket.IO, by Wikipedia https://socket.io/get-started/chat/, by socket.io]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PowerDesigner使用经验总结]]></title>
    <url>%2F2018%2F05%2F09%2FPowerDesigner%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[需求分析在系统工程及软件工程中，需求分析指的是在创建一个新的或改变一个现存的系统或产品时，确定新系统的目的、范围、定义和功能时所要做的所有工作。需求分析是软件工程中的一个关键过程。在这个过程中，系统分析员和软件工程师确定顾客的需要。只有在确定了这些需要后他们才能够分析和寻求新系统的解决方法。 在软件工程的历史中，很长时间里人们一直认为需求分析是整个软件工程中最简单的一个步骤，但在过去十年中越来越多的人认识到它是整个过程中最关键的一个过程。假如在需求分析时，分析者们未能正确地认识到顾客的需要的话，那么最后的软件实际上不可能达到顾客的需要，或者软体无法在规定的时间里完工。 软件设计软件设计是从软件需求规格说明书出发，根据需求分析阶段确定的功能设计软件系统的整体结构、划分功能模块、确定每个模块的实现算法以及编写具体的代码，形成软件的具体设计方案。 软件设计是把许多事物和问题抽象起来，并且抽象它们不同的层次和角度。将问题或事物分解并模块化使得解决问题变得容易，分解的越细模块数量也就越多，它的副作用就是使得设计者考虑更多的模块之间耦合度的情况。 UML统一建模语言（英语：Unified Modeling Language，缩写UML）是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。 这个语言由葛来迪·布区，伊瓦尔·雅各布森与詹姆士·兰宝于1994年至1995年间，在Rational Software公司中开发，于1996年，又进一步发展。UML集成了Booch，OMT和面向对象软件工程的概念，将这些方法融合为单一的，通用的，并且可以广泛使用的建模语言。UML打算成为可以对并发和分布式系统的标准建模语言。 在UML系统开发中有三个主要的模型： 功能模型：从用户的角度展示系统的功能，包括用例图。 静态模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图。 动态模型：展现系统的内部行为。包括序列图，活动图，状态图。） PowerDesigner工具PowerDesigner是Sybase的企业建模和设计解决方案，采用模型驱动方法，将业务与IT结合起来，可帮助部署有效的企业体系架构，并为研发生命周期管理提供强大的分析与设计技术。 PowerDesigner独具匠心地将多种标准数据建模技术（UML、业务流程建模以及市场领先的数据建模）集成一体，并与 .NET、WorkSpace、PowerBuilder、Java™、Eclipse 等主流开发平台集成起来，从而为传统的软件开发周期管理提供业务分析和规范的数据库设计解决方案。此外，它支持60多种关系数据库管理系统（RDBMS）／版本[来源请求]。PowerDesigner运行在Microsoft Windows平台上，并提供了Eclipse插件。 PowerDesigner使用经验遵循UML方法，使用PowerDesigner对系统进行建模。 在需求分析阶段，通常使用用例图、序列图（序列图中主要描述用户与系统之间交互关系）、组合结构图、类图（用于描述组件或类的接口及其调用关系）等UML图描述。 在设计阶段，从架构设计、概要设计到详细设计，粒度由粗到细。 通常架构设计是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。架构设计通常使用组织结构图、对象图、活动图、状态图等UML图描述。 概要设计就是设计软件的结构，包括组成模块，模块的层次结构，模块的调用关系，每个模块的功能等等。同时，还要设计该项目的应用系统的总体数据结构和数据库结构，即应用系统要存储什么数据，这些数据是什么样的结构，它们之间有什么关系。概要设计从模块角度描述系统，通常使用组合结构图进行描述。 详细设计就是为每个模块完成的功能进行具体的描述，要把功能描述转变为精确的、结构化的过程描述。如采用面向对象的开发方法，详细设计通常使用UML类图描述。]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>powerdesigner</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Bootstrap4]]></title>
    <url>%2F2018%2F05%2F09%2FVue-js%E9%9B%86%E6%88%90Bootstrap4%2F</url>
    <content type="text"><![CDATA[记录在Vue.js中集成Bootstrap4的方法，防止忘了！ 创建Vue.js工程 12npm install -g vue-clivue init webpack project_name 安裝Sass / Sass-loader / node-sass 1npm install sass sass-loader node-sass --save 安裝BootStrap / jQuery / Popper 1npm install bootstrap jquery popper.js --save 配置build/webpack.base.conf.js 123456789101112module.exports = &#123; ... // 新增plugins plugins: [ new webpack.ProvidePlugin(&#123; &apos;$&apos;: &quot;jquery&quot;, &apos;jQuery&apos;: &quot;jquery&quot;, &apos;Popper&apos;: &apos;popper.js&apos; &#125;) ], ...&#125; 在src/main.js中载入Bootstrap 12import &apos;bootstrap&apos;import &apos;bootstrap/dist/css/bootstrap.css&apos; 使用Bootstrap和sass编写Vue.js组件]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux mysql 终端操作]]></title>
    <url>%2F2018%2F05%2F08%2Flinux-mysql-%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[进入mysql数据库 1#mysql -uroot -proot 创建mysql user 12MariaDB [(none)]&gt; create user &apos;stock&apos;@&apos;localhost&apos; identified by &apos;stock&apos;;Query OK, 0 rows affected (0.00 sec) 查询mysql用户 12345678MariaDB [(none)]&gt; SELECT User,Host FROM mysql.user;+-------+-----------+| User | Host |+-------+-----------+| root | localhost || stock | localhost |+-------+-----------+2 rows in set (0.00 sec) 授予mysql用户权限 12MariaDB [(none)]&gt; GRANT ALL ON stock.* TO &apos;stock&apos;@&apos;localhost&apos;;Query OK, 0 rows affected (0.00 sec) 使用show语句查找数据库 123456789MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec) 创建数据库stock 12MariaDB [(none)]&gt; create database stock;Query OK, 1 row affected (0.00 sec) 选择创建的数据库 12MariaDB [(none)]&gt; use stock;Database changed 使用show语句查找数据库中的表 1MariaDB [stock]&gt; show tables; 删除创建的数据库 12MariaDB [(none)]&gt; drop database stock;Query OK, 0 rows affected (0.00 sec) 删除表 12mysql&gt; drop table sequelizemeta;Query OK, 0 rows affected (0.01 sec) 查询表结构 1mysql&gt; desc t_records; 清除表记录 1mysql&gt; delete from t_records;]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[侠客行]]></title>
    <url>%2F2018%2F05%2F08%2F%E4%BE%A0%E5%AE%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[作者：李白 赵客缦胡缨，吴钩霜雪明。 银鞍照白马，飒沓如流星。 十步杀一人，千里不留行。 事了拂衣去，深藏身与名。 闲过信陵饮，脱剑膝前横。 将炙啖朱亥，持觞劝侯嬴。 三杯吐然诺，五岳倒为轻。 眼花耳热后，意气素霓生。 救赵挥金锤，邯郸先震惊。 千秋二壮士，烜赫大梁城。 纵死侠骨香，不惭世上英。 谁能书阁下，白首太玄经。]]></content>
      <tags>
        <tag>传统文化</tag>
        <tag>唐诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立功立德立言]]></title>
    <url>%2F2018%2F05%2F08%2F%E7%AB%8B%E5%8A%9F%E7%AB%8B%E5%BE%B7%E7%AB%8B%E8%A8%80%2F</url>
    <content type="text"><![CDATA[来源：《左传》二十四年春，穆叔如晋。范宣子逆之，问焉，曰：“古人有言曰：‘死而不朽’，何谓也？”穆叔未对。宣子曰：“昔匄之祖，自虞以上为陶唐氏，在夏为御龙氏，在商为豕韦氏，在周为唐杜氏，晋主夏盟为范氏，其是之谓乎？”穆叔曰：“以豹所闻，此之谓世禄，非不朽也。鲁有先大夫曰臧文仲，既没，其言立，其是之谓乎！豹闻之，‘太上有立德，其次有立功，其次有立言’，虽久不废，此之谓不朽。若夫保姓受氏，以守宗祊，世不绝祀，无国无之，禄之大者，不可谓不朽。]]></content>
      <tags>
        <tag>传统文化</tag>
        <tag>国学</tag>
      </tags>
  </entry>
</search>
