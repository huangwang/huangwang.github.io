<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[matplotlib用法笔记]]></title>
    <url>%2F2018%2F05%2F26%2Fmatplotlib%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[matplotlib 是Python编程语言及其数值数学扩展包 NumPy的可视化操作界面。它为利用通用的图形用户界面工具包，如Tkinter, wxPython, Qt或GTK+向应用程序嵌入式绘图提供了应用程序接口（API）。此外，matplotlib还有一个基于图像处理库（如开放图形库OpenGL）的pylab接口，其设计与MATLAB非常类似–尽管并不怎么好用。SciPy就是用matplotlib进行图形绘制。 基本用法使用plt.figure定义一个图像窗口。1234567import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-1, 1, 50)y = 2*x + 1plt.figure() plt.plot(x, y)plt.show() 设置坐标轴使用plt.xlim设置x坐标轴范围：(-1, 2)； 使用plt.ylim设置y坐标轴范围：(-2, 3)；使用plt.xlabel设置x坐标轴名称：’I am x’； 使用plt.ylabel设置y坐标轴名称：’I am y’；1234plt.xlim((-1, 2))plt.ylim((-2, 3))plt.xlabel(&apos;I am x&apos;)plt.ylabel(&apos;I am y&apos;) 使用np.linspace定义范围以及个数：范围是(-1,2);个数是5. 使用print打印出新定义的范围. 使用plt.xticks设置x轴刻度：范围是(-1,2);个数是5.123new_ticks = np.linspace(-1, 2, 5)print(new_ticks)plt.xticks(new_ticks) 使用plt.yticks设置y轴刻度以及名称：刻度为[-2, -1.8, -1, 1.22, 3]；对应刻度的名称为[‘really bad’,’bad’,’normal’,’good’, ‘really good’]. 使用plt.show显示图像.12plt.yticks([-2, -1.8, -1, 1.22, 3],[r&apos;$really\ bad$&apos;, r&apos;$bad$&apos;, r&apos;$normal$&apos;, r&apos;$good$&apos;, r&apos;$really\ good$&apos;])plt.show() 参考链接 https://zh.wikipedia.org/wiki/Matplotlib, by wikipedia https://morvanzhou.github.io, by morvanzhou]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python笔记]]></title>
    <url>%2F2018%2F05%2F26%2Fpython%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Python是一种广泛使用的高级编程语言，属于通用型编程语言，由吉多·范罗苏姆创造，第一版发布于1991年。可以视之为一种改良（加入一些其他编程语言的优点，如面向对象）的LISP。作为一种解释型语言，Python的设计哲学强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词）。相比于C++或Java，Python让开发者能够用更少的代码表达想法。不管是小型还是大型程序，该语言都试图让程序的结构清晰明了。 与Scheme、Ruby、Perl、Tcl等动态类型编程语言一样，Python拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且支持多种编程范式，包括面向对象、命令式、函数式和过程式编程。其本身拥有一个巨大而广泛的标准库。 Python 解释器本身几乎可以在所有的操作系统中运行。Python的正式解释器CPython是用C语言编写的、是一个由社区驱动的自由软件，目前由Python软件基金会管理。 python3与python2区别print函数Python 2 的 print 声明在Python 3中已经被 print() 函数取代12345#!/usr/bin/python2print &apos;Hello, World!&apos;#!/usr/bin/python3print(&apos;Hello, World!&apos;) 整除/是精确除法，//是向下取整除法，%是求模。 //和%运算符在2和3版本中一样，但是运算符/不一样。12345678910111213141516171819#!/usr/bin/python2&gt;&gt;&gt; 3 / 21&gt;&gt;&gt; 3 // 21&gt;&gt;&gt; 3 / 2.01.5&gt;&gt;&gt; 3 // 2.01.0#!/usr/bin/python3&gt;&gt;&gt; 3 / 21.5&gt;&gt;&gt; 3 // 21&gt;&gt;&gt; 3 / 2.01.5&gt;&gt;&gt; 3 // 2.01.0 Unicode由于历史遗留问题，Python 2.x版本虽然支持Unicode，但在语法上需要’xxx’和u’xxx’两种字符串表示方式。 在Python 3.x版本中，把’xxx’和u’xxx’统一成Unicode编码，即写不写前缀u都是一样的，而以字节形式表示的字符串则必须加上b前缀：b’xxx’。123456#!/usr/bin/python2#!/usr/bin/python3&gt;&gt;&gt; 中国 = &apos;china&apos; &gt;&gt;&gt; print(中国)china xrange模块在 Python 2 中 xrange() 创建迭代对象的用法是非常流行的。比如： for 循环或者是列表/集合/字典推导式。 在 Python 3 中，range() 是像 xrange() 那样实现以至于一个专门的 xrange() 函数都不再存在（在 Python 3 中 xrange() 会抛出命名异常）。 不等运算符Python 2.x中不等于有两种写法 != 和 &lt;&gt; Python 3.x中去掉了&lt;&gt;, 只有!=一种写法 数据类型 Py3.X去除了long类型，现在只有一种整型——int，但它的行为就像2.X版本的long 新增了bytes类型，对应于2.X版本的八位串 dict的.keys()、.items 和.values()方法返回迭代器，而之前的iterkeys()等函数都被废弃。同时去掉的还有 dict.has_key()，用 in替代它吧 。 异常 在 Python 3 中处理异常也轻微的改变了，在 Python 3 中我们现在使用 as 作为关键词。 捕获异常的语法由 except exc, var 改为 except exc as var。使用语法except (exc1, exc2) as var可以同时捕获多种类别的异常。 Python 2.6已经支持这两种语法。 解析用户的输入 在python2.x中raw_input()和input()，两个函数都存在，其中区别为 raw_input()—将所有输入作为字符串看待，返回字符串类型 input()—–只能接收“数字”的输入，在对待纯数字输入时具有自己的特性，它返回所输入的数字的类型（int, float） 在python3.x中raw_input()和input()进行了整合，去除了raw_input()，仅保留了input()函数，其接收任意任性输入，将所有输入默认为字符串处理，并返回字符串类型。 返回可迭代对象，而不是列表如果在 xrange 章节看到的，现在在 Python 3 中一些方法和函数返回迭代对象 — 代替 Python 2 中的列表。 因为我们通常那些遍历只有一次，我认为这个改变对节约内存很有意义。尽管如此，它也是可能的，相对于生成器 —- 如需要遍历多次。它是不那么高效的。 而对于那些情况下，我们真正需要的是列表对象，我们可以通过 list() 函数简单的把迭代对象转换成一个列表。12345678910111213#!/usr/bin/python2&gt;&gt;&gt; print range(3) [0, 1, 2]&gt;&gt;&gt; print type(range(3))&lt;type &apos;list&apos;&gt;#!/usr/bin/python3&gt;&gt;&gt; print(range(3))range(0, 3)&gt;&gt;&gt; print(type(range(3)))&lt;class &apos;range&apos;&gt;&gt;&gt;&gt; print(list(range(3)))[0, 1, 2] For循环变量和全局命名空间泄漏在 Python 3.x 中 for 循环变量不会再导致命名空间泄漏。 在 Python 3.x 中做了一个改变，在 What’s New In Python 3.0 中有如下描述：“列表推导不再支持 [… for var in item1, item2, …] 这样的语法。使用 [… for var in (item1, item2, …)] 代替。1234567891011121314151617#!/usr/bin/python2&gt;&gt;&gt; i = 1&gt;&gt;&gt; print &apos;before: i =&apos;, ibefore: i = 1&gt;&gt;&gt; print &apos;comprehension: &apos;, [i for i in range(5)]comprehension: [0, 1, 2, 3, 4]&gt;&gt;&gt; print &apos;after: i =&apos;, iafter: i = 4#!/usr/bin/python3&gt;&gt;&gt; i = 1&gt;&gt;&gt; print(&apos;before: i =&apos;, i)before: i = 1&gt;&gt;&gt; print(&apos;comprehension:&apos;, [i for i in range(5)])comprehension: [0, 1, 2, 3, 4]&gt;&gt;&gt; print(&apos;after: i =&apos;, i)after: i = 1 兼容python3与python2当前python3的普及还不尽人意，因此编写的python程序能同时兼容python2与python3是十分必要的。下面介绍同时支持python2与python3的方法。 放弃python 2.6之前的python版本 使用 2to3 工具对代码检查 使用python -3执行python程序 from future import “from future import”后即可使使用python的未来特性了。python的完整future特性可见 future 。python3中所有字符都变成了unicode。在python2中unicode字符在定义时需要在字符前面加 u，但在3中则不需要家u，而且在加u后程序会无法编译通过。为了解决该问题可以 “from future import unicode_literals” ，这样python2中字符的行为将和python3中保持一致，python2中定义普通字符将自动识别为unicode。 import问题 python3中“少”了很多python2的包，在大多情况下这些包之是改了个名字而已。我们可以在import的时候对这些问题进行处理。 1234567try:#python2 from UserDict import UserDict #建议按照python3的名字进行import from UserDict import DictMixin as MutableMappingexcept ImportError:#python3 from collections import UserDict from collections import MutableMapping 使用python3的方式写程序 检查当前运行的python版本 12345import sysif sys.version &gt; &apos;3&apos;: PY3 = Trueelse: PY3 = False six不推荐使用six。 参考链接 https://zh.wikipedia.org/wiki/Python, by wikipedia https://www.jianshu.com/p/85583e032eb8, by EarthChen http://python.jobbole.com/83987/, by 天地一沙鸥]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git用法总结]]></title>
    <url>%2F2018%2F05%2F24%2Fgit%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[git是一个分布式版本控制软件，最初由林纳斯·托瓦兹（Linus Torvalds）创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计[1]。 查看代码仓库中标签 1git tag 检出指定标签代码 1git checkout tag_name 参考链接 https://zh.wikipedia.org/zh-hans/Git, by wikipedia http://yijiebuyi.com/blog/eacf4d053fad77affffae397d9af7172.html, by 一介布衣]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成three.js]]></title>
    <url>%2F2018%2F05%2F13%2FVue-js%E9%9B%86%E6%88%90three-js%2F</url>
    <content type="text"><![CDATA[Three.js是一个跨浏览器的脚本，使用JavaScript函数库或API来在网页浏览器中创建和展示动画的三维计算机图形。Three.js使用WebGL。源代码托管在GitHub。 下面介绍在Vue.js中集成three.js的步骤。 安装vue-cli脚手架 安装three.js 1npm install --save three 编写使用three.js创建3D场景的Vuejs组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;template&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import * as Three from &apos;three&apos;export default &#123; name: &apos;Home&apos;, data () &#123; return &#123; camera: null, scene: null, renderer: null, mesh: null &#125; &#125;, methods: &#123; init: function () &#123; var container = document.getElementById(&apos;container&apos;) this.camera = new Three.PerspectiveCamera(70, container.clientWidth / container.clientHeight, 0.01, 10) this.camera.position.z = 1 this.scene = new Three.Scene() var geometry = new Three.BoxGeometry(0.2, 0.2, 0.2) var material = new Three.MeshNormalMaterial() this.mesh = new Three.Mesh(geometry, material) this.scene.add(this.mesh) this.renderer = new Three.WebGLRenderer(&#123; antialias: true &#125;) this.renderer.setSize(container.clientWidth, container.clientHeight) container.appendChild(this.renderer.domElement) &#125;, animate: function () &#123; requestAnimationFrame(this.animate) this.mesh.rotation.x += 0.01 this.mesh.rotation.y += 0.02 this.renderer.render(this.scene, this.camera) &#125; &#125;, mounted () &#123; this.init() this.animate() &#125;&#125;&lt;/script&gt;&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot; scoped&gt;#container &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125;&lt;/style&gt; 参考链接 https://zh.wikipedia.org/wiki/Three.js, by Wikipedia https://stackoverflow.com/questions/47849626/import-and-use-three-js-library-in-vue-component, by Stackoverlflow]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows批处理编程语法解析]]></title>
    <url>%2F2018%2F05%2F13%2FWindows%E6%89%B9%E5%A4%84%E7%90%86%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[批处理文件(BAT文件)是DOS，OS/2和Microsoft Windows中的一种脚本文件[1]。 它由命令行解释器执行的一系列命令组成，存储在纯文本文件中，通常以BAT为扩展名。批处理文件可以包含解释器交互接受的任何命令，并使用在批处理文件中启用条件分支和循环的构造，如IF，FOR和GOTO标签。在Windows平台自动化部署或处理日常重复性工作时，常使用Windows批处理文件。 下面简单介绍Windows BAT文件的语法。 @ 让执行窗口中不显示它后面这一行的命令本身。12// 使用@将不显示后面的echo off命令@ echo off echo echo即回显或反馈的意思。它由两种状态：打开和关闭。1234// 将不显示后续的命令@ echo off// 将显示后续的命令@ echo on :: 注释命令。在批处理文件中与rem命令等效 call call命令用来从一个批处理文件调用另一个批处理文件。只有当被调用的批处理文件执行完成时，才返回。1call pm2-startup install pause 暂停命令。方便用户查看信息，查看完毕后可继续执行。 参考链接 https://en.wikipedia.org/wiki/Batch_file,by Wikipedia. https://www.cnblogs.com/s1ihome/archive/2009/01/15/batTutorial.html, by s1ihome.]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Cesium]]></title>
    <url>%2F2018%2F05%2F11%2FVue-js%E9%9B%86%E6%88%90Cesium%2F</url>
    <content type="text"><![CDATA[近期在研究集成封装Cesium为Vue.js组件，记录一下过程，防止忘了。 安装环境 node.js: v8.9.4 npm: 5.6.0 vue: 2.5.2 cesium: 1.45.0 vue-cli: 2.9.3 webpack: 3.6.0 安装配置 安装nodejs 安装vue-cli脚手架 12345npm install -g vue-clivue init webpack my-projectcd my-projectnpm installnpm run dev 安装cesium 1npm install --save cesium webpack配置 在build/webpack.base.conf.js文件中做如下修改 123456789101112131415161718192021222324252627282930313233343536//定义cesium源代码位置const cesiumSource = &apos;../node_modules/cesium/Source&apos;...module.exports = &#123;...output: &#123; path: config.build.assetsRoot, filename: &apos;[name].js&apos;, publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath, // Needed to compile multiline strings in Cesium sourcePrefix: &apos;&apos; &#125;,amd:&#123; // Enable webpack-friendly use of require in Cesium toUrlUndefined: true &#125;,resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), //设置cesium的别名 &apos;cesium&apos;: path.resolve(__dirname, cesiumSource) &#125; &#125;,module: &#123; rules: [ ... ], //不让Webpack打印载入特定库时候的警告 unknownContextCritical: false &#125;,...&#125; 在build/webpack.dev.conf.js文件中做如下修改 12345678910111213141516//定义 Cesium 源代码路径，前面没有../const cesiumSource = &apos;node_modules/cesium/Source&apos;//定义 Cesium Workers 路径const cesiumWorkers = &apos;../Build/Cesium/Workers&apos;...plugins: [ ... new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, cesiumWorkers), to: &apos;Workers&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Assets&apos;), to: &apos;Assets&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Widgets&apos;), to: &apos;Widgets&apos; &#125; ]), new webpack.DefinePlugin(&#123; // Define relative base path in cesium for loading assets CESIUM_BASE_URL: JSON.stringify(&apos;&apos;) &#125;) ... ] 在build/webpack.prod.conf.js文件中做如下修改 12345678910111213141516//定义 Cesium 源代码路径，前面没有../const cesiumSource = &apos;node_modules/cesium/Source&apos;//定义 Cesium Workers 路径const cesiumWorkers = &apos;../Build/Cesium/Workers&apos;...plugins: [ ... new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, cesiumWorkers), to: &apos;Workers&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Assets&apos;), to: &apos;Assets&apos; &#125; ]), new CopyWebpackPlugin([ &#123; from: path.join(cesiumSource, &apos;Widgets&apos;), to: &apos;Widgets&apos; &#125; ]), new webpack.DefinePlugin(&#123; //定义 Cesium 从哪里加载资源，如果使用默认的&apos;&apos;，却变成了绝对路径了，所以这里使用&apos;./&apos;,使用相对路径 CESIUM_BASE_URL: JSON.stringify(&apos;./&apos;) &#125;) ... ] Vue.js组件编写 在src/components下新建 CesiumViewer.vue vue组件 12345678910111213141516171819202122232425&lt;template&gt; &lt;div id=&quot;cesiumContainer&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt;import Cesium from &apos;cesium/Cesium&apos;import widgets from &apos;cesium/Widgets/widgets.css&apos;export default &#123; name: &apos;CesiumViewer&apos;, mounted () &#123; var viewer = new Cesium.Viewer(&apos;cesiumContainer&apos;) &#125;&#125;&lt;/script&gt;&lt;style rel=&quot;stylesheet/scss&quot; lang=&quot;scss&quot; scoped&gt;#cesiumContainer &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125;&lt;/style&gt; 创建全局样式文件src/styles/index.scss，做如下修改 12345678html,body &#123; width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;&#125; 在src/main.js中做如下修改 1import &apos;@/styles/index.scss&apos; // global css 参考链接 https://www.jianshu.com/p/fb237c7eb48c, by QingMings https://cesiumjs.org/tutorials/cesium-and-webpack/, by cesiumjs.org]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离线环境下Node.js应用部署方法]]></title>
    <url>%2F2018%2F05%2F10%2F%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8BNode-js%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[离线环境下Node.js应用部署时需要解决以下三个基本问题： Node.js应用的进程管理，如性能监控、自动重启、负载均衡等 Node.js应用开机如何自启动 离线环境下如何部署Node.js应用 下面以在Windows Server 2012上离线部署Node.js应用为例，记录上述问题的解决方案： Node.js应用的进程管理在生产环境中运行 Express 应用程序时，使用进程管理器对于完成以下任务很有帮助[1]： 在应用程序崩溃后将其重新启动。 获得对运行时性能和资源消耗的洞察。 动态修改设置以改善性能。 控制集群。 进程管理器有点类似于应用程序服务器：它是应用程序的“容器”，可促进部署，提供高可用性并使您可以在运行时管理应用程序。 用于 Express 和其他 Node.js 应用程序的最流行的进程管理器包括： StrongLoop Process Manager PM2 Forever 上述三种工具的比较请参阅http://strong-pm.io/compare/。其中，StrongLoop Process Manager无法在Windows平台工作，再综合比较PM2和Forever，由于Forever没有操作系统自启动的脚本，故选择PM2作为Windows平台Node.js应用的进程管理器。 Node.js应用开机如何自启动选择PM2作为Node.js应用的进程管理器后，Node.js应用开机自启动的问题就变为如何开机自启动PM2。Windows平台存在两个自启动PM2的脚本： pm2-windows-service pm2-windows-startup pm2-windows-service基于 node-windows将PM2注册为Windows服务，从而实现自启动。pm2-windows-startup则基于start-on-windows-boot在注册表中将PM2设为自启动程序，从而实现自启动。两种方案经测试，只有pm2-windows-startup在Windows Server 2012上可行，故选择pm2-windows-startup作为解决Node.js应用开机自启动的方案。 离线环境下如何部署Node.js应用PM2和pm2-windows-startup必须全局安装，如何简单方便地在离线环境下全局安装这两个模块是一个问题。网上搜到的方法有： npm link npm-bundle npm link[2]是npm的一个命令，可将本地包链接成全局包，但实际测试过程中，无法解决PM2包的依赖问题，故放弃。而npm-bundle[3]则能很好的解决PM2的依赖问题。具体过程为：12345\\在线环境下npm install -g npm-bundlenpm-bundle pm2\\离线环境下call npm install .\pm2-2.10.3.tgz -g 参考链接 http://expressjs.com/zh-cn/advanced/pm.html, by Express https://blog.csdn.net/fay462298322/article/details/53432691, by 爱死费崇政 https://stackoverflow.com/questions/41156556/what-exact-command-is-to-install-pm2-on-offline-rhel, by stackoverflow]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Highcharts]]></title>
    <url>%2F2018%2F05%2F10%2FVue-js%E9%9B%86%E6%88%90Highcharts%2F</url>
    <content type="text"><![CDATA[Vue.js集成Highcharts方法 安装highcharts 1npm install --save highcharts 封装hightcharts成Vue.js组件 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;highcharts-container&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Highcharts from &apos;highcharts/highstock&apos;import HighchartsMore from &apos;highcharts/highcharts-more&apos;import HighchartsDrilldown from &apos;highcharts/modules/drilldown&apos;import Highcharts3D from &apos;highcharts/highcharts-3d&apos;HighchartsMore(Highcharts)HighchartsDrilldown(Highcharts)Highcharts3D(Highcharts)export default &#123; props: [&apos;options&apos;], name: &apos;HighCharts&apos;, data () &#123; return &#123; chart: null &#125; &#125;, watch: &#123; options: function (newVal, oldVal) &#123; // watch it this.chart.update(newVal, true) &#125; &#125;, mounted () &#123; this.initChart() &#125;, methods: &#123; initChart () &#123; this.chart = new Highcharts.Chart(this.$el, this.options) &#125; &#125;&#125;&lt;/script&gt; 在src/main.js引入组件 12import HighCharts from &apos;./components/HighCharts.vue&apos;Vue.component(&apos;HighCharts&apos;, HighCharts) 使用组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;template&gt; &lt;div class=&quot;radarGraph&quot;&gt; &lt;HighCharts :options=&quot;options&quot; class=&quot;radar&quot; &gt;&lt;/HighCharts&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;RadarGraph&apos;, computed: &#123; gameInfo () &#123; return this.$store.state.gameInfo &#125;, options () &#123; return &#123; chart: &#123; polar: true, type: &apos;line&apos;, marginTop: 0, marginBottom: 0, marginLeft: 0, marginRight: 0 &#125;, credits: &#123; enabled: false &#125;, pane: &#123; size: &apos;75%&apos; &#125;, title: null, legend: &#123; enabled: false &#125;, xAxis: &#123; categories: [&apos;分类1&apos;, &apos;分类2&apos;, &apos;分类3&apos;, &apos;分类4&apos;, &apos;分类5&apos;, &apos;分类6&apos; ], labels: &#123; style: &#123; fontSize: &apos;14px&apos; &#125; &#125;, tickmarkPlacement: &apos;on&apos;, lineWidth: 0 &#125;, yAxis: &#123; gridLineInterpolation: &apos;polygon&apos;, lineWidth: 0, min: 0 &#125;, series: [&#123; type: &apos;area&apos;, name: &apos;得分&apos;, data: [this.gameInfo.radar1, this.gameInfo.radar2, this.gameInfo.radar3, this.gameInfo.radar4, this.gameInfo.radar5, this.gameInfo.radar6], pointPlacement: &apos;on&apos; &#125;] &#125; &#125;, ...mapGetters([ &apos;userId&apos; ]) &#125;, created () &#123; this.fetchData() &#125;, methods: &#123; fetchData () &#123; this.$store.dispatch(&apos;GetGameInfo&apos;, this.userId) &#125; &#125;&#125;&lt;/script&gt; 参考链接 https://blog.jianshukeji.com/2017/09/use-highcharts-with-vue/]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Socket.io]]></title>
    <url>%2F2018%2F05%2F09%2FVue-js%E9%9B%86%E6%88%90Socket-io%2F</url>
    <content type="text"><![CDATA[Socket.IO简介 Socket.IO 是一个面向实时 web 应用的 JavaScript 库。它使得服务器和客户端之间实时双向的通信成为可能。他有两个部分：在浏览器中运行的客户端库，和一个面向Node.js的服务端库。两者有着几乎一样的API。像Node.js一样，它也是事件驱动的. Socket.IO 主要使用WebSocket协议。但是如果需要的话，Socket.io可以回退到几种其它方法，例如Adobe Flash Sockets，JSONP拉取，或是传统的AJAX拉取，[2]并且在同时提供完全相同的接口。尽管它可以被用作WebSocket的包装库，它还是提供了许多其它功能，比如广播至多个套接字，存储与不同客户有关的数据，和异步IO操作。 Vue.js集成Socket.IO 安装socket.io-client 1npm install --save socket.io-client 在src/main.js中载入socket.io-client 123import io from &apos;socket.io-client&apos;const socket = io(process.env.BASE_API)Object.defineProperty(Vue.prototype, &apos;$socket&apos;, &#123; value: socket &#125;) 在Vuejs组件中使用socket.io-client 1this.$socket.on(&apos;event&apos;,function(e)&#123;&#125;) 参考链接 https://zh.wikipedia.org/wiki/Socket.IO, by Wikipedia https://socket.io/get-started/chat/, by socket.io]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PowerDesigner使用经验总结]]></title>
    <url>%2F2018%2F05%2F09%2FPowerDesigner%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[需求分析在系统工程及软件工程中，需求分析指的是在创建一个新的或改变一个现存的系统或产品时，确定新系统的目的、范围、定义和功能时所要做的所有工作。需求分析是软件工程中的一个关键过程。在这个过程中，系统分析员和软件工程师确定顾客的需要。只有在确定了这些需要后他们才能够分析和寻求新系统的解决方法。 在软件工程的历史中，很长时间里人们一直认为需求分析是整个软件工程中最简单的一个步骤，但在过去十年中越来越多的人认识到它是整个过程中最关键的一个过程。假如在需求分析时，分析者们未能正确地认识到顾客的需要的话，那么最后的软件实际上不可能达到顾客的需要，或者软体无法在规定的时间里完工。 软件设计软件设计是从软件需求规格说明书出发，根据需求分析阶段确定的功能设计软件系统的整体结构、划分功能模块、确定每个模块的实现算法以及编写具体的代码，形成软件的具体设计方案。 软件设计是把许多事物和问题抽象起来，并且抽象它们不同的层次和角度。将问题或事物分解并模块化使得解决问题变得容易，分解的越细模块数量也就越多，它的副作用就是使得设计者考虑更多的模块之间耦合度的情况。 UML统一建模语言（英语：Unified Modeling Language，缩写UML）是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。 这个语言由葛来迪·布区，伊瓦尔·雅各布森与詹姆士·兰宝于1994年至1995年间，在Rational Software公司中开发，于1996年，又进一步发展。UML集成了Booch，OMT和面向对象软件工程的概念，将这些方法融合为单一的，通用的，并且可以广泛使用的建模语言。UML打算成为可以对并发和分布式系统的标准建模语言。 在UML系统开发中有三个主要的模型： 功能模型：从用户的角度展示系统的功能，包括用例图。 静态模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图。 动态模型：展现系统的内部行为。包括序列图，活动图，状态图。） PowerDesigner工具PowerDesigner是Sybase的企业建模和设计解决方案，采用模型驱动方法，将业务与IT结合起来，可帮助部署有效的企业体系架构，并为研发生命周期管理提供强大的分析与设计技术。 PowerDesigner独具匠心地将多种标准数据建模技术（UML、业务流程建模以及市场领先的数据建模）集成一体，并与 .NET、WorkSpace、PowerBuilder、Java™、Eclipse 等主流开发平台集成起来，从而为传统的软件开发周期管理提供业务分析和规范的数据库设计解决方案。此外，它支持60多种关系数据库管理系统（RDBMS）／版本[来源请求]。PowerDesigner运行在Microsoft Windows平台上，并提供了Eclipse插件。 PowerDesigner使用经验遵循UML方法，使用PowerDesigner对系统进行建模。 在需求分析阶段，通常使用用例图、序列图（序列图中主要描述用户与系统之间交互关系）、组合结构图、类图（用于描述组件或类的接口及其调用关系）等UML图描述。 在设计阶段，从架构设计、概要设计到详细设计，粒度由粗到细。 通常架构设计是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。架构设计通常使用组织结构图、对象图、活动图、状态图等UML图描述。 概要设计就是设计软件的结构，包括组成模块，模块的层次结构，模块的调用关系，每个模块的功能等等。同时，还要设计该项目的应用系统的总体数据结构和数据库结构，即应用系统要存储什么数据，这些数据是什么样的结构，它们之间有什么关系。概要设计从模块角度描述系统，通常使用组合结构图进行描述。 详细设计就是为每个模块完成的功能进行具体的描述，要把功能描述转变为精确的、结构化的过程描述。如采用面向对象的开发方法，详细设计通常使用UML类图描述。]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js集成Bootstrap4]]></title>
    <url>%2F2018%2F05%2F09%2FVue-js%E9%9B%86%E6%88%90Bootstrap4%2F</url>
    <content type="text"><![CDATA[记录在Vue.js中集成Bootstrap4的方法，防止忘了！ 创建Vue.js工程 12npm install -g vue-clivue init webpack project_name 安裝Sass / Sass-loader / node-sass 1npm install sass sass-loader node-sass --save 安裝BootStrap / jQuery / Popper 1npm install bootstrap jquery popper.js --save 配置build/webpack.base.conf.js 123456789101112module.exports = &#123; ... // 新增plugins plugins: [ new webpack.ProvidePlugin(&#123; &apos;$&apos;: &quot;jquery&quot;, &apos;jQuery&apos;: &quot;jquery&quot;, &apos;Popper&apos;: &apos;popper.js&apos; &#125;) ], ...&#125; 在src/main.js中载入Bootstrap 12import &apos;bootstrap&apos;import &apos;bootstrap/dist/css/bootstrap.css&apos; 使用Bootstrap和sass编写Vue.js组件]]></content>
      <tags>
        <tag>笔记本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux mysql 终端操作]]></title>
    <url>%2F2018%2F05%2F08%2Flinux-mysql-%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[进入mysql数据库 1#mysql -uroot -proot 创建mysql user 12MariaDB [(none)]&gt; create user &apos;stock&apos;@&apos;localhost&apos; identified by &apos;stock&apos;;Query OK, 0 rows affected (0.00 sec) 查询mysql用户 12345678MariaDB [(none)]&gt; SELECT User,Host FROM mysql.user;+-------+-----------+| User | Host |+-------+-----------+| root | localhost || stock | localhost |+-------+-----------+2 rows in set (0.00 sec) 授予mysql用户权限 12MariaDB [(none)]&gt; GRANT ALL ON stock.* TO &apos;stock&apos;@&apos;localhost&apos;;Query OK, 0 rows affected (0.00 sec) 使用show语句查找数据库 123456789MariaDB [(none)]&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec) 创建数据库stock 12MariaDB [(none)]&gt; create database stock;Query OK, 1 row affected (0.00 sec) 选择创建的数据库 12MariaDB [(none)]&gt; use stock;Database changed 删除创建的数据库 12MariaDB [(none)]&gt; drop database stock;Query OK, 0 rows affected (0.00 sec)]]></content>
      <tags>
        <tag>笔记本</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[侠客行]]></title>
    <url>%2F2018%2F05%2F08%2F%E4%BE%A0%E5%AE%A2%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[作者：李白赵客缦胡缨，吴钩霜雪明。银鞍照白马，飒沓如流星。十步杀一人，千里不留行。事了拂衣去，深藏身与名。闲过信陵饮，脱剑膝前横。将炙啖朱亥，持觞劝侯嬴。三杯吐然诺，五岳倒为轻。眼花耳热后，意气素霓生。救赵挥金锤，邯郸先震惊。千秋二壮士，烜赫大梁城。纵死侠骨香，不惭世上英。谁能书阁下，白首太玄经。]]></content>
      <tags>
        <tag>传统文化</tag>
        <tag>唐诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[立功立德立言]]></title>
    <url>%2F2018%2F05%2F08%2F%E7%AB%8B%E5%8A%9F%E7%AB%8B%E5%BE%B7%E7%AB%8B%E8%A8%80%2F</url>
    <content type="text"><![CDATA[来源：《左传》二十四年春，穆叔如晋。范宣子逆之，问焉，曰：“古人有言曰：‘死而不朽’，何谓也？”穆叔未对。宣子曰：“昔匄之祖，自虞以上为陶唐氏，在夏为御龙氏，在商为豕韦氏，在周为唐杜氏，晋主夏盟为范氏，其是之谓乎？”穆叔曰：“以豹所闻，此之谓世禄，非不朽也。鲁有先大夫曰臧文仲，既没，其言立，其是之谓乎！豹闻之，‘太上有立德，其次有立功，其次有立言’，虽久不废，此之谓不朽。若夫保姓受氏，以守宗祊，世不绝祀，无国无之，禄之大者，不可谓不朽。]]></content>
      <tags>
        <tag>传统文化</tag>
      </tags>
  </entry>
</search>
