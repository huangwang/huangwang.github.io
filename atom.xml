<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jack Huang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huangwang.github.io/"/>
  <updated>2019-04-27T01:46:40.631Z</updated>
  <id>https://huangwang.github.io/</id>
  
  <author>
    <name>Jack Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Px4编译开发环境配置</title>
    <link href="https://huangwang.github.io/2019/04/26/Px4%E7%BC%96%E8%AF%91%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://huangwang.github.io/2019/04/26/Px4编译开发环境配置/</id>
    <published>2019-04-26T12:50:05.000Z</published>
    <updated>2019-04-27T01:46:40.631Z</updated>
    
    <content type="html"><![CDATA[<p>拟在基于NuttX的硬件平台如Pixhawk系列开源硬件平台上运行自定义的Px4自驾仪软件，因此需要建立Px4的编译开发环境。以官方文档推荐，在Ubuntu 16.04 LTS操作系统上建立Px4编译开发环境为例，记录整个配置过程。</p><h1 id="安装Ubuntu-16-04-LTS"><a href="#安装Ubuntu-16-04-LTS" class="headerlink" title="安装Ubuntu 16.04 LTS"></a>安装Ubuntu 16.04 LTS</h1><p>官方推荐在Mac OS和Linux上进行开发，因此选择安装Ubuntu 16.04 LTS作为Px4开发的操作系统。主要步骤如下：</p><ol><li>安装VirtualBox系统虚拟机</li><li>在VirtualBox创建虚拟机</li><li>在虚拟机中安装Ubuntu 16.04 LTS操作系统</li></ol><h1 id="Ubuntu中安装工具链"><a href="#Ubuntu中安装工具链" class="headerlink" title="Ubuntu中安装工具链"></a>Ubuntu中安装工具链</h1><h2 id="权限设置"><a href="#权限设置" class="headerlink" title="权限设置"></a>权限设置</h2><p>为了使当前用户能够访问串口，将当前用户添加到dialout组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G dialout $USER</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="安装工具链"><a href="#安装工具链" class="headerlink" title="安装工具链"></a>安装工具链</h2><h3 id="Pixhawk-NuttX-and-jMAVSim"><a href="#Pixhawk-NuttX-and-jMAVSim" class="headerlink" title="Pixhawk/NuttX (and jMAVSim)"></a>Pixhawk/NuttX (and jMAVSim)</h3><p>针对基于NuttX的硬件平台如Pixhawk构建开发工具链，步骤如下：</p><ol><li>下载ubuntu_sim_nuttx.sh</li><li>运行脚本ubuntu_sim_nuttx.sh</li><li>完成后重启</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/PX4/Devguide/master/build_scripts/ubuntu_sim_nuttx.sh</span><br><span class="line">sh ubuntu_sim_nuttx.sh</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="编译Px4软件"><a href="#编译Px4软件" class="headerlink" title="编译Px4软件"></a>编译Px4软件</h1><h2 id="下载Px4源代码"><a href="#下载Px4源代码" class="headerlink" title="下载Px4源代码"></a>下载Px4源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/src</span><br><span class="line">cd ~/src</span><br><span class="line">git clone https://github.com/PX4/Firmware.git</span><br><span class="line">cd Firmware</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><p>现在可以通过编译源代码来构建二进制文件。在直接使用硬件前，推荐先<strong>进行仿真</strong>。</p><h2 id="基于NuttX-Pixhawk的硬件板"><a href="#基于NuttX-Pixhawk的硬件板" class="headerlink" title="基于NuttX / Pixhawk的硬件板"></a>基于NuttX / Pixhawk的硬件板</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Firmware</span><br><span class="line">make px4fmu-v2_default</span><br></pre></td></tr></table></figure><p>注意到“make”是一个字符命令编译工具，“px4fmu-v2”是硬件/ardupilot版本，“default”是默认配置，所有的PX4编译目标遵循这个规则。</p><p>成功编译的最后输出是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[100%] Linking CXX executable firmware_nuttx</span><br><span class="line">[100%] Built target firmware_nuttx</span><br><span class="line">Scanning dependencies of target build/firmware_px4fmu-v2</span><br><span class="line">[100%] Generating nuttx-px4fmu-v2-default.px4</span><br><span class="line">[100%] Built target build/firmware_px4fmu-v2</span><br></pre></td></tr></table></figure><p>通过在命令后面添加‘upload’，编译的二进制程序就会通过USB上传到飞控硬件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make px4fmu-v2_default upload</span><br></pre></td></tr></table></figure><p>上传成功时输出情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Erase  : [====================] 100.0%</span><br><span class="line">Program: [====================] 100.0%</span><br><span class="line">Verify : [====================] 100.0%</span><br><span class="line">Rebooting.</span><br><span class="line"></span><br><span class="line">[100%] Built target upload</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://dev.px4.io/en/" target="_blank" rel="noopener">PX4 Development Guide (STABLE - v1.8.2)</a>,by Dronecode.</li><li><a href="https://dev.px4.io/zh/" target="_blank" rel="noopener">PX4开发指南</a>, by Dronecode.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;拟在基于NuttX的硬件平台如Pixhawk系列开源硬件平台上运行自定义的Px4自驾仪软件，因此需要建立Px4的编译开发环境。以官方文档推荐，在Ubuntu 16.04 LTS操作系统上建立Px4编译开发环境为例，记录整个配置过程。&lt;/p&gt;
&lt;h1 id=&quot;安装Ubuntu
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="无人机" scheme="https://huangwang.github.io/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
      <category term="飞行仿真" scheme="https://huangwang.github.io/tags/%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>硬件在环与软件在环概念辨析</title>
    <link href="https://huangwang.github.io/2019/04/25/%E7%A1%AC%E4%BB%B6%E5%9C%A8%E7%8E%AF%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%9C%A8%E7%8E%AF%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90/"/>
    <id>https://huangwang.github.io/2019/04/25/硬件在环与软件在环概念辨析/</id>
    <published>2019-04-25T13:51:19.000Z</published>
    <updated>2019-04-25T14:46:16.952Z</updated>
    
    <content type="html"><![CDATA[<p>在PX4自驾仪软件的二次开发过程中，涉及硬件在环与软件在环两个概念，不易理解。下面对这两个概念进行辨析。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="硬件在环"><a href="#硬件在环" class="headerlink" title="硬件在环"></a>硬件在环</h2><p>硬件在环（Hardware in the Loop，简称HIL）即硬件在控制环路，是一种半实物仿真。根据控制器和控制对象是否为真实硬件，分为以下两种硬件在环方式：</p><ul><li>虚拟控制器+实际对象=快速控制原型(RCP)仿真系统，是系统的一种半实物仿真；</li><li>实际控制器+虚拟对象=硬件在回路(HIL)仿真系统，是系统的另一种半实物仿真。</li></ul><p>硬件在环主要用于测试控制器系统。</p><h2 id="软件在环"><a href="#软件在环" class="headerlink" title="软件在环"></a>软件在环</h2><p>软件在环主要测试控制器模型与控制器模型代码实现之间的一致性。</p><h2 id="处理器在环"><a href="#处理器在环" class="headerlink" title="处理器在环"></a>处理器在环</h2><p>软件在环主要测试控制器模型与控制器模型代码实现在目标处理器上运行之间的一致性。</p><h2 id="模型在环"><a href="#模型在环" class="headerlink" title="模型在环"></a>模型在环</h2><p>模型在环（Model in the Loop，简称MIL）是用模型驱动进行嵌入式系统的开发时，在开发阶段初期及建模阶段中进行的仿真方式。嵌入式系统需和其运作的环境互动，一般会预期有合理的传感器信号为其输入，也会依输入及系统设计来驱动实体系统。为了使系统正常工作，需要将嵌入式系统的环境纳入仿真考量范围内。若嵌入式系统模型和环境模型连接，一起进行仿真，则即称为模型在环模拟。</p><p>模型在环主要用于测试控制算法，其控制器模型和控制器对象都是虚拟的。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://www.zhihu.com/question/32069347" target="_blank" rel="noopener">请明白人通俗的解释一下什么叫硬件在环？</a>, by zhihu.</li><li><a href="http://www.360doc.com/content/16/0908/10/22368478_589256146.shtml" target="_blank" rel="noopener">简单说说MIL、SIL、PIL和HIL</a>, by Wangxn665.</li><li><a href="https://zh.wikipedia.org/wiki/模型在环" target="_blank" rel="noopener">模型在环</a>, by wikipedia.</li><li><a href="https://baike.baidu.com/item/硬件在环" target="_blank" rel="noopener">硬件在环</a>, by 百度百科.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在PX4自驾仪软件的二次开发过程中，涉及硬件在环与软件在环两个概念，不易理解。下面对这两个概念进行辨析。&lt;/p&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="飞行仿真" scheme="https://huangwang.github.io/tags/%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>机器人路径规划、轨迹规划和运动规划概念辨析</title>
    <link href="https://huangwang.github.io/2019/04/17/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92-%E8%BD%A8%E8%BF%B9%E8%A7%84%E5%88%92%E5%92%8C%E8%BF%90%E5%8A%A8%E8%A7%84%E5%88%92%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90/"/>
    <id>https://huangwang.github.io/2019/04/17/机器人路径规划-轨迹规划和运动规划概念辨析/</id>
    <published>2019-04-17T13:15:42.000Z</published>
    <updated>2019-04-17T13:56:21.132Z</updated>
    
    <content type="html"><![CDATA[<p>在机器人自动控制研究中，路径规划、轨迹规划和运动规划三个概念总是混淆不清，难以捉摸。下面结合各种资料，给出我个人的一些理解，对这三个概念进行辨析。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="路径规划（path-planning）"><a href="#路径规划（path-planning）" class="headerlink" title="路径规划（path planning）"></a>路径规划（path planning）</h2><p>路径是机器人位姿的一定序列，<strong>不考虑机器人位姿参数随时间变化的因素</strong>。路径规划（一般指位置规划）是找到一系列要经过的路径点，路径点是空间中的位置或关节角度。</p><h2 id="轨迹规划（trajectory-planning）"><a href="#轨迹规划（trajectory-planning）" class="headerlink" title="轨迹规划（trajectory planning）"></a>轨迹规划（trajectory planning）</h2><p>路径是机器人位姿的一定序列，<strong>不考虑机器人位姿参数随时间变化的因素</strong>。路径规划（一般指位置规划）是找到一系列要经过的路径点，路径点是空间中的位置或关节角度，而轨迹规划是赋予路径时间信息。</p><h2 id="运动规划（motion-planning）"><a href="#运动规划（motion-planning）" class="headerlink" title="运动规划（motion planning）"></a>运动规划（motion planning）</h2><p>运动规划就是在给定的位置A与位置B之间为机器人找到一条符合约束条件的路径。运动规划包含路径规划和轨迹规划。</p><p>运动规划，又称运动插补，是在给定的路径端点之间插入用于控制的中间点序列从而实现沿给定的平稳运动。</p><p>运动控制则是主要解决如何控制目标系统准确跟踪指令轨迹的问题，即对于给定的指令轨迹，选择适合的控制算法和参数，产生输出，控制目标实时，准确地跟踪给定的指令轨迹。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://www.cnblogs.com/wdzeng/p/9159575.html" target="_blank" rel="noopener">运动（motion）规划、路径（path）规划和轨迹（trajectory）规划之区别</a>,by Roger_Ceng.</li><li><a href="https://blog.csdn.net/wx545644217/article/details/54175035" target="_blank" rel="noopener">运动规划/路径规划/轨迹规划</a>,by 小白鼠2号.</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA5MDE2MjQ0OQ==&amp;mid=2652786406&amp;idx=1&amp;sn=f937dd6aa91344fed689baf51dc821ab#rd" target="_blank" rel="noopener">运动规划 | 简介篇</a>,by qqfly.</li><li><a href="https://www.zhihu.com/question/67867008" target="_blank" rel="noopener">无人车运动规划，路径规划，轨迹规划的区别和联系？</a>, by zhihu.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在机器人自动控制研究中，路径规划、轨迹规划和运动规划三个概念总是混淆不清，难以捉摸。下面结合各种资料，给出我个人的一些理解，对这三个概念进行辨析。&lt;/p&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="机器学习" scheme="https://huangwang.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>FlightGear简易飞行教程</title>
    <link href="https://huangwang.github.io/2019/03/29/FlightGear%E7%AE%80%E6%98%93%E9%A3%9E%E8%A1%8C%E6%95%99%E7%A8%8B/"/>
    <id>https://huangwang.github.io/2019/03/29/FlightGear简易飞行教程/</id>
    <published>2019-03-29T02:29:07.000Z</published>
    <updated>2019-03-29T08:34:07.255Z</updated>
    
    <content type="html"><![CDATA[<p>FlightGear是一个始于1997年多平台飞行模拟器、自由软件项目。下面简要介绍如何在FlightGear中驾驶飞行。</p><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><h2 id="飞机操纵"><a href="#飞机操纵" class="headerlink" title="飞机操纵"></a>飞机操纵</h2><ul><li>9/3</li></ul><p>推力：9增加推力（油门），3减小推力（油门）</p><ul><li>4/6</li></ul><p>副翼：4向左滚转，6向右滚转</p><ul><li>8/2</li></ul><p>升降舵：8推杆低头，2拉杆抬头</p><ul><li>0/Enter</li></ul><p>方向舵：0向右偏航，Enter向右偏航</p><ul><li>5</li></ul><p>居中副翼/升降舵/方向舵</p><ul><li>]/[</li></ul><p>放/收襟翼</p><ul><li>g/G</li></ul><p>收/放起落架</p><ul><li>b/B</li></ul><p>刹车（全部轮胎）/或释放刹车</p><h2 id="视角变换"><a href="#视角变换" class="headerlink" title="视角变换"></a>视角变换</h2><ul><li>x/X</li></ul><p>放大/缩小</p><ul><li>v/V</li></ul><p>切换飞行员的观测模式</p><ul><li>Tab</li></ul><p>循环切换鼠标模式：正常模式(默认)、控制模式和查看模式。</p><h2 id="自动驾驶"><a href="#自动驾驶" class="headerlink" title="自动驾驶"></a>自动驾驶</h2><ul><li>Ctril + A</li></ul><p>高度保持开关</p><ul><li>Ctril + G</li></ul><p>下滑角跟随开关</p><ul><li>Ctril + H</li></ul><p>航向保持开关</p><ul><li>Ctril + N</li></ul><p>NAV 开关</p><ul><li>Ctril + T</li></ul><p>地形跟随开关</p><ul><li>Ctril + U</li></ul><p>高度增加 1000 英尺（紧急情况）</p><h1 id="起飞教程"><a href="#起飞教程" class="headerlink" title="起飞教程"></a>起飞教程</h1><p>起飞步骤如下：</p><p>1.启动引擎</p><p>在驾驶舱内通过按键启动飞机引擎的过程很麻烦，且各种类型飞机引擎启动过程不一样。幸运的是，FlightGear的飞机菜单中会有自动启动或快速启动的子菜单，点击它们自动启动飞机引擎和各种航电设备。</p><p>2.释放刹车</p><p>使用快捷键B释放刹车。</p><p>3.滑跑起飞</p><p>飞机尽量在跑道中央进行滑跑起飞，使用快捷键“0/Enter”控制飞机方向舵，使飞机在跑道中央滑跑; 当飞机达到起飞速度（一般200～300km/h）时，<strong>先使用快捷键“5”居中副翼/升降舵/方向舵，以降低飞机在空中操纵的难度，再使用快捷键“8/2”操纵飞机升降舵，注意应避免仰角过大</strong>。</p><h1 id="武器使用教程"><a href="#武器使用教程" class="headerlink" title="武器使用教程"></a>武器使用教程</h1><p>各种战斗机可通过飞机菜单选择不同武器加载方案。但各种战斗机的武器使用方法不一样，对应武器发射的快捷键也不一样，可通过菜单“Help-&gt;Aircraft Help”查看具体飞机的自定义快捷键。下面以官方飞机库中的F15和F16为例说明武器使用方法。</p><h2 id="F15"><a href="#F15" class="headerlink" title="F15"></a>F15</h2><p>F15武器使用步骤如下：</p><p>1.打开Master ARM开关</p><p>该军械总开关防止武器误发射，使用快捷键Ctrl+w控制。</p><p>2.选择武器</p><p>可选择航炮和导弹等武器，使用快捷键m控制</p><p>3.发射航炮或释放导弹</p><p>使用快捷键e控制，注意航炮按e就发射，而导弹按e得持续3秒钟才能释放导弹。</p><p>4.使用诱饵弹</p><p>使用快捷键Ctrl+q释放诱饵弹。</p><h2 id="F16"><a href="#F16" class="headerlink" title="F16"></a>F16</h2><p>F16武器使用步骤如下：</p><p>1.打开Master ARM开关</p><p>该开关防止武器误发射，使用快捷键m控制。</p><p>2.选择武器</p><p>可选择航炮和导弹等武器，使用快捷键w控制</p><p>3.发射航炮或释放导弹</p><p>使用快捷键e控制，注意航炮按e就发射，而导弹按e得持续3秒钟才能释放导弹。</p><p>4.使用诱饵弹</p><p>使用快捷键q释放诱饵弹。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zh.wikipedia.org/wiki/FlightGear" target="_blank" rel="noopener">FlightGear</a>,by wikipedia.</li><li><a href="http://www.flightgear.org.cn/thread-23-1-1.html" target="_blank" rel="noopener">FlightGear基本飞行操作快捷键</a>,by zxc.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FlightGear是一个始于1997年多平台飞行模拟器、自由软件项目。下面简要介绍如何在FlightGear中驾驶飞行。&lt;/p&gt;
&lt;h1 id=&quot;常用快捷键&quot;&gt;&lt;a href=&quot;#常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;常用快捷键&quot;&gt;&lt;/a&gt;常用
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="飞行仿真" scheme="https://huangwang.github.io/tags/%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>JSBSim编程实践之入门</title>
    <link href="https://huangwang.github.io/2019/03/27/JSBSim%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwang.github.io/2019/03/27/JSBSim编程实践之入门/</id>
    <published>2019-03-27T07:32:05.000Z</published>
    <updated>2019-03-27T08:12:15.251Z</updated>
    
    <content type="html"><![CDATA[<p>JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。JSBSim可以独立运行，通过命令行参数指定飞行器和初始状态，进行简单情境下的飞行动力学仿真，也可以将JSBSim作为代码库，编程实现飞行器模型加载，设置输入，获得输出。下面即介绍在Linux平台编程调用JSBSim库的方法和步骤。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="gcc与g"><a href="#gcc与g" class="headerlink" title="gcc与g++"></a>gcc与g++</h2><p>GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU项目的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。</p><p>通常gcc用于编译链接c代码文件，而g++用于编译链接c++代码文件，但它们的使用方法很类似。下面介绍gcc和g++的常用选项。</p><ul><li>添加头文件搜索路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc foo.c -I /home/xiaowp/include -o foo</span><br></pre></td></tr></table></figure><ul><li>添加动态库搜索路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc foo.c -L /home/xiaowp/lib -lfoo -o foo</span><br></pre></td></tr></table></figure><ul><li>添加静态库搜索路径</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc foo.c -L /home/xiaowp/lib -static -lfoo -o foo</span><br></pre></td></tr></table></figure><h1 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h1><h2 id="最简仿真"><a href="#最简仿真" class="headerlink" title="最简仿真"></a>最简仿真</h2><p>下面是JSBSim参考手册中的最简单实例，因JSBSim的不断开发，JSBSim参考手册中该编程实例有点过时，因此进行了少量修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;FGFDMExec.h&gt;</span><br><span class="line">#include &lt;sg_path.hxx&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  JSBSim::FGFDMExec FDMExec;</span><br><span class="line">  bool result = true;</span><br><span class="line"> </span><br><span class="line">  FDMExec.LoadScript(SGPath::fromUtf8(argv[1]));</span><br><span class="line"> </span><br><span class="line">  while (result) result = FDMExec.Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可知，调用JSBSim的主要方法是利用FGFDMExec类，通过实例化一个FGFDMExec类，就相当于获得了一个运行JSBSim仿真的工具箱，通过这个工具箱就可以调用JSBSim的大部分功能，实现我们要的仿真目标。</p><p>接下来对该实例进行编译链接，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># jsbsim_script.cpp是上述实例的代码文件</span><br><span class="line">g++ jsbsim_script.cpp -I ../jsbsim/src/ -I../jsbsim/src/simgear/misc  -L ../jsbsim/build/src/ -static -l JSBSim -o jsbsim_script</span><br></pre></td></tr></table></figure><p>测试该实例，使用如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># jsbsim是JSBSim项目文件夹</span><br><span class="line"># JSBSimTest是JSBSim测试实例所在文件夹</span><br><span class="line">cd jsbsim</span><br><span class="line">../JSBSimTest/jsbsim_script ./scripts/c1723.xml</span><br></pre></td></tr></table></figure></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://blog.csdn.net/yu_lei_/article/details/81916143" target="_blank" rel="noopener">JSBSim编程实践</a>,by 32768.</li><li><a href="https://huangwang.github.io/2019/03/20/Linux平台编译安装测试JSBSim/">Linux平台编译安装测试JSBSim</a>,by jack huang.</li><li><a href="http://jsbsim.sourceforge.net/documentation.html" target="_blank" rel="noopener">JSBSim Reference Manual </a>,by jsbsim.</li><li><a href="https://www.cnblogs.com/zxouxuewei/p/7263568.html" target="_blank" rel="noopener">gcc和g++头文件和库路径的寻找和添加</a>,by 周学伟.</li><li><a href="https://zh.wikipedia.org/wiki/GCC" target="_blank" rel="noopener">GCC</a>,by wikipedia.</li><li><a href="https://www.freelancinggig.com/blog/2017/11/10/difference-gcc-g/" target="_blank" rel="noopener">WHAT IS THE DIFFERENCE BETWEEN GCC AND G++</a>,by KITTY GUPTA.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。JSBSim可以独立运行，通过命令行参数指定飞行器和初始状态，进行简单情境下的飞行动力学仿真，也可以将
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="飞行仿真" scheme="https://huangwang.github.io/tags/%E9%A3%9E%E8%A1%8C%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>四旋翼无人机制作简易教程</title>
    <link href="https://huangwang.github.io/2019/03/25/%E5%9B%9B%E6%97%8B%E7%BF%BC%E6%97%A0%E4%BA%BA%E6%9C%BA%E5%88%B6%E4%BD%9C%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
    <id>https://huangwang.github.io/2019/03/25/四旋翼无人机制作简易教程/</id>
    <published>2019-03-25T13:40:54.000Z</published>
    <updated>2019-04-08T12:24:22.360Z</updated>
    
    <content type="html"><![CDATA[<p>四轴飞行器又称四旋翼、四转子，是一种多轴飞行器，有四个旋翼来悬停、维持姿态及平飞。和固定翼飞机不同，它通过旋翼提供的推力使飞机升空。它的四个旋翼大小相同，分布位置接近对称。对于简单的设计来说，仅仅通过调整不同旋翼之间的相对速度来调节不同位置的推力，并克服每个旋翼之间的反扭力矩，就可以控制飞机维持姿态、或完成各种机动飞行。下面简单介绍四旋翼无人机的制作过程。</p><h1 id="无人机硬件装配"><a href="#无人机硬件装配" class="headerlink" title="无人机硬件装配"></a>无人机硬件装配</h1><p>组装一件无人机所需配件及其连接示意图如图1所示。</p><p></p><p align="center">    <img src="images/drone_connect.jpg" width="100%" alt="四旋翼无人机机硬件连接图"></p><p></p><center>图1  四旋翼无人机机硬件连接图</center><p>所需配件主要有：</p><ul><li>机身骨架</li><li>一对正浆和一对反浆。注意浆的固定方向与电机旋转方向要一致。</li><li>遥控器及接收机</li><li>无刷电机及电调</li><li>ppm sum receiver</li><li>pixhawk 1，内含安全开关和蜂鸣器</li><li>gps</li><li>锂电池</li><li>云台和摄像头（可选）</li><li>telemetry无线收发装置与图传（可选）</li></ul><h1 id="无人机软件调试"><a href="#无人机软件调试" class="headerlink" title="无人机软件调试"></a>无人机软件调试</h1><h2 id="遥控器与接收机之间对码"><a href="#遥控器与接收机之间对码" class="headerlink" title="遥控器与接收机之间对码"></a>遥控器与接收机之间对码</h2><p>遥控器和接收机之间是配对的，使用之前必须对码，可根据遥控器的使用说明书进行操作。其连接示意图如图2所示。</p><p></p><p align="center">    <img src="images/pair_code.png" width="80%" alt="航模遥控器与接收机对码示意图"></p><p></p><center>图2  航模遥控器与接收机对码示意图</center><h2 id="电子调速器的油门行程和进角设置"><a href="#电子调速器的油门行程和进角设置" class="headerlink" title="电子调速器的油门行程和进角设置"></a>电子调速器的油门行程和进角设置</h2><p>电子调速器主要控制马达的转速，其调试连接示意图如图3所示。</p><p></p><p align="center">    <img src="images/esc.jpg" width="80%" alt="电子调速器连接示意图"></p><p></p><center>图3 电子调速器连接示意图</center><p>如图3所示将电子调速器连接后，即开始设置油门行程和电子调速器进角。设置油门行程即让电子调速器知道遥控器的油门输入范围。而电子调速器进角有高中低之分，类似于汽车档位。低进角速度慢但扭力大，高进角速度快但扭力小，一般设置电子调速器中进角即可满足大多数要求。具体设置说明参照电子调速器使用说明书。</p><h2 id="pixhawk飞控平台的设置"><a href="#pixhawk飞控平台的设置" class="headerlink" title="pixhawk飞控平台的设置"></a>pixhawk飞控平台的设置</h2><p>Pixhawk是PX4飞行堆栈的标准微控制器平台。在pixhawk硬件平台上可运行PX4和ArduPilot两种不同的自动驾驶仪软件套件。如果在pixhawk平台上安装px4自驾仪软件，则使用QGroundControl地面站软件进行设置；如果在pixhawk平台上安装ArduPilot自驾仪软件，则使用MissionPlanner地面站软件进行设置。</p><p>Pixhawk和GPS按照方向捆绑好后，按照地面站软件的指示进行设置。设置好之后，长按Pixhawk的安全开关，再将遥控器油门拉动底并推向最右方，即可解锁Pixhawk。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zh.wikipedia.org/wiki/四轴飞行器" target="_blank" rel="noopener">四轴飞行器</a>,by wikipedia.</li><li><a href="http://dev.px4.io/" target="_blank" rel="noopener">PX4 autopilot</a>, by px4 homepage.</li><li><a href="http://www.crazepony.com/book/" target="_blank" rel="noopener">Crazepony开源四轴飞行器</a>,by crazepony.</li><li><a href="https://en.wikipedia.org/wiki/ArduPilot" target="_blank" rel="noopener">ArduPilot</a>,by wikipedia.</li><li><a href="https://en.wikipedia.org/wiki/PX4_autopilot" target="_blank" rel="noopener">PX4 autopilot</a>,by wikipedia.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;四轴飞行器又称四旋翼、四转子，是一种多轴飞行器，有四个旋翼来悬停、维持姿态及平飞。和固定翼飞机不同，它通过旋翼提供的推力使飞机升空。它的四个旋翼大小相同，分布位置接近对称。对于简单的设计来说，仅仅通过调整不同旋翼之间的相对速度来调节不同位置的推力，并克服每个旋翼之间的反扭力
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="无人机" scheme="https://huangwang.github.io/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>FlightGear多人服务器的本地安装配置</title>
    <link href="https://huangwang.github.io/2019/03/20/FlightGear%E5%A4%9A%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://huangwang.github.io/2019/03/20/FlightGear多人服务器的本地安装配置/</id>
    <published>2019-03-20T12:28:23.000Z</published>
    <updated>2019-03-20T13:53:22.827Z</updated>
    
    <content type="html"><![CDATA[<p>FGMS或FlightGear多人游戏服务器是FlightGear的独立网络服务器，并根据GPL许可。 它允许通过FGFS内的网络与其他飞行员一起飞行。</p><p>FGMS服务器列表类型主要有：</p><ul><li>中继服务器 - 网络中的其他服务器。 每个都必须有完整的列表（减去自己）以获得适当的网络功能。</li><li>交叉馈送服务器 - 服务器从本地用户和其他服务器接收的所有内容都将转发到交叉馈送服务器。 用于在同一主机上运行多个连接的fgms实例，例如用于提供跟踪和未跟踪服务，而不会产生额外的外部流量。</li><li>跟踪服务器 - 服务器每10秒向跟踪器发送一个每个本地用户的摘要更新。</li><li>HUB服务器  - 通常服务器不会将从服务器接收的数据包发送到其他中继。 HUB服务器将数据从服务器发送到它知道的所有中继。</li></ul><p>特别呼号：</p><ul><li>“obsXXXX”（用您喜欢的任何字符替换X）允许连接的FlightGear客户端查看全球所有其他MP飞行员（位置数据和聊天消息），但对他们和MPmap保持不可见。</li><li>“mpdummy”阻止在FGTracker上跟踪飞行员。 不推荐 - 如果多个用户使用此呼号，服务器将忽略一些用户。 改为连接到未跟踪的服务器。</li></ul><h1 id="安装配置FGMS服务器"><a href="#安装配置FGMS服务器" class="headerlink" title="安装配置FGMS服务器"></a>安装配置FGMS服务器</h1><h2 id="下载FGMS服务器源码"><a href="#下载FGMS服务器源码" class="headerlink" title="下载FGMS服务器源码"></a>下载FGMS服务器源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://git.code.sf.net/p/fgms/src fgms-src</span><br></pre></td></tr></table></figure><h2 id="安装配置FGMS服务器源码"><a href="#安装配置FGMS服务器源码" class="headerlink" title="安装配置FGMS服务器源码"></a>安装配置FGMS服务器源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd fgms-src</span><br><span class="line">mkdir build</span><br><span class="line">cd build </span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">cd ..</span><br><span class="line">cp contrib/etc/fgms_production.skel.conf build/fgms.cfg</span><br><span class="line">cd build</span><br><span class="line">./fgms</span><br></pre></td></tr></table></figure><h1 id="安装配置FGMS跟踪服务器源码"><a href="#安装配置FGMS跟踪服务器源码" class="headerlink" title="安装配置FGMS跟踪服务器源码"></a>安装配置FGMS跟踪服务器源码</h1><h2 id="下载FGMS跟踪服务器源码"><a href="#下载FGMS跟踪服务器源码" class="headerlink" title="下载FGMS跟踪服务器源码"></a>下载FGMS跟踪服务器源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://git.code.sf.net/p/fgms/fgtracker fgms-fgtracker</span><br></pre></td></tr></table></figure><h1 id="FlightGear联网飞行配置"><a href="#FlightGear联网飞行配置" class="headerlink" title="FlightGear联网飞行配置"></a>FlightGear联网飞行配置</h1><p>联机前，请选择合适的服务器名（通常是mpserver0?.flightgear.org）和端口号(通常是5000)，然后按照以下方式启动FlightGear。</p><h2 id="使用向导程序"><a href="#使用向导程序" class="headerlink" title="使用向导程序"></a>使用向导程序</h2><p>在向导程序上专门有一个联网飞行选项，只要选中选项，填入服务器名和端口号以及你的昵称就可以了，你的昵称最长可以使7个字符。同时必须确定AI models选项选中，否则无法看到别的联网飞机。</p><h2 id="使用命令行方式"><a href="#使用命令行方式" class="headerlink" title="使用命令行方式"></a>使用命令行方式</h2><p>基本命令如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--multiplay=out,10,&lt;server&gt;,&lt;portnumber&gt;</span><br><span class="line">--multiplay=in,10,&lt;client&gt;,&lt;portnumber&gt;</span><br><span class="line">--callsign=&lt;anything&gt;</span><br><span class="line">--enable-ai-models</span><br></pre></td></tr></table></figure></p><p>备注:</p><ol><li><portnumber> 为端口号，比如5000.</portnumber></li><li><server> 为服务器名，比如mpserver01.flightgear.org.</server></li><li><client> 是你的计算机名，或者是你的联网的IP地址，比如本地IP地址192.168.0.1</client></li><li><callsign> 是你自己的昵称, 最多7个字符比如NFGFS.<br>当程序开始运行后，你可以在服务器地图上看到自己，如果看不到，检查一下程序是否有报错信息，按照下面将要介绍的内容检查错误。</callsign></li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://wiki.flightgear.org/Howto:Multiplayer" target="_blank" rel="noopener">Howto:Multiplayer</a>,by flightgear home.</li><li><a href="http://wiki.flightgear.org/FlightGear_Multiplayer_Server" target="_blank" rel="noopener">FlightGear Multiplayer Server</a>,by flightgear home.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FGMS或FlightGear多人游戏服务器是FlightGear的独立网络服务器，并根据GPL许可。 它允许通过FGFS内的网络与其他飞行员一起飞行。&lt;/p&gt;
&lt;p&gt;FGMS服务器列表类型主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中继服务器 - 网络中的其他服务器。 每个都必须
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="3D" scheme="https://huangwang.github.io/tags/3D/"/>
    
      <category term="计算机仿真" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux平台编译安装测试JSBSim</title>
    <link href="https://huangwang.github.io/2019/03/20/Linux%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95JSBSim/"/>
    <id>https://huangwang.github.io/2019/03/20/Linux平台编译安装测试JSBSim/</id>
    <published>2019-03-20T02:42:19.000Z</published>
    <updated>2019-03-20T03:29:51.717Z</updated>
    
    <content type="html"><![CDATA[<p>JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。 它也可以从一个小型独立程序调用，以创建批处理模拟工具。 JSBSim是用C ++编写的，使用XML配置文件。下面介绍如何在Linux平台编译按照测试JSBSim。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><p>代码变成可执行文件，叫做编译（compile）；先编译这个，还是先编译那个（即编译的安排），叫做构建（build）。</p><p>Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</p><p>Make工具有很多，例如 GNU Make ，QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。</p><p>CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等。</p><p>在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：</p><ol><li>编写 CMake 配置文件 CMakeLists.txt 。</li><li>执行命令 cmake PATH 或者 ccmake PATH 生成 Makefile。其中， PATH 是 CMakeLists.txt 所在的目录。</li><li>使用 make 命令进行编译。</li></ol><h1 id="编译JSBSim"><a href="#编译JSBSim" class="headerlink" title="编译JSBSim"></a>编译JSBSim</h1><h2 id="下载JSBSim源代码"><a href="#下载JSBSim源代码" class="headerlink" title="下载JSBSim源代码"></a>下载JSBSim源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/JSBSim-Team/jsbsim.git</span><br></pre></td></tr></table></figure><h2 id="编译JSBSim-1"><a href="#编译JSBSim-1" class="headerlink" title="编译JSBSim"></a>编译JSBSim</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 跳转到jsbsim源码目录</span><br><span class="line">cd jsbsim  </span><br><span class="line"># 创建build文件夹用于编译jsbsim</span><br><span class="line">mkdir build </span><br><span class="line">cd build</span><br><span class="line"># 生成Makefile文件</span><br><span class="line">cmake .. </span><br><span class="line"># 编译</span><br><span class="line">make </span><br><span class="line"># 编译完成后跳转到jsbsim所在目录测试</span><br><span class="line">cd src</span><br><span class="line">./jsbsim</span><br></pre></td></tr></table></figure><h1 id="测试jsbsim"><a href="#测试jsbsim" class="headerlink" title="测试jsbsim"></a>测试jsbsim</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 跳转到jsbsim源码目录</span><br><span class="line">cd jsbsim </span><br><span class="line"># 测试jsbsim</span><br><span class="line">./build/src/JSBSim scripts/c1723.xml</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://en.wikipedia.org/wiki/JSBSim" target="_blank" rel="noopener">JSBSim</a>, by wikipedia.</li><li><a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">Make 命令教程</a>,by 阮一峰</li><li><a href="https://www.hahack.com/codes/cmake/" target="_blank" rel="noopener">CMake 入门实战</a>,by hahack.</li><li><a href="https://blog.csdn.net/yu_lei_/article/details/81813203" target="_blank" rel="noopener">JSBSim使用教程</a>, by  32768.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JSBSim是一个开源跨平台的飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。 它也可以从一个小型独立程序调用，以创建批处理模拟工具。 JSBSim是用C ++编写的，使用XML配
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="计算机仿真" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>FlightGear飞行模拟器中创建新飞机的方法</title>
    <link href="https://huangwang.github.io/2019/03/17/FlightGear%E9%A3%9E%E8%A1%8C%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%B0%E9%A3%9E%E6%9C%BA%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://huangwang.github.io/2019/03/17/FlightGear飞行模拟器中创建新飞机的方法/</id>
    <published>2019-03-17T14:24:54.000Z</published>
    <updated>2019-03-18T14:34:48.788Z</updated>
    
    <content type="html"><![CDATA[<p>FlightGear中创建新飞机粗略地分成四步：创建飞机的3D模型，创建飞机的飞行动力学模型，创建飞机操作动画，实现飞机各子系统。具体而言，又可分成两个主要的开发领域：飞行动力学模型开发和飞机3D模型开发。</p><h1 id="飞机3D模型开发"><a href="#飞机3D模型开发" class="headerlink" title="飞机3D模型开发"></a>飞机3D模型开发</h1><p>主要包括飞机外形、驾驶舱的3D模型开发，为飞行动力学模型设计的动画，声音等。</p><h2 id="加载飞机模型"><a href="#加载飞机模型" class="headerlink" title="加载飞机模型"></a>加载飞机模型</h2><p>通过OpenSceneGraph，FlightGear支持许多不同的3D文件格式，包括VRML1，AC3D，DXF等等。 但是，.ac是大多数FG模型中使用的标准。</p><p>主FlightGear属性树中的属性/ sim / model / path控制将加载的模型; 它需要一个字符串值，从$ FG ROOT给出模型的相对路径。</p><p>加载新模型的最简单方法是使用—prop：命令行选项在启动时设置属性; 例如，要使用已安装在$ FG_ROOT / Models / my-cessna.ac中的3D飞机模型，您可以像这样调用FlightGear（在类Unix系统下）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgfs --prop:/sim/model/path=Models/my-cessna.ac</span><br></pre></td></tr></table></figure><p>（注意：通常模型使用的所有纹理必须出现在同一目录中。如果my-cessna.ac使用纹理cessna01.rgb和cessna02.rgb，你还应该在$ FG_ROOT / Models /中安装这些纹理。</p><p>如果要将3D模型永久设置为飞机的默认值而不是在命令行上指定，则需要编辑飞机设置文件。 在$ FG_ROOT / Aircraft /目录中有一系列以-set.xml结尾的文件，例如c172-set.xml，dc3-yasim-set.xml和beech99-uiuc-set.xml。 当您使用—aircraft选项启动FlightGear时，它会从其中一个文件中读取属性; 例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgfs --aircraft=dc3-yasim</span><br></pre></td></tr></table></figure><p>将$ FG_ROOT / Aircraft / dc3-yasim-set.xml中的属性加载到主FlightGear属性树中。 这些文件与$ FG_ROOT / preferences.xml和FlightGear保存文件具有相同的XML属性列表格式。 对于任何单机类型，可能有许多具有不同启动条件，声音，面板，3D模型等的XML文件，因此您最好复制现有的，重命名它，然后更改模型内部路径元素内的值SIM卡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;PropertyList&gt;</span><br><span class="line">&lt;sim&gt;</span><br><span class="line"> &lt;model&gt;</span><br><span class="line">  &lt;path&gt;Models/my-cessna.ac&lt;/path&gt;</span><br><span class="line">  &lt;texture-path&gt;./Textures&lt;/texture-path&gt;</span><br><span class="line"> &lt;/model&gt;</span><br><span class="line">&lt;/sim&gt;</span><br><span class="line">&lt;/PropertyList&gt;</span><br></pre></td></tr></table></figure><h1 id="飞机动力学模型开发"><a href="#飞机动力学模型开发" class="headerlink" title="飞机动力学模型开发"></a>飞机动力学模型开发</h1><p>FlightGear主要使用JSBSim 和 YASim两个开源的飞行动力学模型，也有极少数使用UIUC飞行动力学模型。</p><h2 id="YASim"><a href="#YASim" class="headerlink" title="YASim"></a>YASim</h2><p>FDM是控制模拟器内飞行物理的数学模型。 物理3D飞机模型与飞行动力学无关 - 实质上它只是一张要看的图片。 这是FDM决定模型如何飞行。</p><p>为何选择YASim？ YASim使用飞机的几何形状来生成基本飞行特征。 虽然这表明了一种“现实的”或开箱即用的方法，但在获得接近现实主义的结果之前，这只是一种粗略的近似，需要进行大量的调整。 如果您的飞机有稳定的飞行数据，例如风洞数据，或者您希望最终生成超逼真的模拟，那么JSBSim可能是更好的方法。 如果你缺乏这样的数据但是知道飞机的几何形状并且能够获得与真实飞行员相同的飞行特性和限制，那么YASim可以提供足以满足大多数模拟需求的解决方案。</p><h2 id="JSBSim"><a href="#JSBSim" class="headerlink" title="JSBSim"></a>JSBSim</h2><p>JSBSim是一个开源飞行动力学模型（FDM）软件库，用于模拟航空航天飞行器的飞行动力学。 该库已被纳入飞行模拟软件包FlightGear和OpenEaagles。 它也可以从一个小型独立程序调用，以创建批处理模拟工具。 JSBSim自1996年以来一直在开发和使用，并且已经构建在当今使用的所有最流行的平台上，包括运行Linux，Macintosh和Microsoft Windows操作系统的平台。 JSBSim是用C ++编写的，使用XML配置文件。</p><h1 id="飞机模型开发规范说明"><a href="#飞机模型开发规范说明" class="headerlink" title="飞机模型开发规范说明"></a>飞机模型开发规范说明</h1><h2 id="规则和指导"><a href="#规则和指导" class="headerlink" title="规则和指导"></a>规则和指导</h2><ul><li><p>FlightGear中的所有图像的大小应为2的幂（例如64 <em> 64,128 </em> 256或16 * 1024）。大多数计算机无法处理大于4096像素的纹理。从FlightGear 1.9开始，图像不再需要以.rgb格式保存。现在.png是FlightGear开发人员中最常用的.png。</p></li><li><p>请注意，我们在代码中使用空格，一些开发人员使用相应的选项卡，以使我们的代码易于（呃）阅读。每一行开始一个新标签，我们按空格键一次，这样你就可以得到一种楼梯。只要您在所有文件中始终如一地使用它，使用何种方法并不重要。但是JSBSim FDM使用的XML文件必须使用空格而不是制表符。</p></li><li><p>在大多数操作系统上，文件名和目录区分大小写。 Windows不区分大小写，因此当您在Windows计算机上进行开发时，您不会发现任何问题。在其他操作系统上，“波音”和“波音”之间存在差异。由于FlightGear用于多个平台，请确保您的代码正确使用大写字母！</p></li></ul><h2 id="目录结构说明"><a href="#目录结构说明" class="headerlink" title="目录结构说明"></a>目录结构说明</h2><p>创建一个新的飞机模型，应该在$FG_ROOT/Aircraft/路径下创建文件夹，以飞机名称命名。例如在$FG_ROOT/Aircraft/路径下创建一个Su30的文件夹，开始构建Su30飞机模型。在飞机根目录下，其目录结构如下：</p><ul><li>-set.xml file</li></ul><p>描述飞机依赖关系的最重要文件是aircraft-set.xml文件。</p><ul><li>.xml file (FDM)</li></ul><p>该文件包含飞机的整个（或部分）飞行动力学模型。有YASim、JSBSim、UIUC三种不同的飞行动力学模型，他们都有自己的优缺点。</p><p>由于数据有限，YASim通常被认为是最好的方式。 当您访问真实的风洞数据和/或需要更多灵活性时，JSBSim可能是更好的选择。</p><ul><li>Engines/ directory</li></ul><p>仅适用于JSBSim飞机。 在此目录中，存储引擎和推进器/螺旋桨文件。</p><ul><li>Models/ directory</li></ul><p>该目录包含所有与模型相关的文件; 例如纹理，模型和动画文件（.xml）。 在-set.xml文件中，我们将路径设置为一个.xml文件。 该文件应链接（间接）到飞机所需的每个其他模型文件（包括可能的3D驾驶舱）。 整个飞机可以建模为一个文件，但大多数开发人员更喜欢拆分。 例如，驾驶舱可以由几个文件构建，每个文件只存在一个仪器或面板。 这样很容易（重新）移动飞机的某些部件。 您可以像这样设置模型文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;PropertyList&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;path&gt;Aircraft.ac&lt;/path&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;model&gt;</span><br><span class="line">  &lt;name&gt;Cockpit&lt;/name&gt;</span><br><span class="line">  &lt;path&gt;Aircraft/.../Models/cockpit.xml&lt;/path&gt;</span><br><span class="line">  &lt;offsets&gt;</span><br><span class="line">   &lt;x-m&gt; -5.25&lt;/x-m&gt;</span><br><span class="line">   &lt;y-m&gt;  0.00&lt;/y-m&gt;</span><br><span class="line">   &lt;z-m&gt;  1.30&lt;/z-m&gt;</span><br><span class="line">  &lt;/offsets&gt;</span><br><span class="line"> &lt;/model&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;animation&gt;</span><br><span class="line">  &lt;type&gt;rotate&lt;/type&gt;</span><br><span class="line">  &lt;object-name&gt;AileronLeft&lt;/object-name&gt;</span><br><span class="line">  &lt;property&gt;/controls/flight/aileron&lt;/property&gt;</span><br><span class="line">  &lt;factor&gt;-65&lt;/factor&gt;</span><br><span class="line">  &lt;center&gt;</span><br><span class="line">   &lt;x-m&gt; 2.09&lt;/x-m&gt;</span><br><span class="line">   &lt;y-m&gt;-5.50&lt;/y-m&gt;</span><br><span class="line">   &lt;z-m&gt;-1.50&lt;/z-m&gt;</span><br><span class="line">  &lt;/center&gt;</span><br><span class="line">  &lt;axis&gt;</span><br><span class="line">   &lt;x&gt;1&lt;/x&gt;</span><br><span class="line">   &lt;y&gt;0&lt;/y&gt;</span><br><span class="line">   &lt;z&gt;0&lt;/z&gt;</span><br><span class="line">  &lt;/axis&gt;</span><br><span class="line"> &lt;/animation&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;/PropertyList&gt;</span><br></pre></td></tr></table></figure><p>cockpit.xml文件可以包含相似结构，所有工具都是单独的模型。 模型的数量不受限制，动画的数量也不限。</p><ul><li>Nasal/ directory</li></ul><p>所有针对飞机的Nasal脚本都放在此目录中，但某些系统或仪器特定的Nasal脚本除外。 如果某个Nasal脚本对所有飞机都有用（例如天气或多人相关），它可以放在$ FG_ROOT / Nasal目录中。 可以在$ FG_ROOT / Aircraft / Generic目录中找到可在多架飞机上使用的Nasal脚本（例如空中加油）。</p><ul><li>Sounds/ directory</li></ul><p>声音对于增加你实际进入模拟的感觉非常重要。 在此目录中，存储了特定于飞行器的所有声音文件。 可以在多个飞机上使用的声音（例如，点击开关或雷声）可在$ FG_ROOT / Sounds目录中找到。</p><ul><li>Tutorials/ directory</li></ul><p>FlightGears教程系统是学习如何启动飞机引擎等的有用功能。 它允许您创建一个分步教程，指导用户完成某个过程。 它甚至可以指示应按下哪些开关！</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://wiki.flightgear.org/Howto:Make_an_aircraft" target="_blank" rel="noopener">Howto:Make an aircraft</a>,by flightgear home.</li><li><a href="http://wiki.flightgear.org/Howto:3D_Aircraft_Models" target="_blank" rel="noopener">Howto:3D Aircraft Models</a>,by flightgear home.</li><li><a href="http://wiki.flightgear.org/Howto:Animate_models" target="_blank" rel="noopener">Howto:Animate models</a>,by flightgear home.</li><li><a href="http://wiki.flightgear.org/YASim" target="_blank" rel="noopener">YASim</a>,by flightgear home.</li><li><a href="http://wiki.flightgear.org/JSBSim" target="_blank" rel="noopener">JSBSim</a>,by flightgear home.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FlightGear中创建新飞机粗略地分成四步：创建飞机的3D模型，创建飞机的飞行动力学模型，创建飞机操作动画，实现飞机各子系统。具体而言，又可分成两个主要的开发领域：飞行动力学模型开发和飞机3D模型开发。&lt;/p&gt;
&lt;h1 id=&quot;飞机3D模型开发&quot;&gt;&lt;a href=&quot;#飞
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="3D" scheme="https://huangwang.github.io/tags/3D/"/>
    
      <category term="计算机仿真" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>FlightGear安装飞机和场景的方法</title>
    <link href="https://huangwang.github.io/2019/03/13/FlightGear%E5%AE%89%E8%A3%85%E9%A3%9E%E6%9C%BA%E5%92%8C%E5%9C%BA%E6%99%AF%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://huangwang.github.io/2019/03/13/FlightGear安装飞机和场景的方法/</id>
    <published>2019-03-13T00:21:13.000Z</published>
    <updated>2019-03-13T09:56:42.301Z</updated>
    
    <content type="html"><![CDATA[<p>FlightGear可安装额外的飞行器和地景。</p><h1 id="安装地景"><a href="#安装地景" class="headerlink" title="安装地景"></a>安装地景</h1><p>FlightGear的详细地景可以覆盖整个世界。默认的FlightGear安装包只包括旧金山周边一小块区域，因此想要飞到其他地方，得下载额外的地景。</p><p>每一块地景被打包成一个压缩包，每经纬度10度为一块。每一个压缩包以10×10经纬度命名，如w130n50.tgz。</p><p>下载FlightGear地景参考链接1。下载后的地景复制到$FG_ROOT/Scenery或者$FG_SCENERY下。</p><p>使用如下命令解压地景，将在$FG_ROOT/Scenery产生Objects和Terrain两个文件夹，分别为卫星地图和地形数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $FG_ROOT/Scenery</span><br><span class="line">tar -xvf e110n30.tgz</span><br><span class="line">rm e110n30.tgz</span><br></pre></td></tr></table></figure></p><h1 id="安装飞行器"><a href="#安装飞行器" class="headerlink" title="安装飞行器"></a>安装飞行器</h1><p>默认的FlightGear安装包只有少数几个飞行器，可以从参考链接2中获得大量的飞行器。</p><p>下载的飞行器复制到$FG_ROOT/Aircraft文件夹下。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://home.flightgear.org/download/scenery/" target="_blank" rel="noopener">下载FlightGear地景</a>， by flightgear.</li><li><a href="http://home.flightgear.org/download/download-aircraft/" target="_blank" rel="noopener">下载FlightGear飞行器</a>, by flightgear.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FlightGear可安装额外的飞行器和地景。&lt;/p&gt;
&lt;h1 id=&quot;安装地景&quot;&gt;&lt;a href=&quot;#安装地景&quot; class=&quot;headerlink&quot; title=&quot;安装地景&quot;&gt;&lt;/a&gt;安装地景&lt;/h1&gt;&lt;p&gt;FlightGear的详细地景可以覆盖整个世界。默认的Flig
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="3D" scheme="https://huangwang.github.io/tags/3D/"/>
    
      <category term="计算机仿真" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫获取网页链接</title>
    <link href="https://huangwang.github.io/2019/03/13/Python%E7%88%AC%E8%99%AB%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5/"/>
    <id>https://huangwang.github.io/2019/03/13/Python爬虫获取网页链接/</id>
    <published>2019-03-13T00:20:11.000Z</published>
    <updated>2019-03-13T10:18:02.888Z</updated>
    
    <content type="html"><![CDATA[<p>最近研究开源飞行模拟器，想将其世界地景全部下载下来。一个个手动下载太麻烦，于是想先用python的requests和Beautiful Soup组件获取地景链接，再以每行一个地景链接写入文本文档，最后使用axel多线程自动下载每一个地景包。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="requests组件"><a href="#requests组件" class="headerlink" title="requests组件"></a>requests组件</h2><p>Requests是一个Python HTTP库，在Apache 2许可证下发布。该项目的目标是使HTTP请求更简单，更人性化。</p><p>下面是示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import requests</span><br><span class="line">&gt;&gt;&gt; r = requests.get(&apos;https://api.github.com/user&apos;, auth=(&apos;user&apos;, &apos;pass&apos;))</span><br><span class="line">&gt;&gt;&gt; r.status_code</span><br><span class="line">200</span><br><span class="line">&gt;&gt;&gt; r.headers[&apos;content-type&apos;]</span><br><span class="line">&apos;application/json; charset=utf8&apos;</span><br><span class="line">&gt;&gt;&gt; r.encoding</span><br><span class="line">&apos;utf-8&apos;</span><br><span class="line">&gt;&gt;&gt; r.text # doctest: +ELLIPSIS</span><br><span class="line">u&apos;&#123;&quot;type&quot;:&quot;User&quot;...&apos;</span><br><span class="line">&gt;&gt;&gt; r.json() # doctest: +ELLIPSIS</span><br><span class="line">&#123;u&apos;private_gists&apos;: 419, u&apos;total_private_repos&apos;: 77, ...&#125;</span><br></pre></td></tr></table></figure><h2 id="Beautiful-Soup组件"><a href="#Beautiful-Soup组件" class="headerlink" title="Beautiful Soup组件"></a>Beautiful Soup组件</h2><p>Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库。它能够通过你喜欢的转换器实现惯用的文档导航，查找，修改文档的方式。Beautiful Soup会帮你节省数小时甚至数天的工作时间。</p><p>Beautiful Soup支持Python标准库中的HTML解析器，还支持一些第三方的解析器，其中一个是 lxml。</p><p>Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment。</p><ul><li>Tag 对象与XML或HTML原生文档中的tag相同，有最重要的属性: name和attributes。</li><li>BeautifulSoup 对象表示的是一个文档的全部内容，但并不是真正的HTML或XML的tag，所以它没有name和attribute属性。</li><li>Beautiful Soup用 NavigableString 类来包装tag中的字符串。</li><li>Comment 对象是一个特殊类型的 NavigableString 对象:</li></ul><p>下面是BeautifulSoup的一个简单示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html_doc)</span><br><span class="line"></span><br><span class="line">print(soup.prettify())</span><br><span class="line"># &lt;html&gt;</span><br><span class="line">#  &lt;head&gt;</span><br><span class="line">#   &lt;title&gt;</span><br><span class="line">#    The Dormouse&apos;s story</span><br><span class="line">#   &lt;/title&gt;</span><br><span class="line">#  &lt;/head&gt;</span><br><span class="line">#  &lt;body&gt;</span><br><span class="line">#   &lt;p class=&quot;title&quot;&gt;</span><br><span class="line">#    &lt;b&gt;</span><br><span class="line">#     The Dormouse&apos;s story</span><br><span class="line">#    &lt;/b&gt;</span><br><span class="line">#   &lt;/p&gt;</span><br><span class="line">#   &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">#    Once upon a time there were three little sisters; and their names were</span><br><span class="line">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;</span><br><span class="line">#     Elsie</span><br><span class="line">#    &lt;/a&gt;</span><br><span class="line">#    ,</span><br><span class="line">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;</span><br><span class="line">#     Lacie</span><br><span class="line">#    &lt;/a&gt;</span><br><span class="line">#    and</span><br><span class="line">#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link2&quot;&gt;</span><br><span class="line">#     Tillie</span><br><span class="line">#    &lt;/a&gt;</span><br><span class="line">#    ; and they lived at the bottom of a well.</span><br><span class="line">#   &lt;/p&gt;</span><br><span class="line">#   &lt;p class=&quot;story&quot;&gt;</span><br><span class="line">#    ...</span><br><span class="line">#   &lt;/p&gt;</span><br><span class="line">#  &lt;/body&gt;</span><br><span class="line"># &lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="axel工具"><a href="#axel工具" class="headerlink" title="axel工具"></a>axel工具</h2><p>axel是Linux下一个不错的HTTP/ftp高速下载工具。支持多线程下载、断点续传，且可以从多个地址或者从一个地址的多个连接来下载同一个文件。适合网速不给力时多线程下载提高下载速度。</p><p>axel语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axel [options] url1 [url2] [url...]</span><br></pre></td></tr></table></figure></p><p>axel选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--max-speed=x , -s x         最高速度x</span><br><span class="line">--num-connections=x , -n x   连接数x</span><br><span class="line">--output=f , -o f            下载为本地文件f</span><br><span class="line">--search[=x] , -S [x]        搜索镜像</span><br><span class="line">--header=x , -H x            添加头文件字符串x（指定 HTTP header）</span><br><span class="line">--user-agent=x , -U x        设置用户代理（指定 HTTP user agent）</span><br><span class="line">--no-proxy ， -N             不使用代理服务器</span><br><span class="line">--quiet ， -q                静默模式</span><br><span class="line">--verbose ，-v               更多状态信息</span><br><span class="line">--alternate ， -a            Alternate progress indicator</span><br><span class="line">--help ，-h                  帮助</span><br><span class="line">--version ，-V               版本信息</span><br></pre></td></tr></table></figure></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="获取地景链接"><a href="#获取地景链接" class="headerlink" title="获取地景链接"></a>获取地景链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line"># 下载指定URI链接</span><br><span class="line">def getUriContent(uri):</span><br><span class="line">    try:</span><br><span class="line">        fgWorldScenery = requests.get(link, timeout=10)</span><br><span class="line">    except requests.exceptions.HTTPError as errh:</span><br><span class="line">        print (&quot;Http Error:&quot;,errh)</span><br><span class="line">    except requests.exceptions.ConnectionError as errc:</span><br><span class="line">        print (&quot;Error Connecting:&quot;,errc)</span><br><span class="line">    except requests.exceptions.Timeout as errt:</span><br><span class="line">        print (&quot;Timeout Error:&quot;,errt)  </span><br><span class="line">    except requests.exceptions.RequestException as err:</span><br><span class="line">        print (&quot;OOps: Something Else&quot;,err)</span><br><span class="line">    else:    </span><br><span class="line">        print(&quot;Http Request Success!&quot;)</span><br><span class="line">        return fgWorldScenery.text</span><br><span class="line"></span><br><span class="line"># 获取所有地景链接，存入列表</span><br><span class="line">def getTargetLinks(html):</span><br><span class="line">    soup = BeautifulSoup(html)</span><br><span class="line">    list=[]</span><br><span class="line">    #print(soup.prettify())</span><br><span class="line">    for child in soup.find_all(&apos;area&apos;):</span><br><span class="line">        list.append(child[&apos;href&apos;])</span><br><span class="line">    print(&quot;Get Target Links Success!&quot;)</span><br><span class="line">    return list</span><br><span class="line"></span><br><span class="line"># 将地景链接逐行写入文件</span><br><span class="line">def writeToFile(linkList):</span><br><span class="line">    file = open(&apos;./sceneLink.txt&apos;,&apos;w&apos;)</span><br><span class="line">    for link in linkList:</span><br><span class="line">        file.write(link)</span><br><span class="line">        file.write(&apos;\t\n&apos;)</span><br><span class="line">    print(&quot;Write Target Link To File Success!&quot;)</span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    link = &quot;http://www.flightgear.org/legacy-Downloads/scenery-v2.12.html&quot;</span><br><span class="line">    html=getUriContent(link)</span><br><span class="line">    linkList=getTargetLinks(html)</span><br><span class="line">    writeToFile(linkList)</span><br></pre></td></tr></table></figure><h2 id="下载世界地景"><a href="#下载世界地景" class="headerlink" title="下载世界地景"></a>下载世界地景</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for line in $(cat sceneLink.txt)</span><br><span class="line">do </span><br><span class="line">    axel -n 10 $line</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">requests快速上手</a>,by requests.</li><li><a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">Python 基础教程</a>, by runoob.</li><li><a href="http://codingpy.com/article/guido-shows-how-to-write-main-function/" target="_blank" rel="noopener">Python之父教你写main()函数</a>,by 编程派.</li><li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">Beautiful Soup 4.2.0 文档</a>,by BeautifulSoup.</li><li><a href="https://huangwang.github.io/2019/03/13/FlightGear安装飞机和场景的方法/">FlightGear安装飞机和场景的方法</a>,by jack huang.</li><li><a href="http://man.linuxde.net/axel" target="_blank" rel="noopener">axel命令</a>,by Linux命令大全.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近研究开源飞行模拟器，想将其世界地景全部下载下来。一个个手动下载太麻烦，于是想先用python的requests和Beautiful Soup组件获取地景链接，再以每行一个地景链接写入文本文档，最后使用axel多线程自动下载每一个地景包。&lt;/p&gt;
&lt;h1 id=&quot;基础知识
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="python" scheme="https://huangwang.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Git_Clone大项目超过1G失败解决方案</title>
    <link href="https://huangwang.github.io/2019/03/09/Git-Clone%E5%A4%A7%E9%A1%B9%E7%9B%AE%E8%B6%85%E8%BF%871G%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://huangwang.github.io/2019/03/09/Git-Clone大项目超过1G失败解决方案/</id>
    <published>2019-03-09T00:59:46.000Z</published>
    <updated>2019-03-09T12:19:21.799Z</updated>
    
    <content type="html"><![CDATA[<p>SourceForge.net，又称SF.net，是开源软件的开发者进行开发管理的集中式场所，也是全球最大开源软件开发平台和仓库。FlightGear的源代码就托管在该平台。最近在使用Git克隆FlightGear的子项目fgdata时，老是到1G时失败。具体情况如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># git clone fgdata大项目时超过1G就会出错</span><br><span class="line">$ git clone https://git.code.sf.net/p/flightgear/fgdata</span><br><span class="line">Cloning into &apos;fgdata&apos;...</span><br><span class="line">remote: Counting objects: 61455, done.</span><br><span class="line">remote: Compressing objects: 100% (27321/27321), done.</span><br><span class="line">error: RPC failed; curl 56 GnuTLS recv error (-110): The TLS connection was non-properly terminated.</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br><span class="line">fatal: early EOF</span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure><p>经多种方案尝试，使用如下方法可避免该问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git://git.code.sf.net/p/flightgear/fgdata</span><br></pre></td></tr></table></figure></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://forum.flightgear.org/viewtopic.php?f=20&amp;t=33620&amp;p=329768&amp;hilit=clone+fgdata+fail#p329768" target="_blank" rel="noopener">FGdata downloading error</a>,by flightgear forum.</li><li><a href="https://sourceforge.net/p/forge/documentation/Git/#anonymous-access-read-only" target="_blank" rel="noopener">SourceForge Support</a>,by sourceforge.</li><li><a href="https://www.aneasystone.com/archives/2015/08/git-clone-faster.html" target="_blank" rel="noopener">git clone 太慢怎么办？</a>, by aneasystone.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SourceForge.net，又称SF.net，是开源软件的开发者进行开发管理的集中式场所，也是全球最大开源软件开发平台和仓库。FlightGear的源代码就托管在该平台。最近在使用Git克隆FlightGear的子项目fgdata时，老是到1G时失败。具体情况如下：&lt;/
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="git" scheme="https://huangwang.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Flightgear在Linux/Debian中的下载编译安装教程</title>
    <link href="https://huangwang.github.io/2019/03/08/Flightgear%E5%9C%A8Linux-Debian%E4%B8%AD%E7%9A%84%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>https://huangwang.github.io/2019/03/08/Flightgear在Linux-Debian中的下载编译安装教程/</id>
    <published>2019-03-08T02:29:59.000Z</published>
    <updated>2019-03-13T07:50:03.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><p>使用如下脚本在Linux/Debian操作系统下从源代码构建开源飞行模拟器FlightGear.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd  &lt;your working directory for building FlightGear&gt;</span><br><span class="line">wget -O download_and_compile.sh  http://sourceforge.net/p/flightgear/fgmeta/ci/next/tree/download_and_compile.sh?format=raw</span><br><span class="line">chmod +x download_and_compile.sh</span><br><span class="line">mkdir -p stable</span><br><span class="line">mkdir -p next</span><br><span class="line">cd stable</span><br><span class="line">../download_and_compile.sh -s</span><br><span class="line">cd ../next</span><br><span class="line">../download_and_compile.sh -p n</span><br></pre></td></tr></table></figure></p><p>需要注意的是，该脚本git clone fgdata时超过1G时就会报错退出，解决方案见链接4。</p><p>此外，如果之前安装过FlightGear的旧版本，编译过程也有可能报错，清理之前旧版本之后即可解决问题。</p><h1 id="启动模拟器"><a href="#启动模拟器" class="headerlink" title="启动模拟器"></a>启动模拟器</h1><p>启动FlightGear命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;your working directory for building FlightGear&gt;</span><br><span class="line">cd stable</span><br><span class="line">./run_fgfs.sh</span><br></pre></td></tr></table></figure></p><h1 id="fgfs常用选项"><a href="#fgfs常用选项" class="headerlink" title="fgfs常用选项"></a>fgfs常用选项</h1><p>fgfs为flightgear的飞行模拟器主程序，在命令行中输入fgfs —launcher即可打开启动器，选择飞机、位置等配置，然后开始模拟飞行。下面介绍fgfs的一些常用选项。</p><ul><li><p>—launcher</p><p>  打开启动器。</p></li><li><p>—fg-root=path</p><p>  告诉flightgear到path下寻找数据文件，如飞机、地景等。</p></li><li><p>—fg-scenery=path</p><p>  告诉flightgear到path下寻找地景文件。</p></li><li><p>—fg-aircraft=path</p><p>  告诉flightgear到path下寻找飞机文件。</p></li><li><p>—language=code</p><p>  指定会话语音， 例如 pl, nl, it, fr, en, de。</p></li><li><p>—aircraft= 飞行器</p><p>  载入特定飞行器。</p></li><li><p>—show-aircraft</p><p>  打印可用的飞行器列表。</p></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://wiki.flightgear.org/Howto:Get_Local_Copies_of_Flightgear_Source_Code" target="_blank" rel="noopener">Howto:Get Local Copies of Flightgear Source Code</a>,by flightgear wiki.</li><li><a href="http://wiki.flightgear.org/Scripted_Compilation_on_Linux_Debian/Ubuntu" target="_blank" rel="noopener">Scripted Compilation on Linux Debian/Ubuntu</a>, by flightgear wiki.</li><li><a href="http://wiki.flightgear.org/Building_FlightGear" target="_blank" rel="noopener">Building FlightGear</a>,by flightgear wiki.</li><li><a href="https://huangwang.github.io/2019/03/09/Git-Clone大项目超过1G失败解决方案/">Git_Clone大项目超过1G失败解决方案</a>,by jack huang.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编译安装&quot;&gt;&lt;a href=&quot;#编译安装&quot; class=&quot;headerlink&quot; title=&quot;编译安装&quot;&gt;&lt;/a&gt;编译安装&lt;/h1&gt;&lt;p&gt;使用如下脚本在Linux/Debian操作系统下从源代码构建开源飞行模拟器FlightGear.&lt;br&gt;&lt;figure cl
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="3D" scheme="https://huangwang.github.io/tags/3D/"/>
    
      <category term="计算机仿真" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%BF%E7%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>博弈论简介</title>
    <link href="https://huangwang.github.io/2019/02/26/%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%AE%80%E4%BB%8B/"/>
    <id>https://huangwang.github.io/2019/02/26/博弈论简介/</id>
    <published>2019-02-26T02:37:31.000Z</published>
    <updated>2019-02-26T04:35:57.635Z</updated>
    
    <content type="html"><![CDATA[<p>博弈论（英语：game theory），又译为对策论，经济学的一个分支，1944年冯·诺伊曼与奥斯卡·摩根斯特恩合著《博弈论与经济行为》，标志着现代系统博弈理论的的初步形成，因此他被称为“博弈论之父”。博弈论被认为是20世纪经济学最伟大的成果之一。目前在生物学、经济学、国际关系、计算机科学、政治学、军事战略和其他很多学科都有广泛的应用。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。表面上不同的相互作用可能表现出相似的激励结构（incentive structure），所以它们是同一个游戏的特例。其中一个有名有趣的应用例子是囚徒困境。</p><p>具有竞争或对抗性质的行为称为博弈行为。在这类行为中，参加斗争或竞争的各方各自具有不同的目标或利益。为了达到各自的目标和利益，各方必须考虑对手的各种可能的行动方案，并力图选取对自己最为有利或最为合理的方案。比如日常生活中的下棋，打牌等。博弈论就是研究博弈行为中斗争各方是否存在着最合理的行为方案，以及如何找到这个合理的行为方案的数学理论和方法。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p></p><p align="center">    <img src="images/game_theory.png" width="100%" alt="博弈论知识结构"></p><p></p><center>图1 博弈论知识结构</center><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><ul><li><p>局中人（players）：在一场竞赛或博弈中，每一个有决策权的参与者成为一个局中人。只有两个局中人的博弈现象称为“两人博弈”，而多于两个局中人的博弈称为 “多人博弈”。</p></li><li><p>策略（strategies）：一局博弈中，每个局中人都有选择实际可行的完整的行动方案，即方案不是某阶段的行动方案，而是指导整个行动的一个方案，一个局中人的一个可行的自始至终全局筹划的一个行动方案，称为这个局中人的一个策略。如果在一个博弈中局中人都总共有有限个策略，则称为“有限博弈”，否则称为“无限博弈”。</p></li><li><p>得失（payoffs）：一局博弈结局时的结果称为得失。每个局中人在一局博弈结束时的得失，不仅与该局中人自身所选择的策略有关，而且与全局中人所取定的一组策略有关。所以，一局博弈结束时每个局中人的“得失”是全体局中人所取定的一组策略的函数，通常称为支付（payoff）函数。</p></li><li><p>次序（orders）：各博弈方的决策有先后之分，且一个博弈方要作不止一次的决策选择，就出现了次序问题；其他要素相同次序不同，博弈就不同。</p></li><li><p>博弈涉及到均衡：均衡是平衡的意思，在经济学中，均衡意即相关量处于稳定值。在供求关系中，某一商品市场如果在某一价格下，想以此价格买此商品的人均能买到，而想卖的人均能卖出，此时我们就说，该商品的供求达到了均衡。所谓纳什均衡，它是一稳定的博弈结果。</p></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zh.wikipedia.org/wiki/博弈论" target="_blank" rel="noopener">博弈论</a>,by wikipedia.</li><li><a href="https://wiki.mbalib.com/wiki/博弈论" target="_blank" rel="noopener">博弈论</a>, by 智库百科.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;博弈论（英语：game theory），又译为对策论，经济学的一个分支，1944年冯·诺伊曼与奥斯卡·摩根斯特恩合著《博弈论与经济行为》，标志着现代系统博弈理论的的初步形成，因此他被称为“博弈论之父”。博弈论被认为是20世纪经济学最伟大的成果之一。目前在生物学、经济学、国际
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="博弈论" scheme="https://huangwang.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Linux代理工具简介</title>
    <link href="https://huangwang.github.io/2019/02/23/Linux%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E7%AE%80%E4%BB%8B/"/>
    <id>https://huangwang.github.io/2019/02/23/Linux代理工具简介/</id>
    <published>2019-02-23T08:32:06.000Z</published>
    <updated>2019-02-23T08:50:58.113Z</updated>
    
    <content type="html"><![CDATA[<p>下面介绍两个Linux代理工具shadowsock和proxychains。</p><h1 id="shadowsock"><a href="#shadowsock" class="headerlink" title="shadowsock"></a>shadowsock</h1><p>Shadowsocks可以指一种基于Socks5代理方式的加密传输协议，也可以指实现这个协议的各种开发包。当前包使用Python、C、C++、C#、Go语言等编程语言开发，大部分主要实现（iOS平台的除外）采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。<strong>Shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装方法</span><br><span class="line">sudo apt-get install shadowsocks</span><br><span class="line"># 使用方法</span><br><span class="line">nohup /usr/bin/sslocal -c /etc/shadowsocks/server.json</span><br></pre></td></tr></table></figure><h1 id="proxychains"><a href="#proxychains" class="headerlink" title="proxychains"></a>proxychains</h1><p>ProxyChains是一个开源代理工具，能够强制使任何应用的TCP连接使用SOCKS4,SOCKS或者HTTP(S)代理进行连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装配置</span><br><span class="line">sudo apt install proxychains</span><br><span class="line">sudo gedit /etc/proxychains.conf</span><br><span class="line">socks5 127.0.0.1 1080</span><br><span class="line"># 使用方法</span><br><span class="line">proxychains firefoxt</span><br><span class="line">proxychains aria2c</span><br><span class="line">proxychains wget</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zh.wikipedia.org/wiki/Shadowsocks" target="_blank" rel="noopener">Shadowsocks</a>,by wikipedia.</li><li><a href="https://zh.wikipedia.org/wiki/SOCKS" target="_blank" rel="noopener">SOCKS</a>,by wikipedia.</li><li><a href="https://linux.cn/article-6836-1.html" target="_blank" rel="noopener">将 Tor socks 转换成 http 代理</a>,by linux 中国.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面介绍两个Linux代理工具shadowsock和proxychains。&lt;/p&gt;
&lt;h1 id=&quot;shadowsock&quot;&gt;&lt;a href=&quot;#shadowsock&quot; class=&quot;headerlink&quot; title=&quot;shadowsock&quot;&gt;&lt;/a&gt;shadowsock
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="linux" scheme="https://huangwang.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统的CAP理论简介</title>
    <link href="https://huangwang.github.io/2019/02/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84CAP%E7%90%86%E8%AE%BA%E7%AE%80%E4%BB%8B/"/>
    <id>https://huangwang.github.io/2019/02/17/分布式系统的CAP理论简介/</id>
    <published>2019-02-17T02:25:41.000Z</published>
    <updated>2019-02-17T13:01:50.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式系统定义"><a href="#分布式系统定义" class="headerlink" title="分布式系统定义"></a>分布式系统定义</h1><blockquote><p>分布式系统是其组件分布正在连网的计算机上，组件之间通过传递消息进行通信和动作协调的系统<sup>[1]</sup>。通过该定义可知，分布式系统具有以下重要特征：组件的并发性、缺乏全局时钟、组件故障的独立性。</p></blockquote><h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p>CAP理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p><ul><li>一致性（Consistency）</li><li>可用性（Availability）</li><li>分区容错性（Partition Tolerance）</li></ul><h2 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h2><p>在分布式系统中,是指对于一组服务器,给定一组操作,我们需要一个协议使得最后它们的结果达成一致。更详细的解释就是,当其中某个服务器收到客户端的一组指令时,它必须与其它服务器交流以保证所有的服务器都是以同样的顺序收到同样的指令,这样的话所有的服务器会产生一致的结果,看起来就像是一台机器一样。</p><p>分布式系统的一致性算法分为：</p><ul><li>弱一致性（最终一致性），例如DNS域名解析。</li><li>强一致性，例如主从同步、多数派（读/写）、Paxos、Raft（multi Paxos）、ZAB（multi Paxos）。</li></ul><h2 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h2><p>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。所以，一般我们在衡量一个系统的可用性的时候，都是通过停机时间来计算的。</p><p>通常我们描述一个系统的可用性时，我们说淘宝的系统可用性可以达到5个9，意思就是说他的可用水平是99.999%，即全年停机时间不超过 $(1-0.99999)<em>365</em>24*60 = 5.256 min$ ，这是一个极高的要求。</p><h2 id="分区容错性（Partition-Tolerance）"><a href="#分区容错性（Partition-Tolerance）" class="headerlink" title="分区容错性（Partition Tolerance）"></a>分区容错性（Partition Tolerance）</h2><p>分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</p><p>好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。</p><p>简单点说，就是在网络中断，消息丢失的情况下，系统如果还能正常工作，就是有比较好的分区容错性。</p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><ol><li>George Coulouris, Jean Dollimore， Tim Kindberg，Gordon Blair，金蓓弘，马应龙，等译. 分布式系统概念与设计[M].2013.</li><li><a href="https://zhuanlan.zhihu.com/p/49760579" target="_blank" rel="noopener">Zookeeper之分布式系统的一致性算法</a>, by 养兔子的大叔.</li><li><a href="https://zh.wikipedia.org/wiki/分布式计算" target="_blank" rel="noopener">分布式计算</a>,by wikipedia.</li><li><a href="https://www.hollischuang.com/archives/666" target="_blank" rel="noopener">分布式系统的CAP理论</a>,by HollisChuang.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式系统定义&quot;&gt;&lt;a href=&quot;#分布式系统定义&quot; class=&quot;headerlink&quot; title=&quot;分布式系统定义&quot;&gt;&lt;/a&gt;分布式系统定义&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;分布式系统是其组件分布正在连网的计算机上，组件之间通过传递消息进行通信和动
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="软件工程" scheme="https://huangwang.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>最优化算法之动态规划入门</title>
    <link href="https://huangwang.github.io/2019/02/10/%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwang.github.io/2019/02/10/最优化算法之动态规划入门/</id>
    <published>2019-02-10T15:15:14.000Z</published>
    <updated>2019-02-10T15:25:39.630Z</updated>
    
    <content type="html"><![CDATA[<p>动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划中包含三个重要子概念：</p><ul><li>最优子结构</li><li>边界</li><li>状态转移公式</li></ul><p>对有重叠子问题和最优子结构性质的问题，在建模之后，即获得其状态转移公式和边界之后，可采用下列算法求解：</p><ul><li>递归求解</li><li>备忘录算法</li><li>动态规划求解</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zh.wikipedia.org/wiki/动态规划" target="_blank" rel="noopener">动态规划</a>,by wikipedia.</li><li><a href="https://zhuanlan.zhihu.com/p/31628866" target="_blank" rel="noopener">漫画：什么是动态规划？</a>,by 程序员小灰.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。&lt;/p&gt;
&lt;p&gt;动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="机器学习" scheme="https://huangwang.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>PID控制算法原理分析</title>
    <link href="https://huangwang.github.io/2019/02/09/PID%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://huangwang.github.io/2019/02/09/PID控制算法原理分析/</id>
    <published>2019-02-09T04:02:31.000Z</published>
    <updated>2019-02-09T04:51:16.108Z</updated>
    
    <content type="html"><![CDATA[<p>最近研究深度强化学习算法，进而对控制理论感兴趣，发现了PID这个广泛使用的控制算法。大概了解记录一下。<strong>PID控制器（比例-积分-微分控制器），由比例单元(P)、积分单元(I)和微分单元(D)组成。透过Kp，Ki和Kd三个参数的设定。PID控制器主要适用于基本上线性，且动态特性不随时间变化的系统</strong>。</p><p></p><p align="center">    <img src="images/Pid-feedback-nct-int-correct.png" width="90%" alt="PID控制器的方块图"></p><p></p><center>图1  PID控制器的方块图</center><p>PID是以它的三种纠正算法而命名。受控变数是三种算法（比例、积分、微分）相加后的结果，即为其输出，其输入为误差值（设定值减去测量值后的结果）或是由误差值衍生的信号。若定义 $u(t)$为控制输出，PID算法可以用下式表示：</p><script type="math/tex; mode=display">{u}(t)= {MV}(t)=K_{p}e(t)+K_i\int _{0}^{t}{e(\tau )}{d\tau }+K_d{\frac{d}{dt}}e(t)</script><p>其中:</p><p>$K_{p}$：比例增益，是调适参数</p><p>$K_{i}$：积分增益，也是调适参数</p><p>$K_{d}$：微分增益，也是调适参数</p><p>$e$：误差=设定值（SP）- 回授值（PV）</p><p>$t$：目前时间</p><p>$\tau$ ：积分变数，数值从0到目前时间 $t$</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zh.wikipedia.org/wiki/PID控制器" target="_blank" rel="noopener">PID控制器</a>,by wikipedia.</li><li><a href="https://zhuanlan.zhihu.com/p/39573490" target="_blank" rel="noopener">PID控制算法原理（抛弃公式，从本质上真正理解PID控制）</a>,by 确定有穷自动机.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近研究深度强化学习算法，进而对控制理论感兴趣，发现了PID这个广泛使用的控制算法。大概了解记录一下。&lt;strong&gt;PID控制器（比例-积分-微分控制器），由比例单元(P)、积分单元(I)和微分单元(D)组成。透过Kp，Ki和Kd三个参数的设定。PID控制器主要适用于基本
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="控制理论" scheme="https://huangwang.github.io/tags/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统架构入门</title>
    <link href="https://huangwang.github.io/2019/02/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwang.github.io/2019/02/01/分布式系统架构入门/</id>
    <published>2019-02-01T09:59:25.000Z</published>
    <updated>2019-02-01T13:21:07.340Z</updated>
    
    <content type="html"><![CDATA[<p>随着互联网高速公路的不断发展，以往的单机应用系统逐渐没落，分布式系统逐渐成为主流。</p><h1 id="分布式系统定义"><a href="#分布式系统定义" class="headerlink" title="分布式系统定义"></a>分布式系统定义</h1><p>分布式系统是其组件分布正在连网的计算机上，组件之间通过传递消息进行通信和动作协调的系统<sup>[1]</sup>。通过该定义可知，分布式系统具有以下重要特征：组件的并发性、缺乏全局时钟、组件故障的独立性。</p><p>现代分布式系统的例子有：</p><ul><li>Web搜索</li><li>大型多人在线游戏</li><li>金融交易</li></ul><h1 id="分布式系统架构演变"><a href="#分布式系统架构演变" class="headerlink" title="分布式系统架构演变"></a>分布式系统架构演变</h1><p>大多数的开发者最开始接触的是单机系统架构，即所有的数据和程序都在一台计算机上，这是分布式系统架构演变的起点。随着用户规模的不断增长和用户需求的不断变化，分布式系统架构开始不断演变。</p><h2 id="系统架构演化历程-初始阶段架构"><a href="#系统架构演化历程-初始阶段架构" class="headerlink" title="系统架构演化历程-初始阶段架构"></a>系统架构演化历程-初始阶段架构</h2><p align="center">    <img src="images/dsa1.png" width="90%" alt="系统架构演化历程-初始阶段架构"></p><p>初始阶段的小型系统中应用程序、数据库、文件等所有的资源都在一台服务器上。随着业务量的增长，小型系统的负载将越来越重。但如果没有达到单台机器的性能瓶颈，则根本没必要进行分布式架构，可以考虑机器升级，提高机器配置解决问题。或者考虑技术升级，更换更加高效或者场景适合的技术。</p><h2 id="系统架构演化历程-应用服务和数据服务分离"><a href="#系统架构演化历程-应用服务和数据服务分离" class="headerlink" title="系统架构演化历程-应用服务和数据服务分离"></a>系统架构演化历程-应用服务和数据服务分离</h2><p align="center">    <img src="images/dsa2.png" width="90%" alt="系统架构演化历程-应用服务和数据服务分离"></p><p>数据量增加，单台服务器性能及存储空间不足，需要将应用和数据分离，并发处理能力和数据存储空间得到了很大改善。</p><h2 id="系统架构演化历程-使用缓存改善性能"><a href="#系统架构演化历程-使用缓存改善性能" class="headerlink" title="系统架构演化历程-使用缓存改善性能"></a>系统架构演化历程-使用缓存改善性能</h2><p align="center">    <img src="images/dsa3.jpg" width="90%" alt="系统架构演化历程-使用缓存改善性能"></p><p>系统访问特点遵循二八定律，即80%的业务访问集中在20%的数据上。缓存分为本地缓存和远程分布式缓存，本地缓存访问速度更快但缓存数据量有限，同时存在与应用程序争用内存的情况。</p><h2 id="系统架构演化历程-使用应用服务器集群"><a href="#系统架构演化历程-使用应用服务器集群" class="headerlink" title="系统架构演化历程-使用应用服务器集群"></a>系统架构演化历程-使用应用服务器集群</h2><p align="center">    <img src="images/dsa4.jpg" width="90%" alt="系统架构演化历程-使用应用服务器集群"></p><p>使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。</p><h2 id="系统架构演化历程-数据库读写分离"><a href="#系统架构演化历程-数据库读写分离" class="headerlink" title="系统架构演化历程-数据库读写分离"></a>系统架构演化历程-数据库读写分离</h2><p align="center">    <img src="images/dsa5.jpg" width="90%" alt="系统架构演化历程-数据库读写分离"></p><p>数据库访问通常是读多写少。针对这个情况，就是写一个主库，但是主库挂多个从库，然后从多个从库来读，以支撑更高的读并发压力。</p><h2 id="系统架构演化历程-反向代理和CDN加速"><a href="#系统架构演化历程-反向代理和CDN加速" class="headerlink" title="系统架构演化历程-反向代理和CDN加速"></a>系统架构演化历程-反向代理和CDN加速</h2><p align="center">    <img src="images/dsa6.jpg" width="90%" alt="系统架构演化历程-反向代理和CDN加速"></p><p>为了应付复杂的网络环境和不同地区用户的访问，通过CDN和反向代理加快用户访问的速度，同时减轻后端服务器的负载压力。CDN与反向代理的基本原理都是缓存。</p><h2 id="系统架构演化历程-分布式文件系统和分布式数据库"><a href="#系统架构演化历程-分布式文件系统和分布式数据库" class="headerlink" title="系统架构演化历程-分布式文件系统和分布式数据库"></a>系统架构演化历程-分布式文件系统和分布式数据库</h2><p align="center">    <img src="images/dsa7.jpg" width="90%" alt="系统架构演化历程-分布式文件系统和分布式数据库"></p><p>任何强大的单一服务器都满足不了大型系统持续增长的业务需求，数据库读写分离随着业务的发展最终也将无法满足需求，需要使用分布式数据库及分布式文件系统来支撑。分布式数据库是系统数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。</p><h2 id="系统架构演化历程-使用NoSQL和搜索引擎"><a href="#系统架构演化历程-使用NoSQL和搜索引擎" class="headerlink" title="系统架构演化历程-使用NoSQL和搜索引擎"></a>系统架构演化历程-使用NoSQL和搜索引擎</h2><p align="center">    <img src="images/dsa8.jpg" width="90%" alt="系统架构演化历程-使用NoSQL和搜索引擎"></p><p>随着业务越来越复杂，对数据存储和检索的需求也越来越复杂，系统需要采用一些非关系型数据库如NoSQL和分数据库查询技术如搜索引擎。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。</p><h2 id="系统架构演化历程-业务拆分"><a href="#系统架构演化历程-业务拆分" class="headerlink" title="系统架构演化历程-业务拆分"></a>系统架构演化历程-业务拆分</h2><p align="center">    <img src="images/dsa9.jpg" width="90%" alt="系统架构演化历程-业务拆分"></p><p>为了应对日益复杂的业务场景，通常使用分而治之的手段将整个系统业务分成不同的产品线，应用之间通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。</p><ul><li><p>纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的Web应用系统纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。</p></li><li><p>横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。</p></li></ul><h2 id="系统架构演化历程-分布式服务"><a href="#系统架构演化历程-分布式服务" class="headerlink" title="系统架构演化历程-分布式服务"></a>系统架构演化历程-分布式服务</h2><p align="center">    <img src="images/dsa10.jpg" width="90%" alt="系统架构演化历程-分布式服务"></p><h1 id="分布式服务关键技术"><a href="#分布式服务关键技术" class="headerlink" title="分布式服务关键技术"></a>分布式服务关键技术</h1><p>分布式服务应用将会面临以下问题：</p><ul><li>当服务越来越多时，服务URL配置管理变得非常困难，硬件负载均衡器的单点压力也越来越大。</li><li>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</li><li>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</li><li>服务多了，沟通成本也开始上升，调某个服务失败该找谁？服务的参数都有什么约定？ </li><li>一个服务有多个业务消费者，如何确保服务质量？</li><li>随着服务的不停升级，总有些意想不到的事发生，比如cache写错了导致内存溢出，故障不可避免，每次核心服务一挂，影响一大片，人心慌慌，如何控制故障的影响面？服务是否可以功能降级？或者资源劣化？</li></ul><p>为解决上述问题，可采用以下关键技术。</p><h2 id="消息队列架构"><a href="#消息队列架构" class="headerlink" title="消息队列架构"></a>消息队列架构</h2><p>消息对列通过消息对象分解系统耦合性，不同子系统处理同一个消息。</p><p align="center">    <img src="images/msgQueue.jpg" width="90%" alt="消息队列原理"></p><h2 id="面向服务架构"><a href="#面向服务架构" class="headerlink" title="面向服务架构"></a>面向服务架构</h2><p>服务框架通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务启用服务框架是一个点对点模型服务框架面向同构系统适合：移动应用、互联网应用、外部系统。</p><p align="center">    <img src="images/SOA.jpg" width="90%" alt="面向服务架构原理"></p><h2 id="服务总线架构"><a href="#服务总线架构" class="headerlink" title="服务总线架构"></a>服务总线架构</h2><p>服务总线架构同面向服务架构一样，均是通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务启用。服务总线架构是一个总线式的架构模型。</p><p align="center">    <img src="images/ESB.png" width="90%" alt="服务总线架构原理"></p><h1 id="分布式系统交互的通信模式"><a href="#分布式系统交互的通信模式" class="headerlink" title="分布式系统交互的通信模式"></a>分布式系统交互的通信模式</h1><p>分布式系统交互的通信模式共有五种：</p><ul><li>request/response模式（同步模式）：客户端发起请求一直阻塞到服务端返回请求为止。</li><li>Callback（异步模式）：客户端发送一个RPC请求给服务器，服务端处理后再发送一个消息给消息发送端提供的callback端点，此类情况非常合适以下场景：A组件发送RPC请求给B，B处理完成后，需要通知A组件做后续处理。</li><li>Future模式：客户端发送完请求后，继续做自己的事情，返回一个包含消息结果的Future对象。客户端需要使用返回结果时，使用Future对象的.get(),如果此时没有结果返回的话，会一直阻塞到有结果返回为止。</li><li>Oneway模式：客户端调用完继续执行，不管接收端是否成功。</li><li>Reliable模式：为保证通信可靠，将借助于消息中心来实现消息的可靠送达，请求将做持久化存储，在接收方在线时做送达，并由消息中心保证异常重试。</li></ul><h1 id="常用的分布式服务框架"><a href="#常用的分布式服务框架" class="headerlink" title="常用的分布式服务框架"></a>常用的分布式服务框架</h1><p>现在业界比较成熟的服务框架有很多，比如：Hessian、CXF、Dubbo、Dubbox、Spring Cloud、gRPC、thrift等技术实现，都可以进行远程调用。</p><ul><li>Spring Cloud：Spring全家桶，用起来很舒服，只有你想不到，没有它做不到。可惜因为发布的比较晚，国内还没出现比较成功的案例，大部分都是试水，不过毕竟有Spring作背书，还是比较看好。</li><li>Dubbox：相对于Dubbo支持了REST，估计是很多公司选择Dubbox的一个重要原因之一，但如果使用Dubbo的RPC调用方式，服务间仍然会存在API强依赖，各有利弊，懂的取舍吧。</li><li>Thrift：如果你比较高冷，完全可以基于Thrift自己搞一套抽象的自定义框架吧。</li><li>Montan：可能因为出来的比较晚，目前除了新浪微博16年初发布的，</li><li>Hessian：如果是初创公司或系统数量还没有超过5个，推荐选择这个，毕竟在开发速度、运维成本、上手难度等都是比较轻量、简单的，即使在以后迁移至SOA，也是无缝迁移。</li><li>rpcx/gRPC：在服务没有出现严重性能的问题下，或技术栈没有变更的情况下，可能一直不会引入，即使引入也只是小部分模块优化使用。</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li>George Coulouris, Jean Dollimore， Tim Kindberg，Gordon Blair，金蓓弘，马应龙，等译. 分布式系统概念与设计[M].2013.</li><li><a href="http://zhuanlan.51cto.com/art/201712/561516.htm" target="_blank" rel="noopener">聊聊分布式系统的架构套路</a>,by 大蕉.</li><li><a href="https://www.jianshu.com/p/ab35b6d74fed" target="_blank" rel="noopener">分布式架构的演进</a>,by 稳稳的幸福y.</li><li><a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">互联网 Java 工程师进阶知识完全扫盲</a>,by dooc.</li><li><a href="https://juejin.im/post/5a5ee63d518825732914748c" target="_blank" rel="noopener">聊聊Dubbo（一）：为何选择</a>, by 猿码道.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着互联网高速公路的不断发展，以往的单机应用系统逐渐没落，分布式系统逐渐成为主流。&lt;/p&gt;
&lt;h1 id=&quot;分布式系统定义&quot;&gt;&lt;a href=&quot;#分布式系统定义&quot; class=&quot;headerlink&quot; title=&quot;分布式系统定义&quot;&gt;&lt;/a&gt;分布式系统定义&lt;/h1&gt;&lt;p&gt;分
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="软件工程" scheme="https://huangwang.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>元强化学习研究笔记</title>
    <link href="https://huangwang.github.io/2019/01/27/%E5%85%83%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%A0%94%E7%A9%B6%E7%AC%94%E8%AE%B0/"/>
    <id>https://huangwang.github.io/2019/01/27/元强化学习研究笔记/</id>
    <published>2019-01-27T04:48:18.000Z</published>
    <updated>2019-01-31T12:33:49.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="元强化学习定义"><a href="#元强化学习定义" class="headerlink" title="元强化学习定义"></a>元强化学习定义</h1><p>什么是元强化学习？这得从深度学习开始说起。</p><p>Deep Learning研究一个从x到y的映射mapping，只是这个映射函数f是用一个端到端的深度神经网络来表示。如果是计算机视觉中的图像识别，那么x就是图片，y就是标签；如果是自然语言处理中的文本翻译，那么x就是比如中文，y就是英文；如果是深度增强学习中的玩Atari游戏，那么x就是屏幕画面，y就是输出的动作。<strong>深度学习研究的就是通过深度神经网络来学习一个针对某一特定任务task的模型</strong>。通过大量的样本进行训练，训练完，这个模型就可以用在特定任务上。</p><p>而<strong>Meta Learning研究Task</strong>！Meta Learning的目的是希望学习很多很多的task，然后有了这些学习经验之后，在面对新的task的时候可以游刃有余，学的快又学的好！那为什么叫Meta呢？Deep Learning是在Task里面研究，现在Meta Learning是在Task外面，更高层级来研究。也就是在Meta Learning的问题上，Task是作为样本来输入的。</p><p>Meta RL（Meta Reinforcement Learning）是Meta Learning应用到Reinforcement Learning的一个研究方向，核心的想法就是希望AI在学习大量的RL任务中获取足够的先验知识Prior Knowledge然后在面对新的RL任务时能够 学的更快，学的更好，能够自适应新环境！</p><h1 id="元强化学习意义"><a href="#元强化学习意义" class="headerlink" title="元强化学习意义"></a>元强化学习意义</h1><p>元强化学习试图解决深度强化学习存在的如下问题：</p><ul><li><strong>它的样本利用率非常低</strong>。换言之为了让模型的表现达到一定高度需要极为大量的训练样本。</li><li><strong>最终表现很多时候不够好</strong>。在很多任务上用非强化学习甚至非学习的其它方法，如基于模型的控制（model based control），线性二次型调节器（Linear Quadratic Regulator）等等可以获得好得多的表现。最气人的是这些模型很多时候样本利用率还高。当然这些模型有的时候会有一些假设比如有训练好的模型可以模仿，比如可以进行蒙特卡洛树搜索等等。</li><li><strong>DRL成功的关键离不开一个好的奖励函数（reward function），然而这种奖励函数往往很难设计</strong>。在Deep Reinforcement Learning That Matters作者提到有时候把奖励乘以一个常数模型表现就会有天和地的区别。但奖励函数的坑爹之处还不止如此。奖励函数的设计需要保证：<ul><li>加入了合适的先验，良好的定义了问题和在一切可能状态下的对应动作。坑爹的是模型很多时候会找到作弊的手段。Alex举的一个例子是有一个任务需要把红色的乐高积木放到蓝色的乐高积木上面，奖励函数的值基于红色乐高积木底部的高度而定。结果一个模型直接把红色乐高积木翻了一个底朝天。仔啊，你咋学坏了，阿爸对你很失望啊。</li><li>奖励函数的值太过稀疏。换言之大部分情况下奖励函数在一个状态返回的值都是0。这就和我们人学习也需要鼓励，学太久都没什么回报就容易气馁。都说21世纪是生物的世纪，怎么我还没感觉到呢？21世纪才刚开始呢。我等不到了啊啊啊啊啊。</li><li>有的时候在奖励函数上下太多功夫会引入新的偏见（bias）。</li><li>要找到一个大家都使用而又具有好的性质的奖励函数。这里Alex没很深入地讨论，但链接了一篇陶神（Terence Tao）的博客，大家有兴趣可以去看下。</li></ul></li><li><strong>局部最优/探索和剥削（exploration vs. exploitation）的不当应用</strong>。Alex举的一个例子是有一个连续控制的环境里，一个类似马的四足机器人在跑步，结果模型不小心多看到了马四脚朝天一顿乱踹后结果较好的情况，于是你只能看到四脚朝天的马了。</li><li><strong>对环境的过拟合</strong>。DRL少有在多个环境上玩得转的。你训练好的DQN在一个Atari game上work了，换一个可能就完全不work。即便你想要做迁移学习，也没有任何保障你能成功。</li><li><strong>不稳定性</strong>。<ul><li>读DRL论文的时候会发现有时候作者们会给出一个模型表现随着尝试random seed数量下降的图，几乎所有图里模型表现最终都会降到0。相比之下在监督学习里不同的超参数或多或少都会表现出训练带来的变化，而DRL里运气不好可能很长时间你模型表现的曲线都没有任何变化，因为完全不work。</li><li>即便知道了超参数和随机种子，你的实现只要稍有差别，模型的表现就可以千差万别。这可能就是Deep Reinforcement Learning That Matters一文里John Schulman两篇不同文章里同一个算法在同一个任务上表现截然不同的原因。</li><li>即便一切都很顺利，从我个人的经验和之前同某DRL研究人员的交流来看只要时间一长你的模型表现就可能突然从很好变成完全不work。原因我不是完全确定，可能和过拟合和variance过大有关。</li></ul></li></ul><h1 id="元强化学习方法"><a href="#元强化学习方法" class="headerlink" title="元强化学习方法"></a>元强化学习方法</h1><p>Meta RL（Meta Reinforcement Learning）是Meta Learning应用到Reinforcement Learning的一个研究方向。因此元强化学习的研究借鉴了元学习的思想和方法。</p><h2 id="元学习方法"><a href="#元学习方法" class="headerlink" title="元学习方法"></a>元学习方法</h2><h3 id="HyperNetwork-生成参数"><a href="#HyperNetwork-生成参数" class="headerlink" title="HyperNetwork 生成参数"></a>HyperNetwork 生成参数</h3><p>HyperNetwork是一个蛮有名的网络，简单说就是用一个网络来生成另外一个网络的参数。那么我们这里非常直接，我们的设想就是希望用一个hypernetwork输入训练集数据，然后给我输出我的对应模型也就是上图f的参数，我们希望输出的这个参数能够使得在测试图片上取得好的识别效果。那么，有了这样设计，这个hypernetwork其实就是一个meta network。大家可以看到，本来基本的做法是用训练集直接训练这个模型f，但是现在我们用这个hypernetwork不训练了，直接给你输出参数，这等价于hypernetwork学会了如何学习图像识别，这也是为什么meta learning也同时叫做learning to learn的原因。我们通过hypernetwork学会学习。训练好了这个模型，连反向传播梯度下降都不要了，直接给你参数，是不是很酷？</p><h3 id="Conditional-Neural-Network-条件神经网络"><a href="#Conditional-Neural-Network-条件神经网络" class="headerlink" title="Conditional Neural Network 条件神经网络"></a>Conditional Neural Network 条件神经网络</h3><p>直接把D_train当做条件输入到f中，那么这个f本身就变成一个meta network了。也就是条件神经网络实际上能够得到和上面的hypernetwork一样的意义。因为我们可以想，只要条件D_train变了，那么y_test肯定也就变了。所以这里就非常非常直接了。把数据全部输入进去，让神经网络自己学就行了，不外乎就是去设计一个合适的网络结构而已。那么，这里最最简单粗暴的网络结构就是SNAIL算法使用temporal convolutional network，也就是wavenet的架构：</p><h3 id="MAML-基于梯度的做法"><a href="#MAML-基于梯度的做法" class="headerlink" title="MAML 基于梯度的做法"></a>MAML 基于梯度的做法</h3><p>MAML的核心步骤就是</p><ul><li><p>采集Task，得到D_train和D_test</p></li><li><p>使用D_train对神经网络f训练少数几步，得到新的参数</p></li><li><p>利用新的参数训练D_test，然后使得梯度下降更新一开始的参数。</p></li></ul><h3 id="三种解决办法的优缺点"><a href="#三种解决办法的优缺点" class="headerlink" title="三种解决办法的优缺点"></a>三种解决办法的优缺点</h3><p>先说HyperNetwork生成参数的做法。这种做法最大的问题就在于参数空间是很大的，所以要生成合适的参数特别是巨量的参数其实是比较困难的，所以目前绝大多数生成参数的做法都是只生成少量参数，比如一层的MLP，或者对于参数的空间进行一定的限制，比如就在[-1,1]之间，否则空间太多，有无数种选择输出一样的结果，就很难训了。但是采样HyperNetwork又有其灵活性，意味着我们可以只更新少部分参数，而不用全部。</p><p>接下来就是条件神经网络了。这又有什么问题呢？我觉得在性能上绝对会是最好的，很直接，但是不好看，一直要拖着一个条件，网络很大。不管是生成参数还是MAML，他们的模型网络就是独立的，之后只要输入x就行了，而条件神经网络每次都要输入条件，很烦啊。</p><p>那么MAML呢？可能最烦人的就是二次梯度了，这意味着MAML的训练会很慢，那么就很难hold住大网络了。实际上MAML目前对于大的网络结构比如Resnet效果并不好。然后MAML是使用D_train的Loss来更新整个网络，对比HyperNetwork缺少灵活性。这个Loss就是最好的吗？不见得。如果D_train是无监督数据，那怎么办？所以MAML是有局限性的。</p><p>目前各种各样的Meta Learning研究，在方法论上都逃不出这三种方法。要么改改网络结构，要么结合一下上面的方法，比如先MAML再生成参数，或者hypernetwork和conditional neural network混着用等等。那么什么才是终极必杀呢？可能还是要具体问题具体看吧，对于不同的问题采用不同办法效果会不一样。这些都值得我们去探索。</p><h2 id="元强化学习方法-1"><a href="#元强化学习方法-1" class="headerlink" title="元强化学习方法"></a>元强化学习方法</h2><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/46059552" target="_blank" rel="noopener">Meta Learning单排小教学</a>,by Flood Sung.</li><li><a href="https://zhuanlan.zhihu.com/p/41223529" target="_blank" rel="noopener">最前沿: Meta RL论文解读</a>,by Flood Sung.</li><li><a href="https://zhuanlan.zhihu.com/p/33936457" target="_blank" rel="noopener">这里有一篇深度强化学习劝退文</a>,by Frankenstein.</li><li><a href="https://juejin.im/post/5ad41c826fb9a028d375ddd7" target="_blank" rel="noopener">周志华：满足这三大条件，可以考虑不用深度神经网络</a>,by 周志华教授.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;元强化学习定义&quot;&gt;&lt;a href=&quot;#元强化学习定义&quot; class=&quot;headerlink&quot; title=&quot;元强化学习定义&quot;&gt;&lt;/a&gt;元强化学习定义&lt;/h1&gt;&lt;p&gt;什么是元强化学习？这得从深度学习开始说起。&lt;/p&gt;
&lt;p&gt;Deep Learning研究一个从x到y
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="机器学习" scheme="https://huangwang.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
