<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jack Huang&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huangwang.github.io/"/>
  <updated>2019-09-20T14:04:05.527Z</updated>
  <id>https://huangwang.github.io/</id>
  
  <author>
    <name>Jack Huang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库表主键设计方法</title>
    <link href="https://huangwang.github.io/2019/09/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <id>https://huangwang.github.io/2019/09/20/数据库表主键设计方法/</id>
    <published>2019-09-20T13:17:43.000Z</published>
    <updated>2019-09-20T14:04:05.527Z</updated>
    
    <content type="html"><![CDATA[<p>数据库表主键使用自增整型字段还是使用GUID字段，这是一个问题。下面详细分析它们的优劣。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h2><ul><li><p>第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。简而言之，第一范式就是无重复的列</p></li><li><p>第二范式（2NF）：首先要满足它是1NF，另外还需要包含两部分内容：一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。简而言之，第二范式就是非主属性非部分依赖于主关键字</p></li><li><p>第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。</p></li></ul><h2 id="反范式主键的设计原则"><a href="#反范式主键的设计原则" class="headerlink" title="反范式主键的设计原则"></a>反范式主键的设计原则</h2><ul><li>主键应当是对用户没有意义的。业务上的‘主键’可以通过唯一键（Unique Key）或唯一索引（Unique Index）和其它约束条件实现</li><li>主键应该是单列的，以便提高连接和筛选操作的效率</li><li>不要更新主键。实际上，因为主键除了惟一地标识一行之外再没有其他的用途了，所以也就没有理由去对它更新。</li><li>主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等</li><li>主键应当由计算机自动生成。</li></ul><h1 id="数据库表主键设计方法"><a href="#数据库表主键设计方法" class="headerlink" title="数据库表主键设计方法"></a>数据库表主键设计方法</h1><p>数据库表主键设计主要有自增整型字段和使用GUID字段两种方法。</p><h2 id="自增整型字段作为主键"><a href="#自增整型字段作为主键" class="headerlink" title="自增整型字段作为主键"></a>自增整型字段作为主键</h2><p>最常用的主键设计方法。例如《阿里 Java 开发手册》中规定有以下 MySQL 建表规约：</p><blockquote><p>表必备三字段：id, gmt_create, gmt_modified。 说明：其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。gmt_create, gmt_modified的类型均为date_time类型。</p></blockquote><p>该方法优点是：数据库自动编号，速度快，而且是增量增长，聚集型主键按顺序存放，对于检索非常有利;数字型的，占用空间小，易排序，在程序中传递也方便;如果通过非系统增加记录(比如手动录入，或是用其他工具直接在表里插入新记录，或老系统数据导入)时，非常方便，不用担心主键重复问题。</p><p>该方法缺点是：因为自动增长，在手动要插入指定ID的记录时会显得麻烦，尤其是当系统与其他系统集成时，需要数据导入时，很难保证原系统的ID不发生主键冲突。</p><h2 id="GUID字符串作为主键"><a href="#GUID字符串作为主键" class="headerlink" title="GUID字符串作为主键"></a>GUID字符串作为主键</h2><p>Guid:指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的，其算法是通过以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字生成。其格式为:04755396-9A29-4B8C-A38D-00042C1B9028。</p><p>GUID字符串作为主键的优点如下：</p><ul><li><p>在扩展数据库的时候，当你有多个数据库包含同一段（片）数据时，比如一个顾客集，使用 GUID 意味着该 ID 在所有的数据库中是唯一标识的，而不是仅仅本数据库唯一。这保障了跨数据库迁移数据的安全。又比如，我曾在项目中把多个数据库分片合并到一个 Hadoop 集群中，也没有产生键的冲突。</p></li><li><p>在插入数据之前，你就能知道这个主键的值，这避免了一轮的数据查找，并且简化了事务的逻辑，即在你插入子记录之前，因为需要使用这个主键作为一个外键，你必须要知道这个主键的值。</p></li><li><p>GUID 不会透露数据的信息，因此被用在 URL 中也比自增整数更安全。比如，我是编号 12345678 号顾客，那么人们就会猜测编号为 12345677 和 12345679 的顾客的存在，这就提供了一种攻击向量。（但是后面我们会看到一个更好的替代品）</p></li></ul><p>GUID字符串作为主键的缺点如下：</p><ul><li>GUID 值较长，不容易记忆和输入，而且这个值是随机、无顺序的。</li><li>GUID 的值有 16 个字节，与其它那些诸如 4 字节的整数相比要相对大一些。这意味着如果在数据库中使用 uniqueidentifier 键，可能会带来两方面的消极影响：存储空间增大;索引时间较慢。</li></ul><h1 id="主流数据库中GUID实现"><a href="#主流数据库中GUID实现" class="headerlink" title="主流数据库中GUID实现"></a>主流数据库中GUID实现</h1><h2 id="MSSQL"><a href="#MSSQL" class="headerlink" title="MSSQL"></a>MSSQL</h2><p>在MS Sql 数据库中可以在建立表结构是指定字段类型为uniqueidentifier,并且其默认值可以使用NewID()来生成唯一的Guid(全局唯一标识符).</p><p>使用NewID生成的比较随机,如果是SQL 2005可以使用NewSequentialid()来顺序生成,在此为了兼顾使用SQL 2000使用了NewID().</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>MySQL中使用UUID()函数生成主键，UUID()函数将生成格式为xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)的字符串，包含32个16进制数字，以连字号分为五段。示例：550e8400-e29b-41d4-a716-446655440000。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://blog.csdn.net/kleguan/article/details/74502330" target="_blank" rel="noopener">数据库表主键设计原则</a>,by 乐哉悠哉.</li><li><a href="https://blog.csdn.net/linzhiqiang0316/article/details/52881151" target="_blank" rel="noopener">[MySQL]数据库主键设计之思考</a>,by 林老师带你学编程.</li><li><a href="http://www.nowamagic.net/librarys/veda/detail/383" target="_blank" rel="noopener">如何设计数据库的主键</a>,by Veda 原型.</li><li><a href="https://juejin.im/post/59561e5b6fb9a06bbf6fdf16" target="_blank" rel="noopener">[译] 把 UUID 或者 GUID 作为主键？你得小心啦！</a>,by zaraguo.</li><li><a href="https://blog.csdn.net/shiyong1949/article/details/78411509" target="_blank" rel="noopener">MySQL中使用UUID()函数生成主键</a>,by shiyonghm.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库表主键使用自增整型字段还是使用GUID字段，这是一个问题。下面详细分析它们的优劣。&lt;/p&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;h2 id=&quot;数据库设计
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="数据库" scheme="https://huangwang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎与物理引擎</title>
    <link href="https://huangwang.github.io/2019/09/16/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%8E%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/"/>
    <id>https://huangwang.github.io/2019/09/16/游戏引擎与物理引擎/</id>
    <published>2019-09-16T13:44:49.000Z</published>
    <updated>2019-09-17T01:21:52.374Z</updated>
    
    <content type="html"><![CDATA[<p>游戏引擎提供一系列可视化开发工具和可重用组件。这些工具通过与开发环境进行集成，方便开发者简单、快速进行数据驱动方式的游戏开发。为了提高游戏开发人员的开发效率，引擎开发者会开发出大量的游戏所需要的软件组件。大多数引擎集成了图形、声音、物理和人工智能等功能部件。游戏引擎会被称为“中间件”，因为它们可以提供灵活和重用平台，向游戏开发者提供所需要的全部核心功能，从而节省大量的游戏开发费用，降低开发的复杂性，缩短游戏的上市时间，所有这些对于高竞争性的游戏产业来说都是关键因素。诸如虚幻系列引擎、Unity3D、Frostbite Engine、zerodin引擎、Doom3引擎、CryENGINE、3DGame Studio、RenderWare、Gamebryo、Virtools以及Source引擎等引擎。</p><p>物理引擎是一个计算机程序模拟牛顿力学模型，使用质量、速度、摩擦力和空气阻力等变量。可以用来预测这种不同情况下的效果。它主要用在计算物理学和电子游戏以及计算机动画当中。物理引擎可作为游戏引擎的一个组件。</p><p>物理引擎有两种类型常见的型类：实时物理引擎和高精度物理引擎。高精度的物理引擎需要更多的处理能力来计算非常精确的物理，通常使用在科学研究（计算物理学）和计算机动画电影制作。实时物理引擎使用通常使用在电子游戏并且简化运算，降低精确度增以减少计算时间，得到在电子游戏当中可以接受的的处理速度。常用的物理引擎有：ODE、Box2D、PhysX、Bullet、Havok引擎。</p><h1 id="游戏主循环、帧速控制"><a href="#游戏主循环、帧速控制" class="headerlink" title="游戏主循环、帧速控制"></a>游戏主循环、帧速控制</h1><p>FPS(Frame Per Second)游戏帧速60帧是指游戏每秒循环更新60次。  </p><p>一个游戏程序的基本结构像是这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (isRunning)</span><br><span class="line">&#123;</span><br><span class="line">updateEverything();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="固定拖时间更新法"><a href="#固定拖时间更新法" class="headerlink" title="固定拖时间更新法"></a>固定拖时间更新法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (isRunning)</span><br><span class="line">&#123;</span><br><span class="line">updateEverything();</span><br><span class="line">sleep(1.0/60);//程序进程等待1/60秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="累积时间更新法"><a href="#累积时间更新法" class="headerlink" title="累积时间更新法"></a>累积时间更新法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* getCurrentTime()每次调用返回当前的时间 */</span><br><span class="line">float lastUpdateTime = getCurrentTime();</span><br><span class="line">while (isRunning)</span><br><span class="line">&#123;</span><br><span class="line">float currentTime = getCurrentTime();</span><br><span class="line">float deltaTime = currentTime - lastUpdateTime;</span><br><span class="line">    /* 每调用updateEverything()后检查时间，</span><br><span class="line">     直到过去的时间达到1/60秒就进行下一次更新 */</span><br><span class="line">if (deltaTime &gt;= 1.0/60)</span><br><span class="line">&#123;</span><br><span class="line">lastUpdateTime = currentTime;</span><br><span class="line">updateEverything();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图形更新调用法"><a href="#图形更新调用法" class="headerlink" title="图形更新调用法"></a>图形更新调用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while (isRunning)</span><br><span class="line">&#123;</span><br><span class="line">updateEverything();</span><br><span class="line">/* 等待垂直同步信号间的空白时间，程序执行到这里会进入等待</span><br><span class="line"> 一般会被封装在类似swapBuffer之类的图形API中执行，</span><br><span class="line"> 但是程序要开启了垂直同步的功能才有效。</span><br><span class="line"> 不过貌似现在的智能手机都默认有垂直同步的效果，</span><br><span class="line"> 当然手机和PC的硬件技术不同，可能也不叫这个名字了。*/</span><br><span class="line">waitForVerticalBlank();</span><br><span class="line">drawEverything();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死循环并计算时间差用于更新法"><a href="#死循环并计算时间差用于更新法" class="headerlink" title="死循环并计算时间差用于更新法"></a>死循环并计算时间差用于更新法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">float lastUpdateTime = getCurrentTime();</span><br><span class="line">while (isRunning)</span><br><span class="line">&#123;</span><br><span class="line">float currentTime = getCurrentTime();</span><br><span class="line">float deltaTime = currentTime - lastUpdateTime;</span><br><span class="line">lastUpdateTime = currentTime;</span><br><span class="line">updateEverything(deltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void updateMove(float deltaTime)</span><br><span class="line">&#123;</span><br><span class="line">position.x += speedX * deltaTime;</span><br><span class="line">position.y += speedY * deltaTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="累积时间半固定时长等图形更新并将时间差用于更新法"><a href="#累积时间半固定时长等图形更新并将时间差用于更新法" class="headerlink" title="累积时间半固定时长等图形更新并将时间差用于更新法"></a>累积时间半固定时长等图形更新并将时间差用于更新法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//假设目标是60帧/秒更新的游戏</span><br><span class="line">float lastUpdateTime = getCurrentTime();</span><br><span class="line">while (isRunning)</span><br><span class="line">&#123;</span><br><span class="line">float currentTime = getCurrentTime();</span><br><span class="line">float deltaTime = currentTime - lastUpdateTime;</span><br><span class="line">lastUpdateTime = currentTime;</span><br><span class="line">    /* 如果游戏太卡，过长的时间差可能会导致跳过一些不能跳过的游戏逻辑，</span><br><span class="line">     所以做一些人为限制 */</span><br><span class="line">    if (deltaTime &gt; 1.0/30) deltaTime = 1.0/30;</span><br><span class="line">updateEverything(deltaTime);</span><br><span class="line">waitForVerticalBlank();</span><br><span class="line">drawEverything();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法只针对单机游戏有效，如果是网络游戏，考虑客户端之间的同步问题的话，帧速不稳定地变来变去是不好的，我们可以记录过去的时间里跑过的帧数，如果达不到目标帧数就连续进行更新直到赶上需要的帧数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//假设目标是60帧/秒更新的游戏</span><br><span class="line">float startTime = getCurrentTime();</span><br><span class="line">long passedFrames = 0;</span><br><span class="line">while (isRunning)</span><br><span class="line">&#123;</span><br><span class="line">float currentTime = getCurrentTime();</span><br><span class="line">float totalTime = currentTime - startTime;</span><br><span class="line">long targetTotalFrames = totalTime/(1.0/60);</span><br><span class="line">/* 如果某一次更新耗时太久，则会导致passedFrames和targetTotalFrames差太多，</span><br><span class="line"> 所以就连续更新好几次逻辑来赶上目标的更新次数，以保证游戏的进度稳定*/</span><br><span class="line">while (passedFrames &lt; targetTotalFrames)</span><br><span class="line">&#123;</span><br><span class="line">updateEverything();</span><br><span class="line">passedFrames++;</span><br><span class="line">&#125;</span><br><span class="line">/* 图形更新应该在逻辑完全完成更新以后才进行 */</span><br><span class="line">drawEverything();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://blog.jmecn.net/chapter-16-physics-engine/" target="_blank" rel="noopener">第十六章：物理引擎</a>,by 冰点.</li><li><a href="https://www.zhihu.com/question/277300055" target="_blank" rel="noopener">为什么单机游戏中的碰撞很不真实？物理引擎真的很难做到和现实一样吗？</a>,by zhihu.</li><li><a href="http://blog.gifplane.com/2018/10/08/1-UnityOpt14.html" target="_blank" rel="noopener">5.1、Faster Physics(一)</a>,by GIFPlane.</li><li><a href="http://www.luvfight.me/game-loop/" target="_blank" rel="noopener">游戏主循环、帧速控制</a>,by luvfight.</li><li><a href="http://www.luvfight.me/update-components/" target="_blank" rel="noopener">一些游戏程序的基础知识（一）</a>,by luvfight.</li><li><a href="http://www.luvfight.me/draw-components/" target="_blank" rel="noopener">一些游戏程序的基础知识（二）</a>,by luvfight.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;游戏引擎提供一系列可视化开发工具和可重用组件。这些工具通过与开发环境进行集成，方便开发者简单、快速进行数据驱动方式的游戏开发。为了提高游戏开发人员的开发效率，引擎开发者会开发出大量的游戏所需要的软件组件。大多数引擎集成了图形、声音、物理和人工智能等功能部件。游戏引擎会被称为
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="3D" scheme="https://huangwang.github.io/tags/3D/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数与纯虚函数</title>
    <link href="https://huangwang.github.io/2019/09/15/CPlusPlus%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://huangwang.github.io/2019/09/15/CPlusPlus虚函数与纯虚函数/</id>
    <published>2019-09-15T13:19:43.000Z</published>
    <updated>2019-09-15T13:27:14.101Z</updated>
    
    <content type="html"><![CDATA[<p>在面向对象程序设计领域，C++、Object Pascal 等语言中有<strong>虚函数</strong>（英语：virtual function）或虚方法（英语：virtual method）的概念。这种函数或方法可以被子类继承和覆盖，通常使用动态调度实现。</p><p><strong>纯虚函数或纯虚方法</strong>是一个需要被非抽象的派生类覆盖（override）的虚函数. 包含纯虚方法的类被称作抽象类; 抽象类不能被直接实例化。 一个抽象基类的一个子类只有在所有的纯虚函数在该类(或其父类)内给出实现时, 才能直接实例化. 纯虚方法通常只有声明(签名)而没有定义(实现)，但有特例情形要求纯虚函数必须给出函数体定义.</p><h1 id="虚函数示例"><a href="#虚函数示例" class="headerlink" title="虚函数示例"></a>虚函数示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void eat() const &#123; cout &lt;&lt; &quot;I eat like a generic Animal.&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    virtual ~Animal() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class Wolf : public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void eat() const &#123; cout &lt;&lt; &quot;I eat like a wolf!&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class Fish : public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void eat() const &#123; cout &lt;&lt; &quot;I eat like a fish!&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class GoldFish : public Fish</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void eat() const &#123; cout &lt;&lt; &quot;I eat like a goldfish!&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class OtherAnimal : public Animal</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;Animal*&gt; animals;</span><br><span class="line">    animals.push_back( new Animal() );</span><br><span class="line">    animals.push_back( new Wolf() );</span><br><span class="line">    animals.push_back( new Fish() );</span><br><span class="line">    animals.push_back( new GoldFish() );</span><br><span class="line">    animals.push_back( new OtherAnimal() );</span><br><span class="line"> </span><br><span class="line">    for( std::vector&lt;Animal*&gt;::const_iterator it = animals.begin();</span><br><span class="line">       it != animals.end(); ++it) </span><br><span class="line">    &#123;</span><br><span class="line">        (*it)-&gt;eat();</span><br><span class="line">        delete *it;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是虚函数 Animal::eat() 的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I eat like a generic Animal.</span><br><span class="line">I eat like a wolf!</span><br><span class="line">I eat like a fish!</span><br><span class="line">I eat like a goldfish!</span><br><span class="line">I eat like a generic Animal.</span><br></pre></td></tr></table></figure><h1 id="纯虚函数示例"><a href="#纯虚函数示例" class="headerlink" title="纯虚函数示例"></a>纯虚函数示例</h1><p>在C++语言中, 纯虚函数用一种特别的语法[=0]定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Abstract &#123;</span><br><span class="line">public:</span><br><span class="line">   virtual void pure_virtual() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>纯虚函数的定义仅提供方法的原型. 虽然在抽象类中通常不提供纯虚函数的实现, 但是抽象类中可以包含其实现, 而且可以不在声明的同时给出定义[2]. 每个非抽象子类仍然需要重载该方法, 抽象类中实现的调用可以采用以下这种形式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Abstract::pure_virtual() &#123;</span><br><span class="line">  // do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child : public Abstract &#123;</span><br><span class="line">  virtual void pure_virtual(); // no longer abstract, this class may be</span><br><span class="line">                               // instantiated.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Child::pure_virtual() &#123;</span><br><span class="line">  Abstract::pure_virtual(); // the implementation in the abstract class </span><br><span class="line">                            // is executed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://blog.csdn.net/Hackbuteer1/article/details/7558868" target="_blank" rel="noopener">虚函数和纯虚函数的区别</a>,by hackbuteer1.</li><li><a href="https://zh.wikipedia.org/wiki/虚函数" target="_blank" rel="noopener">虚函数</a>,by wikipedia.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在面向对象程序设计领域，C++、Object Pascal 等语言中有&lt;strong&gt;虚函数&lt;/strong&gt;（英语：virtual function）或虚方法（英语：virtual method）的概念。这种函数或方法可以被子类继承和覆盖，通常使用动态调度实现。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="C/C++" scheme="https://huangwang.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04编译安装OSG</title>
    <link href="https://huangwang.github.io/2019/09/14/Ubuntu16-04%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85OSG/"/>
    <id>https://huangwang.github.io/2019/09/14/Ubuntu16-04编译安装OSG/</id>
    <published>2019-09-14T10:22:43.000Z</published>
    <updated>2019-09-14T11:18:45.819Z</updated>
    
    <content type="html"><![CDATA[<p>OpenSceneGraph是一个开源高性能3D图形工具包，应用程序开发人员在视觉模拟，游戏，虚拟现实，科学可视化和建模等领域使用。 它完全使用标准C ++和OpenGL编写，可在所有Windows平台，OSX，GNU / Linux，IRIX，Solaris，HP-Ux，AIX和FreeBSD操作系统上运行。 OpenSceneGraph现已成为世界领先的场景图技术，广泛应用于视觉，空间，科学，石油天然气，游戏和虚拟现实行业。本文主要记录在Ubuntu 16.04下编译安装OpenSceneGraph的过程。</p><h1 id="下载OSG源代码"><a href="#下载OSG源代码" class="headerlink" title="下载OSG源代码"></a>下载OSG源代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd ~/software</span><br><span class="line"># git clone https://github.com/openscenegraph/OpenSceneGraph.git</span><br><span class="line"># git checkout OpenSceneGraph-3.6.4</span><br></pre></td></tr></table></figure><h1 id="下载安装依赖"><a href="#下载安装依赖" class="headerlink" title="下载安装依赖"></a>下载安装依赖</h1><h2 id="安装OSG编译所需依赖"><a href="#安装OSG编译所需依赖" class="headerlink" title="安装OSG编译所需依赖"></a>安装OSG编译所需依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo apt-get build-dep openscenegraph</span><br></pre></td></tr></table></figure><h2 id="下载OSG数据资源"><a href="#下载OSG数据资源" class="headerlink" title="下载OSG数据资源"></a>下载OSG数据资源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cd ~/software</span><br><span class="line"># wget http://www.openscenegraph.org/downloads/stable_releases/OpenSceneGraph-3.4.0/data/OpenSceneGraph-Data-3.4.0.zip</span><br><span class="line"># unzip OpenSceneGraph-Data-3.4.0.zip</span><br></pre></td></tr></table></figure><h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cd ~/software/openscenegraph</span><br><span class="line"># cmake .</span><br><span class="line"># make</span><br><span class="line"># sudo make install</span><br><span class="line"># sudo ldconfig -v //如找不到相关osg库，可运行该命令</span><br></pre></td></tr></table></figure><h1 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h1><p>编辑.bashrc文件，添加如下环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PATH&#125;:/home/myaccount/software/OpenSceneGraph/bin</span><br><span class="line">export LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:/home/myaccount/software/OpenSceneGraph/lib</span><br><span class="line">export OSG_FILE_PATH=/home/myaccount/software/OpenSceneGraph-Data:/home/myaccount/OpenSceneGraph-Data/Images</span><br></pre></td></tr></table></figure><p>使用如下命令运行示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ./runexamples.bat</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://www.openscenegraph.org/index.php/documentation/getting-started" target="_blank" rel="noopener">Getting Started</a>,by OpenSceneGraph.</li><li><a href="https://blog.csdn.net/qing101hua/article/details/53080274" target="_blank" rel="noopener">ubuntu 环境 安装OSG</a>,by qing101hua.</li><li><a href="http://www.openscenegraph.org/index.php/download-section/data" target="_blank" rel="noopener">OSG Data Resources</a>,by OpenSceneGraph.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OpenSceneGraph是一个开源高性能3D图形工具包，应用程序开发人员在视觉模拟，游戏，虚拟现实，科学可视化和建模等领域使用。 它完全使用标准C ++和OpenGL编写，可在所有Windows平台，OSX，GNU / Linux，IRIX，Solaris，HP-Ux，
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="3D" scheme="https://huangwang.github.io/tags/3D/"/>
    
      <category term="计算机图形学" scheme="https://huangwang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>VSCode离线安装插件</title>
    <link href="https://huangwang.github.io/2019/09/07/VSCode%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/"/>
    <id>https://huangwang.github.io/2019/09/07/VSCode离线安装插件/</id>
    <published>2019-09-07T11:16:59.000Z</published>
    <updated>2019-09-12T12:52:06.029Z</updated>
    
    <content type="html"><![CDATA[<p>Visual Studio Code（简称VS Code）是一个由微软开发，同时支持Windows 、 Linux和macOS等操作系统且开放源代码的代码编辑器。与Sublime相比，VSCode开源，且有强大的社区支持，各种插件层出不穷。因为工作原因，需要在离线情况下使用VSCode。为了增强VSCode的功能，需要离线情况下安装其插件。具体方法如下：</p><h1 id="下载VSCode插件"><a href="#下载VSCode插件" class="headerlink" title="下载VSCode插件"></a>下载VSCode插件</h1><p>从VSCode的官方市场<a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="noopener">Extensions for the Visual Studio family of products</a>搜索和下载插件。官方市场下载VSCode插件可能会下载失败，可以跑到插件的github代码库，下载其最新发布版。</p><p></p><p align="center">    <img src="images/vscode_plugin_download.jpg" width="100%" alt="下载VSCode插件"></p><p></p><center>图1 下载VSCode插件</center><h1 id="离线安装VSCode插件"><a href="#离线安装VSCode插件" class="headerlink" title="离线安装VSCode插件"></a>离线安装VSCode插件</h1><p>打开VSCode的软件，选择左侧Extension，点击“…”，选择“从VSIX安装”，选择离线下载的VSCode插件进行安装。</p><p></p><p align="center">    <img src="images/vscode_plugin_install.jpg" width="100%" alt="离线安装VSCode插件"></p><p></p><center>图2  离线安装VSCode插件</center><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zh.wikipedia.org/wiki/Visual_Studio_Code" target="_blank" rel="noopener">Visual Studio Code</a>,by wikipedia.</li><li><a href="https://marketplace.visualstudio.com/vscode" target="_blank" rel="noopener">Extensions for the Visual Studio family of products</a>,by vscode.</li><li><a href="https://zhuanlan.zhihu.com/p/66056611" target="_blank" rel="noopener">GitHub最热！码代码不得不知的所有定律法则</a>,by Dave Kerr.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Visual Studio Code（简称VS Code）是一个由微软开发，同时支持Windows 、 Linux和macOS等操作系统且开放源代码的代码编辑器。与Sublime相比，VSCode开源，且有强大的社区支持，各种插件层出不穷。因为工作原因，需要在离线情况下使用
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="前端" scheme="https://huangwang.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Vue-js父子组件渲染过程简介</title>
    <link href="https://huangwang.github.io/2019/09/03/Vue-js%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B/"/>
    <id>https://huangwang.github.io/2019/09/03/Vue-js父子组件渲染过程简介/</id>
    <published>2019-09-03T01:29:04.000Z</published>
    <updated>2019-09-03T01:35:40.848Z</updated>
    
    <content type="html"><![CDATA[<p>Vuejs组件化开发是前端工程化的一个重要里程碑。在实际开发过程中，子组件渲染得不到理想的视觉效果。导致这一问题的原因埋藏在Vuejs父子组件的渲染过程。因此简单介绍Vuejs父子组件的渲染过程。</p><h1 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h1><p>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</p><h1 id="子组件更新过程"><a href="#子组件更新过程" class="headerlink" title="子组件更新过程"></a>子组件更新过程</h1><p>父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p><h1 id="父组件更新过程"><a href="#父组件更新过程" class="headerlink" title="父组件更新过程"></a>父组件更新过程</h1><p>父beforeUpdate-&gt;父updated</p><h1 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h1><p>父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://juejin.im/post/5bf37cb8e51d451b3b63f590" target="_blank" rel="noopener">vue父子组件的渲染顺序</a>, by rosenWang.</li><li><a href="https://huangwang.github.io/2019/07/26/Vue-js%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/">Vue-js入门简介</a>,by jackhuang.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vuejs组件化开发是前端工程化的一个重要里程碑。在实际开发过程中，子组件渲染得不到理想的视觉效果。导致这一问题的原因埋藏在Vuejs父子组件的渲染过程。因此简单介绍Vuejs父子组件的渲染过程。&lt;/p&gt;
&lt;h1 id=&quot;加载渲染过程&quot;&gt;&lt;a href=&quot;#加载渲染过程&quot; 
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="vuejs" scheme="https://huangwang.github.io/tags/vuejs/"/>
    
  </entry>
  
  <entry>
    <title>vuejs组件间通信的方法</title>
    <link href="https://huangwang.github.io/2019/09/02/vuejs%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://huangwang.github.io/2019/09/02/vuejs组件间通信的方法/</id>
    <published>2019-09-02T03:48:50.000Z</published>
    <updated>2019-09-02T03:54:15.494Z</updated>
    
    <content type="html"><![CDATA[<p>Vuejs一个吸引人的地方是可以进行组件化开发，避免了前端开发的无序状态。组件无法单独工作，必然会跟父子组件或兄弟组件之间进行通信，以合作实现某种功能。下面即简单介绍Vuejs组件之间的各种通信方式。</p><h1 id="方法一、props-emit"><a href="#方法一、props-emit" class="headerlink" title="方法一、props/$emit"></a>方法一、props/$emit</h1><h1 id="方法二、-emit-on"><a href="#方法二、-emit-on" class="headerlink" title="方法二、$emit/$on"></a>方法二、$emit/$on</h1><h1 id="方法三、vuex"><a href="#方法三、vuex" class="headerlink" title="方法三、vuex"></a>方法三、vuex</h1><h1 id="方法四、-attrs-listeners"><a href="#方法四、-attrs-listeners" class="headerlink" title="方法四、$attrs/$listeners"></a>方法四、$attrs/$listeners</h1><h1 id="方法五、provide-inject"><a href="#方法五、provide-inject" class="headerlink" title="方法五、provide/inject"></a>方法五、provide/inject</h1><h1 id="方法六、-parent-children与-ref"><a href="#方法六、-parent-children与-ref" class="headerlink" title="方法六、$parent / $children与 ref"></a>方法六、$parent / $children与 ref</h1><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://juejin.im/post/5cde0b43f265da03867e78d3" target="_blank" rel="noopener">Vue 组件间通信六种方式（完整版）</a>,by<br>浪里行舟.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vuejs一个吸引人的地方是可以进行组件化开发，避免了前端开发的无序状态。组件无法单独工作，必然会跟父子组件或兄弟组件之间进行通信，以合作实现某种功能。下面即简单介绍Vuejs组件之间的各种通信方式。&lt;/p&gt;
&lt;h1 id=&quot;方法一、props-emit&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="vuejs" scheme="https://huangwang.github.io/tags/vuejs/"/>
    
  </entry>
  
  <entry>
    <title>客户端使用JS导出CSV文件及中文乱码问题解决方案</title>
    <link href="https://huangwang.github.io/2019/08/27/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8JS%E5%AF%BC%E5%87%BACSV%E6%96%87%E4%BB%B6%E5%8F%8A%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://huangwang.github.io/2019/08/27/客户端使用JS导出CSV文件及中文乱码问题解决方案/</id>
    <published>2019-08-27T09:29:11.000Z</published>
    <updated>2019-08-27T23:55:36.571Z</updated>
    
    <content type="html"><![CDATA[<p>在浏览器端无需服务器端支持，直接将JS Array数据导出成CSV文件并下载，是一个常见的开发需求。具体方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var csvContent= this.$refs.flightInfoGrid.exportdata(&apos;csv&apos;)</span><br><span class="line">var link = document.createElement(&apos;a&apos;);</span><br><span class="line">// &quot;\ufeff&quot;是为了解决CSV中文乱码问题</span><br><span class="line">var blob = new Blob([&quot;\ufeff&quot; +csvContent],&#123;type: &apos;text/csv;charset=utf-8;&apos;&#125;);</span><br><span class="line">var url = URL.createObjectURL(blob);</span><br><span class="line">link.href = url;</span><br><span class="line">link.setAttribute(&apos;download&apos;, &apos;FlightInfo.csv&apos;);</span><br><span class="line">link.click();</span><br><span class="line">document.body.removeChild(link);</span><br></pre></td></tr></table></figure><h1 id="中文乱码问题分析"><a href="#中文乱码问题分析" class="headerlink" title="中文乱码问题分析"></a>中文乱码问题分析</h1><p>utf-8保存的csv格式要让Excel正常打开的话，必须加入在文件最前面加入BOM(Byte order mark)。</p><p>ANSI的话是可以做到正常显示和保存，但是这是有前提的，就是必须在你的电脑（区域和语言设置）把对非Unicode字符处理设置为Chinese，如果是English的话，显示照样是乱码。</p><p>Unicode的csv，Excel就根本不支持，打开虽然可以显示不乱码，但是已经不是按逗号显示在不同的单元格里面了，而是按行显示在第一个单元格里面。</p><p> BOM（byte-order mark），即字节顺序标记，它是插入到以UTF-8、UTF16或UTF-32编码Unicode文件开头的特殊标记，用来识别Unicode文件的编码类型。具体编码如下表：</p><div class="table-container"><table><thead><tr><th>BOM</th><th>Encoding</th></tr></thead><tbody><tr><td>EF BB BF</td><td>UTF-8</td></tr><tr><td>FE FF</td><td>UTF-16 (big-endian)</td></tr><tr><td>FF FE</td><td>UTF-16 (little-endian)</td></tr><tr><td>00 00 FE FF</td><td>UTF-32 (big-endian)</td></tr><tr><td>FF FE 00 00</td><td>UTF-32 (little-endian)</td></tr></tbody></table></div><p>微软建议所有的 Unicode 文件应该以 ZERO WIDTH NOBREAK SPACE（U+FEFF）字符开头。这作为一个“特征符”来识别文件中使用的编码和字节顺序。BOM的本意不错，但它并不是一个通用标准，从而导致了很多不兼容的问题。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://blog.csdn.net/oyi319/article/details/6406506" target="_blank" rel="noopener">Excel 2007 打开 UTF-8 编码 CSV 文件的BUG</a>,by oyi319.</li><li><a href="https://stackoverflow.com/questions/14964035/how-to-export-javascript-array-info-to-csv-on-client-side" target="_blank" rel="noopener">How to export JavaScript array info to csv (on client side)?</a>,by stackoverflow.</li><li><a href="https://my.oschina.net/dawd/blog/801323" target="_blank" rel="noopener">blob 导出csv 用execl打开出现乱码</a>,by 黑魔法.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在浏览器端无需服务器端支持，直接将JS Array数据导出成CSV文件并下载，是一个常见的开发需求。具体方法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="前端" scheme="https://huangwang.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Javascript" scheme="https://huangwang.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>如何使用图标icon</title>
    <link href="https://huangwang.github.io/2019/08/25/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E6%A0%87icon/"/>
    <id>https://huangwang.github.io/2019/08/25/如何使用图标icon/</id>
    <published>2019-08-25T08:46:07.000Z</published>
    <updated>2019-08-25T10:01:35.303Z</updated>
    
    <content type="html"><![CDATA[<p>在前端网页的世界里，Icon是最基本的元素之一。使用Icon已成为前端开发者最基本的技能。下面将主要介绍利用SVG Sprites技术在前端中使用Icon的方法。</p><h1 id="Icon的演化史"><a href="#Icon的演化史" class="headerlink" title="Icon的演化史"></a>Icon的演化史</h1><p>Icon最早用img实现，后为了提高效率，减少img请求，出现image sprite技术，实现将多个图片合成一个图片，然后利用 css 的 background-position 定位显示不同的 icon 图标。但该技术维护困难。</p><p>随后出现了<strong>font库</strong>实现页面图标，例如<a href="https://fontawesome.com/" target="_blank" rel="noopener"> Font Awesome</a>。目前最常用的是<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a>，里面图标应有尽有，且开源。</p><h1 id="iconfont的使用方法"><a href="#iconfont的使用方法" class="headerlink" title="iconfont的使用方法"></a>iconfont的使用方法</h1><h2 id="unicode"><a href="#unicode" class="headerlink" title="unicode"></a>unicode</h2><p>优势：</p><ul><li>兼容性最好，支持ie6+</li><li>支持按字体的方式去动态调整图标大小，颜色等等</li></ul><p>劣势:</p><ul><li>不支持多色图标</li><li>在不同的设备浏览器字体的渲染会略有差别</li></ul><p>具体使用方法参考<a href="https://juejin.im/post/59bb864b5188257e7a427c09" target="_blank" rel="noopener">手摸手，带你优雅的使用 icon</a>，不建议使用。</p><h2 id="font-class"><a href="#font-class" class="headerlink" title="font-class"></a>font-class</h2><p>与unicode使用方式相比，具有如下特点：</p><ul><li>兼容性良好，支持ie8+</li><li>相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。</li></ul><h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p>随着IE浏览器逐渐淡出历史舞台，svg-icon 使用形式慢慢成为主流和推荐的方法，请参考<a href="https://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/?spm=a313x.7781069.1998910419.50" target="_blank" rel="noopener">未来必热：SVG Sprites技术介绍</a>。其优点有：</p><ul><li>支持多色图标了，不再受单色限制。</li><li>支持像字体那样通过font-size,color来调整样式。</li><li>支持 ie9+</li><li>可利用CSS实现动画。</li><li>减少HTTP请求。</li><li>矢量，缩放不失真</li><li>可以很精细的控制SVG图标的每一部分</li></ul><p>具体使用方法如下：</p><ul><li>使用SVG Sprite生成SVG雪碧图</li></ul><p></p><p align="center">    <img src="images/svg_sprite.png" width="90%" alt="SVG雪碧图"></p><p></p><center>图1  SVG雪碧图</center><ul><li>加入通用css代码（引入一次就行）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    .icon &#123;</span><br><span class="line">       width: 1em; height: 1em;</span><br><span class="line">       vertical-align: -0.15em;</span><br><span class="line">       fill: currentColor;</span><br><span class="line">       overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>挑选相应图标并获取类名，应用于页面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;</span><br><span class="line">    &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>使用svg-icon的好处是再也不用发送woff|eot|ttf| 这些很多个字体库请求了，所有的svg都可以内联在html内。且svg 是一个真正的矢量，不管再怎么的放缩它都不会失真模糊，而且svg可以控制的属性也更加的丰富，也能做出更加生动和复杂的图标。</p><h1 id="生成SVG-sprite的方法"><a href="#生成SVG-sprite的方法" class="headerlink" title="生成SVG sprite的方法"></a>生成SVG sprite的方法</h1><p>推荐使用<a href="https://github.com/kisenka/svg-sprite-loader" target="_blank" rel="noopener">svg-sprite-loader </a>,它是一个Webpack loader。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;@/src/icons/qq.svg; //引入图标</span><br><span class="line">&lt;svg&gt;&lt;use xlink:href=&quot;#qq&quot; /&gt;&lt;/svg&gt;  //使用图标</span><br></pre></td></tr></table></figure><h1 id="自动导入多个SVG"><a href="#自动导入多个SVG" class="headerlink" title="自动导入多个SVG"></a>自动导入多个SVG</h1><p>使用 webpack 的 <a href="https://webpack.js.org/guides/dependency-management/#require-context" target="_blank" rel="noopener">require.context</a> 实现自动导入多个SVG Icon，避免手动一个个引入。</p><p>require.context有三个参数：</p><ul><li>directory：说明需要检索的目录</li><li>useSubdirectories：是否检索子目录</li><li>regExp: 匹配文件的正则表达式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)</span><br><span class="line">const req = require.context(&apos;./svg&apos;, false, /\.svg$/)</span><br><span class="line">requireAll(req)</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://juejin.im/post/59bb864b5188257e7a427c09" target="_blank" rel="noopener">手摸手，带你优雅的使用 icon</a>,by 花裤衩.</li><li><a href="https://www.zhangxinxu.com/wordpress/2014/07/introduce-svg-sprite-technology/?spm=a313x.7781069.1998910419.50" target="_blank" rel="noopener">未来必热：SVG Sprites技术介绍</a>,by 张鑫旭.</li><li><a href="https://juejin.im/post/5c049a28f265da61273d2317" target="_blank" rel="noopener">如何在vue项目中优雅的使用SVG</a>,by SilentLove.</li><li><a href="https://juejin.im/post/5c10dbcbf265da61441fe8e2" target="_blank" rel="noopener">关于webpack的require.context</a>,by yeyan1996.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前端网页的世界里，Icon是最基本的元素之一。使用Icon已成为前端开发者最基本的技能。下面将主要介绍利用SVG Sprites技术在前端中使用Icon的方法。&lt;/p&gt;
&lt;h1 id=&quot;Icon的演化史&quot;&gt;&lt;a href=&quot;#Icon的演化史&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="vuejs" scheme="https://huangwang.github.io/tags/vuejs/"/>
    
      <category term="前端" scheme="https://huangwang.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>USB供电能力简介</title>
    <link href="https://huangwang.github.io/2019/08/20/USB%E4%BE%9B%E7%94%B5%E8%83%BD%E5%8A%9B%E7%AE%80%E4%BB%8B/"/>
    <id>https://huangwang.github.io/2019/08/20/USB供电能力简介/</id>
    <published>2019-08-20T13:43:22.000Z</published>
    <updated>2019-08-20T14:13:52.095Z</updated>
    
    <content type="html"><![CDATA[<p>最近买了个行车记录仪，它通过USB接口供电，要求电源输入为5V2A，即要求电源的输出功率要达到10W。不想直接安装到车上，想插在电脑的USB接口上，测试行车记录仪的功能。那么电脑USB接口的供电能力足够吗？</p><h1 id="USB标准供电能力"><a href="#USB标准供电能力" class="headerlink" title="USB标准供电能力"></a>USB标准供电能力</h1><p>USB有多个标准，供电能力各不相同：</p><ul><li>USB1.1 传输速率最高12Mbps; 电源供应 5V 500mA</li><li>USB2.0 传输速率最高480Mbps; 电源供应 5V 500mA</li><li>USB3.0 传输速率最高5Gbps; 电源供应 5V 900mA</li></ul><p>最新的USB3.0标准输出电压为5V，输出电流最大为900mA，如果超过可能会因发热造成线路损坏。，因此电脑上的标准USB接口无法支持行车记录仪的正常使用。</p><p><strong>注意: 输出电压由电源输出决定，但输出电流大小由负载决定。</strong></p><h1 id="USB快充技术"><a href="#USB快充技术" class="headerlink" title="USB快充技术"></a>USB快充技术</h1><p>目前的快充技术基本有三种：USB-IF组织的USB PD、高通QC、联发科PEP/PE，其他手机厂商的快充方案大多来自这三个。</p><ul><li><p>USB PD（快充标准）目前基本绑定在USB3.0（数据传输标准）和USB Type-C（接头物理标准）上了，也得到谷歌和苹果两大巨头的支持，非常有希望成为未来的统一标准。</p></li><li><p>高通Quick Charge技术则是实际上被中高端智能手机采用最多的，小米、华硕、LG、乐视、中兴、HTC等最近两年的旗舰都是这个标准，三星FastCharge是QC的马甲，索尼也用QC。 由于硬件端和软件端都被强硬规定， 高通最新的QC 4.0已经使用了USB PD协议，成为了USB PD的一个分支。</p></li><li><p>联发科PEP技术推广成本最低，广泛用于中低端手机，魅族mCharge也是基于PEP。 不过联发科的PE3.0有可能被苹果采用。</p></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://www.ednchina.com/news/20180228.html" target="_blank" rel="noopener">关于USB快充你不得不知的几点问题</a>,by EDN.</li><li><a href="https://www.zhihu.com/question/20275311" target="_blank" rel="noopener">手机充电是用电脑 USB 快还是用插座快？</a>,by zhihu.</li><li><a href="https://zh.wikipedia.org/wiki/%E7%93%A6%E7%89%B9" target="_blank" rel="noopener">瓦特</a>,by wikipedia.</li><li><a href="https://www.zhihu.com/question/50528184" target="_blank" rel="noopener">手机快充是跟数据线有关还是跟充电器有关？</a>,by zhihu.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近买了个行车记录仪，它通过USB接口供电，要求电源输入为5V2A，即要求电源的输出功率要达到10W。不想直接安装到车上，想插在电脑的USB接口上，测试行车记录仪的功能。那么电脑USB接口的供电能力足够吗？&lt;/p&gt;
&lt;h1 id=&quot;USB标准供电能力&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="硬件" scheme="https://huangwang.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>MSSQL2008中分页查询的实现</title>
    <link href="https://huangwang.github.io/2019/08/17/MSSQL2008%E4%B8%AD%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://huangwang.github.io/2019/08/17/MSSQL2008中分页查询的实现/</id>
    <published>2019-08-17T10:22:02.000Z</published>
    <updated>2019-08-17T14:04:42.404Z</updated>
    
    <content type="html"><![CDATA[<p>在后台管理中，涉及分页操作，需要数据库支持limit和offset选项，但在MSSQL2008中这两个选项不支持，不过可以用ROW_NUMBER函数在SQL语句中实现数据分页效果。SQL代码示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM  </span><br><span class="line">(SELECT Users.id as id,name,sign,account,audit,roleName,RoleId, Users.deleteFlag as deleteFlag,</span><br><span class="line">ROW_NUMBER() OVER (ORDER BY Users.createdAt) AS Seq </span><br><span class="line">FROM Users LEFT JOIN Roles ON Users.RoleId=Roles.id)Users </span><br><span class="line">Where deleteFlag=0 and </span><br><span class="line">Seq &gt; :offset_num and Seq&lt;= :offset_num+:limit_num</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://social.msdn.microsoft.com/Forums/sqlserver/en-US/f24c0a3d-e8e9-4041-aca5-590a6e1a2e81/how-to-use-offset-fetch-next-in-sql-server-2008-r2?forum=databasedesign" target="_blank" rel="noopener">How to use Offset . . .Fetch Next in SQL SERVER 2008 R2</a>,by microsoft msdn.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在后台管理中，涉及分页操作，需要数据库支持limit和offset选项，但在MSSQL2008中这两个选项不支持，不过可以用ROW_NUMBER函数在SQL语句中实现数据分页效果。SQL代码示例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="数据库" scheme="https://huangwang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关系数据库中存储树结构及前端还原的方法</title>
    <link href="https://huangwang.github.io/2019/08/17/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%AD%98%E5%82%A8%E6%A0%91%E7%BB%93%E6%9E%84%E5%8F%8A%E5%89%8D%E7%AB%AF%E8%BF%98%E5%8E%9F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://huangwang.github.io/2019/08/17/关系数据库中存储树结构及前端还原的方法/</id>
    <published>2019-08-17T00:04:48.000Z</published>
    <updated>2019-08-17T10:12:58.853Z</updated>
    
    <content type="html"><![CDATA[<p>树形结构很常见，例如组织结构图、线性化讨论等。树形结构中，实例被称为节点（node），每个节点有多个子节点和一个父节点。最上层的节点叫根（root）节点，它没有父节点。最底层的节点叫叶（leaf）节点，它没有子节点。本文主要介绍如何在关系数据库中存储树结构，以及如何从关系数据库中恢复树结构。</p><h1 id="关系数据库中存储树结构的方法"><a href="#关系数据库中存储树结构的方法" class="headerlink" title="关系数据库中存储树结构的方法"></a>关系数据库中存储树结构的方法</h1><h2 id="层级数据设计方案"><a href="#层级数据设计方案" class="headerlink" title="层级数据设计方案"></a>层级数据设计方案</h2><p>在关系数据库中存储树结构主要有以下几种方案：</p><ul><li>邻接表模型</li></ul><p>最常见的解决方案，在数据库表中添加parent_id字段，再引用同一张表中的其他记录的id。可通过一个外键约束维护这种关系。</p><p>优点：增加叶节点、修改节点或子树位置很方便。</p><p>缺点：查询节点的所有后代、删除子树很困难。</p><ul><li>路径枚举</li></ul><p>路径枚举是一个由连续的直接层级关系组成的完整路径。例如/usr/local/lib。</p><p>优点：查询节点所有后代、插入新节点很方便。<br>缺点：依赖应用程序逻辑代码维护路径字符串，验证字符串正确性开销大。受限于字符串长度，树结构无法无限扩展。</p><ul><li>嵌套集</li></ul><p>嵌套集解决方案是存储子孙节点的相关信息，而不是节点的直接祖先。通常使用两个数字nsleft和nsright编码每个节点，以表示子孙节点信息。</p><p>nsleft的数值小于该节点所有后代的ID，同时nsright的值大于该节点所有后代的ID。</p><p>确定这三个值（nsleft，ID，nsright）的简单方法是对树进行一次深度优先遍历，在逐层深入过程中依次递增地分配nsleft的值，并在返回时依次递增地分配nsright的值。</p><p>优点：查询给定节点祖先和后代很容易，删除非叶子节点，其后代会自动代替被删除节点成为其祖先节点的直接后代。</p><p>缺点：不易理解，插入和移动节点复杂。</p><ul><li>闭包表</li></ul><p>闭包表通过额外的数据库表记录树中节点间父子的关系，包括直接的父子关系、间接的父子关系和指向自己的关系。</p><h2 id="层级数据设计比较"><a href="#层级数据设计比较" class="headerlink" title="层级数据设计比较"></a>层级数据设计比较</h2><center>层级数据设计比较</center><div class="table-container"><table><thead><tr><th>设计</th><th>表</th><th>查询子</th><th>查询树</th><th>插入</th><th>删除</th><th>引用完整性</th></tr></thead><tbody><tr><td>邻接表</td><td>1</td><td>简单</td><td>困难</td><td>简单</td><td>简单</td><td>是</td></tr><tr><td>邻接表+递归查询</td><td>1</td><td>简单</td><td>简单</td><td>简单</td><td>简单</td><td>否</td></tr><tr><td>路径枚举</td><td>1</td><td>简单</td><td>简单</td><td>简单</td><td>简单</td><td>否</td></tr><tr><td>嵌套集</td><td>1</td><td>困难</td><td>简单</td><td>困难</td><td>困难</td><td>否</td></tr><tr><td>闭包集</td><td>2</td><td>简单</td><td>简单</td><td>简单</td><td>简单</td><td>是</td></tr></tbody></table></div><ul><li>邻接表设计最简单，如果使用的数据库支持WITH或CONNECT BY PRIOR的递归查询，将使得邻接表查询更为高效。</li></ul><h1 id="前端从关系数据库中还原树结构"><a href="#前端从关系数据库中还原树结构" class="headerlink" title="前端从关系数据库中还原树结构"></a>前端从关系数据库中还原树结构</h1><p>表结构，使用sequelize的对象表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">module.exports = (sequelize, DataTypes) =&gt; &#123;</span><br><span class="line">  const Role = sequelize.define(&apos;Role&apos;, &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">      type: DataTypes.STRING(50),</span><br><span class="line">      primaryKey: true</span><br><span class="line">    &#125;,</span><br><span class="line">    roleName: &#123;</span><br><span class="line">      type: DataTypes.STRING(128),</span><br><span class="line">      allowNull: false</span><br><span class="line">    &#125;,</span><br><span class="line">    path: &#123;</span><br><span class="line">      type: DataTypes.STRING(512),</span><br><span class="line">      allowNull: false,</span><br><span class="line">      unique: true,</span><br><span class="line">      comment: &apos;角色路径唯一！&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    deleteFlag:&#123;</span><br><span class="line">      type: DataTypes.BOOLEAN,</span><br><span class="line">      defaultValue: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">  Role.associate = function(models) &#123;</span><br><span class="line">    // associations can be defined here</span><br><span class="line">    Role.hasMany(models.User)</span><br><span class="line">  &#125;;</span><br><span class="line">  return Role;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>递归生成角色树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 获取第一层节点</span><br><span class="line">function getFirstLevel(recordList)&#123;</span><br><span class="line">    var firstLevelList=[];</span><br><span class="line">    for(let i=0;i&lt; recordList.length;i++)&#123;</span><br><span class="line">        let record=recordList[i]</span><br><span class="line">        if (record.path.length === 2 &amp;&amp; record.path.split(&apos;&apos;)[1] === &apos;/&apos; &amp;&amp; parseInt(record.path.split(&apos;&apos;)[0])&gt;=0)&#123;</span><br><span class="line">            record.label=record.roleName</span><br><span class="line">            firstLevelList.push(record)</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    return firstLevelList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 指定根节点，递归生成角色树</span><br><span class="line">function recursiveTree(parentRecord,recordList)&#123;</span><br><span class="line">    for (let i = 0; i &lt; recordList.length; i++)&#123;</span><br><span class="line">        let record = recordList[i]</span><br><span class="line">        if(parentRecord.path==record.path.slice(0,-2))&#123;</span><br><span class="line">            record=recursiveTree(record,recordList)</span><br><span class="line">            if (parentRecord.children==undefined)&#123;</span><br><span class="line">                parentRecord.children=[]</span><br><span class="line">            &#125;</span><br><span class="line">            parentRecord.children.push(record)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parentRecord.label = parentRecord.roleName</span><br><span class="line">    return parentRecord</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成角色树</span><br><span class="line">export function parseRoleTree(recordList)&#123;</span><br><span class="line">    var result = getFirstLevel(recordList);</span><br><span class="line"></span><br><span class="line">    for (let i=0;i&lt;result.length;i++)&#123;</span><br><span class="line">        parent = result[i]</span><br><span class="line">        parent = recursiveTree(parent, recordList)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://blog.csdn.net/LDY1016/article/details/85784001" target="_blank" rel="noopener">java递归生成树形结构菜单</a>,by 伊宇紫.</li><li>Bill Karwin著,谭振林,Push Chen译. SQL反模式[M].人民邮电出版社.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;树形结构很常见，例如组织结构图、线性化讨论等。树形结构中，实例被称为节点（node），每个节点有多个子节点和一个父节点。最上层的节点叫根（root）节点，它没有父节点。最底层的节点叫叶（leaf）节点，它没有子节点。本文主要介绍如何在关系数据库中存储树结构，以及如何从关系数
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="数据库" scheme="https://huangwang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>网页布局方法入门</title>
    <link href="https://huangwang.github.io/2019/08/10/%E7%BD%91%E9%A1%B5%E5%B8%83%E5%B1%80%E6%96%B9%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwang.github.io/2019/08/10/网页布局方法入门/</id>
    <published>2019-08-10T00:56:46.000Z</published>
    <updated>2019-08-11T13:14:31.528Z</updated>
    
    <content type="html"><![CDATA[<p>使用CSS对网页布局进行设计是前端工程师的重要工作。下面即介绍各种CSS网页布局的方法，以及相应的技术。</p><h1 id="居中方法"><a href="#居中方法" class="headerlink" title="居中方法"></a>居中方法</h1><p>居中在布局中很常见，假设DOM文档结构如下，子元素要在父元素中居中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><p>子元素为行内元素还是块状元素，宽度一定还是宽度未定，采取的布局方案不同。以下即根据子元素的类型给出对应水平居中方法：</p><ul><li><strong>行内元素</strong>：对父元素设置text-align:center;</li><li><strong>定宽块状元素</strong>: 设置左右margin值为auto;</li><li><strong>不定宽块状元素</strong>: 设置子元素为display:inline,然后在父元素上设置text-align:center;</li><li><strong>通用方案</strong>: flex布局，对父元素设置display:flex;justify-content:center;</li></ul><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><p>垂直居中对于子元素是单行内联文本、多行内联文本以及块状元素采用的方案是不同的。具体方法如下：</p><ul><li><strong>父元素一定，子元素为单行内联文本</strong>：设置父元素的height等于行高line-height</li><li><strong>父元素一定，子元素为多行内联文本</strong>：设置父元素的display:table-cell或inline-block，再设置vertical-align:middle;</li><li><strong>块状元素</strong>:设置子元素position:absolute 并设置top、bottom为0，父元素要设置定位为static以外的值，margin:auto;</li></ul><h1 id="单列布局"><a href="#单列布局" class="headerlink" title="单列布局"></a>单列布局</h1><p>单列布局如图1所示，可分成两种类型，有定宽、水平居中的特点。</p><ul><li>一种是header、content、footer宽度都相同，其一般不会占满浏览器的最宽宽度，但当浏览器宽度缩小低于其最大宽度时，宽度会自适应。</li><li>一种是header、footer宽度为浏览器宽度，但content以及header和footer里的内容却不会占满浏览器宽度。</li></ul><center>![单列布局的两种形式](https://pic4.zhimg.com/80/v2-12cd0eddc97721987b9f6e41e5a1fc4b_hd.png "单列布局的两种形式")图1  单列布局的两种形式</center><p>对于第一种，对header、content、footer统一设置width或max-width，并通过margin:auto实现居中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;layout&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;header&quot;&gt;头部&lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;content&quot;&gt;内容&lt;/div&gt;</span><br><span class="line">  &lt;div id=&quot;footer&quot;&gt;尾部&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.layout&#123;</span><br><span class="line">  /*   width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/</span><br><span class="line">    max-width: 960px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对于第二种，header、footer的内容宽度为100%，但header、footer的内容区以及content统一设置width 或 max-width，并通过margin:auto实现居中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;header&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;layout&quot;&gt;头部&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;content&quot; class=&quot;layout&quot;&gt;内容&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;layout&quot;&gt;尾部&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.layout&#123;</span><br><span class="line">  /*   width: 960px; *//*设置width当浏览器窗口宽度小于960px时，单列布局不会自适应。*/</span><br><span class="line">    max-width: 960px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="二列-amp-三列布局"><a href="#二列-amp-三列布局" class="headerlink" title="二列&amp;三列布局"></a>二列&amp;三列布局</h1><p><strong>二列布局的特征是侧栏固定宽度，主栏自适应宽度。三列布局的特征是两侧两列固定宽度，中间列自适应宽度。</strong> 之所以将二列布局和三列布局写在一起，是因为二列布局可以看做去掉一个侧栏的三列布局，其布局的思想有异曲同工之妙。</p><p>对于传统的实现方法，主要讨论上图2中前三种布局，经典的带有侧栏的二栏布局以及带有左右侧栏的三栏布局。使用flex技术，可实现图2的五种布局。</p><center>![二列&三列布局](https://pic2.zhimg.com/80/v2-784022577a47ea5fc449b06de53c4651_hd.png "二列&三列布局")图2  二列&三列布局</center><p>实现二列&amp;三列布局的CSS技术主要有：</p><h2 id="float-margin"><a href="#float-margin" class="headerlink" title="float+margin"></a>float+margin</h2><p>原理说明：设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;content&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;sub&quot;&gt;sub&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;extra&quot;&gt;extra&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.sub&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.extra&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    float: right;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">    margin-left: 100px; </span><br><span class="line">    margin-right: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>DOM文档的书写顺序，先写两侧栏，再写主面板，更换后则侧栏会被挤到下一列（圣杯布局和双飞翼布局都会用到）。 　</li><li>这种布局方式比较简单明了，但缺点是渲染时先渲染了侧边栏，而不是比较重要的主面板。</li></ul><h2 id="position-margin"><a href="#position-margin" class="headerlink" title="position+margin"></a>position+margin</h2><p>原理说明：通过绝对定位将两个侧栏固定，同样通过外边距给两个侧栏腾出空间，中间列自适应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;sub&quot;&gt;left&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;extra&quot;&gt;right&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.sub, .extra &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0; </span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br><span class="line">.sub &#123; </span><br><span class="line">    left: 0;</span><br><span class="line">&#125;</span><br><span class="line">.extra &#123; </span><br><span class="line">    right: 0; </span><br><span class="line">&#125;</span><br><span class="line">.main &#123; </span><br><span class="line">    margin: 0 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>本方法不限制DOM书写顺序，先写主面板会使主面板部分优先渲染（一般主面板会比侧栏内容重要）。</li><li>与上一种方法相比，本种方法是通过定位来实现侧栏的位置固定。</li><li>如果中间栏含有最小宽度限制，或是含有宽度的内部元素，则浏览器窗口小到一定程度，主面板与侧栏会发生重叠。</li></ul><h2 id="圣杯布局-float-负margin"><a href="#圣杯布局-float-负margin" class="headerlink" title="圣杯布局(float + 负margin)"></a>圣杯布局(float + 负margin)</h2><p>原理说明：</p><p>主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对齐的左边，右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边。为了避免侧栏遮挡主面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小。由于侧栏的负margin都是相对主面板的，两个侧栏并不会像我们理想中的停靠在左右两边，而是跟着缩小的主面板一起向中间靠拢。此时使用相对布局，调整两个侧栏到相应的位置。</p><h2 id="双飞翼布局-float-负margin"><a href="#双飞翼布局-float-负margin" class="headerlink" title="双飞翼布局(float + 负margin )"></a>双飞翼布局(float + 负margin )</h2><p>原理说明：</p><p>双飞翼布局和圣杯布局的思想有些相似，都利用了浮动和负边距，但双飞翼布局在圣杯布局上做了改进，在main元素上加了一层div, 并设置margin,由于两侧栏的负边距都是相对于main-wrap而言，main的margin值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤。</p><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><p>与之前所讲的几种传统布局方案相比，flex布局的代码可谓异常简洁，而且非常通用，利用简单的三行CSS即实现了常见的五种布局。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;layout&quot;&gt;</span><br><span class="line">    &lt;aside class=&quot;aside&quot;&gt;侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;layout&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">    &lt;aside class=&quot;aside&quot;&gt;侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;layout&quot;&gt;</span><br><span class="line">    &lt;aside class=&quot;aside&quot;&gt;左侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">    &lt;aside class=&quot;aside&quot;&gt;右侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;layout&quot;&gt;</span><br><span class="line">    &lt;aside class=&quot;aside&quot;&gt;第1个侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;aside class=&quot;aside&quot;&gt;第2个侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;layout&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;主内容栏宽度自适应&lt;/div&gt;</span><br><span class="line">    &lt;aside class=&quot;aside&quot;&gt;第1个侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">    &lt;aside class=&quot;aside&quot;&gt;第2个侧边栏宽度固定&lt;/aside&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.layout &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.main &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">&#125;</span><br><span class="line">.aside &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自适应与响应式布局"><a href="#自适应与响应式布局" class="headerlink" title="自适应与响应式布局"></a>自适应与响应式布局</h1><p>自适应是为了解决如何才能在不同大小的设备上呈现同样的网页，实现一次设计，普遍适用而提出的技术，以避免维护多个版本的针对不同分辨率设备的网页。</p><p>但自适应存在一个问题，如果屏幕太小，即使网页能够根据屏幕大小进行适配，但是会感觉在小屏幕上查看，内容过于拥挤。响应式正是为了解决这个问题而衍生出来的概念。它可以自动识别屏幕宽度、并做出相应调整的网页设计，布局和展示的内容可能会有所变动。</p><p>目前网页的响应式布局解决方案成为当前主流，并因 twitter 开源的 bootstrap 而被大家熟知。响应式布局的实现原理如下：</p><ul><li>允许网页宽度自动调整</li></ul><p>网页代码的头部，加入一行viewport元标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</span><br></pre></td></tr></table></figure><p>viewport是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device-width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%。</p><ul><li>尽量少使用绝对宽度</li></ul><p>由于网页会根据屏幕宽度调整布局，所以不能使用绝对宽度的布局，也不能使用具有绝对宽度的元素。这一条非常重要。具体说，CSS代码不能指定像素宽度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width:xxx px;</span><br></pre></td></tr></table></figure><p>通过指定百分比宽度来替代：同时还可以配合css的cal，进行计算宽度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width: xx%;</span><br><span class="line">width:auto;</span><br></pre></td></tr></table></figure></p><ul><li>相对大小的字体</li></ul><p>字体也不能使用绝对大小（px），而只能使用相对大小（em）或者高清方案（rem）,rem不局限于字体大小，前面的宽度width也可以使用，代替百分比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  font: normal 100% Helvetica, Arial, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码指定，字体大小是页面默认大小的100%，即16像素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1 &#123;</span><br><span class="line">　　font-size: 1.5em; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，h1的大小是默认大小的1.5倍，即24像素（24/16=1.5）。</p><ul><li>流动布局（fluid grid）</li></ul><p>“流动布局”的含义是，各个区块的位置都是浮动的，不是固定不变的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">　　float: right;</span><br><span class="line">　　width: 70%; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.leftBar &#123;</span><br><span class="line">　　float: left;</span><br><span class="line">　　width: 25%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。</p><ul><li>选择加载CSS</li></ul><p>“自适应网页设计”的核心，就是CSS3引入的Media Query模块。</p><p>它的意思就是，自动探测屏幕宽度，然后加载相应的CSS文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;</span><br><span class="line">　　　　media=&quot;screen and (max-device-width: 400px)&quot;</span><br><span class="line">　　　　href=&quot;tinyScreen.css&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot;</span><br><span class="line">　　　　media=&quot;screen and (min-width: 400px) and (max-device-width: 600px)&quot;</span><br><span class="line">　　　　href=&quot;smallScreen.css&quot; /&gt;</span><br></pre></td></tr></table></figure><p>除了用html标签加载CSS文件，还可以在现有CSS文件中加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import  url(&quot;tinyScreen.css&quot;) screen and (max-device-width: 400px);</span><br></pre></td></tr></table></figure><ul><li>CSS的@media规则</li></ul><p>同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@media  screen and (max-device-width: 400px) &#123;</span><br><span class="line">　　.column &#123;</span><br><span class="line">　　　　float: none;</span><br><span class="line">　　　　width:auto;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　#sidebar &#123;</span><br><span class="line">　　　　display:none;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>图片的自适应（fluid image）</li></ul><p>除了布局和文本，”自适应网页设计”还必须实现图片的自动缩放。这只要一行CSS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img &#123; max-width: 100%;&#125;</span><br></pre></td></tr></table></figure><h1 id="布局相关CSS"><a href="#布局相关CSS" class="headerlink" title="布局相关CSS"></a>布局相关CSS</h1><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p>display CSS 属性指定了元素的显示类型，它包含两类基础特征，用于指定元素怎样生成盒模型——<strong>外部显示类型</strong>定义了元素怎样参与流式布局的处理，<strong>内部显示类型</strong>定义了元素内子元素的布局方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/* &lt;display-outside&gt; values */</span><br><span class="line">display: block;</span><br><span class="line">display: inline;</span><br><span class="line">display: run-in;</span><br><span class="line"></span><br><span class="line">/* &lt;display-inside&gt; values */</span><br><span class="line">display: flow;</span><br><span class="line">display: flow-root;</span><br><span class="line">display: table;</span><br><span class="line">display: flex;</span><br><span class="line">display: grid;</span><br><span class="line">display: ruby;</span><br><span class="line"></span><br><span class="line">/* &lt;display-outside&gt; plus &lt;display-inside&gt; values */</span><br><span class="line">display: block flow;</span><br><span class="line">display: inline table;</span><br><span class="line">display: flex run-in;</span><br><span class="line"></span><br><span class="line">/* &lt;display-listitem&gt; values */</span><br><span class="line">display: list-item;</span><br><span class="line">display: list-item block;</span><br><span class="line">display: list-item inline;</span><br><span class="line">display: list-item flow;</span><br><span class="line">display: list-item flow-root;</span><br><span class="line">display: list-item block flow;</span><br><span class="line">display: list-item block flow-root;</span><br><span class="line">display: flow list-item block;</span><br><span class="line"></span><br><span class="line">/* &lt;display-internal&gt; values */</span><br><span class="line">display: table-row-group;</span><br><span class="line">display: table-header-group;</span><br><span class="line">display: table-footer-group;</span><br><span class="line">display: table-row;</span><br><span class="line">display: table-cell;</span><br><span class="line">display: table-column-group;</span><br><span class="line">display: table-column;</span><br><span class="line">display: table-caption;</span><br><span class="line">display: ruby-base;</span><br><span class="line">display: ruby-text;</span><br><span class="line">display: ruby-base-container;</span><br><span class="line">display: ruby-text-container;</span><br><span class="line"></span><br><span class="line">/* &lt;display-box&gt; values */</span><br><span class="line">display: contents;</span><br><span class="line">display: none;</span><br><span class="line"></span><br><span class="line">/* &lt;display-legacy&gt; values */</span><br><span class="line">display: inline-block;</span><br><span class="line">display: inline-table;</span><br><span class="line">display: inline-flex;</span><br><span class="line">display: inline-grid;</span><br><span class="line"></span><br><span class="line">/* Global values */</span><br><span class="line">display: inherit;</span><br><span class="line">display: initial;</span><br><span class="line">display: unset;</span><br></pre></td></tr></table></figure><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>CSS position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。position 属性被指定为从下面的值列表中选择的单个关键字：</p><ul><li>static</li></ul><p>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</p><ul><li>relative</li></ul><p>该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。</p><ul><li>absolute</li></ul><p>不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</p><ul><li>fixed</li></ul><p>不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform  属性非 none 时，容器由视口改为该祖先。</p><ul><li>sticky </li></ul><p>盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果与 position: relative 相同。</p><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性（与绝对定位相反）。float 属性的值被指定为单一的关键字，值从下面的值列表中选择:</p><ul><li>left</li></ul><p>表明元素必须浮动在其所在的块容器左侧的关键字。</p><ul><li>right</li></ul><p>表明元素必须浮动在其所在的块容器右侧的关键字。</p><ul><li>none</li></ul><p>表明元素不进行浮动的关键字。</p><ul><li>inline-start</li></ul><p>关键字，表明元素必须浮动在其所在块容器的开始一侧，在ltr脚本中是左侧，在rtl脚本中是右侧。</p><ul><li>inline-end</li></ul><p>关键字，表明元素必须浮动在其所在块容器的结束一侧，在ltr脚本中是右侧，在rtl脚本中是左侧。</p><p>float属性具有<strong>包裹性和高度欺骗</strong>两个特性。</p><h3 id="包裹性"><a href="#包裹性" class="headerlink" title="包裹性"></a>包裹性</h3><p>block元素不指定width的话，默认是100%，一旦让该div浮动起来，立刻会像inline元素一样产生包裹性，宽度会跟随内容自适应。（这也是通常float元素需要手动指定width的原因）。</p><center>![float的包裹性](https://upload-images.jianshu.io/upload_images/1959053-1b1dda5d416c60eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/395/format/webp "float的包裹性")图3  float的包裹性</center><p>效果非常近似于display:inline-block。但相比之下，浮动能设定为左浮和右浮，但display:inline-block都是从左到右排列的。（还有些细微差别，两个display:inline-block间会有空隙，但两个float间没有。）</p><h3 id="高度欺骗性"><a href="#高度欺骗性" class="headerlink" title="高度欺骗性"></a>高度欺骗性</h3><center>![float的高度欺骗性](https://upload-images.jianshu.io/upload_images/1959053-5170f426197de08b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/394/format/webp "float的高度欺骗性")图4  float的高度欺骗性</center><p>外层div在没有手动设定height的前提下，其高度是由内部content的最大高度决定的，由于img的float使得img具有高度塌陷的欺骗性，让div误以为img的line-height为0，因此div的高度就是文字的匿名inline-box的inline-height。</p><h3 id="闭合浮动"><a href="#闭合浮动" class="headerlink" title="闭合浮动"></a>闭合浮动</h3><p>闭合浮动的实现方法很多，最合理的方法是用:after伪元素，思路是用:after元素在div后面插入一个隐藏文本”.”，隐藏文本用clear来实现闭合浮动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.clearfix:after &#123;</span><br><span class="line">    clear: both;</span><br><span class="line">    content: &quot;.&quot;;   //你头可以改成其他任意文本如“abc”</span><br><span class="line">    display: block;</span><br><span class="line">    height: 0;      //高度为0且hidden让该文本彻底隐藏</span><br><span class="line">    visibility: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.clearfix &#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;border:4px solid blue;&quot; class=&quot;clearfix&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;width:200px; border:4px solid red; float:left;&quot;&gt;</span><br><span class="line">        我是浮动元素1</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div style=&quot;width:200px; border:4px solid yellow; float:left;&quot;&gt;</span><br><span class="line">        我是浮动元素2</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;border:4px solid gray;&quot;&gt;我是页脚&lt;/div&gt;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/25565751" target="_blank" rel="noopener">CSS布局十八般武艺都在这里了</a>,by Shelley Lee.</li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">Flex 布局教程：语法篇</a>,by 阮一峰.</li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">Flex 布局教程：实例篇</a>,by 阮一峰.</li><li><a href="http://www.ruanyifeng.com/blog/2018/10/flexbox-form.html" target="_blank" rel="noopener">Flexbox 布局的最简单表单</a>,by 阮一峰.</li><li><a href="http://www.ruanyifeng.com/blog/2012/05/responsive_web_design.html" target="_blank" rel="noopener">自适应网页设计（Responsive Web Design）</a>,by 阮一峰.</li><li><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">CSS Grid 网格布局教程</a>,by 阮一峰.</li><li><a href="https://juejin.im/entry/58b6414a128fe1006421bfa7" target="_blank" rel="noopener">响应式和自适应的区别</a>,by LorinLuo.</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/display" target="_blank" rel="noopener">display</a>,by mozilla.</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener">position</a>,by mozilla.</li><li><a href="https://www.jianshu.com/p/07eb19957991" target="_blank" rel="noopener">CSS浮动float详解</a>,by 张歆琳.</li><li><a href="https://developer.mozilla.org/zh-CN/docs/CSS/float" target="_blank" rel="noopener">float</a>,by mozilla.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用CSS对网页布局进行设计是前端工程师的重要工作。下面即介绍各种CSS网页布局的方法，以及相应的技术。&lt;/p&gt;
&lt;h1 id=&quot;居中方法&quot;&gt;&lt;a href=&quot;#居中方法&quot; class=&quot;headerlink&quot; title=&quot;居中方法&quot;&gt;&lt;/a&gt;居中方法&lt;/h1&gt;&lt;p&gt;居中
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="前端" scheme="https://huangwang.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Mockjs入门简介</title>
    <link href="https://huangwang.github.io/2019/08/09/Mockjs%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/"/>
    <id>https://huangwang.github.io/2019/08/09/Mockjs入门简介/</id>
    <published>2019-08-09T03:14:04.000Z</published>
    <updated>2019-08-09T03:27:51.231Z</updated>
    
    <content type="html"><![CDATA[<p>Mock.js可生成随机数据，拦截Ajax请求，实现前后端分离的目的。Mockjs支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等数据类型，增加了单元测试的真实性，具有用法简单，方便扩展和开发无侵入的特点。下面简单介绍Mockjs的用法。</p><h1 id="开始-amp-安装"><a href="#开始-amp-安装" class="headerlink" title="开始 &amp; 安装"></a>开始 &amp; 安装</h1><h2 id="Node-CommonJS"><a href="#Node-CommonJS" class="headerlink" title="Node (CommonJS)"></a>Node (CommonJS)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">npm install mockjs</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用 Mock</span><br><span class="line">var Mock = require(&apos;mockjs&apos;)</span><br><span class="line">var data = Mock.mock(&#123;</span><br><span class="line">    // 属性 list 的值是一个数组，其中含有 1 到 10 个元素</span><br><span class="line">    &apos;list|1-10&apos;: [&#123;</span><br><span class="line">        // 属性 id 是一个自增数，起始值为 1，每次增 1</span><br><span class="line">        &apos;id|+1&apos;: 1</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br><span class="line">// 输出结果</span><br><span class="line">console.log(JSON.stringify(data, null, 4))</span><br></pre></td></tr></table></figure><h1 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h1><p>Mock.js 的语法规范包括两部分：</p><ul><li>数据模板定义规范（Data Template Definition，DTD）</li><li>数据占位符定义规范（Data Placeholder Definition，DPD）</li></ul><h2 id="数据模板定义规范-DTD"><a href="#数据模板定义规范-DTD" class="headerlink" title="数据模板定义规范 DTD"></a>数据模板定义规范 DTD</h2><p>数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 属性名   name</span><br><span class="line">// 生成规则 rule</span><br><span class="line">// 属性值   value</span><br><span class="line">&apos;name|rule&apos;: value</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>属性名 和 生成规则 之间用竖线 | 分隔。</li><li>生成规则 是可选的。</li><li>生成规则 有 7 种格式：<ul><li>‘name|min-max’: value</li><li>‘name|count’: value</li><li>‘name|min-max.dmin-dmax’: value</li><li>‘name|min-max.dcount’: value</li><li>‘name|count.dmin-dmax’: value</li><li>‘name|count.dcount’: value</li><li>‘name|+step’: value</li></ul></li><li>生成规则 的 含义 需要依赖 属性值的类型 才能确定。</li><li>属性值 中可以含有 @占位符。</li><li>属性值 还指定了最终值的初始值和类型。</li></ul><h2 id="数据占位符定义规范-DPD"><a href="#数据占位符定义规范-DPD" class="headerlink" title="数据占位符定义规范 DPD"></a>数据占位符定义规范 DPD</h2><p>占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。</p><p>占位符 的格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@占位符</span><br><span class="line">@占位符(参数 [, 参数])</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>用 @ 来标识其后的字符串是 占位符。</li><li>占位符 引用的是 Mock.Random 中的方法。</li><li>通过 Mock.Random.extend() 来扩展自定义占位符。</li><li>占位符 也可以引用 数据模板 中的属性。</li><li>占位符 会优先引用 数据模板 中的属性。</li><li>占位符 支持 相对路径 和 绝对路径。</li></ul><h1 id="Mock-Random"><a href="#Mock-Random" class="headerlink" title="Mock.Random"></a>Mock.Random</h1><p>Mock.Random 是一个工具类，用于生成各种随机数据。</p><p><strong>Mock.Random 的方法在数据模板中称为『占位符』，书写格式为 @占位符(参数 [, 参数]) 。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Random = Mock.Random</span><br><span class="line">Random.email()</span><br><span class="line">// =&gt; &quot;n.clark@miller.io&quot;</span><br><span class="line">Mock.mock(&apos;@email&apos;)</span><br><span class="line">// =&gt; &quot;y.lee@lewis.org&quot;</span><br><span class="line">Mock.mock( &#123; email: &apos;@email&apos; &#125; )</span><br><span class="line">// =&gt; &#123; email: &quot;v.lewis@hall.gov&quot; &#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">Mockjs</a>,by nuysoft.</li><li><a href="https://github.com/nuysoft/Mock/wiki/Syntax-Specification" target="_blank" rel="noopener">Mockjs语法规范</a>,by nuysoft.</li><li><a href="https://github.com/nuysoft/Mock/wiki/Mock.Random" target="_blank" rel="noopener">Mock.Random</a>,by nuysoft.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mock.js可生成随机数据，拦截Ajax请求，实现前后端分离的目的。Mockjs支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等数据类型，增加了单元测试的真实性，具有用法简单，方便扩展和开发无侵入的特点。下面简单介绍Mockjs的用法。&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="前端" scheme="https://huangwang.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>软件设计模式简介</title>
    <link href="https://huangwang.github.io/2019/08/06/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
    <id>https://huangwang.github.io/2019/08/06/软件设计模式简介/</id>
    <published>2019-08-06T15:25:47.000Z</published>
    <updated>2019-08-06T15:28:44.745Z</updated>
    
    <content type="html"><![CDATA[<p>软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。下面重点介绍各种经典的设计模式。</p><ul><li>创建型模式<ol><li>简单工厂模式( Simple Factory Pattern )</li><li>工厂方法模式(Factory Method Pattern)</li><li>抽象工厂模式(Abstract Factory)</li><li>建造者模式</li><li>单例模式</li></ol></li><li>结构型模式<ol><li>适配器模式</li><li>桥接模式</li><li>装饰模式</li><li>外观模式</li><li>享元模式</li><li>代理模式</li></ol></li><li>行为型模式<ol><li>命令模式</li><li>中介者模式</li><li>观察者模式</li><li>状态模式</li><li>策略模式</li></ol></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">图说设计模式</a>,by me115.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;软件模式是将模式的一般概念应用于软件开发领域，即软件开发的 总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括 架构模式、分析模式和过程模式等，实际上，在软件生存期的每一个阶段都存在着一些被认同的模式。下面重点介绍各种经典的设计模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="软件工程" scheme="https://huangwang.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>UML类图中类之间关系</title>
    <link href="https://huangwang.github.io/2019/08/06/UML%E7%B1%BB%E5%9B%BE%E4%B8%AD%E7%B1%BB%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB/"/>
    <id>https://huangwang.github.io/2019/08/06/UML类图中类之间关系/</id>
    <published>2019-08-06T14:40:17.000Z</published>
    <updated>2019-08-06T15:17:11.106Z</updated>
    
    <content type="html"><![CDATA[<p>UML类图中类之间的关系主要有六种：泛化、实现、聚合、组合、依赖、关联。如图1所示。</p><center>![UML类图](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg "UML类图")</center><ul><li>车的类图结构为&lt;<abstract>&gt;，表示车是一个抽象类；</abstract></li><li>它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；</li><li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；</li><li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；</li><li>学生与班级之间是聚合关系，使用带空心箭头的实线表示；</li><li>学生与身份证之间为关联关系，使用一根实线表示；</li><li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</li></ul><p>熟悉这六种关系及其符号表示，有利于我们设计类图和同行之间交流。下面介绍这六种关系。</p><h1 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h1><p>类的继承结构表现在UML中为：泛化(generalize)与实现(realize)：</p><p>继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)</p><p>例如：自行车是车、猫是动物。</p><p>泛化关系用一条带空心箭头的直接表示；如下图表示；</p><center>![泛化关系](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg)</center><p>汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；<strong>最终代码中，泛化关系表现为继承非抽象类；</strong></p><h1 id="实现关系-realize"><a href="#实现关系-realize" class="headerlink" title="实现关系(realize)"></a>实现关系(realize)</h1><p>实现关系用一条带空心箭头的虚线表示；</p><p>例如：”车”为一个抽象概念，在现实中并无法直接用来定义对象；只有指明具体的子类(汽车还是自行车)，才可以用来定义对象（”车”这个类在C++中用抽象类表示，在JAVA中有接口这个概念，更容易理解）</p><center>![实现关系](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg)</center><p><strong>最终代码中，实现关系表现为继承抽象类；</strong></p><h1 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h1><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p><center>![聚合关系](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg)</center><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p><p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；</p><h1 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h1><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p><center>![组合关系](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg)</center><p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p><p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p><h1 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h1><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；</p><p>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；</p><p>关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A<br>知道B，但 B不知道A；</p><center>![关联关系](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg)</center><p><strong>在最终代码中，关联对象通常是以成员变量的形式实现的；</strong></p><h1 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h1><p>依赖关系是用一套带箭头的虚线表示的；如下图表示A依赖于B；他描述一个对象在运行期间会用到另一个对象的关系；</p><center>![依赖关系](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg)</center><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</p><p><strong>在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</strong></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html" target="_blank" rel="noopener">看懂UML类图和时序图</a>,by me115.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;UML类图中类之间的关系主要有六种：泛化、实现、聚合、组合、依赖、关联。如图1所示。&lt;/p&gt;
&lt;center&gt;

![UML类图](https://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_s
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="软件工程" scheme="https://huangwang.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>提高效率的在线工具</title>
    <link href="https://huangwang.github.io/2019/08/06/%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/"/>
    <id>https://huangwang.github.io/2019/08/06/提高效率的在线工具/</id>
    <published>2019-08-06T10:11:42.000Z</published>
    <updated>2019-08-06T10:17:32.636Z</updated>
    
    <content type="html"><![CDATA[<p>在此记录一些常用在线工具，提高工作效率。</p><h1 id="百度文库在线下载"><a href="#百度文库在线下载" class="headerlink" title="百度文库在线下载"></a>百度文库在线下载</h1><p>在某个文档页面的网址域名后面加上 vvv 三个字母，访问后就可以快捷下载。    </p><p>比如：</p><p><a href="https://wenku.baidu.com/view/3e6d30b2fd0a79563c1e72bd.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/3e6d30b2fd0a79563c1e72bd.html</a>    </p><p>加上 vvv 为：</p><p><a href="https://wenku.baiduvvv.com/view/3e6d30b2fd0a79563c1e72bd.html" target="_blank" rel="noopener">https://wenku.baiduvvv.com/view/3e6d30b2fd0a79563c1e72bd.html</a></p><h1 id="商品历史价格查询"><a href="#商品历史价格查询" class="headerlink" title="商品历史价格查询"></a>商品历史价格查询</h1><p>在电商网站商品详情页的网址域名后面加入vvv三个字母访问后即可查询该商品的历史价格。</p><p>例如：</p><p><a href="https://detail.tmall.com/item.htm?id=527080261251" target="_blank" rel="noopener">https://detail.tmall.com/item.htm?id=527080261251</a> </p><p>添加vvv后变为：</p><p><a href="https://detail.tmallvvv.com/item.htm?id=527080261251" target="_blank" rel="noopener">https://detail.tmallvvv.com/item.htm?id=527080261251</a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="http://wenku.baiduvvv.com/doc/" target="_blank" rel="noopener">VVV文档在线导出工具</a>,by vvv.</li><li><a href="http://www.hisprice.cn/" target="_blank" rel="noopener">商品历史价格查询</a>,by hisprice.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在此记录一些常用在线工具，提高工作效率。&lt;/p&gt;
&lt;h1 id=&quot;百度文库在线下载&quot;&gt;&lt;a href=&quot;#百度文库在线下载&quot; class=&quot;headerlink&quot; title=&quot;百度文库在线下载&quot;&gt;&lt;/a&gt;百度文库在线下载&lt;/h1&gt;&lt;p&gt;在某个文档页面的网址域名后面加上 v
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="常用工具" scheme="https://huangwang.github.io/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs调试入门</title>
    <link href="https://huangwang.github.io/2019/07/31/Nodejs%E8%B0%83%E8%AF%95%E5%85%A5%E9%97%A8/"/>
    <id>https://huangwang.github.io/2019/07/31/Nodejs调试入门/</id>
    <published>2019-07-31T14:01:28.000Z</published>
    <updated>2019-07-31T14:16:03.625Z</updated>
    
    <content type="html"><![CDATA[<p>调试是每个程序员必备的技能，因此选择合适的调试工具能极大地方便我们调试代码。Node.js 的调试方式也有很多，常见的有：</p><ol><li>万能的 console.log</li><li>debugger</li><li>node —inspect + chrome devtools</li></ol><p>本文重点介绍最有用的node —inspect方法。具体步骤如下：</p><ol><li>node —inspect app.js</li><li>打开 Chrome 浏览器，访问 chrome://inspect，选择第一步的调试目标。</li><li>在chrome访问源代码，设置断点调试。</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://github.com/nswbmw/node-in-debugging" target="_blank" rel="noopener">《Node.js 调试指南》</a>,by nswbmw.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;调试是每个程序员必备的技能，因此选择合适的调试工具能极大地方便我们调试代码。Node.js 的调试方式也有很多，常见的有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;万能的 console.log&lt;/li&gt;
&lt;li&gt;debugger&lt;/li&gt;
&lt;li&gt;node —inspect + chr
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="nodejs" scheme="https://huangwang.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Mock数据</title>
    <link href="https://huangwang.github.io/2019/07/28/Mock%E6%95%B0%E6%8D%AE/"/>
    <id>https://huangwang.github.io/2019/07/28/Mock数据/</id>
    <published>2019-07-28T15:38:30.000Z</published>
    <updated>2019-08-08T12:56:08.391Z</updated>
    
    <content type="html"><![CDATA[<p>在实际开发中，最理想的前后端交互方式当然是后端先帮前端 mock 数据，然后前端开发，但现实很骨感，总会因为种种原因，前端需要自己来 mock 假数据。常用的伪造假数据的库有：Mockjs和easy-mock。这两个库有各自问题，因此需要一种新的 mock 假数据方案。</p><h1 id="Mockjs"><a href="#Mockjs" class="headerlink" title="Mockjs"></a>Mockjs</h1><p>原理是: 拦截了所有的请求并代理到本地，然后进行数据模拟，所以你会发现 network 中没有发出任何的请求。</p><p>但它的最大的问题是就是它的实现机制。它会重写浏览器的XMLHttpRequest对象，从而才能拦截所有请求，代理到本地。</p><p>大部分情况下用起来还是蛮方便的，但就因为它重写了XMLHttpRequest对象，所以比如progress方法，或者一些底层依赖XMLHttpRequest的库都会和它发生不兼容。</p><p>另外，因为是它是本地模拟数据，实际上不会走任何网络请求。所以本地调试起来很蛋疼，只能通过console.log来调试。</p><h1 id="easy-mock"><a href="#easy-mock" class="headerlink" title="easy-mock"></a>easy-mock</h1><p>天然支持跨域，还是支持MockJs的所有语法。但因为用的人多了，它的免费服务会经常的挂，可以说天天挂。官方的建议是自己搭建服务。如果你的公司整体搭建一个这样的 mock 服务的话也是一个不错的选择。但大部分人可能还是没有这个技术条件的。</p><h1 id="新的Mock假数据方案"><a href="#新的Mock假数据方案" class="headerlink" title="新的Mock假数据方案"></a>新的Mock假数据方案</h1><p>本地会启动一个mock-server来模拟数据，线上环境还是继续使用mockjs来进行模拟(因为本项目是一个纯前端项目，你也可以自己搭建一个线上 server 来提供数据)。不管是本地还是线上所以的数据模拟都是基于mockjs生成的，所以只要写一套 mock 数据，就可以在多环境中使用。</p><p>该方案的好处是，在保留 mockjs 的优势的同时，解决之前的痛点。由于我们的 mock 是完全基于webpack-dev-serve来实现的，所以在你启动前端服务的同时，mock-server就会自动启动，这里还通过 chokidar 来观察 mock 文件夹内容的变化。在发生变化时会清除之前注册的mock-api接口，重新动态挂载新的接口，从而支持热更新。有兴趣的可以自己看一下代码 mock-server.js。由于是一个真正的server，所以你可以通过控制台中的network，清楚的知道接口返回的数据结构。并且同时解决了之前mockjs会重写 XMLHttpRequest对象，导致很多第三方库失效的问题。</p><p>vue.config.js中配置本地mock-server服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    port: port,</span><br><span class="line">    open: true,</span><br><span class="line">    overlay: &#123;</span><br><span class="line">      warnings: false,</span><br><span class="line">      errors: true</span><br><span class="line">    &#125;,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      // change xxx-api/login =&gt; mock/login</span><br><span class="line">      // detail: https://cli.vuejs.org/config/#devserver-proxy</span><br><span class="line">      [process.env.VUE_APP_BASE_API]: &#123;</span><br><span class="line">        target: `http://127.0.0.1:$&#123;port&#125;/mock`,</span><br><span class="line">        changeOrigin: true,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          [&apos;^&apos; + process.env.VUE_APP_BASE_API]: &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 输入app为exress实例，即var app = express();</span><br><span class="line">    // after: function(app, server) &#123;</span><br><span class="line">       // do fancy stuff</span><br><span class="line">    // &#125;</span><br><span class="line">    after: require(&apos;./mock/mock-server.js&apos;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://juejin.im/post/5c92ff94f265da6128275a85#heading-5" target="_blank" rel="noopener">手摸手，带你用vue撸后台 系列五(v4.0新版本)</a>,by 花裤衩.</li><li><a href="https://github.com/nuysoft/Mock/wiki/Getting-Started" target="_blank" rel="noopener">Getting Started</a>,by mockjs.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在实际开发中，最理想的前后端交互方式当然是后端先帮前端 mock 数据，然后前端开发，但现实很骨感，总会因为种种原因，前端需要自己来 mock 假数据。常用的伪造假数据的库有：Mockjs和easy-mock。这两个库有各自问题，因此需要一种新的 mock 假数据方案。&lt;/
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="前端" scheme="https://huangwang.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript最新语法学习笔记</title>
    <link href="https://huangwang.github.io/2019/07/28/JavaScript%E6%9C%80%E6%96%B0%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://huangwang.github.io/2019/07/28/JavaScript最新语法学习笔记/</id>
    <published>2019-07-28T08:33:13.000Z</published>
    <updated>2019-07-31T14:00:43.671Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript目前发展很快，明年都会出一些新的语法特性。为了便于学习，本文对一些遇到的JavaScript语法特性做一些笔记。</p><h1 id="JavaScript版本简介"><a href="#JavaScript版本简介" class="headerlink" title="JavaScript版本简介"></a>JavaScript版本简介</h1><p>JavaScript 由 Brendan Eich 于 1995 年发明，并于 1997 年成为 ECMA 标准。</p><p>ECMAScript 是该语言的官方名称。</p><p>从 2015 年起，ECMAScript 按年命名（ECMAScript 2015）。</p><center>ECMAScript 版本</center><div class="table-container"><table><thead><tr><th>版本</th><th>官方名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>ECMAScript 1 (1997)</td><td>第一版。</td></tr><tr><td>2</td><td>ECMAScript 2 (1998)</td><td>只改变编辑方式。</td></tr><tr><td>3</td><td>ECMAScript 3 (1999)</td><td>添加了正则表达式。添加了 try/catch。</td></tr><tr><td>4</td><td>ECMAScript 4</td><td>从未发布过。</td></tr><tr><td>5</td><td>ECMAScript 5 (2009)</td><td>添加了“严格模式”。添加了 JSON 支持。添加了 String.trim()。添加了 Array.isArray()。添加了数组迭代方法。</td></tr><tr><td>5.1</td><td>ECMAScript 5.1 (2011)</td><td>编辑改变。</td></tr><tr><td>6</td><td>ECMAScript 2015</td><td>添加了 let 和 const。添加了默认参数值。添加了 Array.find()。添加了 Array.findIndex()</td></tr><tr><td>7</td><td>ECMAScript 2016</td><td>添加了指数运算符（**）。添加了 Array.prototype.includes。</td></tr><tr><td>8</td><td>ECMAScript 2017</td><td>添加了字符串填充。添加了新的 Object 属性。添加了异步功能。添加了共享内存。</td></tr><tr><td>9</td><td>ECMAScript 2018</td><td>添加了 rest / spread 属性。添加了异步迭代。添加了 Promise.finally()。增加 RegExp。</td></tr></tbody></table></div><h1 id="JavaScript新语法特性"><a href="#JavaScript新语法特性" class="headerlink" title="JavaScript新语法特性"></a>JavaScript新语法特性</h1><h2 id="…运算符"><a href="#…运算符" class="headerlink" title="…运算符"></a>…运算符</h2><p>es6中引入扩展运算符（…），它用于把一个数组转化为用逗号分隔的参数序列，它常用在不定参数个数时的函数调用，数组合并等情形。</p><ul><li>将实现了 Iterator 接口的对象转为数组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var nodeList = document.querySelectorAll(&apos;div&apos;);  </span><br><span class="line">var array = [...nodeList];</span><br></pre></td></tr></table></figure><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let &#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;</span><br><span class="line">a; // 10 </span><br><span class="line">b; // 20 </span><br><span class="line">rest; // &#123; c: 30, d: 40 &#125;</span><br></pre></td></tr></table></figure><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><p>async函数是最新的javascript异步操作方式，初始定义于ES2017。async函数声明用于定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。但是如果你的代码使用了异步函数，它的语法和结构会更像是标准的同步函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* 获取用户信息 */</span><br><span class="line">async function userInfoRoute(req, res, next) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var decoded = jwt.verify(req.body.token.split(&apos; &apos;)[1], appConfig.secretOrPrivateKey);</span><br><span class="line">        var user = await models.User.findByPk(decoded.userId);</span><br><span class="line">        res.json(&#123;</span><br><span class="line">            code: 20000,</span><br><span class="line">            data: user</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        res.send(406, &#123;</span><br><span class="line">            message: &apos;Account and password are incorrect.&apos;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 获取用户信息 */</span><br><span class="line">router.post(&apos;/user_info&apos;, userInfoRoute);</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="https://www.w3school.com.cn/js/js_versions.asp" target="_blank" rel="noopener">JavaScript 版本</a>,by w3school.</li><li><a href="https://www.jianshu.com/p/86cbabeda999" target="_blank" rel="noopener">ES6 扩展运算符 三个点（…）</a>,by ten5743.</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值</a>,by MDN web docs.</li><li><a href="http://www.ruanyifeng.com/blog/2015/05/async.html" target="_blank" rel="noopener">async 函数的含义和用法</a>,by 阮一峰.</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">async function</a>,by MDN web docs.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript目前发展很快，明年都会出一些新的语法特性。为了便于学习，本文对一些遇到的JavaScript语法特性做一些笔记。&lt;/p&gt;
&lt;h1 id=&quot;JavaScript版本简介&quot;&gt;&lt;a href=&quot;#JavaScript版本简介&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="笔记本" scheme="https://huangwang.github.io/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
      <category term="JavaScript" scheme="https://huangwang.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
